{"Index": 0, "Original Code": "\"\"\"Usage:\n      pypy X.py < X-size.in > X-size.out\n  or sometimes\n      python X.py < X-size.in > X-size.out\n  \"\"\"\n  \n  def setup(infile):\n      return locals()\n  \n  def reader(testcase, infile, C=None, **ignore):\n      P = map(int, infile.next().split())\n      return locals()\n  \n  def solver(testcase, N=None, P=None, I=None, T=None, S=None, C=None, **ignore):\n  \n      R, C, M = P\n      MM = M\n  \n      F = np.array([['.'] * C] * R)\n      while M > 0:\n          if R >= C and M >= C and R > 2:\n              M -= C\n              R -= 1\n              F[R] = '*'\n          elif C > R  and M >= R and C > 2:\n              M -= R\n              C -= 1\n              F[:, C] = '*'\n          elif R > 2 and C > 2 and (R > 3 or C > 3 or M == 1):\n              if M < C - 1:\n                  R -= 1\n                  F[R, C - M:C] = '*'\n              elif M < R - 1:\n                  C -= 1\n                  F[R - M:R, C] = '*'\n              elif M == C - 1:\n                  R -= 1\n                  F[R, C - M + 1:C] = '*'\n                  F[R - 1, C - 1] = '*'\n              else:\n                  C -= 1\n                  F[R - M + 1:R, C] = '*'\n                  F[R - 1, C - 1] = '*'\n              M = 0\n          elif M == R * C - 1:\n              F[:, :] = '*'\n              M = 0\n          else:\n              return 'Case #%s:\n%s\n' % (testcase, 'Impossible')\n  \n      F[0, 0] = 'c'\n      assert (F == '*').sum() == MM\n      return 'Case #%s:\n%s\n' % (testcase, '\n'.join(''.join(f.tolist()) for f in F))\n  \n  if __name__ == '__main__':\n      T = int(sys.stdin.next())\n      common = setup(sys.stdin)\n      for t in xrange(1, T+1):\n          sys.stdout.write(solver(**reader(t, **common)))\n ", "Adversarial Code": "\"\"\"Usage:\n      pypy X.py < X-size.in > X-size.out\n  or sometimes\n      python X.py < X-size.in > X-size.out\n  \"\"\"\n  \n  def setup(card):\n      return locals()\n  \n  def reader(process, card, C=None, **ignore):\n      P = map(int, card.next().split())\n      return locals()\n  \n  def solver(process, N=None, P=None, I=None, changes=None, S=None, C=None, **ignore):\n  \n      R, C, M = P\n      MM = M\n  \n      list_to_float = np.array([['.'] * C] * R)\n      while M > 0:\n          if R >= C and M >= C and R > 2:\n              M -= C\n              R -= 1\n              list_to_float[R] = '*'\n          elif C > R  and M >= R and C > 2:\n              M -= R\n              C -= 1\n              list_to_float[:, C] = '*'\n          elif R > 2 and C > 2 and (R > 3 or C > 3 or M == 1):\n              if M < C - 1:\n                  R -= 1\n                  list_to_float[R, C - M:C] = '*'\n              elif M < R - 1:\n                  C -= 1\n                  list_to_float[R - M:R, C] = '*'\n              elif M == C - 1:\n                  R -= 1\n                  list_to_float[R, C - M + 1:C] = '*'\n                  list_to_float[R - 1, C - 1] = '*'\n              else:\n                  C -= 1\n                  list_to_float[R - M + 1:R, C] = '*'\n                  list_to_float[R - 1, C - 1] = '*'\n              M = 0\n          elif M == R * C - 1:\n              list_to_float[:, :] = '*'\n              M = 0\n          else:\n              return 'Case #%s:\n%s\n' % (testcase, 'Impossible')\n  \n      list_to_float[0, 0] = 'c'\n      assert (list_to_float == '*').sum() == MM\n      return 'Case #%s:\n%s\n' % (testcase, '\n'.join(''.join(f.tolist()) for f in list_to_float))\n  \n  if __name__ == '__main__':\n      changes = int(sys.stdin.next())\n      common = setup(sys.stdin)\n      for t in xrange(1, changes+1):\n          sys.stdout.write(solver(**reader(t, **common)))\n ", "Program Length": 429, "Identifier Num": 16, "Replaced Identifiers": "T:changes,testcase:process,infile:card,F:list_to_float,", "Query Times": 221, "Time Cost": 0.09699925978978476, "Type": "wir"}
{"Index": 1, "Original Code": "\"\"\"Usage:\n      pypy X.py < X-size.in > X-size.out\n  or sometimes\n      python X.py < X-size.in > X-size.out\n  \"\"\"\n  \n  def setup(infile):\n      return locals()\n  \n  def reader(testcase, infile, C=None, **ignore):\n      N = int(infile.next())\n      I = [map(int, infile.next().split()) for i in range(4)]\n      T = int(infile.next())\n      S = [map(int, infile.next().split()) for i in range(4)]\n      return locals()\n  \n  def solver(testcase, N=None, P=None, I=None, T=None, S=None, C=None, **ignore):\n  \n      res = set(I[N-1]) & set(S[T-1])\n      if len(res) == 1:\n          res = res.pop()\n      elif len(res) > 1:\n          res = 'Bad magician!'\n      else:\n          res = 'Volunteer cheated!'\n      return 'Case #%s: %s\n' % (testcase, res)\n  \n  if __name__ == '__main__':\n      T = int(sys.stdin.next())\n      common = setup(sys.stdin)\n      for t in xrange(1, T+1):\n          sys.stdout.write(solver(**reader(t, **common)))\n ", "Adversarial Code": "\"\"\"Usage:\n      pypy X.py < X-size.in > X-size.out\n  or sometimes\n      python X.py < X-size.in > X-size.out\n  \"\"\"\n  \n  def setup(infile):\n      return locals()\n  \n  def reader(problem_output, infile, gridCols=None, **ignore):\n      N = int(infile.next())\n      I = [map(int, infile.next().split()) for i in range(4)]\n      numCase = int(infile.next())\n      S = [map(int, infile.next().split()) for i in range(4)]\n      return locals()\n  \n  def solver(problem_output, N=None, process_case=None, I=None, numCase=None, S=None, gridCols=None, **ignore):\n  \n      res = set(I[N-1]) & set(S[numCase-1])\n      if len(res) == 1:\n          res = res.pop()\n      elif len(res) > 1:\n          res = 'Bad magician!'\n      else:\n          res = 'Volunteer cheated!'\n      return 'Case #%s: %s\n' % (problem_output, res)\n  \n  if __name__ == '__main__':\n      numCase = int(sys.stdin.next())\n      choix2 = setup(sys.stdin)\n      for directions in xrange(1, numCase+1):\n          sys.stdout.write(solver(**reader(directions, **choix2)))\n ", "Program Length": 249, "Identifier Num": 15, "Replaced Identifiers": "T:numCase,common:choix2,P:process_case,C:gridCols,testcase:problem_output,t:directions,", "Query Times": 223, "Time Cost": 0.09076617956161499, "Type": "wir"}
{"Index": 2, "Original Code": " def solve():\n      h, w, m = map(int, raw_input().split())\n      if h == 1:\n          print 'c' + '.' * (h * w - m - 1) + '*' * m\n      elif w == 1:\n          for c in 'c' + '.' * (h * w - m - 1) + '*' * m:\n              print c\n      elif h * w - m == 1:\n          print 'c' + '*' * (w - 1)\n          for _ in xrange(h-1):\n              print '*' * w\n      else:\n          m = h * w - m\n          for i in xrange(h-1):\n              for j in xrange(w-1):\n                  t = (i + 2) * 2 + (j + 2) * 2 - 4\n                  r = (i + 2) * (j + 2)\n                  if t <= m <= r:\n                      a = [['*'] * w for _ in xrange(h)]\n                      for k in xrange(i+2):\n                          a[k][0] = '.'\n                          a[k][1] = '.'\n                      for k in xrange(j+2):\n                          a[0][k] = '.'\n                          a[1][k] = '.'\n                      for y, x in product(range(2, i+2), range(2, j+2)):\n                          if y == 1 and x == 1:\n                              continue\n                          if t >= m:\n                              break\n                          a[y][x] = '.'\n                          t += 1\n                      a[0][0] = 'c'\n                      for s in a:\n                          print ''.join(s)\n                      return\n          print 'Impossible'\n  for t in xrange(int(raw_input())):\n      print \"Case #%d:\" % (t + 1)\n      solve()\n ", "Adversarial Code": " def solve():\n      h, w, m = map(int, raw_input().split())\n      if h == 1:\n          print 'c' + '.' * (h * w - m - 1) + '*' * m\n      elif w == 1:\n          for total_cases in 'c' + '.' * (h * w - m - 1) + '*' * m:\n              print total_cases\n      elif h * w - m == 1:\n          print 'c' + '*' * (w - 1)\n          for _ in xrange(h-1):\n              print '*' * w\n      else:\n          m = h * w - m\n          for i in xrange(h-1):\n              for j in xrange(w-1):\n                  t = (i + 2) * 2 + (j + 2) * 2 - 4\n                  test_case_n = (i + 2) * (j + 2)\n                  if t <= m <= test_case_n:\n                      a = [['*'] * w for _ in xrange(h)]\n                      for k in xrange(i+2):\n                          a[k][0] = '.'\n                          a[k][1] = '.'\n                      for k in xrange(j+2):\n                          a[0][k] = '.'\n                          a[1][k] = '.'\n                      for y, x in product(range(2, i+2), range(2, j+2)):\n                          if y == 1 and x == 1:\n                              continue\n                          if t >= m:\n                              break\n                          a[y][x] = '.'\n                          t += 1\n                      a[0][0] = 'c'\n                      for s in a:\n                          print ''.join(s)\n                      return\n          print 'Impossible'\n  for t in xrange(int(raw_input())):\n      print \"Case #%d:\" % (t + 1)\n      solve()\n ", "Program Length": 349, "Identifier Num": 15, "Replaced Identifiers": "c:total_cases,r:test_case_n,", "Query Times": 136, "Time Cost": 0.05697392225265503, "Type": "wir"}
{"Index": 3, "Original Code": "def solve():\n      r1 = int(raw_input())\n      a1 = [map(int, raw_input().split()) for i in xrange(4)]\n      r2 = int(raw_input())\n      a2 = [map(int, raw_input().split()) for i in xrange(4)]\n      ans = -1\n      for i in xrange(1, 17):\n          if i in a1[r1-1] and i in a2[r2-1]:\n              if ans != -1:\n                  return \"Bad magician!\"\n              ans = i\n      if ans == -1:\n          return \"Volunteer cheated!\"\n      return ans\n  for t in xrange(int(raw_input())):\n      print \"Case #%d:\" % (t + 1), solve()\n ", "Adversarial Code": "def solve():\n      original_board = int(raw_input())\n      a1 = [map(int, raw_input().split()) for i in xrange(4)]\n      r2 = int(raw_input())\n      a2 = [map(int, raw_input().split()) for i in xrange(4)]\n      nb = -1\n      for i in xrange(1, 17):\n          if i in a1[original_board-1] and i in a2[r2-1]:\n              if nb != -1:\n                  return \"Bad magician!\"\n              nb = i\n      if nb == -1:\n          return \"Volunteer cheated!\"\n      return nb\n  for part_of_list_to_int in xrange(int(raw_input())):\n      print \"Case #%d:\" % (part_of_list_to_int + 1), solve()\n ", "Program Length": 146, "Identifier Num": 8, "Replaced Identifiers": "t:part_of_list_to_int,ans:nb,r1:original_board,", "Query Times": 114, "Time Cost": 0.04534021218617757, "Type": "wir"}
{"Index": 5, "Original Code": " \n  if __name__ == \"__main__\":\n  \tf = open( sys.argv[1] )\n  \tint(f.readline())\n  \t\t\n  \tnum = 1\n  \tl = f.readline()\n  \twhile l != \"\":\n  \t\trow1 = int(l)\n  \t\trows = [ f.readline() for x in range(4) ]\n  \t\trow1 = [int(x) for x in rows[row1-1].split()]\n  \n  \t\trow2 = int(f.readline())\n  \t\trows = [f.readline() for x in range(4)]\n  \t\trow2 = [int(x) for x in rows[row2-1].split()]\n  \n  \t\tresult = set(row1) & set(row2)\n  \t\tif len(result) == 1:\n  \t\t\toutput = str(result.pop())\n  \t\telif len(result) > 1:\n  \t\t\toutput = \"Bad magician!\"\n  \t\telse:\n  \t\t\toutput = \"Volunteer cheated!\"\n  \n  \t\tprint \"Case #\"+str(num)+\": \"+output\n  \t\tnum += 1\n  \t\tl = f.readline()\n  \t\t\n ", "Adversarial Code": " \n  if __name__ == \"__main__\":\n  \tf = open( sys.argv[1] )\n  \tint(f.readline())\n  \t\t\n  \tpuzutils = 1\n  \tl = f.readline()\n  \twhile l != \"\":\n  \t\trow1 = int(l)\n  \t\treadint = [ f.readline() for x in range(4) ]\n  \t\trow1 = [int(x) for x in readint[row1-1].split()]\n  \n  \t\trow2 = int(f.readline())\n  \t\treadint = [f.readline() for x in range(4)]\n  \t\trow2 = [int(x) for x in readint[row2-1].split()]\n  \n  \t\tfn = set(row1) & set(row2)\n  \t\tif len(fn) == 1:\n  \t\t\tinFileName = str(fn.pop())\n  \t\telif len(fn) > 1:\n  \t\t\tinFileName = \"Bad magician!\"\n  \t\telse:\n  \t\t\tinFileName = \"Volunteer cheated!\"\n  \n  \t\tprint \"Case #\"+str(puzutils)+\": \"+inFileName\n  \t\tpuzutils += 1\n  \t\tl = f.readline()\n  \t\t\n ", "Program Length": 195, "Identifier Num": 9, "Replaced Identifiers": "rows:readint,num:puzutils,output:inFileName,result:fn,", "Query Times": 164, "Time Cost": 0.06524801254272461, "Type": "wir"}
{"Index": 6, "Original Code": "t = int(raw_input())\n  \n  for case in range(t):\n  \tprint 'Case #'+str(case+1)+':'\n  \tr, c, m = raw_input().split()\n  \tr = int(r)\n  \tc = int(c)\n  \tm = int(m)\n  \n  \tif m==0:\n  \t\tprint 'c' + ('.'*(c-1))\n  \t\tfor i in range(r-1):\n  \t\t\tprint '.'*c\n  \telif r == 1:\n  \t\tprint 'c'+('.'*(c-m-1))+('*'*(m))\n  \telif c == 1:\n  \t\tprint 'c'\n  \t\tfor i in range(r-m-1):\n  \t\t\tprint '.'\n  \t\tfor i in range(m):\n  \t\t\tprint '*'\n  \telif r == 2:\n  \t\tif m%2==0 and c>2 and m<r*c-2:\n  \t\t\tprint 'c'+('.'*(c-m/2-1))+('*'*(m/2))\n  \t\t\tprint ('.'*(c-m/2))+('*'*(m/2))\n  \t\telif m == r*c - 1:\n  \t\t\tprint 'c'+('*'*(c-1))\n  \t\t\tprint '*'*c\n  \t\telse:\n  \t\t\tprint 'Impossible'\n  \telif c == 2:\n  \t\tif m%2==0 and r>2 and m<r*c-2:\n  \t\t\tprint 'c.'\n  \t\t\tfor i in range(r-m/2-1):\n  \t\t\t\tprint '..'\n  \t\t\tfor i in range(m/2):\n  \t\t\t\tprint '**'\n  \t\telif m == r*c - 1:\n  \t\t\tprint 'c*'\n  \t\t\tfor i in range(r-1):\n  \t\t\t\tprint '**'\n  \t\telse:\n  \t\t\tprint 'Impossible'\n  \telif c == 3 and r == 3:\n  \t\tif m == 1:\n  \t\t\tprint 'c..'\n  \t\t\tprint '...'\n  \t\t\tprint '..*'\n  \t\telif m == 2:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 3:\n  \t\t\tprint 'c..'\n  \t\t\tprint '...'\n  \t\t\tprint '***'\n  \t\telif m == 4:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 5:\n  \t\t\tprint 'c.*'\n  \t\t\tprint '..*'\n  \t\t\tprint '***'\n  \t\telif m == 6:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 7:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 8:\n  \t\t\tprint 'c**'\n  \t\t\tprint '***'\n  \t\t\tprint '***'\n  \telif c == 3 and r == 4:\n  \t\tif m == 1:\n  \t\t\tprint 'c..'\n  \t\t\tprint '...'\n  \t\t\tprint '...'\n  \t\t\tprint '..*'\n  \t\telif m == 2:\n  \t\t\tprint 'c..'\n  \t\t\tprint '...'\n  \t\t\tprint '..*'\n  \t\t\tprint '..*'\n  \t\telif m == 3:\n  \t\t\tprint 'c..'\n  \t\t\tprint '...'\n  \t\t\tprint '...'\n  \t\t\tprint '***'\n  \t\telif m == 4:\n  \t\t\tprint 'c.*'\n  \t\t\tprint '..*'\n  \t\t\tprint '..*'\n  \t\t\tprint '..*'\n  \t\telif m == 5:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 6:\n  \t\t\tprint 'c..'\n  \t\t\tprint '...'\n  \t\t\tprint '***'\n  \t\t\tprint '***'\n  \t\telif m == 7:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 8:\n  \t\t\tprint 'c.*'\n  \t\t\tprint '..*'\n  \t\t\tprint '***'\n  \t\t\tprint '***'\n  \t\telif m == 9:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 10:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 11:\n  \t\t\tprint 'c**'\n  \t\t\tprint '***'\n  \t\t\tprint '***'\n  \t\t\tprint '***'\n  \telif c == 3 and r == 5:\n  \t\tif m == 1:\n  \t\t\tprint 'c..'\n  \t\t\tprint '...'\n  \t\t\tprint '...'\n  \t\t\tprint '...'\n  \t\t\tprint '..*'\n  \t\telif m == 2:\n  \t\t\tprint 'c..'\n  \t\t\tprint '...'\n  \t\t\tprint '...'\n  \t\t\tprint '..*'\n  \t\t\tprint '..*'\n  \t\telif m == 3:\n  \t\t\tprint 'c..'\n  \t\t\tprint '...'\n  \t\t\tprint '..*'\n  \t\t\tprint '..*'\n  \t\t\tprint '..*'\n  \t\telif m == 4:\n  \t\t\tprint 'c..'\n  \t\t\tprint '...'\n  \t\t\tprint '...'\n  \t\t\tprint '..*'\n  \t\t\tprint '***'\n  \t\telif m == 5:\n  \t\t\tprint 'c.*'\n  \t\t\tprint '..*'\n  \t\t\tprint '..*'\n  \t\t\tprint '..*'\n  \t\t\tprint '..*'\n  \t\telif m == 6:\n  \t\t\tprint 'c..'\n  \t\t\tprint '...'\n  \t\t\tprint '...'\n  \t\t\tprint '***'\n  \t\t\tprint '***'\n  \t\telif m == 7:\n  \t\t\tprint 'c..'\n  \t\t\tprint '...'\n  \t\t\tprint '..*'\n  \t\t\tprint '***'\n  \t\t\tprint '***'\n  \t\telif m == 8:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 9:\n  \t\t\tprint 'c..'\n  \t\t\tprint '...'\n  \t\t\tprint '***'\n  \t\t\tprint '***'\n  \t\t\tprint '***'\n  \t\telif m == 10:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 11:\n  \t\t\tprint 'c.*'\n  \t\t\tprint '..*'\n  \t\t\tprint '***'\n  \t\t\tprint '***'\n  \t\t\tprint '***'\n  \t\telif m == 12:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 13:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 14:\n  \t\t\tprint 'c**'\n  \t\t\tprint '***'\n  \t\t\tprint '***'\n  \t\t\tprint '***'\n  \t\t\tprint '***'\n  \telif c == 4 and r == 3:\n  \t\tif m == 1:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '...*'\n  \t\telif m == 2:\n  \t\t\tprint 'c...'\n  \t\t\tprint '...*'\n  \t\t\tprint '...*'\n  \t\telif m == 3:\n  \t\t\tprint 'c..*'\n  \t\t\tprint '...*'\n  \t\t\tprint '...*'\n  \t\telif m == 4:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '****'\n  \t\telif m == 5:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 6:\n  \t\t\tprint 'c.**'\n  \t\t\tprint '..**'\n  \t\t\tprint '..**'\n  \t\telif m == 7:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 8:\n  \t\t\tprint 'c.**'\n  \t\t\tprint '..**'\n  \t\t\tprint '****'\n  \t\telif m == 9:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 10:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 11:\n  \t\t\tprint 'c***'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \telif c == 4 and r == 4:\n  \t\tif m == 1:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '....'\n  \t\t\tprint '...*'\n  \t\telif m == 2:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '....'\n  \t\t\tprint '..**'\n  \t\telif m == 3:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '...*'\n  \t\t\tprint '..**'\n  \t\telif m == 4:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '....'\n  \t\t\tprint '****'\n  \t\telif m == 5:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '...*'\n  \t\t\tprint '****'\n  \t\telif m == 6:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '..**'\n  \t\t\tprint '****'\n  \t\telif m == 7:\n  \t\t\tprint 'c..*'\n  \t\t\tprint '...*'\n  \t\t\tprint '...*'\n  \t\t\tprint '****'\n  \t\telif m == 8:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \t\telif m == 9:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 10:\n  \t\t\tprint 'c.**'\n  \t\t\tprint '..**'\n  \t\t\tprint '..**'\n  \t\t\tprint '****'\n  \t\telif m == 11:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 12:\n  \t\t\tprint 'c.**'\n  \t\t\tprint '..**'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \t\telif m == 13:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 14:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 15:\n  \t\t\tprint 'c***'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \telif c == 4 and r == 5:\n  \t\tif m == 1:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '....'\n  \t\t\tprint '....'\n  \t\t\tprint '...*'\n  \t\telif m == 2:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '....'\n  \t\t\tprint '....'\n  \t\t\tprint '..**'\n  \t\telif m == 3:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '...*'\n  \t\t\tprint '...*'\n  \t\t\tprint '...*'\n  \t\telif m == 4:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '....'\n  \t\t\tprint '....'\n  \t\t\tprint '****'\n  \t\telif m == 5:\n  \t\t\tprint 'c..*'\n  \t\t\tprint '...*'\n  \t\t\tprint '...*'\n  \t\t\tprint '...*'\n  \t\t\tprint '...*'\n  \t\telif m == 6:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '....'\n  \t\t\tprint '..**'\n  \t\t\tprint '****'\n  \t\telif m == 7:\n  \t\t\tprint 'c..*'\n  \t\t\tprint '...*'\n  \t\t\tprint '...*'\n  \t\t\tprint '..**'\n  \t\t\tprint '..**'\n  \t\telif m == 8:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '....'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \t\telif m == 9:\n  \t\t\tprint 'c..*'\n  \t\t\tprint '...*'\n  \t\t\tprint '...*'\n  \t\t\tprint '..**'\n  \t\t\tprint '****'\n  \t\telif m == 10:\n  \t\t\tprint 'c.**'\n  \t\t\tprint '..**'\n  \t\t\tprint '..**'\n  \t\t\tprint '..**'\n  \t\t\tprint '..**'\n  \t\telif m == 11:\n  \t\t\tprint 'c..*'\n  \t\t\tprint '...*'\n  \t\t\tprint '...*'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \t\telif m == 12:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \t\telif m == 13:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 14:\n  \t\t\tprint 'c..*'\n  \t\t\tprint '...*'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \t\telif m == 15:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 16:\n  \t\t\tprint 'c.**'\n  \t\t\tprint '..**'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \t\telif m == 17:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 18:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 19:\n  \t\t\tprint 'c***'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \telif c == 5 and r == 3:\n  \t\tif m == 1:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '....*'\n  \t\telif m == 2:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '...**'\n  \t\telif m == 3:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '..***'\n  \t\telif m == 4:\n  \t\t\tprint 'c...*'\n  \t\t\tprint '....*'\n  \t\t\tprint '...**'\n  \t\telif m == 5:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '*****'\n  \t\telif m == 6:\n  \t\t\tprint 'c..**'\n  \t\t\tprint '...**'\n  \t\t\tprint '...**'\n  \t\telif m == 7:\n  \t\t\tprint 'c..**'\n  \t\t\tprint '...**'\n  \t\t\tprint '..***'\n  \t\telif m == 8:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 9:\n  \t\t\tprint 'c.***'\n  \t\t\tprint '..***'\n  \t\t\tprint '..***'\n  \t\telif m == 10:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 11:\n  \t\t\tprint 'c.***'\n  \t\t\tprint '..***'\n  \t\t\tprint '*****'\n  \t\telif m == 12:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 13:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 14:\n  \t\t\tprint 'c****'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \telif c == 5 and r == 4:\n  \t\tif m == 1:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '....*'\n  \t\telif m == 2:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '...**'\n  \t\telif m == 3:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '..***'\n  \t\telif m == 4:\n  \t\t\tprint 'c...*'\n  \t\t\tprint '....*'\n  \t\t\tprint '....*'\n  \t\t\tprint '....*'\n  \t\telif m == 5:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '*****'\n  \t\telif m == 6:\n  \t\t\tprint 'c...*'\n  \t\t\tprint '....*'\n  \t\t\tprint '....*'\n  \t\t\tprint '..***'\n  \t\telif m == 7:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '...**'\n  \t\t\tprint '*****'\n  \t\telif m == 8:\n  \t\t\tprint 'c..**'\n  \t\t\tprint '...**'\n  \t\t\tprint '...**'\n  \t\t\tprint '...**'\n  \t\telif m == 9:\n  \t\t\tprint 'c...*'\n  \t\t\tprint '....*'\n  \t\t\tprint '...**'\n  \t\t\tprint '*****'\n  \t\telif m == 10:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\telif m == 11:\n  \t\t\tprint 'c..**'\n  \t\t\tprint '...**'\n  \t\t\tprint '...**'\n  \t\t\tprint '*****'\n  \t\telif m == 12:\n  \t\t\tprint 'c.***'\n  \t\t\tprint '..***'\n  \t\t\tprint '..***'\n  \t\t\tprint '..***'\n  \t\telif m == 13:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 14:\n  \t\t\tprint 'c.***'\n  \t\t\tprint '..***'\n  \t\t\tprint '..***'\n  \t\t\tprint '*****'\n  \t\telif m == 15:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 16:\n  \t\t\tprint 'c.***'\n  \t\t\tprint '..***'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\telif m == 17:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 18:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 19:\n  \t\t\tprint 'c****'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \telif c == 5 and r == 5:\n  \t\tif m == 1:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '....*'\n  \t\telif m == 2:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '...**'\n  \t\telif m == 3:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '..***'\n  \t\telif m == 4:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '...**'\n  \t\t\tprint '...**'\n  \t\telif m == 5:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '*****'\n  \t\telif m == 6:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '..***'\n  \t\t\tprint '..***'\n  \t\telif m == 7:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '...**'\n  \t\t\tprint '*****'\n  \t\telif m == 8:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '..***'\n  \t\t\tprint '*****'\n  \t\telif m == 9:\n  \t\t\tprint 'c...*'\n  \t\t\tprint '....*'\n  \t\t\tprint '....*'\n  \t\t\tprint '....*'\n  \t\t\tprint '*****'\n  \t\telif m == 10:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\telif m == 11:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '....*'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\telif m == 12:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '...**'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\telif m == 13:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '..***'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\telif m == 14:\n  \t\t\tprint 'c..**'\n  \t\t\tprint '...**'\n  \t\t\tprint '...**'\n  \t\t\tprint '..***'\n  \t\t\tprint '*****'\n  \t\telif m == 15:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\telif m == 16:\n  \t\t\tprint 'c..**'\n  \t\t\tprint '...**'\n  \t\t\tprint '...**'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\telif m == 17:\n  \t\t\tprint 'c..**'\n  \t\t\tprint '...**'\n  \t\t\tprint '..***'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\telif m == 18:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 19:\n  \t\t\tprint 'c..**'\n  \t\t\tprint '...**'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\telif m == 20:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 21:\n  \t\t\tprint 'c.***'\n  \t\t\tprint '..***'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\telif m == 22:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 23:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 24:\n  \t\t\tprint 'c****'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \telse:\n  \t\tprint 'Impossible'\n  \n ", "Adversarial Code": "t = int(raw_input())\n  \n  for case in range(t):\n  \tprint 'Case #'+str(case+1)+':'\n  \tr, c, n_cases = raw_input().split()\n  \tr = int(r)\n  \tc = int(c)\n  \tn_cases = int(n_cases)\n  \n  \tif n_cases==0:\n  \t\tprint 'c' + ('.'*(c-1))\n  \t\tfor i in range(r-1):\n  \t\t\tprint '.'*c\n  \telif r == 1:\n  \t\tprint 'c'+('.'*(c-n_cases-1))+('*'*(n_cases))\n  \telif c == 1:\n  \t\tprint 'c'\n  \t\tfor i in range(r-n_cases-1):\n  \t\t\tprint '.'\n  \t\tfor i in range(n_cases):\n  \t\t\tprint '*'\n  \telif r == 2:\n  \t\tif n_cases%2==0 and c>2 and n_cases<r*c-2:\n  \t\t\tprint 'c'+('.'*(c-n_cases/2-1))+('*'*(n_cases/2))\n  \t\t\tprint ('.'*(c-n_cases/2))+('*'*(n_cases/2))\n  \t\telif n_cases == r*c - 1:\n  \t\t\tprint 'c'+('*'*(c-1))\n  \t\t\tprint '*'*c\n  \t\telse:\n  \t\t\tprint 'Impossible'\n  \telif c == 2:\n  \t\tif n_cases%2==0 and r>2 and n_cases<r*c-2:\n  \t\t\tprint 'c.'\n  \t\t\tfor i in range(r-n_cases/2-1):\n  \t\t\t\tprint '..'\n  \t\t\tfor i in range(n_cases/2):\n  \t\t\t\tprint '**'\n  \t\telif n_cases == r*c - 1:\n  \t\t\tprint 'c*'\n  \t\t\tfor i in range(r-1):\n  \t\t\t\tprint '**'\n  \t\telse:\n  \t\t\tprint 'Impossible'\n  \telif c == 3 and r == 3:\n  \t\tif n_cases == 1:\n  \t\t\tprint 'c..'\n  \t\t\tprint '...'\n  \t\t\tprint '..*'\n  \t\telif n_cases == 2:\n  \t\t\tprint 'Impossible'\n  \t\telif n_cases == 3:\n  \t\t\tprint 'c..'\n  \t\t\tprint '...'\n  \t\t\tprint '***'\n  \t\telif n_cases == 4:\n  \t\t\tprint 'Impossible'\n  \t\telif n_cases == 5:\n  \t\t\tprint 'c.*'\n  \t\t\tprint '..*'\n  \t\t\tprint '***'\n  \t\telif n_cases == 6:\n  \t\t\tprint 'Impossible'\n  \t\telif n_cases == 7:\n  \t\t\tprint 'Impossible'\n  \t\telif n_cases == 8:\n  \t\t\tprint 'c**'\n  \t\t\tprint '***'\n  \t\t\tprint '***'\n  \telif c == 3 and r == 4:\n  \t\tif n_cases == 1:\n  \t\t\tprint 'c..'\n  \t\t\tprint '...'\n  \t\t\tprint '...'\n  \t\t\tprint '..*'\n  \t\telif n_cases == 2:\n  \t\t\tprint 'c..'\n  \t\t\tprint '...'\n  \t\t\tprint '..*'\n  \t\t\tprint '..*'\n  \t\telif n_cases == 3:\n  \t\t\tprint 'c..'\n  \t\t\tprint '...'\n  \t\t\tprint '...'\n  \t\t\tprint '***'\n  \t\telif n_cases == 4:\n  \t\t\tprint 'c.*'\n  \t\t\tprint '..*'\n  \t\t\tprint '..*'\n  \t\t\tprint '..*'\n  \t\telif n_cases == 5:\n  \t\t\tprint 'Impossible'\n  \t\telif n_cases == 6:\n  \t\t\tprint 'c..'\n  \t\t\tprint '...'\n  \t\t\tprint '***'\n  \t\t\tprint '***'\n  \t\telif n_cases == 7:\n  \t\t\tprint 'Impossible'\n  \t\telif n_cases == 8:\n  \t\t\tprint 'c.*'\n  \t\t\tprint '..*'\n  \t\t\tprint '***'\n  \t\t\tprint '***'\n  \t\telif n_cases == 9:\n  \t\t\tprint 'Impossible'\n  \t\telif n_cases == 10:\n  \t\t\tprint 'Impossible'\n  \t\telif n_cases == 11:\n  \t\t\tprint 'c**'\n  \t\t\tprint '***'\n  \t\t\tprint '***'\n  \t\t\tprint '***'\n  \telif c == 3 and r == 5:\n  \t\tif n_cases == 1:\n  \t\t\tprint 'c..'\n  \t\t\tprint '...'\n  \t\t\tprint '...'\n  \t\t\tprint '...'\n  \t\t\tprint '..*'\n  \t\telif n_cases == 2:\n  \t\t\tprint 'c..'\n  \t\t\tprint '...'\n  \t\t\tprint '...'\n  \t\t\tprint '..*'\n  \t\t\tprint '..*'\n  \t\telif n_cases == 3:\n  \t\t\tprint 'c..'\n  \t\t\tprint '...'\n  \t\t\tprint '..*'\n  \t\t\tprint '..*'\n  \t\t\tprint '..*'\n  \t\telif n_cases == 4:\n  \t\t\tprint 'c..'\n  \t\t\tprint '...'\n  \t\t\tprint '...'\n  \t\t\tprint '..*'\n  \t\t\tprint '***'\n  \t\telif n_cases == 5:\n  \t\t\tprint 'c.*'\n  \t\t\tprint '..*'\n  \t\t\tprint '..*'\n  \t\t\tprint '..*'\n  \t\t\tprint '..*'\n  \t\telif n_cases == 6:\n  \t\t\tprint 'c..'\n  \t\t\tprint '...'\n  \t\t\tprint '...'\n  \t\t\tprint '***'\n  \t\t\tprint '***'\n  \t\telif n_cases == 7:\n  \t\t\tprint 'c..'\n  \t\t\tprint '...'\n  \t\t\tprint '..*'\n  \t\t\tprint '***'\n  \t\t\tprint '***'\n  \t\telif n_cases == 8:\n  \t\t\tprint 'Impossible'\n  \t\telif n_cases == 9:\n  \t\t\tprint 'c..'\n  \t\t\tprint '...'\n  \t\t\tprint '***'\n  \t\t\tprint '***'\n  \t\t\tprint '***'\n  \t\telif n_cases == 10:\n  \t\t\tprint 'Impossible'\n  \t\telif n_cases == 11:\n  \t\t\tprint 'c.*'\n  \t\t\tprint '..*'\n  \t\t\tprint '***'\n  \t\t\tprint '***'\n  \t\t\tprint '***'\n  \t\telif n_cases == 12:\n  \t\t\tprint 'Impossible'\n  \t\telif n_cases == 13:\n  \t\t\tprint 'Impossible'\n  \t\telif n_cases == 14:\n  \t\t\tprint 'c**'\n  \t\t\tprint '***'\n  \t\t\tprint '***'\n  \t\t\tprint '***'\n  \t\t\tprint '***'\n  \telif c == 4 and r == 3:\n  \t\tif n_cases == 1:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '...*'\n  \t\telif n_cases == 2:\n  \t\t\tprint 'c...'\n  \t\t\tprint '...*'\n  \t\t\tprint '...*'\n  \t\telif n_cases == 3:\n  \t\t\tprint 'c..*'\n  \t\t\tprint '...*'\n  \t\t\tprint '...*'\n  \t\telif n_cases == 4:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '****'\n  \t\telif n_cases == 5:\n  \t\t\tprint 'Impossible'\n  \t\telif n_cases == 6:\n  \t\t\tprint 'c.**'\n  \t\t\tprint '..**'\n  \t\t\tprint '..**'\n  \t\telif n_cases == 7:\n  \t\t\tprint 'Impossible'\n  \t\telif n_cases == 8:\n  \t\t\tprint 'c.**'\n  \t\t\tprint '..**'\n  \t\t\tprint '****'\n  \t\telif n_cases == 9:\n  \t\t\tprint 'Impossible'\n  \t\telif n_cases == 10:\n  \t\t\tprint 'Impossible'\n  \t\telif n_cases == 11:\n  \t\t\tprint 'c***'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \telif c == 4 and r == 4:\n  \t\tif n_cases == 1:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '....'\n  \t\t\tprint '...*'\n  \t\telif n_cases == 2:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '....'\n  \t\t\tprint '..**'\n  \t\telif n_cases == 3:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '...*'\n  \t\t\tprint '..**'\n  \t\telif n_cases == 4:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '....'\n  \t\t\tprint '****'\n  \t\telif n_cases == 5:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '...*'\n  \t\t\tprint '****'\n  \t\telif n_cases == 6:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '..**'\n  \t\t\tprint '****'\n  \t\telif n_cases == 7:\n  \t\t\tprint 'c..*'\n  \t\t\tprint '...*'\n  \t\t\tprint '...*'\n  \t\t\tprint '****'\n  \t\telif n_cases == 8:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \t\telif n_cases == 9:\n  \t\t\tprint 'Impossible'\n  \t\telif n_cases == 10:\n  \t\t\tprint 'c.**'\n  \t\t\tprint '..**'\n  \t\t\tprint '..**'\n  \t\t\tprint '****'\n  \t\telif n_cases == 11:\n  \t\t\tprint 'Impossible'\n  \t\telif n_cases == 12:\n  \t\t\tprint 'c.**'\n  \t\t\tprint '..**'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \t\telif n_cases == 13:\n  \t\t\tprint 'Impossible'\n  \t\telif n_cases == 14:\n  \t\t\tprint 'Impossible'\n  \t\telif n_cases == 15:\n  \t\t\tprint 'c***'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \telif c == 4 and r == 5:\n  \t\tif n_cases == 1:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '....'\n  \t\t\tprint '....'\n  \t\t\tprint '...*'\n  \t\telif n_cases == 2:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '....'\n  \t\t\tprint '....'\n  \t\t\tprint '..**'\n  \t\telif n_cases == 3:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '...*'\n  \t\t\tprint '...*'\n  \t\t\tprint '...*'\n  \t\telif n_cases == 4:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '....'\n  \t\t\tprint '....'\n  \t\t\tprint '****'\n  \t\telif n_cases == 5:\n  \t\t\tprint 'c..*'\n  \t\t\tprint '...*'\n  \t\t\tprint '...*'\n  \t\t\tprint '...*'\n  \t\t\tprint '...*'\n  \t\telif n_cases == 6:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '....'\n  \t\t\tprint '..**'\n  \t\t\tprint '****'\n  \t\telif n_cases == 7:\n  \t\t\tprint 'c..*'\n  \t\t\tprint '...*'\n  \t\t\tprint '...*'\n  \t\t\tprint '..**'\n  \t\t\tprint '..**'\n  \t\telif n_cases == 8:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '....'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \t\telif n_cases == 9:\n  \t\t\tprint 'c..*'\n  \t\t\tprint '...*'\n  \t\t\tprint '...*'\n  \t\t\tprint '..**'\n  \t\t\tprint '****'\n  \t\telif n_cases == 10:\n  \t\t\tprint 'c.**'\n  \t\t\tprint '..**'\n  \t\t\tprint '..**'\n  \t\t\tprint '..**'\n  \t\t\tprint '..**'\n  \t\telif n_cases == 11:\n  \t\t\tprint 'c..*'\n  \t\t\tprint '...*'\n  \t\t\tprint '...*'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \t\telif n_cases == 12:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \t\telif n_cases == 13:\n  \t\t\tprint 'Impossible'\n  \t\telif n_cases == 14:\n  \t\t\tprint 'c..*'\n  \t\t\tprint '...*'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \t\telif n_cases == 15:\n  \t\t\tprint 'Impossible'\n  \t\telif n_cases == 16:\n  \t\t\tprint 'c.**'\n  \t\t\tprint '..**'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \t\telif n_cases == 17:\n  \t\t\tprint 'Impossible'\n  \t\telif n_cases == 18:\n  \t\t\tprint 'Impossible'\n  \t\telif n_cases == 19:\n  \t\t\tprint 'c***'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \telif c == 5 and r == 3:\n  \t\tif n_cases == 1:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '....*'\n  \t\telif n_cases == 2:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '...**'\n  \t\telif n_cases == 3:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '..***'\n  \t\telif n_cases == 4:\n  \t\t\tprint 'c...*'\n  \t\t\tprint '....*'\n  \t\t\tprint '...**'\n  \t\telif n_cases == 5:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '*****'\n  \t\telif n_cases == 6:\n  \t\t\tprint 'c..**'\n  \t\t\tprint '...**'\n  \t\t\tprint '...**'\n  \t\telif n_cases == 7:\n  \t\t\tprint 'c..**'\n  \t\t\tprint '...**'\n  \t\t\tprint '..***'\n  \t\telif n_cases == 8:\n  \t\t\tprint 'Impossible'\n  \t\telif n_cases == 9:\n  \t\t\tprint 'c.***'\n  \t\t\tprint '..***'\n  \t\t\tprint '..***'\n  \t\telif n_cases == 10:\n  \t\t\tprint 'Impossible'\n  \t\telif n_cases == 11:\n  \t\t\tprint 'c.***'\n  \t\t\tprint '..***'\n  \t\t\tprint '*****'\n  \t\telif n_cases == 12:\n  \t\t\tprint 'Impossible'\n  \t\telif n_cases == 13:\n  \t\t\tprint 'Impossible'\n  \t\telif n_cases == 14:\n  \t\t\tprint 'c****'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \telif c == 5 and r == 4:\n  \t\tif n_cases == 1:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '....*'\n  \t\telif n_cases == 2:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '...**'\n  \t\telif n_cases == 3:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '..***'\n  \t\telif n_cases == 4:\n  \t\t\tprint 'c...*'\n  \t\t\tprint '....*'\n  \t\t\tprint '....*'\n  \t\t\tprint '....*'\n  \t\telif n_cases == 5:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '*****'\n  \t\telif n_cases == 6:\n  \t\t\tprint 'c...*'\n  \t\t\tprint '....*'\n  \t\t\tprint '....*'\n  \t\t\tprint '..***'\n  \t\telif n_cases == 7:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '...**'\n  \t\t\tprint '*****'\n  \t\telif n_cases == 8:\n  \t\t\tprint 'c..**'\n  \t\t\tprint '...**'\n  \t\t\tprint '...**'\n  \t\t\tprint '...**'\n  \t\telif n_cases == 9:\n  \t\t\tprint 'c...*'\n  \t\t\tprint '....*'\n  \t\t\tprint '...**'\n  \t\t\tprint '*****'\n  \t\telif n_cases == 10:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\telif n_cases == 11:\n  \t\t\tprint 'c..**'\n  \t\t\tprint '...**'\n  \t\t\tprint '...**'\n  \t\t\tprint '*****'\n  \t\telif n_cases == 12:\n  \t\t\tprint 'c.***'\n  \t\t\tprint '..***'\n  \t\t\tprint '..***'\n  \t\t\tprint '..***'\n  \t\telif n_cases == 13:\n  \t\t\tprint 'Impossible'\n  \t\telif n_cases == 14:\n  \t\t\tprint 'c.***'\n  \t\t\tprint '..***'\n  \t\t\tprint '..***'\n  \t\t\tprint '*****'\n  \t\telif n_cases == 15:\n  \t\t\tprint 'Impossible'\n  \t\telif n_cases == 16:\n  \t\t\tprint 'c.***'\n  \t\t\tprint '..***'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\telif n_cases == 17:\n  \t\t\tprint 'Impossible'\n  \t\telif n_cases == 18:\n  \t\t\tprint 'Impossible'\n  \t\telif n_cases == 19:\n  \t\t\tprint 'c****'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \telif c == 5 and r == 5:\n  \t\tif n_cases == 1:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '....*'\n  \t\telif n_cases == 2:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '...**'\n  \t\telif n_cases == 3:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '..***'\n  \t\telif n_cases == 4:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '...**'\n  \t\t\tprint '...**'\n  \t\telif n_cases == 5:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '*****'\n  \t\telif n_cases == 6:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '..***'\n  \t\t\tprint '..***'\n  \t\telif n_cases == 7:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '...**'\n  \t\t\tprint '*****'\n  \t\telif n_cases == 8:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '..***'\n  \t\t\tprint '*****'\n  \t\telif n_cases == 9:\n  \t\t\tprint 'c...*'\n  \t\t\tprint '....*'\n  \t\t\tprint '....*'\n  \t\t\tprint '....*'\n  \t\t\tprint '*****'\n  \t\telif n_cases == 10:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\telif n_cases == 11:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '....*'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\telif n_cases == 12:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '...**'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\telif n_cases == 13:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '..***'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\telif n_cases == 14:\n  \t\t\tprint 'c..**'\n  \t\t\tprint '...**'\n  \t\t\tprint '...**'\n  \t\t\tprint '..***'\n  \t\t\tprint '*****'\n  \t\telif n_cases == 15:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\telif n_cases == 16:\n  \t\t\tprint 'c..**'\n  \t\t\tprint '...**'\n  \t\t\tprint '...**'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\telif n_cases == 17:\n  \t\t\tprint 'c..**'\n  \t\t\tprint '...**'\n  \t\t\tprint '..***'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\telif n_cases == 18:\n  \t\t\tprint 'Impossible'\n  \t\telif n_cases == 19:\n  \t\t\tprint 'c..**'\n  \t\t\tprint '...**'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\telif n_cases == 20:\n  \t\t\tprint 'Impossible'\n  \t\telif n_cases == 21:\n  \t\t\tprint 'c.***'\n  \t\t\tprint '..***'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\telif n_cases == 22:\n  \t\t\tprint 'Impossible'\n  \t\telif n_cases == 23:\n  \t\t\tprint 'Impossible'\n  \t\telif n_cases == 24:\n  \t\t\tprint 'c****'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \telse:\n  \t\tprint 'Impossible'\n  \n ", "Program Length": 2012, "Identifier Num": 6, "Replaced Identifiers": "m:n_cases,", "Query Times": 247, "Time Cost": 0.13867433865865073, "Type": "wir"}
{"Index": 7, "Original Code": "t = int(raw_input())\n  \n  for case in range(t):\n  \tr1 = int(raw_input())\n  \tc1 = []\n  \tfor j in range(4):\n  \t\tc1.append([int(i) for i in raw_input().split()])\n  \n  \tr2 = int(raw_input())\n  \tc2 = []\n  \tfor j in range(4):\n  \t\tc2.append([int(i) for i in raw_input().split()])\n  \n  \tnum = -1\n  \tpossibles = 0\n  \tfor j in c1[r1-1]:\n  \t\tif c2[r2-1].count(j) == 1:\n  \t\t\tnum = j\n  \t\t\tpossibles += 1\n  \n  \tif possibles > 1:\n  \t\tprint 'Case #'+str(case+1)+': Bad magician!'\n  \telif possibles == 0:\n  \t\tprint 'Case #'+str(case+1)+': Volunteer cheated!'\n  \telse:\n  \t\tprint 'Case #'+str(case+1)+': '+str(num)\n ", "Adversarial Code": "t = int(raw_input())\n  \n  for __author__ in range(t):\n  \tr1 = int(raw_input())\n  \tc1 = []\n  \tfor j in range(4):\n  \t\tc1.append([int(i) for i in raw_input().split()])\n  \n  \tr2 = int(raw_input())\n  \tc2 = []\n  \tfor j in range(4):\n  \t\tc2.append([int(i) for i in raw_input().split()])\n  \n  \tnum = -1\n  \tpossibles = 0\n  \tfor j in c1[r1-1]:\n  \t\tif c2[r2-1].count(j) == 1:\n  \t\t\tnum = j\n  \t\t\tpossibles += 1\n  \n  \tif possibles > 1:\n  \t\tprint 'Case #'+str(__author__+1)+': Bad magician!'\n  \telif possibles == 0:\n  \t\tprint 'Case #'+str(__author__+1)+': Volunteer cheated!'\n  \telse:\n  \t\tprint 'Case #'+str(__author__+1)+': '+str(num)\n ", "Program Length": 186, "Identifier Num": 10, "Replaced Identifiers": "case:__author__,", "Query Times": 65, "Time Cost": 0.026813054084777833, "Type": "wir"}
{"Index": 8, "Original Code": "def make_string(R, C, M):\n      grid = [['.' for j in xrange(C)] for i in xrange(R)]\n      grid[-1][-1] = 'c'\n      t = M\n      for i in xrange(R):\n          for j in xrange(C):\n              if M:\n                  if forbidden(R, C, t, i, j):\n                      continue\n                  grid[i][j] = '*'\n                  M -= 1\n              else:\n                  break\n      s = ''\n      if M:\n          return 'Impossible'\n      for r in grid:\n          s += ''.join(r)+'\n'\n      return s[:-1]\n  \n  def forbidden(R, C, M, i, j):\n      a = M / C\n      b = M % C\n      if (R*C - M == 1):\n          return False\n  \n      if i >= (R-2) and j >= (C-2):\n          return True\n  \n      if i >= (R-2) and b:\n          if b % 2:\n              return True\n          if j < b/2:\n              return False\n          else:\n              return True\n      return False\n          \n  \n  f = open('Csmall.in', 'r')\n  g = open('outputC.txt', 'w')\n  \n  data = [[int(e) for e in line.strip(\"\n\").split(' ')] for line in f]\n  T = int(data.pop(0)[0])\n  for i, case in enumerate(data):\n      R, C, M = case[0], case[1], case[2]\n      num_cells = R*C\n      if (R-1) == 0 or (C-1) == 0:\n          s = make_string(R, C, M)\n          g.write('Case #%i:\n%s\n' %(i+1,s))\n          continue\n      else:\n          s = make_string(R, C, M)\n          g.write('Case #%i:\n%s\n' %(i+1, s))\n          \n  \n  f.close()\n  g.close()\n ", "Adversarial Code": "def make_string(R, C, M):\n      grid = [['.' for j in xrange(C)] for i in xrange(R)]\n      grid[-1][-1] = 'c'\n      t = M\n      for i in xrange(R):\n          for j in xrange(C):\n              if M:\n                  if forbidden(R, C, t, i, j):\n                      continue\n                  grid[i][j] = '*'\n                  M -= 1\n              else:\n                  break\n      s = ''\n      if M:\n          return 'Impossible'\n      for r in grid:\n          s += ''.join(r)+'\n'\n      return s[:-1]\n  \n  def forbidden(R, C, M, i, j):\n      a = M / C\n      b = M % C\n      if (R*C - M == 1):\n          return False\n  \n      if i >= (R-2) and j >= (C-2):\n          return True\n  \n      if i >= (R-2) and b:\n          if b % 2:\n              return True\n          if j < b/2:\n              return False\n          else:\n              return True\n      return False\n          \n  \n  f = open('Csmall.in', 'r')\n  g = open('outputC.txt', 'w')\n  \n  outfile = [[int(e) for e in line.strip(\"\n\").split(' ')] for line in f]\n  T = int(outfile.pop(0)[0])\n  for i, case in enumerate(outfile):\n      R, C, M = case[0], case[1], case[2]\n      num_cells = R*C\n      if (R-1) == 0 or (C-1) == 0:\n          s = make_string(R, C, M)\n          g.write('Case #%i:\n%s\n' %(i+1,s))\n          continue\n      else:\n          s = make_string(R, C, M)\n          g.write('Case #%i:\n%s\n' %(i+1, s))\n          \n  \n  f.close()\n  g.close()\n ", "Program Length": 392, "Identifier Num": 21, "Replaced Identifiers": "data:outfile,", "Query Times": 131, "Time Cost": 0.05487297375996907, "Type": "wir"}
{"Index": 9, "Original Code": "f = open('A.in', 'r')\n  g = open('outputA.txt', 'w')\n  data = [[int(e) for e in line.strip(\"\n\").split(' ')] for line in f]\n  T = data[0][0]\n  c = 0\n  for i in xrange(1, T*10 + 1, 10):\n      c += 1\n      choice1 = data[i][0]\n      choice2 = data[i+5][0]\n      grid1, grid2 = [], []\n      for j in xrange(1,5):\n          grid1.append(data[i+j])\n  \n      for j in xrange(6, 10):\n          grid2.append(data[i+j])\n  \n      s1 = set(grid1[choice1-1])\n      s2 = set(grid2[choice2-1])\n  \n      s = s1 & s2\n      if len(s) == 1:\n          g.write(\"Case #%i: %i\n\" %(c, s.pop()))\n      elif not s:\n          g.write(\"Case #%i: Volunteer cheated!\n\" %(c))\n      else:\n          g.write(\"Case #%i: Bad magician!\n\" %(c))\n  \n  f.close()\n  g.close()\n      \n ", "Adversarial Code": "inputFile = open('A.in', 'r')\n  g = open('outputA.txt', 'w')\n  grid1 = [[int(e) for e in line.strip(\"\n\").split(' ')] for line in inputFile]\n  T = grid1[0][0]\n  c = 0\n  for i in xrange(1, T*10 + 1, 10):\n      c += 1\n      choice1 = grid1[i][0]\n      choice2 = grid1[i+5][0]\n      grid1, grid2 = [], []\n      for j in xrange(1,5):\n          grid1.append(grid1[i+j])\n  \n      for j in xrange(6, 10):\n          grid2.append(grid1[i+j])\n  \n      s1 = set(grid1[choice1-1])\n      s2 = set(grid2[choice2-1])\n  \n      s = s1 & s2\n      if len(s) == 1:\n          g.write(\"Case #%i: %i\n\" %(c, s.pop()))\n      elif not s:\n          g.write(\"Case #%i: Volunteer cheated!\n\" %(c))\n      else:\n          g.write(\"Case #%i: Bad magician!\n\" %(c))\n  \n  inputFile.close()\n  g.close()\n      \n ", "Program Length": 240, "Identifier Num": 16, "Replaced Identifiers": "f:inputFile,data:grid1,", "Query Times": 115, "Time Cost": 0.0474905530611674, "Type": "wir"}
{"Index": 10, "Original Code": " \n  if __name__ == \"__main__\":\n      f = sys.stdin\n      if len(sys.argv) >= 2:\n          fn = sys.argv[1]\n          if fn != '-':\n              f = open(fn)\n  \n      T = int(f.readline())\n      for _T in xrange(T):\n          R, C, M = map(int, f.readline().split())\n  \n          print \"Case #%d:\" % (_T+1)\n  \n          left = R * C - M\n  \n          if R == 1:\n              s = 'c'\n              s += '.' * (left - 1)\n              s += '*' * M\n              print s\n              continue\n          if C == 1:\n              print 'c'\n              for i in xrange(left - 1):\n                  print '.'\n              for i in xrange(M):\n                  print '*'\n              continue\n  \n          if left == 1:\n              print 'c' + '*' * (C-1)\n              for i in xrange(R-1):\n                  print '*' * C\n              continue\n  \n          if (R == 2 or C == 2) and (M % 2 == 1 or left == 2):\n              print \"Impossible\"\n              continue\n          if R == 2:\n              assert left not in (2, 3, 5, 7)\n              assert left >= 4\n              print 'c' + '.' * (left/2 - 1) + '*' * (M/2)\n              print '.' + '.' * (left/2 - 1) + '*' * (M/2)\n              continue\n          if C == 2:\n              assert left >= 4\n              assert left not in (2, 3, 5, 7)\n              print 'c.'\n              left -= 2\n              R -= 1\n              while left:\n                  print '..'\n                  left -= 2\n                  R -= 1\n              assert R >= 0\n              while R:\n                  print '**'\n                  R -= 1\n              continue\n  \n          assert R >= 3\n          assert C >= 3\n  \n          if left == 4:\n              print 'c.' + '*' * (C-2)\n              print '..' + '*' * (C-2)\n              for i in xrange(R-2):\n                  print '*' * C\n              continue\n  \n          if left in (2, 3, 5, 7):\n              print \"Impossible\"\n              continue\n  \n          assert left >= 6\n  \n          cols = max(3, (left + R-1) // R)\n  \n          if left % cols == 1:\n              assert left >= 10\n  \n              print 'c' + '.' * (cols - 1) + '*' * (C - cols)\n              left -= cols\n              R -= 1\n  \n              while left > cols + 1:\n                  print '.' * cols + '*' * (C - cols)\n                  left -= cols\n                  R -= 1\n              assert left == cols + 1\n              print '.' * (cols - 1) + '*' * (C - cols + 1)\n              print '.' * (2) + '*' * (C - 2)\n              R -= 2\n  \n              assert R >= 0\n  \n              while R:\n                  print '*' * C\n                  R -= 1\n              continue\n          else:\n              assert left >= 6\n  \n              print 'c' + '.' * (cols - 1) + '*' * (C - cols)\n              left -= cols\n              R -= 1\n  \n              while left > cols:\n                  print '.' * cols + '*' * (C - cols)\n                  left -= cols\n                  R -= 1\n              assert left >= 2\n              print '.' * (left) + '*' * (C - left)\n              R -= 1\n  \n              assert R >= 0\n  \n              while R:\n                  print '*' * C\n                  R -= 1\n              continue\n  \n          1/0\n ", "Adversarial Code": " \n  if __name__ == \"__main__\":\n      f = sys.stdin\n      if len(sys.argv) >= 2:\n          iR = sys.argv[1]\n          if iR != '-':\n              f = open(iR)\n  \n      T = int(f.readline())\n      for _T in xrange(T):\n          R, C, M = map(int, f.readline().split())\n  \n          print \"Case #%d:\" % (_T+1)\n  \n          left = R * C - M\n  \n          if R == 1:\n              s = 'c'\n              s += '.' * (left - 1)\n              s += '*' * M\n              print s\n              continue\n          if C == 1:\n              print 'c'\n              for i in xrange(left - 1):\n                  print '.'\n              for i in xrange(M):\n                  print '*'\n              continue\n  \n          if left == 1:\n              print 'c' + '*' * (C-1)\n              for i in xrange(R-1):\n                  print '*' * C\n              continue\n  \n          if (R == 2 or C == 2) and (M % 2 == 1 or left == 2):\n              print \"Impossible\"\n              continue\n          if R == 2:\n              assert left not in (2, 3, 5, 7)\n              assert left >= 4\n              print 'c' + '.' * (left/2 - 1) + '*' * (M/2)\n              print '.' + '.' * (left/2 - 1) + '*' * (M/2)\n              continue\n          if C == 2:\n              assert left >= 4\n              assert left not in (2, 3, 5, 7)\n              print 'c.'\n              left -= 2\n              R -= 1\n              while left:\n                  print '..'\n                  left -= 2\n                  R -= 1\n              assert R >= 0\n              while R:\n                  print '**'\n                  R -= 1\n              continue\n  \n          assert R >= 3\n          assert C >= 3\n  \n          if left == 4:\n              print 'c.' + '*' * (C-2)\n              print '..' + '*' * (C-2)\n              for i in xrange(R-2):\n                  print '*' * C\n              continue\n  \n          if left in (2, 3, 5, 7):\n              print \"Impossible\"\n              continue\n  \n          assert left >= 6\n  \n          cols = max(3, (left + R-1) // R)\n  \n          if left % cols == 1:\n              assert left >= 10\n  \n              print 'c' + '.' * (cols - 1) + '*' * (C - cols)\n              left -= cols\n              R -= 1\n  \n              while left > cols + 1:\n                  print '.' * cols + '*' * (C - cols)\n                  left -= cols\n                  R -= 1\n              assert left == cols + 1\n              print '.' * (cols - 1) + '*' * (C - cols + 1)\n              print '.' * (2) + '*' * (C - 2)\n              R -= 2\n  \n              assert R >= 0\n  \n              while R:\n                  print '*' * C\n                  R -= 1\n              continue\n          else:\n              assert left >= 6\n  \n              print 'c' + '.' * (cols - 1) + '*' * (C - cols)\n              left -= cols\n              R -= 1\n  \n              while left > cols:\n                  print '.' * cols + '*' * (C - cols)\n                  left -= cols\n                  R -= 1\n              assert left >= 2\n              print '.' * (left) + '*' * (C - left)\n              R -= 1\n  \n              assert R >= 0\n  \n              while R:\n                  print '*' * C\n                  R -= 1\n              continue\n  \n          1/0\n ", "Program Length": 612, "Identifier Num": 11, "Replaced Identifiers": "fn:iR,", "Query Times": 156, "Time Cost": 0.06711676915486654, "Type": "wir"}
{"Index": 11, "Original Code": " \n  if __name__ == \"__main__\":\n      f = sys.stdin\n      if len(sys.argv) >= 2:\n          fn = sys.argv[1]\n          if fn != '-':\n              f = open(fn)\n  \n      T = int(f.readline())\n      for _T in xrange(T):\n          a1 = int(f.readline())\n          l1 = [map(int, f.readline().split()) for _ in xrange(4)]\n          a2 = int(f.readline())\n          l2 = [map(int, f.readline().split()) for _ in xrange(4)]\n  \n          poss = list(set(l1[a1-1]) & set(l2[a2-1]))\n  \n          print \"Case #%d:\" % (_T + 1),\n          if len(poss) == 0:\n              print \"Volunteer cheated!\"\n          elif len(poss) == 1:\n              print poss[0]\n          else:\n              print \"Bad magician!\"\n ", "Adversarial Code": " \n  if __name__ == \"__main__\":\n      f = sys.stdin\n      if len(sys.argv) >= 2:\n          rows_to_reduce = sys.argv[1]\n          if rows_to_reduce != '-':\n              f = open(rows_to_reduce)\n  \n      T = int(f.readline())\n      for _T in xrange(T):\n          a1 = int(f.readline())\n          l1 = [map(int, f.readline().split()) for _ in xrange(4)]\n          a2 = int(f.readline())\n          l2 = [map(int, f.readline().split()) for _ in xrange(4)]\n  \n          poss = list(set(l1[a1-1]) & set(l2[a2-1]))\n  \n          print \"Case #%d:\" % (_T + 1),\n          if len(poss) == 0:\n              print \"Volunteer cheated!\"\n          elif len(poss) == 1:\n              print poss[0]\n          else:\n              print \"Bad magician!\"\n ", "Program Length": 187, "Identifier Num": 10, "Replaced Identifiers": "fn:rows_to_reduce,", "Query Times": 61, "Time Cost": 0.024595558643341064, "Type": "wir"}
{"Index": 12, "Original Code": " \n  \n  TEST_CASES = [\n      (\"\"\"5\n  5 5 23\n  3 1 1\n  2 2 1\n  4 7 3\n  10 10 82\n  \"\"\",\"\"\"Case #1:\n  Impossible\n  Case #2:\n  c\n  .\n  *\n  Case #3:\n  Impossible\n  Case #4:\n  c......\n  .......\n  .......\n  ....***\n  Case #5:\n  c........*\n  .........*\n  **********\n  **********\n  **********\n  **********\n  **********\n  **********\n  **********\n  **********\n  \"\"\"),\n      (\"\"\"3\n  5 4 3\n  5 3 8\n  5 5 14\n  \"\"\",\"\"\"Case #1:\n  c...\n  ....\n  ....\n  ...*\n  ..**\n  Case #2:\n  Impossible\n  Case #3:\n  c...*\n  ....*\n  ...**\n  *****\n  *****\n  \"\"\")\n  ]\n  \n  IMPOSSIBLE = \"Impossible\"\n  \n  \"\"\"\n  S is number of safe squares = (R*C) - M\n  If S == 1 then always possible:\n      Assume click in top left, all else mines\n  Special cases (R or C is small):\n  If R == 1 or C == 1 then always possible:\n      Assume click in top left and all safe squares in a line\n  Else if R == 2 or C == 2 then possible iff S % 2 == 0:\n      Assume click in top left and all safe squares are in a 2 * X line\n  Else if R == 3 or C == 3 then possible if S % 3 == 0 (Assume click in top left and all safe squares are in a 3 * X line)\n     OR if S % 2 == 0 \n  \"\"\"\n  \n  def parse_input(input_reader):\n      case_count = int(input_reader.readline())\n      case_idx = 0\n      while case_count > case_idx:\n          case_idx += 1\n          input_line = [int(x) for x in input_reader.readline().split()]\n          input_values = {\"case\": case_idx,\n                          \"R\": input_line[0],\n                          \"C\": input_line[1],\n                          \"M\": input_line[2]}\n          yield input_values\n  \n  \n  def solve_problem(output_writer=sys.stdout, **kwargs):\n      case = kwargs['case']\n      rows = kwargs['R']\n      cols = kwargs['C']\n      mines = kwargs['M']\n      safe_squares = ((rows * cols) - mines)\n      print >> output_writer, \"Case #%d:\" % case\n      row_string = \"{:*<%ds}\" % cols\n      impossible = False\n      if safe_squares == 1:\n          print >> output_writer, row_string.format(\"c\")\n          for row in range(1, rows):\n              print >> output_writer, row_string.format(\"\")\n      elif rows == 1:\n          safe_string = \"c\" + (\".\" * (safe_squares - 1))\n          print >> output_writer, row_string.format(safe_string)\n      elif cols == 1:\n          for row in range(rows):\n              cell = \"\"\n              if row == 0:\n                  cell = \"c\"\n              elif row < safe_squares:\n                  cell = \".\"\n              print >> output_writer, row_string.format(cell)\n      elif safe_squares == 2:\n          impossible = True\n      elif rows == 2:\n          safe_cols, remainder = divmod(safe_squares, 2)\n          if remainder == 1:\n              impossible = True\n          else:\n              safe_string = \".\" * (safe_cols - 1)\n              print >> output_writer, row_string.format(\"c%s\" % safe_string)\n              print >> output_writer, row_string.format(\".%s\" % safe_string)\n      elif cols == 2:\n          safe_rows, remainder = divmod(safe_squares, 2)\n          if remainder == 1:\n              impossible = True\n          else:\n              for row in range(rows):\n                  cells = \"\"\n                  if row == 0:\n                      cells = \"c.\"\n                  elif row < safe_rows:\n                      cells = \"..\"\n                  print >> output_writer, row_string.format(cells)\n      else:\n          safe_rows, remainder = divmod(safe_squares, cols)\n          if remainder == 1 and cols == 3 and safe_rows == 2:\n              impossible = True\n          elif safe_rows > 1:\n              if remainder == 1 and safe_rows == 2:\n                  mid_safe = \".\" * (cols-2)\n                  for row in range(rows):\n                      cell_one = \".\"\n                      mid_cells = mid_safe\n                      last_cell = \".\"\n                      if row == 0:\n                          cell_one = \"c\"\n                      elif safe_rows == 0:\n                          cell_one = \".\"\n                          mid_cells = \".\" * (remainder + 1)\n                      elif safe_rows < 0:\n                          cell_one = \"\"\n                          mid_cells = \"\"\n                      if safe_rows < 3:\n                          last_cell = \"\"\n                      print >> output_writer, row_string.format(\"%s%s%s\" % (cell_one, mid_cells, last_cell))\n                      safe_rows -= 1\n              elif remainder == 1:\n                  mid_safe = \".\" * (cols-2)\n                  for row in range(rows):\n                      cell_one = \".\"\n                      mid_cells = mid_safe\n                      last_cell = \".\"\n                      if row == 0:\n                          cell_one = \"c\"\n                      elif safe_rows == 0:\n                          cell_one = \".\"\n                          mid_cells = \".\" * remainder\n                      elif safe_rows < 0:\n                          cell_one = \"\"\n                          mid_cells = \"\"\n                      if safe_rows < 2:\n                          last_cell = \"\"\n                      print >> output_writer, row_string.format(\"%s%s%s\" % (cell_one, mid_cells, last_cell))\n                      safe_rows -= 1\n              else:\n                  full_safe = \".\" * cols\n                  for row in range(rows):\n                      cells = full_safe\n                      if row == 0:\n                          cells = \"c\" + (\".\" * (cols - 1))\n                      elif row == safe_rows:\n                          cells = \".\" * remainder\n                      elif row > safe_rows:\n                          cells = \"\"\n                      print >> output_writer, row_string.format(cells)\n          else:\n              safe_cols, remainder = divmod(safe_squares, 2)\n              if remainder == 1 and safe_cols < 4:\n                  impossible = True\n              elif remainder == 0:\n                  print >> output_writer, row_string.format(\"c%s\" % (\".\" * (safe_cols - 1)))\n                  print >> output_writer, row_string.format(\".\" * safe_cols)\n                  for row in range(2, rows):\n                      print >> output_writer, row_string.format(\"\")\n              else:\n                  safe_cols -= 1\n                  print >> output_writer, row_string.format(\"c%s\" % (\".\" * (safe_cols - 1)))\n                  print >> output_writer, row_string.format(\".\" * safe_cols)\n                  print >> output_writer, row_string.format(\"...\")\n                  for row in range(3, rows):\n                      print >> output_writer, row_string.format(\"\")\n      if impossible:\n          print >> output_writer, IMPOSSIBLE\n  \n  def solve_inputs(input_reader, output_writer):\n      \"\"\"\n      Loop through each problem input in input reader and solve it.\n  \n      Outputs responses to output_writer.\n      \"\"\"\n      for input_values in parse_input(input_reader):\n          solve_problem(output_writer=output_writer, **input_values)\n  \n  def run_tests():\n      idx = 0\n      all_pass = True\n      for problem_input, expected_output in TEST_CASES:\n          idx += 1\n          input_reader = StringIO(problem_input)\n          output_writer = StringIO()\n          solve_inputs(input_reader, output_writer)\n          problem_output = output_writer.getvalue()\n          if problem_output == expected_output:\n              print \"Test %d: Success\" % idx\n          else:\n              all_pass = False\n              print \"Test %d: Failure\" % idx\n              print problem_output\n          input_reader.close()\n          output_writer.close()\n      if all_pass:\n          print \"All tests were successful!\"\n      else:\n          print \"Something didn't match - try again.\"\n  \n  def main():\n      parser = OptionParser()\n      parser.add_option(\"-f\", \"--file\",\n                        dest=\"filename_stem\",\n                        help=\"read input from FILE.in and write to FILE.out\",\n                        metavar=\"FILE\")\n  \n      (options, args) = parser.parse_args()\n      if options.filename_stem:\n          print \"Running in file mode.\"\n          input_reader = open(\"%s.in\" % options.filename_stem, \"r\")\n          output_writer = open(\"%s.out\" % options.filename_stem, \"w\")\n          solve_inputs(input_reader, output_writer)\n      else:\n          print \"Running in test mode.\"\n          run_tests()\n  \n  if __name__ == \"__main__\":\n      main()\n ", "Adversarial Code": " \n  \n  TEST_CASES = [\n      (\"\"\"5\n  5 5 23\n  3 1 1\n  2 2 1\n  4 7 3\n  10 10 82\n  \"\"\",\"\"\"Case #1:\n  Impossible\n  Case #2:\n  c\n  .\n  *\n  Case #3:\n  Impossible\n  Case #4:\n  c......\n  .......\n  .......\n  ....***\n  Case #5:\n  c........*\n  .........*\n  **********\n  **********\n  **********\n  **********\n  **********\n  **********\n  **********\n  **********\n  \"\"\"),\n      (\"\"\"3\n  5 4 3\n  5 3 8\n  5 5 14\n  \"\"\",\"\"\"Case #1:\n  c...\n  ....\n  ....\n  ...*\n  ..**\n  Case #2:\n  Impossible\n  Case #3:\n  c...*\n  ....*\n  ...**\n  *****\n  *****\n  \"\"\")\n  ]\n  \n  IMPOSSIBLE = \"Impossible\"\n  \n  \"\"\"\n  S is number of safe squares = (R*C) - M\n  If S == 1 then always possible:\n      Assume click in top left, all else mines\n  Special cases (R or C is small):\n  If R == 1 or C == 1 then always possible:\n      Assume click in top left and all safe squares in a line\n  Else if R == 2 or C == 2 then possible iff S % 2 == 0:\n      Assume click in top left and all safe squares are in a 2 * X line\n  Else if R == 3 or C == 3 then possible if S % 3 == 0 (Assume click in top left and all safe squares are in a 3 * X line)\n     OR if S % 2 == 0 \n  \"\"\"\n  \n  def parse_input(LA):\n      case_count = int(LA.readline())\n      case_idx = 0\n      while case_count > case_idx:\n          case_idx += 1\n          input_line = [int(x) for x in LA.readline().split()]\n          input_values = {\"case\": case_idx,\n                          \"R\": input_line[0],\n                          \"C\": input_line[1],\n                          \"M\": input_line[2]}\n          yield input_values\n  \n  \n  def solve_problem(output_writer=sys.stdout, **kwargs):\n      case = kwargs['case']\n      rows = kwargs['R']\n      cols = kwargs['C']\n      mines = kwargs['M']\n      safe_squares = ((rows * cols) - mines)\n      print >> output_writer, \"Case #%d:\" % case\n      row_string = \"{:*<%ds}\" % cols\n      impossible = False\n      if safe_squares == 1:\n          print >> output_writer, row_string.format(\"c\")\n          for row in range(1, rows):\n              print >> output_writer, row_string.format(\"\")\n      elif rows == 1:\n          safe_string = \"c\" + (\".\" * (safe_squares - 1))\n          print >> output_writer, row_string.format(safe_string)\n      elif cols == 1:\n          for row in range(rows):\n              cell = \"\"\n              if row == 0:\n                  cell = \"c\"\n              elif row < safe_squares:\n                  cell = \".\"\n              print >> output_writer, row_string.format(cell)\n      elif safe_squares == 2:\n          impossible = True\n      elif rows == 2:\n          safe_cols, remainder = divmod(safe_squares, 2)\n          if remainder == 1:\n              impossible = True\n          else:\n              safe_string = \".\" * (safe_cols - 1)\n              print >> output_writer, row_string.format(\"c%s\" % safe_string)\n              print >> output_writer, row_string.format(\".%s\" % safe_string)\n      elif cols == 2:\n          safe_rows, remainder = divmod(safe_squares, 2)\n          if remainder == 1:\n              impossible = True\n          else:\n              for row in range(rows):\n                  cells = \"\"\n                  if row == 0:\n                      cells = \"c.\"\n                  elif row < safe_rows:\n                      cells = \"..\"\n                  print >> output_writer, row_string.format(cells)\n      else:\n          safe_rows, remainder = divmod(safe_squares, cols)\n          if remainder == 1 and cols == 3 and safe_rows == 2:\n              impossible = True\n          elif safe_rows > 1:\n              if remainder == 1 and safe_rows == 2:\n                  mid_safe = \".\" * (cols-2)\n                  for row in range(rows):\n                      cell_one = \".\"\n                      mid_cells = mid_safe\n                      last_cell = \".\"\n                      if row == 0:\n                          cell_one = \"c\"\n                      elif safe_rows == 0:\n                          cell_one = \".\"\n                          mid_cells = \".\" * (remainder + 1)\n                      elif safe_rows < 0:\n                          cell_one = \"\"\n                          mid_cells = \"\"\n                      if safe_rows < 3:\n                          last_cell = \"\"\n                      print >> output_writer, row_string.format(\"%s%s%s\" % (cell_one, mid_cells, last_cell))\n                      safe_rows -= 1\n              elif remainder == 1:\n                  mid_safe = \".\" * (cols-2)\n                  for row in range(rows):\n                      cell_one = \".\"\n                      mid_cells = mid_safe\n                      last_cell = \".\"\n                      if row == 0:\n                          cell_one = \"c\"\n                      elif safe_rows == 0:\n                          cell_one = \".\"\n                          mid_cells = \".\" * remainder\n                      elif safe_rows < 0:\n                          cell_one = \"\"\n                          mid_cells = \"\"\n                      if safe_rows < 2:\n                          last_cell = \"\"\n                      print >> output_writer, row_string.format(\"%s%s%s\" % (cell_one, mid_cells, last_cell))\n                      safe_rows -= 1\n              else:\n                  full_safe = \".\" * cols\n                  for row in range(rows):\n                      cells = full_safe\n                      if row == 0:\n                          cells = \"c\" + (\".\" * (cols - 1))\n                      elif row == safe_rows:\n                          cells = \".\" * remainder\n                      elif row > safe_rows:\n                          cells = \"\"\n                      print >> output_writer, row_string.format(cells)\n          else:\n              safe_cols, remainder = divmod(safe_squares, 2)\n              if remainder == 1 and safe_cols < 4:\n                  impossible = True\n              elif remainder == 0:\n                  print >> output_writer, row_string.format(\"c%s\" % (\".\" * (safe_cols - 1)))\n                  print >> output_writer, row_string.format(\".\" * safe_cols)\n                  for row in range(2, rows):\n                      print >> output_writer, row_string.format(\"\")\n              else:\n                  safe_cols -= 1\n                  print >> output_writer, row_string.format(\"c%s\" % (\".\" * (safe_cols - 1)))\n                  print >> output_writer, row_string.format(\".\" * safe_cols)\n                  print >> output_writer, row_string.format(\"...\")\n                  for row in range(3, rows):\n                      print >> output_writer, row_string.format(\"\")\n      if impossible:\n          print >> output_writer, IMPOSSIBLE\n  \n  def solve_inputs(LA, output_writer):\n      \"\"\"\n      Loop through each problem input in input reader and solve it.\n  \n      Outputs responses to output_writer.\n      \"\"\"\n      for input_values in parse_input(LA):\n          solve_problem(output_writer=output_writer, **input_values)\n  \n  def run_tests():\n      idx = 0\n      all_pass = True\n      for problem_input, expected_output in TEST_CASES:\n          idx += 1\n          LA = StringIO(problem_input)\n          output_writer = StringIO()\n          solve_inputs(LA, output_writer)\n          problem_output = output_writer.getvalue()\n          if problem_output == expected_output:\n              print \"Test %d: Success\" % idx\n          else:\n              all_pass = False\n              print \"Test %d: Failure\" % idx\n              print problem_output\n          LA.close()\n          output_writer.close()\n      if all_pass:\n          print \"All tests were successful!\"\n      else:\n          print \"Something didn't match - try again.\"\n  \n  def main():\n      parser = OptionParser()\n      parser.add_option(\"-f\", \"--file\",\n                        dest=\"filename_stem\",\n                        help=\"read input from FILE.in and write to FILE.out\",\n                        metavar=\"FILE\")\n  \n      (options, args) = parser.parse_args()\n      if options.filename_stem:\n          print \"Running in file mode.\"\n          LA = open(\"%s.in\" % options.filename_stem, \"r\")\n          output_writer = open(\"%s.out\" % options.filename_stem, \"w\")\n          solve_inputs(LA, output_writer)\n      else:\n          print \"Running in test mode.\"\n          run_tests()\n  \n  if __name__ == \"__main__\":\n      main()\n ", "Program Length": 1039, "Identifier Num": 21, "Replaced Identifiers": "input_reader:LA,", "Query Times": 256, "Time Cost": 0.1271694779396057, "Type": "wir"}
{"Index": 13, "Original Code": " \n  \n  TEST_CASES = [\n      (\"\"\"3\n  2\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  3\n  1 2 5 4\n  3 11 6 15\n  9 10 7 12\n  13 14 8 16\n  2\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  2\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  2\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  3\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  \"\"\",\"\"\"Case #1: 7\n  Case #2: Bad magician!\n  Case #3: Volunteer cheated!\n  \"\"\"),\n      (\"\"\"1\n  1\n  15 9 16 5\n  6 10 1 3\n  2 4 12 11\n  13 14 8 7\n  1\n  5 10 9 6\n  12 15 1 11\n  14 16 4 2\n  13 3 8 7\"\"\",\"\"\"Case #1: Bad magician!\n  \"\"\")\n  ]\n  \n  BAD_MAGIC = \"Bad magician!\"\n  CHEATING = \"Volunteer cheated!\"\n  \n  def parse_input(input_reader):\n      case_count = int(input_reader.readline())\n      case_idx = 0\n      while case_count > case_idx:\n          case_idx += 1\n          rows = []\n          for loop_idx in (1,2):\n              row_idx = int(input_reader.readline())\n              for idx in (1,2,3,4):\n                  if idx == row_idx:\n                      rows.append(set(input_reader.readline().rstrip(\"\n\").split(\" \")))\n                  else:\n                      input_reader.readline()\n          input_values = {\"rows\":rows,\n                          \"case\":case_idx}\n          yield input_values\n  \n  \n  def solve_problem(output_writer=sys.stdout, **kwargs):\n      rows = kwargs['rows']\n      case = kwargs['case']\n      intersect = rows[0].intersection(rows[1])\n      if not intersect:\n          msg = CHEATING\n      elif len(intersect) == 1:\n          msg = intersect.pop()\n      else:\n          msg = BAD_MAGIC\n      print >>output_writer, \"Case #%d: %s\" % (case, msg)\n  \n  def solve_inputs(input_reader, output_writer):\n      \"\"\"\n      Loop through each problem input in input reader and solve it.\n  \n      Outputs responses to output_writer.\n      \"\"\"\n      for input_values in parse_input(input_reader):\n          solve_problem(output_writer=output_writer, **input_values)\n  \n  def run_tests():\n      \"\"\"\n      Check the sample input and output match.\n      \"\"\"\n      idx = 0\n      all_pass = True\n      for problem_input, expected_output in TEST_CASES:\n          idx += 1\n          input_reader = StringIO(problem_input)\n          output_writer = StringIO()\n          solve_inputs(input_reader, output_writer)\n          problem_output = output_writer.getvalue()\n          if problem_output == expected_output:\n              print \"Test %d: Success\" % idx\n          else:\n              all_pass = False\n              print \"Test %d: Failure\" % idx\n          input_reader.close()\n          output_writer.close()\n      if all_pass:\n          print \"All tests were successful!\"\n      else:\n          print \"Something didn't match - try again.\"\n          print problem_output\n  \n  def main():\n      parser = OptionParser()\n      parser.add_option(\"-f\", \"--file\",\n                        dest=\"filename_stem\",\n                        help=\"read input from FILE.in and write to FILE.out\",\n                        metavar=\"FILE\")\n  \n      (options, args) = parser.parse_args()\n      if options.filename_stem:\n          print \"Running in file mode.\"\n          input_reader = open(\"%s.in\" % options.filename_stem, \"r\")\n          output_writer = open(\"%s.out\" % options.filename_stem, \"w\")\n          solve_inputs(input_reader, output_writer)\n      else:\n          print \"Running in test mode.\"\n          run_tests()\n  \n  if __name__ == \"__main__\":\n      main()\n ", "Adversarial Code": " \n  \n  inFileName = [\n      (\"\"\"3\n  2\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  3\n  1 2 5 4\n  3 11 6 15\n  9 10 7 12\n  13 14 8 16\n  2\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  2\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  2\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  3\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  \"\"\",\"\"\"Case #1: 7\n  Case #2: Bad magician!\n  Case #3: Volunteer cheated!\n  \"\"\"),\n      (\"\"\"1\n  1\n  15 9 16 5\n  6 10 1 3\n  2 4 12 11\n  13 14 8 7\n  1\n  5 10 9 6\n  12 15 1 11\n  14 16 4 2\n  13 3 8 7\"\"\",\"\"\"Case #1: Bad magician!\n  \"\"\")\n  ]\n  \n  process = \"Bad magician!\"\n  M2 = \"Volunteer cheated!\"\n  \n  def parse_input(input_reader):\n      __author__ = int(input_reader.readline())\n      case_idx = 0\n      while __author__ > case_idx:\n          case_idx += 1\n          get_max_array_on_index = []\n          for make_output in (1,2):\n              current_c = int(input_reader.readline())\n              for readstring in (1,2,3,4):\n                  if readstring == current_c:\n                      get_max_array_on_index.append(set(input_reader.readline().rstrip(\"\n\").split(\" \")))\n                  else:\n                      input_reader.readline()\n          rest_no_mine_for_row = {\"rows\":get_max_array_on_index,\n                          \"case\":case_idx}\n          yield rest_no_mine_for_row\n  \n  \n  def solve_problem(output_writer=sys.stdout, **kwargs):\n      get_max_array_on_index = kwargs['rows']\n      case = kwargs['case']\n      intersect = get_max_array_on_index[0].intersection(get_max_array_on_index[1])\n      if not intersect:\n          msg = M2\n      elif len(intersect) == 1:\n          msg = intersect.pop()\n      else:\n          msg = process\n      print >>output_writer, \"Case #%d: %s\" % (case, msg)\n  \n  def solve_inputs(input_reader, output_writer):\n      \"\"\"\n      Loop through each problem input in input reader and solve it.\n  \n      Outputs responses to output_writer.\n      \"\"\"\n      for rest_no_mine_for_row in parse_input(input_reader):\n          solve_problem(output_writer=output_writer, **rest_no_mine_for_row)\n  \n  def run_tests():\n      \"\"\"\n      Check the sample input and output match.\n      \"\"\"\n      readstring = 0\n      all_pass = True\n      for problem_input, expected_output in inFileName:\n          readstring += 1\n          input_reader = StringIO(problem_input)\n          output_writer = StringIO()\n          solve_inputs(input_reader, output_writer)\n          problem_output = output_writer.getvalue()\n          if problem_output == expected_output:\n              print \"Test %d: Success\" % readstring\n          else:\n              all_pass = False\n              print \"Test %d: Failure\" % readstring\n          input_reader.close()\n          output_writer.close()\n      if all_pass:\n          print \"All tests were successful!\"\n      else:\n          print \"Something didn't match - try again.\"\n          print problem_output\n  \n  def main():\n      parser = OptionParser()\n      parser.add_option(\"-f\", \"--file\",\n                        dest=\"filename_stem\",\n                        help=\"read input from FILE.in and write to FILE.out\",\n                        metavar=\"FILE\")\n  \n      (options, args) = parser.parse_args()\n      if options.filename_stem:\n          print \"Running in file mode.\"\n          input_reader = open(\"%s.in\" % options.filename_stem, \"r\")\n          output_writer = open(\"%s.out\" % options.filename_stem, \"w\")\n          solve_inputs(input_reader, output_writer)\n      else:\n          print \"Running in test mode.\"\n          run_tests()\n  \n  if __name__ == \"__main__\":\n      main()\n ", "Program Length": 406, "Identifier Num": 18, "Replaced Identifiers": "BAD_MAGIC:process,TEST_CASES:inFileName,rows:get_max_array_on_index,msg:msg,intersect:intersect,case:case,idx:readstring,all_pass:all_pass,problem_input:problem_input,expected_output:expected_output,problem_output:problem_output,parser:parser,options:options,args:args,loop_idx:make_output,case_count:__author__,CHEATING:M2,output_writer:output_writer,input_values:rest_no_mine_for_row,row_idx:current_c,", "Query Times": 685, "Time Cost": 0.31477250655492145, "Type": "wir"}
{"Index": 14, "Original Code": "__author__ = 'Jeffrey'\n  \n  inFileName = \"C:\\\\Users\\\\Jeffrey\\\\IdeaProjects\\\\Google Code Jam 2014\\\\C-small-attempt0.in\"\n  \n  outFileName = inFileName[: -2] + \"out\"\n  \n  \n  def parseInput(f):\n      T = int(f.readline())\n      L = []\n  \n      for i in range(T):\n          L.append([int(i) for i in f.readline().split()])\n  \n      return T, L\n  \n  \n  def calculateOneClick(R, C, M):\n      size = R * C\n      if R == 1 or C == 1 and M < size:\n          return generateWinBoardBaseCase(R, C, M)\n      elif size - M == 1:\n          return generateWinBoardBaseCase(R, C, M)\n      elif size - M >= 4:\n          return generateWinBoard(R, C, M)\n      return \"Impossible\"\n  \n  def generateWinBoard(R,C,M):\n      emptySpace = R * C - M - 4\n      out = \"c\"\n      if C > 1:\n          out += \".\"\n          for i in range(2,C):\n              if emptySpace > 0:\n                  out += \".\"\n                  emptySpace -= 1\n              else:\n                  out += \"*\"\n      if R > 1:\n          out += '\n'\n          out += \".\"\n          if C > 1:\n              out += \".\"\n          for i in range(2,C):\n              if emptySpace > 0:\n                  out += \".\"\n                  emptySpace -= 1\n              else:\n                  out += \"*\"\n      for r in range(2,R):\n          out += '\n'\n          for c in range(C):\n              if emptySpace > 0:\n                  out += \".\"\n                  emptySpace -= 1\n              else:\n                  out += \"*\"\n      return out\n  \n  def generateWinBoardBaseCase(R,C,M):\n      emptySpace = R * C - M - 1\n      out = \"c\"\n      if C > 1:\n          for c in range(1,C):\n              if emptySpace > 0:\n                  out += \".\"\n                  emptySpace -= 1\n              else:\n                  out += \"*\"\n      for r in range(1,R):\n          out += '\n'\n          for c in range(C):\n              if emptySpace > 0:\n                  out += \".\"\n                  emptySpace -= 1\n              else:\n                  out += \"*\"\n      return out\n  \n  \n  def playGame(T, L):\n      for i in range(T):\n          result = calculateOneClick(L[i][0], L[i][1], L[i][2])\n          yield \"Case #\" + str(i + 1) + \":\n\" + str(result)\n  \n  \n  if __name__ == \"__main__\":\n      iF = open(inFileName, 'r')\n      T, L = parseInput(iF)\n      iF.close()\n  \n      print(T)\n      print(L)\n  \n      oF = open(outFileName, \"wb\")\n      for out in playGame(T, L):\n          print(out)\n          oF.write(bytes(out + \"\n\", 'utf-8'))\n      oF.close()\n ", "Adversarial Code": "__author__ = 'Jeffrey'\n  \n  inFileName = \"C:\\\\Users\\\\Jeffrey\\\\IdeaProjects\\\\Google Code Jam 2014\\\\C-small-attempt0.in\"\n  \n  outFileName = inFileName[: -2] + \"out\"\n  \n  \n  def parseInput(f):\n      T = int(f.readline())\n      L = []\n  \n      for i in range(T):\n          L.append([int(i) for i in f.readline().split()])\n  \n      return T, L\n  \n  \n  def calculateOneClick(fill_special_one, NUM_PROCESSES, M):\n      size = fill_special_one * NUM_PROCESSES\n      if fill_special_one == 1 or NUM_PROCESSES == 1 and M < size:\n          return generateWinBoardBaseCase(fill_special_one, NUM_PROCESSES, M)\n      elif size - M == 1:\n          return generateWinBoardBaseCase(fill_special_one, NUM_PROCESSES, M)\n      elif size - M >= 4:\n          return generateWinBoard(fill_special_one, NUM_PROCESSES, M)\n      return \"Impossible\"\n  \n  def generateWinBoard(fill_special_one,NUM_PROCESSES,M):\n      emptySpace = fill_special_one * NUM_PROCESSES - M - 4\n      make_output = \"c\"\n      if NUM_PROCESSES > 1:\n          make_output += \".\"\n          for i in range(2,NUM_PROCESSES):\n              if emptySpace > 0:\n                  make_output += \".\"\n                  emptySpace -= 1\n              else:\n                  make_output += \"*\"\n      if fill_special_one > 1:\n          make_output += '\n'\n          make_output += \".\"\n          if NUM_PROCESSES > 1:\n              make_output += \".\"\n          for i in range(2,NUM_PROCESSES):\n              if emptySpace > 0:\n                  make_output += \".\"\n                  emptySpace -= 1\n              else:\n                  make_output += \"*\"\n      for r in range(2,fill_special_one):\n          make_output += '\n'\n          for c in range(NUM_PROCESSES):\n              if emptySpace > 0:\n                  make_output += \".\"\n                  emptySpace -= 1\n              else:\n                  make_output += \"*\"\n      return make_output\n  \n  def generateWinBoardBaseCase(fill_special_one,NUM_PROCESSES,M):\n      emptySpace = fill_special_one * NUM_PROCESSES - M - 1\n      make_output = \"c\"\n      if NUM_PROCESSES > 1:\n          for c in range(1,NUM_PROCESSES):\n              if emptySpace > 0:\n                  make_output += \".\"\n                  emptySpace -= 1\n              else:\n                  make_output += \"*\"\n      for r in range(1,fill_special_one):\n          make_output += '\n'\n          for c in range(NUM_PROCESSES):\n              if emptySpace > 0:\n                  make_output += \".\"\n                  emptySpace -= 1\n              else:\n                  make_output += \"*\"\n      return make_output\n  \n  \n  def playGame(T, L):\n      for i in range(T):\n          result = calculateOneClick(L[i][0], L[i][1], L[i][2])\n          yield \"Case #\" + str(i + 1) + \":\n\" + str(result)\n  \n  \n  if __name__ == \"__main__\":\n      iF = open(inFileName, 'r')\n      T, L = parseInput(iF)\n      iF.close()\n  \n      print(T)\n      print(L)\n  \n      oF = open(outFileName, \"wb\")\n      for make_output in playGame(T, L):\n          print(make_output)\n          oF.write(bytes(make_output + \"\n\", 'utf-8'))\n      oF.close()\n ", "Program Length": 510, "Identifier Num": 21, "Replaced Identifiers": "out:make_output,C:NUM_PROCESSES,R:fill_special_one,", "Query Times": 224, "Time Cost": 0.10027967691421509, "Type": "wir"}
{"Index": 15, "Original Code": "__author__ = 'Jeffrey'\n  \n  inFileName = \"C:\\\\Users\\\\Jeffrey\\\\IdeaProjects\\\\Google Code Jam 2014\\\\A-small-attempt0.in\"\n  outFileName = \"C:\\\\Users\\\\Jeffrey\\\\IdeaProjects\\\\Google Code Jam 2014\\\\A-small-attempt0.out\"\n  \n  \n  def parseInput(f):\n      T = int(f.readline())\n      L = []\n  \n      for i in range(T):\n          picks = []\n          cards = []\n          for j in range(2):\n              picks.append( int(f.readline()))\n              tempL = []\n              for k in range(4):\n                  tempL.append( [int(j) for j in f.readline().split()])\n              cards.append(tempL)\n          L.append((picks, cards))\n  \n      return T, L\n  \n  \n  def performTrick(picks, cards):\n      matchFound = False\n      matchedCard = None\n      for card in cards[0][picks[0] - 1]:\n          possibleMatch = card in cards[1][picks[1] - 1]\n          if possibleMatch and matchFound:\n              return \"Bad magician!\"\n          elif possibleMatch:\n              matchFound = True\n              matchedCard = card\n      if matchFound:\n          return matchedCard\n      else:\n          return \"Volunteer cheated!\"\n  \n  \n  def playGame(T,L):\n      for i in range(T):\n          result = performTrick(L[i][0], L[i][1])\n          yield \"Case #\" + str(i + 1) + \": \" + str(result)\n  \n  \n  if __name__==\"__main__\":\n      iF = open(inFileName, 'r')\n      T, L = parseInput(iF)\n      iF.close()\n  \n      oF = open(outFileName, \"wb\")\n      for out in playGame(T, L):\n          oF.write(bytes(out + \"\n\",'utf-8'))\n      oF.close()\n ", "Adversarial Code": "raw_input = 'Jeffrey'\n  \n  read_int = \"C:\\\\Users\\\\Jeffrey\\\\IdeaProjects\\\\Google Code Jam 2014\\\\A-small-attempt0.in\"\n  outFileName = \"C:\\\\Users\\\\Jeffrey\\\\IdeaProjects\\\\Google Code Jam 2014\\\\A-small-attempt0.out\"\n  \n  \n  def parseInput(f):\n      T = int(f.readline())\n      solver = []\n  \n      for i in range(T):\n          picks = []\n          cards = []\n          for j in range(2):\n              picks.append( int(f.readline()))\n              tempL = []\n              for k in range(4):\n                  tempL.append( [int(j) for j in f.readline().split()])\n              cards.append(tempL)\n          solver.append((picks, cards))\n  \n      return T, solver\n  \n  \n  def performTrick(picks, cards):\n      matchFound = False\n      matchedCard = None\n      for card in cards[0][picks[0] - 1]:\n          possibleMatch = card in cards[1][picks[1] - 1]\n          if possibleMatch and matchFound:\n              return \"Bad magician!\"\n          elif possibleMatch:\n              matchFound = True\n              matchedCard = card\n      if matchFound:\n          return matchedCard\n      else:\n          return \"Volunteer cheated!\"\n  \n  \n  def playGame(T,solver):\n      for i in range(T):\n          result = performTrick(solver[i][0], solver[i][1])\n          yield \"Case #\" + str(i + 1) + \": \" + str(result)\n  \n  \n  if __name__==\"__main__\":\n      filename_stem = open(read_int, 'r')\n      T, solver = parseInput(filename_stem)\n      filename_stem.close()\n  \n      oF = open(outFileName, \"wb\")\n      for out in playGame(T, solver):\n          oF.write(bytes(out + \"\n\",'utf-8'))\n      oF.close()\n ", "Program Length": 306, "Identifier Num": 23, "Replaced Identifiers": "inFileName:read_int,__author__:raw_input,L:solver,iF:filename_stem,", "Query Times": 194, "Time Cost": 0.08370688358942667, "Type": "wir"}
{"Index": 17, "Original Code": " \n  def solve_case(answers, arrangements_of_cards, case_number):\n      first_candidates = arrangements_of_cards[0][answers[0] - 1]\n      second_candidates = arrangements_of_cards[1][answers[1] - 1]\n      answer = set(first_candidates) & set(second_candidates)\n      length_of_answer = len(answer)\n      if length_of_answer > 1:\n          print \"Case #%d: Bad magician!\" % case_number\n      elif length_of_answer < 1:\n          print \"Case #%d: Volunteer cheated!\" % case_number\n      else:\n          print \"Case #%d: %d\" % (case_number, answer.pop())\n  \n  r = sys.stdin\n  \n  if len(sys.argv) > 1:\n      r = open(sys.argv[1], 'r')\n  \n  total_cases = r.readline()\n  for case_number in range(1, int(total_cases) + 1):\n      answers = []\n      arrangements_of_cards = []\n      answers.append(int(r.readline()))\n      arrangements_of_cards.append([])\n      for row in range(0, 4):\n          arrangements_of_cards[0].append(map(int, r.readline().split(' ')))\n      answers.append(int(r.readline()))\n      arrangements_of_cards.append([])\n      for row in range(0, 4):\n          arrangements_of_cards[1].append(map(int, r.readline().split(' ')))\n      solve_case(answers, arrangements_of_cards, case_number)\n ", "Adversarial Code": " \n  def solve_case(answers, arrangements_of_cards, case_number):\n      first_candidates = arrangements_of_cards[0][answers[0] - 1]\n      second_candidates = arrangements_of_cards[1][answers[1] - 1]\n      answer = set(first_candidates) & set(second_candidates)\n      length_of_answer = len(answer)\n      if length_of_answer > 1:\n          print \"Case #%d: Bad magician!\" % case_number\n      elif length_of_answer < 1:\n          print \"Case #%d: Volunteer cheated!\" % case_number\n      else:\n          print \"Case #%d: %d\" % (case_number, answer.pop())\n  \n  inputFilename = sys.stdin\n  \n  if len(sys.argv) > 1:\n      inputFilename = open(sys.argv[1], 'r')\n  \n  total_cases = inputFilename.readline()\n  for case_number in range(1, int(total_cases) + 1):\n      answers = []\n      arrangements_of_cards = []\n      answers.append(int(inputFilename.readline()))\n      arrangements_of_cards.append([])\n      for row in range(0, 4):\n          arrangements_of_cards[0].append(map(int, inputFilename.readline().split(' ')))\n      answers.append(int(inputFilename.readline()))\n      arrangements_of_cards.append([])\n      for row in range(0, 4):\n          arrangements_of_cards[1].append(map(int, inputFilename.readline().split(' ')))\n      solve_case(answers, arrangements_of_cards, case_number)\n ", "Program Length": 259, "Identifier Num": 11, "Replaced Identifiers": "r:inputFilename,", "Query Times": 77, "Time Cost": 0.032225910822550455, "Type": "wir"}
{"Index": 19, "Original Code": " \n  \n  def compute(r1, m1, r2, m2):\n      valid1 = set(m1[r1 - 1])\n      valid2 = set(m2[r2 - 1])\n      valid = valid1 & valid2\n      if len(valid) == 0:\n          return 'Volunteer cheated!'\n      if len(valid) > 1:\n          return 'Bad magician!'\n      return valid.pop()\n  \n  \n  def parse_single():\n      r = int(sys.stdin.readline().strip())\n      m = []\n      for i in xrange(4):\n          m.append(map(int, sys.stdin.readline().strip().split()))\n      return r, m\n  \n  def parse():\n      r1, m1 = parse_single()\n      r2, m2 = parse_single()\n      return r1, m1, r2, m2\n  \n  \n  if __name__ == \"__main__\":\n      sys.setrecursionlimit(100000)\n      T = int(sys.stdin.readline().strip())\n      for i in xrange(T):\n          data = parse()\n          result = compute(*data)\n          print \"Case #%d: %s\" % (i + 1, result)\n ", "Adversarial Code": " \n  \n  def compute(r1, m1, r2, case_inputs):\n      valid1 = set(m1[r1 - 1])\n      valid2 = set(case_inputs[r2 - 1])\n      valid = valid1 & valid2\n      if len(valid) == 0:\n          return 'Volunteer cheated!'\n      if len(valid) > 1:\n          return 'Bad magician!'\n      return valid.pop()\n  \n  \n  def parse_single():\n      r = int(sys.stdin.readline().strip())\n      m = []\n      for i in xrange(4):\n          m.append(map(int, sys.stdin.readline().strip().split()))\n      return r, m\n  \n  def parse():\n      r1, m1 = parse_single()\n      r2, case_inputs = parse_single()\n      return r1, m1, r2, case_inputs\n  \n  \n  if __name__ == \"__main__\":\n      sys.setrecursionlimit(100000)\n      f = int(sys.stdin.readline().strip())\n      for i in xrange(f):\n          data = parse()\n          result = compute(*data)\n          print \"Case #%d: %s\" % (i + 1, result)\n ", "Program Length": 211, "Identifier Num": 16, "Replaced Identifiers": "T:f,m2:case_inputs,", "Query Times": 102, "Time Cost": 0.04163113037745158, "Type": "wir"}
{"Index": 20, "Original Code": " \n  def read_line():\n      return sys.stdin.readline().rstrip( '\n' )\n  \n  def read_integer():\n      return int( read_line() )\n  \n  def read_integers():\n      return [ int( x ) for x in read_line().split() ]\n  \n  def flip( grid ):\n      return [ bytearray( ''.join( chr( grid[ row ][ column ] ) for row in range( len( grid ) ) ) ) for column in range( len( grid[ 0 ] ) ) ]\n  \n  def grow( R, C, M ):\n      grid = [ bytearray( C*[ '*' ] ) for row in range( R ) ]\n      b = R*C - M\n      if C > R:\n          R, C, grid = C, R, flip( grid )\n          flipped = True\n      else:\n          flipped = False\n      if b < 2*C:\n          if b == 1:\n              grid[ 0 ][ 0 ] = 'c'\n          elif b == 3 and C >= 3:\n              grid[ 0 ][ : 3 ] = bytearray( '.c.' )\n          elif b % 2:\n              return\n          else:\n              grid[ 0 ][ : b//2 ] = bytearray( b//2*'.' )\n              grid[ 1 ][ : b//2 ] = bytearray( b//2*'.' )\n              grid[ 0 ][ 0 ] = 'c'\n      else:\n          r = 0\n          while b >= C:\n              grid[ r ] = bytearray( C*[ '.' ] )\n              b -= C\n              r += 1\n          if b:\n              if b >= 2:\n                  grid[ r ][ : b ] = b*'.'\n              elif C > 2 and r > 2:\n                  grid[ r - 1 ][ -1 ] = '*'\n                  grid[ r ][ : 2 ] = '..'\n              else:\n                  return\n          grid[ 0 ][ 0 ] = 'c'\n      return flip( grid ) if flipped else grid\n      \n  T = read_integer()\n  for t in range( T ):\n      print 'Case #%i:' % ( t + 1 )\n      R, C, M = read_integers()\n      grid = grow( R, C, M )\n      print '\n'.join( str( row ) for row in grid ) if grid else 'Impossible'\n ", "Adversarial Code": " \n  def read_line():\n      return sys.stdin.readline().rstrip( '\n' )\n  \n  def read_integer():\n      return int( read_line() )\n  \n  def read_integers():\n      return [ int( x ) for x in read_line().split() ]\n  \n  def flip( TestCase ):\n      return [ bytearray( ''.join( chr( TestCase[ row ][ column ] ) for row in range( len( TestCase ) ) ) ) for column in range( len( TestCase[ 0 ] ) ) ]\n  \n  def grow( R, neighbor, table ):\n      TestCase = [ bytearray( neighbor*[ '*' ] ) for row in range( R ) ]\n      b = R*neighbor - table\n      if neighbor > R:\n          R, neighbor, TestCase = neighbor, R, flip( TestCase )\n          Data2 = True\n      else:\n          Data2 = False\n      if b < 2*neighbor:\n          if b == 1:\n              TestCase[ 0 ][ 0 ] = 'c'\n          elif b == 3 and neighbor >= 3:\n              TestCase[ 0 ][ : 3 ] = bytearray( '.c.' )\n          elif b % 2:\n              return\n          else:\n              TestCase[ 0 ][ : b//2 ] = bytearray( b//2*'.' )\n              TestCase[ 1 ][ : b//2 ] = bytearray( b//2*'.' )\n              TestCase[ 0 ][ 0 ] = 'c'\n      else:\n          splitext = 0\n          while b >= neighbor:\n              TestCase[ splitext ] = bytearray( neighbor*[ '.' ] )\n              b -= neighbor\n              splitext += 1\n          if b:\n              if b >= 2:\n                  TestCase[ splitext ][ : b ] = b*'.'\n              elif neighbor > 2 and splitext > 2:\n                  TestCase[ splitext - 1 ][ -1 ] = '*'\n                  TestCase[ splitext ][ : 2 ] = '..'\n              else:\n                  return\n          TestCase[ 0 ][ 0 ] = 'c'\n      return flip( TestCase ) if Data2 else TestCase\n      \n  OptionParser = read_integer()\n  for t in range( OptionParser ):\n      print 'Case #%i:' % ( t + 1 )\n      R, neighbor, table = read_integers()\n      TestCase = grow( R, neighbor, table )\n      print '\n'.join( str( row ) for row in TestCase ) if TestCase else 'Impossible'\n ", "Program Length": 406, "Identifier Num": 17, "Replaced Identifiers": "grid:TestCase,T:OptionParser,r:splitext,M:table,b:b,flipped:Data2,C:neighbor,", "Query Times": 295, "Time Cost": 0.12696706453959147, "Type": "wir"}
{"Index": 21, "Original Code": " \n  def read_line():\n      return sys.stdin.readline().rstrip( '\n' )\n  \n  def read_integer():\n      return int( read_line() )\n  \n  def read_integers():\n      return [ int( x ) for x in read_line().split() ]\n  \n  def read_string():\n      return read_line().strip()\n  \n  def read_strings():\n      return read_line().split()\n  \n  def input_string_stack():\n      data = []\n      for line in sys.stdin.readlines():\n          data.extend( line.split() )\n      data.reverse()\n      return data\n  \n  def input_integer_stack():\n      return [ int( x ) for x in read_string_stack() ]\n  \n  class memoized( object ):\n     def __init__( self, function ):\n        self.function = function\n        self.cache = {}\n     def __call__( self, *arguments ):\n        try:\n           return self.cache[ arguments ]\n        except KeyError:\n           value = self.function( *arguments )\n           self.cache[ arguments ] = value\n           return value\n  \n  T = read_integer()\n  for t in range( T ):\n      row = read_integer()\n      candidates = set( [ read_integers() for index in range( 4 ) ][ row - 1 ] )\n      row = read_integer()\n      candidates &= set( [ read_integers() for index in range( 4 ) ][ row - 1 ] )\n      print 'Case #%i:' % ( t + 1 ), candidates.pop() if len( candidates ) == 1 else 'Bad magician!' if len( candidates ) > 1 else 'Volunteer cheated!'\n ", "Adversarial Code": " \n  def read_line():\n      return sys.stdin.readline().rstrip( '\n' )\n  \n  def read_integer():\n      return int( read_line() )\n  \n  def read_integers():\n      return [ int( inFileName ) for inFileName in read_line().split() ]\n  \n  def read_string():\n      return read_line().strip()\n  \n  def read_strings():\n      return read_line().split()\n  \n  def input_string_stack():\n      data = []\n      for line in sys.stdin.readlines():\n          data.extend( line.split() )\n      data.reverse()\n      return data\n  \n  def input_integer_stack():\n      return [ int( inFileName ) for inFileName in read_string_stack() ]\n  \n  class memoized( object ):\n     def __init__( test_case_n, write ):\n        test_case_n.write = write\n        test_case_n.arrang1 = {}\n     def __call__( test_case_n, *arguments ):\n        try:\n           return test_case_n.arrang1[ arguments ]\n        except KeyError:\n           solveit = test_case_n.write( *arguments )\n           test_case_n.arrang1[ arguments ] = solveit\n           return solveit\n  \n  myCases = read_integer()\n  for FA in range( myCases ):\n      readf = read_integer()\n      coord = set( [ read_integers() for solve_small in range( 4 ) ][ readf - 1 ] )\n      readf = read_integer()\n      coord &= set( [ read_integers() for solve_small in range( 4 ) ][ readf - 1 ] )\n      print 'Case #%i:' % ( FA + 1 ), coord.pop() if len( coord ) == 1 else 'Bad magician!' if len( coord ) > 1 else 'Volunteer cheated!'\n ", "Program Length": 297, "Identifier Num": 22, "Replaced Identifiers": "self:test_case_n,function:write,cache:arrang1,value:solveit,T:myCases,x:inFileName,index:solve_small,candidates:coord,t:FA,row:readf,", "Query Times": 349, "Time Cost": 0.14685798088709515, "Type": "wir"}
{"Index": 22, "Original Code": "def Trivial(R,C,char):\n      for i in range(R):\n          Ans = '';\n          for j in range(C):\n              if (i==j==0):\n                  Ans += 'c';\n              else:\n                  Ans += char;\n          print Ans;\n  \n  \n  def Draw1(R,C,Blank):\n      Ans = \"c\";\n      for i in range(Blank-1):\n          Ans += '.';\n      for i in range(R*C-Blank):\n          Ans += '*';\n      if (R == 1):\n          print Ans;        \n          return;\n      if (C == 1):\n          for i in range(len(Ans)):\n              print Ans[i];\n  \n  def Draw2(R,C,Blank):\n      if (Blank%2 != 0) or (Blank == 2):\n          print \"Impossible\";\n          return;\n      Row1 = '.'*(Blank/2) + '*'*(Mine/2);\n      Row0 = 'c' + Row1[1:];\n      if R==2:\n          print Row0;\n          print Row1;\n      else:\n          for i in range(len(Row0)):\n              print Row0[i]+Row1[i];\n      return;\n  \n  \n  def Generate(R, C, Blank):\n      TODO = Blank;\n      Spaces = [0]*R;\n      if TODO <= 2*C:\n          if TODO%2 == 0:\n              Spaces[0] = TODO/2;\n              Spaces[1] = TODO-Spaces[0];\n          else:\n              if (TODO == 7):\n                  Spaces[0] = 3;\n                  Spaces[1] = 2;\n                  Spaces[2] = 2;\n              else:\n                  Spaces[0] = (TODO-3)/2;\n                  Spaces[1] = (TODO-3)/2;\n                  Spaces[2] = 3;\n      else:\n          row = 0;\n          if (TODO >= 2*C+2):\n              Spaces[0] = C;\n              Spaces[1] = C;\n              TODO -= 2*C;\n              row = 2;\n              \n          while TODO > C+1:\n              if (TODO == 2*C+1) and (C != 3):\n                  Spaces[row] = C-1;\n                  Spaces[row+1] = C-1;\n                  Spaces[row+2] = 3;\n                  TODO = 0;\n              else:\n                  Spaces[row] = C;\n                  TODO -= C;\n                  row += 1;\n          if (TODO == C+1):\n              Spaces[row] += C-1;\n              Spaces[row+1] = 2;\n              TODO = 0;\n          Spaces[row] += TODO;\n  \n      for r in range(R):\n          Ans = '.'*Spaces[r] + '*'*(C-Spaces[r]);\n          if r == 0:\n              Ans = 'c'+Ans[1:];\n          print Ans;\n  \n  \n  def Solve(R, C, M):\n      Blank = R*C-M;\n      if Blank == 0:\n          print \"Impossible\";\n          return;\n  \n      if (Blank == 1):\n          Trivial(R,C,'*');\n          return\n      if (Blank == R*C):\n          Trivial(R,C,'.');\n          return\n  \n      if (R == 1) or (C == 1):\n            Draw1(R,C,Blank);\n            return\n  \n      if (R-2)*(C-2) == 0:\n          Draw2(R,C,Blank);\n          return\n  \n      if Blank in [2,3,5,7]:\n          print \"Impossible\";\n          return;\n      \n      if (R >= 3) and (C >= 3):\n          Generate(R, C, Blank);\n  \n      return;\n  \n  \n  T = int(raw_input());\n  for q in range(T):\n      [Row,Col,Mine] = map(int, raw_input().split());\n  \n      Blanks = Row*Col - Mine;\n      \n      print \"Case #%d:\" % (q+1)\n      Solve(Row, Col, Mine);\n      \n          \n ", "Adversarial Code": "def Trivial(R,C,char):\n      for i in range(R):\n          Ans = '';\n          for j in range(C):\n              if (i==j==0):\n                  Ans += 'c';\n              else:\n                  Ans += char;\n          print Ans;\n  \n  \n  def Draw1(R,C,Blank):\n      Ans = \"c\";\n      for i in range(Blank-1):\n          Ans += '.';\n      for i in range(R*C-Blank):\n          Ans += '*';\n      if (R == 1):\n          print Ans;        \n          return;\n      if (C == 1):\n          for i in range(len(Ans)):\n              print Ans[i];\n  \n  def Draw2(R,C,Blank):\n      if (Blank%2 != 0) or (Blank == 2):\n          print \"Impossible\";\n          return;\n      Row1 = '.'*(Blank/2) + '*'*(Mine/2);\n      Row0 = 'c' + Row1[1:];\n      if R==2:\n          print Row0;\n          print Row1;\n      else:\n          for i in range(len(Row0)):\n              print Row0[i]+Row1[i];\n      return;\n  \n  \n  def Generate(R, C, Blank):\n      TODO = Blank;\n      chosen1 = [0]*R;\n      if TODO <= 2*C:\n          if TODO%2 == 0:\n              chosen1[0] = TODO/2;\n              chosen1[1] = TODO-chosen1[0];\n          else:\n              if (TODO == 7):\n                  chosen1[0] = 3;\n                  chosen1[1] = 2;\n                  chosen1[2] = 2;\n              else:\n                  chosen1[0] = (TODO-3)/2;\n                  chosen1[1] = (TODO-3)/2;\n                  chosen1[2] = 3;\n      else:\n          row = 0;\n          if (TODO >= 2*C+2):\n              chosen1[0] = C;\n              chosen1[1] = C;\n              TODO -= 2*C;\n              row = 2;\n              \n          while TODO > C+1:\n              if (TODO == 2*C+1) and (C != 3):\n                  chosen1[row] = C-1;\n                  chosen1[row+1] = C-1;\n                  chosen1[row+2] = 3;\n                  TODO = 0;\n              else:\n                  chosen1[row] = C;\n                  TODO -= C;\n                  row += 1;\n          if (TODO == C+1):\n              chosen1[row] += C-1;\n              chosen1[row+1] = 2;\n              TODO = 0;\n          chosen1[row] += TODO;\n  \n      for r in range(R):\n          Ans = '.'*chosen1[r] + '*'*(C-chosen1[r]);\n          if r == 0:\n              Ans = 'c'+Ans[1:];\n          print Ans;\n  \n  \n  def Solve(R, C, M):\n      Blank = R*C-M;\n      if Blank == 0:\n          print \"Impossible\";\n          return;\n  \n      if (Blank == 1):\n          Trivial(R,C,'*');\n          return\n      if (Blank == R*C):\n          Trivial(R,C,'.');\n          return\n  \n      if (R == 1) or (C == 1):\n            Draw1(R,C,Blank);\n            return\n  \n      if (R-2)*(C-2) == 0:\n          Draw2(R,C,Blank);\n          return\n  \n      if Blank in [2,3,5,7]:\n          print \"Impossible\";\n          return;\n      \n      if (R >= 3) and (C >= 3):\n          Generate(R, C, Blank);\n  \n      return;\n  \n  \n  T = int(raw_input());\n  for q in range(T):\n      [Row,Col,Mine] = map(int, raw_input().split());\n  \n      Blanks = Row*Col - Mine;\n      \n      print \"Case #%d:\" % (q+1)\n      Solve(Row, Col, Mine);\n      \n          \n ", "Program Length": 765, "Identifier Num": 17, "Replaced Identifiers": "Spaces:chosen1,", "Query Times": 195, "Time Cost": 0.08517087697982788, "Type": "wir"}
{"Index": 23, "Original Code": "T = int(raw_input());\n  for q in range(T):\n      R1 = int(raw_input());\n      Data1 = [];\n      for i in range(4):\n          Data1.append( map(int, raw_input().split()) );\n          \n      R2 = int(raw_input());\n      Data2 = [];\n      for i in range(4):\n          Data2.append( map(int, raw_input().split()) );\n  \n      Ans = [];\n      for entry in Data1[R1-1]:\n          if entry in Data2[R2-1]:\n              Ans.append(entry);\n  \n      print \"Case #%d:\" % (q+1),;\n  \n      if len(Ans) == 0:\n          print \"Volunteer cheated!\";\n      if len(Ans) == 1:\n          print Ans[0];\n      if len(Ans) > 1:\n          print \"Bad magician!\"\n          \n ", "Adversarial Code": "num_of_cases = int(raw_input());\n  for q in range(num_of_cases):\n      R1 = int(raw_input());\n      Data1 = [];\n      for i in range(4):\n          Data1.append( map(int, raw_input().split()) );\n          \n      safe_string = int(raw_input());\n      Data2 = [];\n      for i in range(4):\n          Data2.append( map(int, raw_input().split()) );\n  \n      Ans = [];\n      for entry in Data1[R1-1]:\n          if entry in Data2[safe_string-1]:\n              Ans.append(entry);\n  \n      print \"Case #%d:\" % (q+1),;\n  \n      if len(Ans) == 0:\n          print \"Volunteer cheated!\";\n      if len(Ans) == 1:\n          print Ans[0];\n      if len(Ans) > 1:\n          print \"Bad magician!\"\n          \n ", "Program Length": 174, "Identifier Num": 9, "Replaced Identifiers": "T:num_of_cases,R2:safe_string,", "Query Times": 88, "Time Cost": 0.03622487386067708, "Type": "wir"}
{"Index": 25, "Original Code": " \n  \n  N = int(sys.stdin.readline())\n  \n  for T in range(1, N+1):\n      first_ans = int(sys.stdin.readline())\n      first_grid = []\n      for i in range(4):\n          row = [int(v) for v in sys.stdin.readline().split(' ')]\n          first_grid.append(row)\n      first_list = set(first_grid[first_ans-1])\n      \n      second_ans = int(sys.stdin.readline())\n      second_grid = []\n      for i in range(4):\n          row = [int(v) for v in sys.stdin.readline().split(' ')]\n          second_grid.append(row)\n      second_list = set(second_grid[second_ans-1])\n  \n      intersection = first_list.intersection(second_list)\n  \n      if len(intersection) == 1:\n          ans = intersection.pop()\n      elif len(intersection) == 0:\n          ans = 'Volunteer cheated!'\n      else:\n          ans = 'Bad magician!'\n  \n      print 'Case #%(T)s: %(ans)s' % locals()\n ", "Adversarial Code": " \n  \n  TestCase = int(sys.stdin.readline())\n  \n  for T in range(1, TestCase+1):\n      first_ans = int(sys.stdin.readline())\n      run_tests = []\n      for i in range(4):\n          __call__ = [int(find_click_point) for find_click_point in sys.stdin.readline().split(' ')]\n          run_tests.append(__call__)\n      main_run = set(run_tests[first_ans-1])\n      \n      chosen_filename = int(sys.stdin.readline())\n      locals = []\n      for i in range(4):\n          __call__ = [int(find_click_point) for find_click_point in sys.stdin.readline().split(' ')]\n          locals.append(__call__)\n      second_list = set(locals[chosen_filename-1])\n  \n      intersection = main_run.intersection(second_list)\n  \n      if len(intersection) == 1:\n          myCases = intersection.pop()\n      elif len(intersection) == 0:\n          myCases = 'Volunteer cheated!'\n      else:\n          myCases = 'Bad magician!'\n  \n      print 'Case #%(T)s: %(ans)s' % locals()\n ", "Program Length": 197, "Identifier Num": 13, "Replaced Identifiers": "ans:myCases,N:TestCase,first_grid:run_tests,first_list:main_run,second_grid:locals,row:__call__,v:find_click_point,second_ans:chosen_filename,", "Query Times": 279, "Time Cost": 0.11380382378896077, "Type": "wir"}
{"Index": 26, "Original Code": " \n  def solve(W, H, M):\n    board = [['*' for x in xrange(H)] for x in xrange(W)]\n    board[0][0] = 'c'\n    \n    S = [((H*W)-1, board, 0, 0, set())]\n    H -= 1\n    W -= 1\n    while len(S) > 0:\n      state = S.pop()\n      mines = state[0]\n      board = deepcopy(state[1])\n      x = state[2]\n      y = state[3]\n      visited = deepcopy(state[4])\n      visited.add((x, y))\n      \n      if mines == M:\n        s = ''\n        for row in board:\n          s += ''.join(row)\n          s += '\n'\n        return s\n      \n      elif mines > M:\n        if x > 0 and board[x-1][y] == '*':\n          board[x-1][y] = '.'\n          mines -= 1\n        \n        if x < W and board[x+1][y] == '*':\n          board[x+1][y] = '.'\n          mines -= 1\n        \n        if y > 0 and board[x][y-1] == '*':\n          board[x][y-1] = '.'\n          mines -= 1\n        \n        if y < H and board[x][y+1] == '*':\n          board[x][y+1] = '.'\n          mines -= 1\n        \n        if x > 0 and y > 0 and board[x-1][y-1] == '*':\n          board[x-1][y-1] = '.'\n          mines -= 1\n        \n        if x > 0 and y < H and board[x-1][y+1] == '*':\n          board[x-1][y+1] = '.'\n          mines -= 1\n        \n        if x < W and y > 0 and board[x+1][y-1] == '*':\n          board[x+1][y-1] = '.'\n          mines -= 1\n        \n        if x < W and y < H and board[x+1][y+1] == '*':\n          board[x+1][y+1] = '.'\n          mines -= 1\n        \n        if x > 0 and not (x-1, y) in visited:\n          S.append((mines, board, x-1, y, visited))\n        \n        if x < W and not (x+1, y) in visited:\n          S.append((mines, board, x+1, y, visited))\n        \n        if y > 0 and not (x, y-1) in visited:\n          S.append((mines, board, x, y-1, visited))\n        \n        if y < H and not (x, y+1) in visited:\n          S.append((mines, board, x, y+1, visited))\n        \n        if x > 0 and y > 0 and not (x-1, y-1) in visited:\n          S.append((mines, board, x-1, y-1, visited))\n        \n        if x > 0 and y < H and not (x-1, y+1) in visited:\n          S.append((mines, board, x-1, y+1, visited))\n        \n        if x < W and y > 0 and not (x+1, y-1) in visited:\n          S.append((mines, board, x+1, y-1, visited))\n        \n        if x < W and y < H and not (x+1, y+1) in visited:\n          S.append((mines, board, x+1, y+1, visited))\n    return 'Impossible'\n  \n  T = int(raw_input())\n  for t in range(T):\n    W, H, M = map(int, raw_input().split())\n    print 'Case #%i:\n%s' % (t+1, solve(W, H, M).strip())\n ", "Adversarial Code": " \n  def solve(W, H, M):\n    board = [['*' for x in xrange(H)] for x in xrange(W)]\n    board[0][0] = 'c'\n    \n    S = [((H*W)-1, board, 0, 0, set())]\n    H -= 1\n    W -= 1\n    while len(S) > 0:\n      state = S.pop()\n      mines = state[0]\n      board = deepcopy(state[1])\n      x = state[2]\n      y = state[3]\n      visited = deepcopy(state[4])\n      visited.add((x, y))\n      \n      if mines == M:\n        TestCase = ''\n        for cachemisses in board:\n          TestCase += ''.join(cachemisses)\n          TestCase += '\n'\n        return TestCase\n      \n      elif mines > M:\n        if x > 0 and board[x-1][y] == '*':\n          board[x-1][y] = '.'\n          mines -= 1\n        \n        if x < W and board[x+1][y] == '*':\n          board[x+1][y] = '.'\n          mines -= 1\n        \n        if y > 0 and board[x][y-1] == '*':\n          board[x][y-1] = '.'\n          mines -= 1\n        \n        if y < H and board[x][y+1] == '*':\n          board[x][y+1] = '.'\n          mines -= 1\n        \n        if x > 0 and y > 0 and board[x-1][y-1] == '*':\n          board[x-1][y-1] = '.'\n          mines -= 1\n        \n        if x > 0 and y < H and board[x-1][y+1] == '*':\n          board[x-1][y+1] = '.'\n          mines -= 1\n        \n        if x < W and y > 0 and board[x+1][y-1] == '*':\n          board[x+1][y-1] = '.'\n          mines -= 1\n        \n        if x < W and y < H and board[x+1][y+1] == '*':\n          board[x+1][y+1] = '.'\n          mines -= 1\n        \n        if x > 0 and not (x-1, y) in visited:\n          S.append((mines, board, x-1, y, visited))\n        \n        if x < W and not (x+1, y) in visited:\n          S.append((mines, board, x+1, y, visited))\n        \n        if y > 0 and not (x, y-1) in visited:\n          S.append((mines, board, x, y-1, visited))\n        \n        if y < H and not (x, y+1) in visited:\n          S.append((mines, board, x, y+1, visited))\n        \n        if x > 0 and y > 0 and not (x-1, y-1) in visited:\n          S.append((mines, board, x-1, y-1, visited))\n        \n        if x > 0 and y < H and not (x-1, y+1) in visited:\n          S.append((mines, board, x-1, y+1, visited))\n        \n        if x < W and y > 0 and not (x+1, y-1) in visited:\n          S.append((mines, board, x+1, y-1, visited))\n        \n        if x < W and y < H and not (x+1, y+1) in visited:\n          S.append((mines, board, x+1, y+1, visited))\n    return 'Impossible'\n  \n  T = int(raw_input())\n  for t in range(T):\n    W, H, M = map(int, raw_input().split())\n    print 'Case #%i:\n%TestCase' % (t+1, solve(W, H, M).strip())\n ", "Program Length": 806, "Identifier Num": 13, "Replaced Identifiers": "row:cachemisses,s:TestCase,", "Query Times": 276, "Time Cost": 0.12085413535435995, "Type": "wir"}
{"Index": 27, "Original Code": "T = int(raw_input())\n  for i in range(T):\n    index = int(raw_input())\n    X = []\n    for j in range(4):\n      X.append(map(int, raw_input().split()))\n    x1 = X[index-1]\n    index = int(raw_input())\n    X = []\n    for j in range(4):\n      X.append(map(int, raw_input().split()))\n    x2 = X[index-1]\n    ans = set(x1).intersection(set(x2))\n    if len(ans) == 0:\n      print 'Case #%i: Volunteer cheated!' % (i+1)\n    elif len(ans) == 1:\n      print 'Case #%i: %i' % (i+1, ans.pop())\n    else:\n      print 'Case #%i: Bad magician!' % (i+1)\n ", "Adversarial Code": "numCase = int(raw_input())\n  for numbers in range(numCase):\n    index = int(raw_input())\n    new_case = []\n    for j in range(4):\n      new_case.append(map(int, raw_input().split()))\n    x1 = new_case[index-1]\n    index = int(raw_input())\n    new_case = []\n    for j in range(4):\n      new_case.append(map(int, raw_input().split()))\n    x2 = new_case[index-1]\n    current_c = set(x1).intersection(set(x2))\n    if len(current_c) == 0:\n      print 'Case #%i: Volunteer cheated!' % (numbers+1)\n    elif len(current_c) == 1:\n      print 'Case #%i: %i' % (numbers+1, current_c.pop())\n    else:\n      print 'Case #%i: Bad magician!' % (numbers+1)\n ", "Program Length": 168, "Identifier Num": 8, "Replaced Identifiers": "X:new_case,ans:current_c,i:numbers,T:numCase,", "Query Times": 149, "Time Cost": 0.06003776391347249, "Type": "wir"}
{"Index": 29, "Original Code": "def solve(c1, g1, c2, g2):\n      row_1 = g1[c1-1]\n      row_2 = g2[c2-1]\n      inter = set(row_1) & set(row_2)\n      if len(inter) == 0:\n          return \"Volunteer cheated!\"\n      if len(inter) > 1:\n          return \"Bad magician!\"\n      return str(inter.pop())\n  \n  if __name__ == \"__main__\":\n      T = int(raw_input())\n      for i in range(1,T+1):\n          c1 = int(raw_input())\n          g1 = []\n          for j in range(4):\n              g1.append(map(int, raw_input().split()))\n          c2 = int(raw_input())\n          g2 = []\n          for j in range(4):\n              g2.append(map(int, raw_input().split()))\n          print \"Case #%d: %s\" % (i, solve(c1,g1,c2,g2)) \n          \n      \n ", "Adversarial Code": "def solve(read_case, f_result, readfromfile, parse_args):\n      val = f_result[read_case-1]\n      row_2 = parse_args[readfromfile-1]\n      Output = set(val) & set(row_2)\n      if len(Output) == 0:\n          return \"Volunteer cheated!\"\n      if len(Output) > 1:\n          return \"Bad magician!\"\n      return str(Output.pop())\n  \n  if __name__ == \"__main__\":\n      T = int(raw_input())\n      for i in range(1,T+1):\n          read_case = int(raw_input())\n          f_result = []\n          for j in range(4):\n              f_result.append(map(int, raw_input().split()))\n          readfromfile = int(raw_input())\n          parse_args = []\n          for j in range(4):\n              parse_args.append(map(int, raw_input().split()))\n          print \"Case #%d: %s\" % (i, solve(read_case,f_result,readfromfile,parse_args)) \n          \n      \n ", "Program Length": 184, "Identifier Num": 11, "Replaced Identifiers": "c1:read_case,g2:parse_args,inter:Output,g1:f_result,row_1:val,c2:readfromfile,", "Query Times": 216, "Time Cost": 0.08718088070551554, "Type": "wir"}
{"Index": 30, "Original Code": " \n  \n  tCase = int(sys.stdin.readline())\n  \n  \n  def map(R, C, Bombs):\n  \tm = [[\".\" for x in xrange(C)] for x in xrange(R)]\n  \tprint Bombs\n  \tm[R-1][C-1] = 'c'\n  \tlastSkip = False\n  \tfor i in xrange(R):\n  \t\tfor j in xrange(C):\n  \t\t\tif Bombs == 0:\n  \t\t\t\tbreak\n  \t\t\t\n  \t\t\tif lastSkip:\n  \t\t\t\tm[i][j] = 'f'\n  \t\t\t\tcontinue\n  \t\t\t\n  \t\t\tif R - i == 2 or C - j == 2:\n  \t\t\t\tif Bombs == 1:\n  \t\t\t\t\tm[i][j] = 'f'\n  \t\t\t\t\tlastSkip = True\n  \t\t\t\t\tcontinue\n  \t\t\t\n  \t\t\t\t\n  \t\t\tm[i][j] = '*'\n  \t\t\tBombs -= 1\n  \t\t\tlastSkip = False\n  \t\tlastSkip = False\n  \t\t\t\t\n  \t\n  \t\n  \tfor line in m:\n  \t\tfor c in line:\n  \t\t\tprint c,\n  \t\tprint\n  \t\t\n  \t\t\n  def imprimir(m):\n  \tfor line in m:\n  \t\tfor c in line:\n  \t\t\tprint c,\n  \t\tprint\n  \t\t\n  def map2(R, C, Bombs):\n  \tm = [[\".\" for x in xrange(C)] for x in xrange(R)]\n  \tm[R-1][C-1] = 'c'\n  \tlastSkip = False\n  \t\n  \tii = 0\n  \tjj = 0\n  \twhile Bombs > 0:\n  \t\tfor j in xrange(jj, C):\n  \t\t\tif Bombs >= (C - j) or Bombs <= (C - j - 2) and Bombs > 0:\n  \t\t\t\tm[ii][j] = '*'\n  \t\t\t\tBombs -= 1\n  \t\t\telse:\n  \t\t\t\tcontinue\n  \t\t\n  \t\t\n  \t\tfor i in xrange(ii+1, R):\n  \t\t\tif Bombs >= (R - i) or Bombs <= (R - i - 2) and Bombs > 0:\n  \t\t\t\tm[i][jj] = '*'\n  \t\t\t\tBombs -= 1\n  \t\t\telse:\n  \t\t\t\tif Bombs > 0:\n  \t\t\t\t\tprint \"Impossible\"\n  \t\t\t\t\treturn\n  \t\t\t\tcontinue\n  \t\tjj += 1\n  \t\tii += 1\n  \timprimir(m)\n  \t\n  \t\t\t\t\n  \t\n  \t\n  \n  \t\t\n  def main(R, C, M):\n  \tvazios = R * C - M\n  \n  \tif R == 1 or C == 1 or vazios == 1 or vazios >= 4:\n  \t\tmap2(R, C, M)\n  \telse:\n  \t\tprint \"Impossible\"\n  \n  \treturn \"\"\n  \t\t\n   \n  if __name__ == '__main__':\n  \tfor i in xrange(tCase):\t\n  \t\t\n  \t\tR, C, M = [int(x) for x in sys.stdin.readline().split(' ')]\n  \t\tprint \"Case #%d:\" % (i + 1)\n  \t\tmain(R, C, M)\n ", "Adversarial Code": " \n  \n  need_adjust = int(sys.stdin.readline())\n  \n  \n  def map(R, C, Bombs):\n  \tm = [[\".\" for x in xrange(C)] for x in xrange(R)]\n  \tprint Bombs\n  \tm[R-1][C-1] = 'c'\n  \tlastSkip = False\n  \tfor i in xrange(R):\n  \t\tfor j in xrange(C):\n  \t\t\tif Bombs == 0:\n  \t\t\t\tbreak\n  \t\t\t\n  \t\t\tif lastSkip:\n  \t\t\t\tm[i][j] = 'f'\n  \t\t\t\tcontinue\n  \t\t\t\n  \t\t\tif R - i == 2 or C - j == 2:\n  \t\t\t\tif Bombs == 1:\n  \t\t\t\t\tm[i][j] = 'f'\n  \t\t\t\t\tlastSkip = True\n  \t\t\t\t\tcontinue\n  \t\t\t\n  \t\t\t\t\n  \t\t\tm[i][j] = '*'\n  \t\t\tBombs -= 1\n  \t\t\tlastSkip = False\n  \t\tlastSkip = False\n  \t\t\t\t\n  \t\n  \t\n  \tfor line in m:\n  \t\tfor c in line:\n  \t\t\tprint c,\n  \t\tprint\n  \t\t\n  \t\t\n  def imprimir(m):\n  \tfor line in m:\n  \t\tfor c in line:\n  \t\t\tprint c,\n  \t\tprint\n  \t\t\n  def map2(R, C, Bombs):\n  \tm = [[\".\" for x in xrange(C)] for x in xrange(R)]\n  \tm[R-1][C-1] = 'c'\n  \tlastSkip = False\n  \t\n  \tii = 0\n  \tjj = 0\n  \twhile Bombs > 0:\n  \t\tfor j in xrange(jj, C):\n  \t\t\tif Bombs >= (C - j) or Bombs <= (C - j - 2) and Bombs > 0:\n  \t\t\t\tm[ii][j] = '*'\n  \t\t\t\tBombs -= 1\n  \t\t\telse:\n  \t\t\t\tcontinue\n  \t\t\n  \t\t\n  \t\tfor i in xrange(ii+1, R):\n  \t\t\tif Bombs >= (R - i) or Bombs <= (R - i - 2) and Bombs > 0:\n  \t\t\t\tm[i][jj] = '*'\n  \t\t\t\tBombs -= 1\n  \t\t\telse:\n  \t\t\t\tif Bombs > 0:\n  \t\t\t\t\tprint \"Impossible\"\n  \t\t\t\t\treturn\n  \t\t\t\tcontinue\n  \t\tjj += 1\n  \t\tii += 1\n  \timprimir(m)\n  \t\n  \t\t\t\t\n  \t\n  \t\n  \n  \t\t\n  def main(R, C, M):\n  \tvazios = R * C - M\n  \n  \tif R == 1 or C == 1 or vazios == 1 or vazios >= 4:\n  \t\tmap2(R, C, M)\n  \telse:\n  \t\tprint \"Impossible\"\n  \n  \treturn \"\"\n  \t\t\n   \n  if __name__ == '__main__':\n  \tfor i in xrange(need_adjust):\t\n  \t\t\n  \t\tR, C, M = [int(x) for x in sys.stdin.readline().split(' ')]\n  \t\tprint \"Case #%d:\" % (i + 1)\n  \t\tmain(R, C, M)\n ", "Program Length": 457, "Identifier Num": 19, "Replaced Identifiers": "tCase:need_adjust,", "Query Times": 154, "Time Cost": 0.06477057933807373, "Type": "wir"}
{"Index": 31, "Original Code": " \n  \n  \n  class Test(unittest.TestCase):\n  \tdef test_1(self):\n  \t\tself.assertEqual(main(5, 2, 2, [2,1]), 12)\n  \tdef test_2(self):\n  \t\tself.assertEqual(main(5,2,2,[1,2]), 12)\n  \tdef test_3(self):\n  \t\tself.assertEqual(main(3,3,4,[4,1,3,5]), 39)\n  \tdef test_4(self):\n  \t\tself.assertEqual(main(5,2,4,[5, 1, 1, 5]), 51)\n  \n  \n  tCase = int(sys.stdin.readline())\n  \n  def main(A, B, AList, BList):\n  \tresp = 0\n  \tA = A - 1\n  \tB = B - 1\n  \tAlist = AList[A*4:A*4+4]\n  \tBList = BList[B*4:B*4+4]\n  \tcont = 0\n  \tfor aa in Alist:\n  \t\tif aa in BList:\n  \t\t\tresp = aa\n  \t\t\tcont += 1\n  \t\t\n  \tif cont == 1:\n  \t\treturn resp\n  \telif cont == 0:\n  \t\treturn \"Volunteer cheated!\"\n  \telse:\n  \t\treturn \"Bad magician!\"\n  \t\t\n   \n  if __name__ == '__main__':\n  \tfor i in xrange(tCase):\t\n  \t\t\n  \t\tA = [int(x) for x in sys.stdin.readline().split(' ')][0]\n  \t\tNList = [int(x) for x in sys.stdin.readline().split(' ')]\n  \t\tNList += [int(x) for x in sys.stdin.readline().split(' ')]\n  \t\tNList += [int(x) for x in sys.stdin.readline().split(' ')]\n  \t\tNList += [int(x) for x in sys.stdin.readline().split(' ')]\n  \t\tB = [int(x) for x in sys.stdin.readline().split(' ')][0]\n  \t\tBList = [int(x) for x in sys.stdin.readline().split(' ')]\n  \t\tBList += [int(x) for x in sys.stdin.readline().split(' ')]\n  \t\tBList += [int(x) for x in sys.stdin.readline().split(' ')]\n  \t\tBList += [int(x) for x in sys.stdin.readline().split(' ')]\n  \t\tprint \"Case #%d: %s\" % (i + 1, main(A, B, NList, BList))\n ", "Adversarial Code": " \n  \n  \n  class Test(unittest.TestCase):\n  \tdef test_1(self):\n  \t\tself.assertEqual(main(5, 2, 2, [2,1]), 12)\n  \tdef test_2(self):\n  \t\tself.assertEqual(main(5,2,2,[1,2]), 12)\n  \tdef test_3(self):\n  \t\tself.assertEqual(main(3,3,4,[4,1,3,5]), 39)\n  \tdef test_4(self):\n  \t\tself.assertEqual(main(5,2,4,[5, 1, 1, 5]), 51)\n  \n  \n  num_of_cases = int(sys.stdin.readline())\n  \n  def main(A, B, AList, BList):\n  \texcept = 0\n  \tA = A - 1\n  \tB = B - 1\n  \tAlist = AList[A*4:A*4+4]\n  \tBList = BList[B*4:B*4+4]\n  \tretval = 0\n  \tfor numTests in Alist:\n  \t\tif numTests in BList:\n  \t\t\texcept = numTests\n  \t\t\tretval += 1\n  \t\t\n  \tif retval == 1:\n  \t\treturn except\n  \telif retval == 0:\n  \t\treturn \"Volunteer cheated!\"\n  \telse:\n  \t\treturn \"Bad magician!\"\n  \t\t\n   \n  if __name__ == '__main__':\n  \tfor new_grid in xrange(num_of_cases):\t\n  \t\t\n  \t\tA = [int(x) for x in sys.stdin.readline().split(' ')][0]\n  \t\tNList = [int(x) for x in sys.stdin.readline().split(' ')]\n  \t\tNList += [int(x) for x in sys.stdin.readline().split(' ')]\n  \t\tNList += [int(x) for x in sys.stdin.readline().split(' ')]\n  \t\tNList += [int(x) for x in sys.stdin.readline().split(' ')]\n  \t\tB = [int(x) for x in sys.stdin.readline().split(' ')][0]\n  \t\tBList = [int(x) for x in sys.stdin.readline().split(' ')]\n  \t\tBList += [int(x) for x in sys.stdin.readline().split(' ')]\n  \t\tBList += [int(x) for x in sys.stdin.readline().split(' ')]\n  \t\tBList += [int(x) for x in sys.stdin.readline().split(' ')]\n  \t\tprint \"Case #%d: %s\" % (new_grid + 1, main(A, B, NList, BList))\n ", "Program Length": 494, "Identifier Num": 18, "Replaced Identifiers": "aa:numTests,i:new_grid,resp:except,cont:retval,tCase:num_of_cases,", "Query Times": 227, "Time Cost": 0.09885107676188151, "Type": "wir"}
{"Index": 32, "Original Code": " \n  def debug(v):\n      pass#print(v)\n  \n  def read(f):\n      t = tuple(int(v) for v in f.readline().split())\n      debug(t)\n      return t\n  \n  def readf(f):\n      t = tuple(float(v) for v in f.readline().split())\n      debug(t)\n      return t\n  \n  def answer(f, X, ans):\n      out = \"Case #{}:\n{}\".format(X, ans)\n      f.write(out)\n      f.write(\"\n\")\n      print(out)\n  \n  def answer_cells(f, X, cells):\n      out = \"Case #{}:\".format(X)\n      f.write(out)\n      f.write(\"\n\")\n      print(out)\n      for row in cells:\n          out = \"\".join(row)\n          f.write(out)\n          f.write(\"\n\")\n          print(out)\n  \n  def main(inf, outf):\n      T, = read(inf)\n      for casenmbr in range(1, T + 1):\n          R, C, M = read(inf)\n  \n          if M == 0:\n              cells = [['.'] * C for i in range(R)]\n              cells[0][0] = 'c'\n              answer_cells(outf, casenmbr, cells)\n              continue\n  \n          empty = R * C - M\n  \n          if empty == 1:\n              cells = [['*'] * C for i in range(R)]\n              cells[0][0] = 'c'\n              answer_cells(outf, casenmbr, cells)\n              continue\n  \n          if R == 1 or C == 1:\n              cells = [['.'] * C for i in range(R)]\n              m = 0\n              for r in range(R):\n                  for c in range(C):\n                      cells[r][c] = '*'\n                      m += 1\n                      if m == M:\n                          break\n                  else:\n                      continue\n                  break\n              cells[-1][-1] = 'c'\n              answer_cells(outf, casenmbr, cells)\n              continue\n  \n          if empty in (2, 3, 5, 7):\n              answer(outf, casenmbr, \"Impossible\")\n              continue\n  \n          if (R == 2 or C == 2) and empty % 2:\n              answer(outf, casenmbr, \"Impossible\")\n              continue\n  \n          cells = [['*'] * C for i in range(R)]\n  \n  \n          cells[0][0] = 'c'\n          empty -= 1\n          cc = 1\n          rr = 1\n          while empty > 0:\n              if cc < C:\n                  for r in range(rr):\n                      if empty == 2 and r == rr - 1:\n                          break\n                      cells[r][cc] = '.'\n                      empty -= 1\n                      if empty == 0:\n                          break\n                  cc += 1\n              if rr < R and empty > 0:\n                  for c in range(cc):\n                      if empty == 2 and c == cc - 1:\n                          break\n                      cells[rr][c] = '.'\n                      empty -= 1\n                      if empty == 0:\n                          break\n                  rr += 1            \n  \n          answer_cells(outf, casenmbr, cells)\n  \n  \n  if __name__==\"__main__\":\n      infname = sys.argv[1]\n      outfname = os.path.splitext(infname)[0] + \".out\"\n      with open(infname, \"r\") as inf:\n          with open(outfname, \"w\") as outf:\n              main(inf, outf)\n ", "Adversarial Code": " \n  def debug(v):\n      pass#print(v)\n  \n  def read(f):\n      t = tuple(int(v) for v in f.readline().split())\n      debug(t)\n      return t\n  \n  def readf(f):\n      t = tuple(float(v) for v in f.readline().split())\n      debug(t)\n      return t\n  \n  def answer(f, X, ans):\n      out = \"Case #{}:\n{}\".format(X, ans)\n      f.write(out)\n      f.write(\"\n\")\n      print(out)\n  \n  def answer_cells(f, X, cells):\n      out = \"Case #{}:\".format(X)\n      f.write(out)\n      f.write(\"\n\")\n      print(out)\n      for row in cells:\n          out = \"\".join(row)\n          f.write(out)\n          f.write(\"\n\")\n          print(out)\n  \n  def main(inf, ctime):\n      T, = read(inf)\n      for casenmbr in range(1, T + 1):\n          R, C, M = read(inf)\n  \n          if M == 0:\n              cells = [['.'] * C for i in range(R)]\n              cells[0][0] = 'c'\n              answer_cells(ctime, casenmbr, cells)\n              continue\n  \n          empty = R * C - M\n  \n          if empty == 1:\n              cells = [['*'] * C for i in range(R)]\n              cells[0][0] = 'c'\n              answer_cells(ctime, casenmbr, cells)\n              continue\n  \n          if R == 1 or C == 1:\n              cells = [['.'] * C for i in range(R)]\n              m = 0\n              for r in range(R):\n                  for c in range(C):\n                      cells[r][c] = '*'\n                      m += 1\n                      if m == M:\n                          break\n                  else:\n                      continue\n                  break\n              cells[-1][-1] = 'c'\n              answer_cells(ctime, casenmbr, cells)\n              continue\n  \n          if empty in (2, 3, 5, 7):\n              answer(ctime, casenmbr, \"Impossible\")\n              continue\n  \n          if (R == 2 or C == 2) and empty % 2:\n              answer(ctime, casenmbr, \"Impossible\")\n              continue\n  \n          cells = [['*'] * C for i in range(R)]\n  \n  \n          cells[0][0] = 'c'\n          empty -= 1\n          cc = 1\n          rr = 1\n          while empty > 0:\n              if cc < C:\n                  for r in range(rr):\n                      if empty == 2 and r == rr - 1:\n                          break\n                      cells[r][cc] = '.'\n                      empty -= 1\n                      if empty == 0:\n                          break\n                  cc += 1\n              if rr < R and empty > 0:\n                  for c in range(cc):\n                      if empty == 2 and c == cc - 1:\n                          break\n                      cells[rr][c] = '.'\n                      empty -= 1\n                      if empty == 0:\n                          break\n                  rr += 1            \n  \n          answer_cells(ctime, casenmbr, cells)\n  \n  \n  if __name__==\"__main__\":\n      infname = sys.argv[1]\n      outfname = os.path.splitext(infname)[0] + \".out\"\n      with open(infname, \"r\") as inf:\n          with open(outfname, \"w\") as ctime:\n              main(inf, ctime)\n ", "Program Length": 627, "Identifier Num": 26, "Replaced Identifiers": "outf:ctime,", "Query Times": 179, "Time Cost": 0.0771124800046285, "Type": "wir"}
{"Index": 33, "Original Code": " \n  def debug(v):\n      pass #print(v)\n  \n  def read(f):\n      t = tuple(int(v) for v in f.readline().split())\n      debug(t)\n      return t\n  \n  def answer(f, X, ans):\n      out = \"Case #{}: {}\".format(X, ans)\n      f.write(out)\n      f.write(\"\n\")\n      print(out)\n  \n  \n  \n  def main(inf, outf):\n      T, = read(inf)\n      for X in range(1, T + 1):\n          row1, = read(inf)\n          cards1 = tuple(read(inf) for i in range(4))\n          row2, = read(inf)\n          cards2 = tuple(read(inf) for i in range(4))\n  \n          kouho = set(cards1[row1 - 1]).intersection(cards2[row2 - 1])\n  \n          if kouho:\n              if len(kouho) == 1:\n                  ans = kouho.pop()\n              else:\n                  ans = \"Bad magician!\"\n          else:\n              ans = \"Volunteer cheated!\"\n  \n          answer(outf, X, ans)\n  \n  \n  if __name__==\"__main__\":\n      infname = sys.argv[1]\n      outfname = os.path.splitext(infname)[0] + \".out\"\n      with open(infname, \"r\") as inf:\n          with open(outfname, \"w\") as outf:\n              main(inf, outf)\n ", "Adversarial Code": " \n  def debug(v):\n      pass #print(v)\n  \n  def read(f):\n      t = tuple(int(v) for v in f.readline().split())\n      debug(t)\n      return t\n  \n  def answer(f, X, ans):\n      out = \"Case #{}: {}\".format(X, ans)\n      f.write(out)\n      f.write(\"\n\")\n      print(out)\n  \n  \n  \n  def main(do_trial, outf):\n      T, = read(do_trial)\n      for X in range(1, T + 1):\n          row1, = read(do_trial)\n          cards1 = tuple(read(do_trial) for i in range(4))\n          row2, = read(do_trial)\n          cards2 = tuple(read(do_trial) for i in range(4))\n  \n          kouho = set(cards1[row1 - 1]).intersection(cards2[row2 - 1])\n  \n          if kouho:\n              if len(kouho) == 1:\n                  ans = kouho.pop()\n              else:\n                  ans = \"Bad magician!\"\n          else:\n              ans = \"Volunteer cheated!\"\n  \n          answer(outf, X, ans)\n  \n  \n  if __name__==\"__main__\":\n      states = sys.argv[1]\n      outfname = os.path.splitext(states)[0] + \".out\"\n      with open(states, \"r\") as do_trial:\n          with open(outfname, \"w\") as outf:\n              main(do_trial, outf)\n ", "Program Length": 260, "Identifier Num": 21, "Replaced Identifiers": "inf:do_trial,infname:states,", "Query Times": 120, "Time Cost": 0.04914464553197225, "Type": "wir"}
{"Index": 35, "Original Code": " \n  if __name__ == \"__main__\":\n      f = sys.stdin\n      if len(sys.argv) >= 2:\n          fn = sys.argv[1]\n          if fn != '-':\n              f = open(fn)\n  \n      t = int(f.readline())\n      for _t in range(t):\n          X = int(f.readline())\n          cardsX = [[int(y) for y in f.readline().split()] for x in range(4)]\n          row = cardsX[X-1]\n          Y = int(f.readline())\n          cardsY = [[int(y) for y in f.readline().split()] for x in range(4)]\n          column = cardsY[Y-1]\n          card = [x for x in row if x in column]\n          if len(card) > 1:\n              answer = \"Bad magician!\"\n          elif len(card) == 0:\n              answer = \"Volunteer cheated!\"\n          else:\n              answer = str(card[0])\n          print (\"Case #\" + str(_t+1) + \": \" + answer)\n      \n  \n ", "Adversarial Code": " \n  if __name__ == \"__main__\":\n      r0 = sys.stdin\n      if len(sys.argv) >= 2:\n          fn = sys.argv[1]\n          if fn != '-':\n              r0 = open(fn)\n  \n      t = int(r0.readline())\n      for _t in range(t):\n          X = int(r0.readline())\n          cardsX = [[int(y) for y in r0.readline().split()] for x in range(4)]\n          row = cardsX[X-1]\n          Y = int(r0.readline())\n          cardsY = [[int(y) for y in r0.readline().split()] for x in range(4)]\n          column = cardsY[Y-1]\n          card = [x for x in row if x in column]\n          if len(card) > 1:\n              answer = \"Bad magician!\"\n          elif len(card) == 0:\n              answer = \"Volunteer cheated!\"\n          else:\n              answer = str(card[0])\n          print (\"Case #\" + str(_t+1) + \": \" + answer)\n      \n  \n ", "Program Length": 212, "Identifier Num": 14, "Replaced Identifiers": "f:r0,", "Query Times": 77, "Time Cost": 0.03040051062901815, "Type": "wir"}
{"Index": 36, "Original Code": " \n  '''\n  Input\n  The first line of the input gives the number of test cases, T. T lines follow. \n  Each line contains three space-separated integers: R, C, and M (Rows, Columns, Mines).\n  \n  Output\n  For each test case, output a line containing \"Case #x:\", where x is the test case number. \n  On the following R lines, output the board configuration with C characters per line, \n  using '.' to represent an empty cell, '*' to represent a cell that contains a mine, \n  and 'c' to represent the clicked cell. If there is no possible configuration, \n  then instead of the grid, output a line with \"Impossible\" instead. \n  If there are multiple possible configurations, output any one of them.\n  \n  Limits\n  0 <= M < R * C.\n  \n  Small dataset\n  1 <= T <= 230.\n  1 <= R, C <= 5.\n  \n  Large dataset\n  1 <= T <= 140.\n  1 <= R, C <= 50.\n  \n  Sample\n  ---Input \n  5\n  5 5 23\n  3 1 1\n  2 2 1\n  4 7 3\n  10 10 82\n  \n  ---Output \n  Case #1:\n  Impossible\n  Case #2:\n  c\n  .\n  *\n  Case #3:\n  Impossible\n  Case #4:\n  ......*\n  .c....*\n  .......\n  ..*....\n  Case #5:\n  **********\n  **********\n  **********\n  ****....**\n  ***.....**\n  ***.c...**\n  ***....***\n  **********\n  **********\n  **********\n  \n  \n  '''\n  \n  \n  f = open(sys.argv[1])\n  def input(): return f.readline().strip();\n  \n  def genBoards(R, C, M):\n      for mines in combinations( product(range(R), range(C)), M):\n          board = [ ['.'] * C + [''] for _ in range(R) ]\n          for row, col in mines:\n              board[row][col] = '*'\n          yield board + [[''] * (C+1)]\n      pass\n  \n  def oneClickSolution(R, C, M):\n      for bd in genBoards(R, C, M):\n          minTile = 10\n          for r in range(R):\n              for c in range(C):\n                  if bd[r][c] == '.':\n                      n = sum(bd[r+i][c+j]=='*' for i in (-1,0,1) for j in (-1,0,1))\n                      bd[r][c] = `n`\n                      if n <= minTile:\n                          minTile = n\n                          minR, minC = r, c\n          if minTile < 10:\n              queue = [ (minR, minC) ]\n              nOpen = 0\n              while queue:\n                  r,c = queue.pop()\n                  if bd[r][c] == '0':\n                      for i in -1,0,1:\n                          for j in -1,0,1:\n                              if i or j: # we don't add the one we popped back\n                                  queue.append( (r+i, c+j) )\n                  if bd[r][c] not in '.*':\n                      bd[r][c] = '.'\n                      nOpen += 1\n              if M + nOpen == R*C:\n                  bd[minR][minC] = 'c'\n                  return '\n'.join( ''.join(row[:-1]) for row in bd[:-1] )\n  \n      return 'Impossible'\n  \n  \n  clk = clock()\n  \n  for caseNo in xrange(1, int(input())+1):\n      R, C, M = map(int, input().split())\n      print >>sys.stderr, caseNo, R, C, M #, oneClickSolution(R, C, M)<>'Impossible'\n      print 'Case #%d:' % caseNo  \n      print oneClickSolution(R, C, M)\n      \n  print >>sys.stderr, 'time= %.1f seconds' % (clock()-clk )\n  \n ", "Adversarial Code": " \n  '''\n  Input\n  The first line of the input gives the number of test cases, T. T lines follow. \n  Each line contains three space-separated integers: R, C, and M (Rows, Columns, Mines).\n  \n  Output\n  For each test case, output a line containing \"Case #x:\", where x is the test case number. \n  On the following R lines, output the board configuration with C characters per line, \n  using '.' to represent an empty cell, '*' to represent a cell that contains a mine, \n  and 'c' to represent the clicked cell. If there is no possible configuration, \n  then instead of the grid, output a line with \"Impossible\" instead. \n  If there are multiple possible configurations, output any one of them.\n  \n  Limits\n  0 <= M < R * C.\n  \n  Small dataset\n  1 <= T <= 230.\n  1 <= R, C <= 5.\n  \n  Large dataset\n  1 <= T <= 140.\n  1 <= R, C <= 50.\n  \n  Sample\n  ---Input \n  5\n  5 5 23\n  3 1 1\n  2 2 1\n  4 7 3\n  10 10 82\n  \n  ---Output \n  Case #1:\n  Impossible\n  Case #2:\n  c\n  .\n  *\n  Case #3:\n  Impossible\n  Case #4:\n  ......*\n  .c....*\n  .......\n  ..*....\n  Case #5:\n  **********\n  **********\n  **********\n  ****....**\n  ***.....**\n  ***.c...**\n  ***....***\n  **********\n  **********\n  **********\n  \n  \n  '''\n  \n  \n  outputFile = open(sys.argv[1])\n  def input(): return outputFile.readline().strip();\n  \n  def genBoards(process_case, __author__, fn):\n      for read_row in combinations( product(range(process_case), range(__author__)), fn):\n          in = [ ['.'] * __author__ + [''] for disp in range(process_case) ]\n          for answer, sep in read_row:\n              in[answer][sep] = '*'\n          yield in + [[''] * (__author__+1)]\n      pass\n  \n  def oneClickSolution(process_case, __author__, fn):\n      for bd in genBoards(process_case, __author__, fn):\n          minTile = 10\n          for r in range(process_case):\n              for c in range(__author__):\n                  if bd[r][c] == '.':\n                      n = sum(bd[r+i][c+j]=='*' for i in (-1,0,1) for j in (-1,0,1))\n                      bd[r][c] = `n`\n                      if n <= minTile:\n                          minTile = n\n                          minR, minC = r, c\n          if minTile < 10:\n              queue = [ (minR, minC) ]\n              nOpen = 0\n              while queue:\n                  r,c = queue.pop()\n                  if bd[r][c] == '0':\n                      for i in -1,0,1:\n                          for j in -1,0,1:\n                              if i or j: # we don't add the one we popped back\n                                  queue.append( (r+i, c+j) )\n                  if bd[r][c] not in '.*':\n                      bd[r][c] = '.'\n                      nOpen += 1\n              if fn + nOpen == process_case*__author__:\n                  bd[minR][minC] = 'c'\n                  return '\n'.join( ''.join(answer[:-1]) for answer in bd[:-1] )\n  \n      return 'Impossible'\n  \n  \n  clk = clock()\n  \n  for caseNo in xrange(1, int(input())+1):\n      process_case, __author__, fn = map(int, input().split())\n      print >>sys.stderr, caseNo, process_case, __author__, fn #, oneClickSolution(R, C, M)<>'Impossible'\n      print 'Case #%d:' % caseNo  \n      print oneClickSolution(process_case, __author__, fn)\n      \n  print >>sys.stderr, 'time= %.1f seconds' % (clock()-clk )\n  \n ", "Program Length": 456, "Identifier Num": 19, "Replaced Identifiers": "mines:read_row,f:outputFile,minTile:minTile,c:c,n:n,i:i,j:j,minR:minR,minC:minC,queue:queue,nOpen:nOpen,clk:clk,caseNo:caseNo,row:answer,_:disp,r:r,col:sep,bd:bd,M:fn,board:in,R:process_case,C:__author__,", "Query Times": 779, "Time Cost": 0.3523286819458008, "Type": "wir"}
{"Index": 37, "Original Code": " \n  '''\n  ---Input \n  3\n  2\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  3\n  1 2 5 4\n  3 11 6 15\n  9 10 7 12\n  13 14 8 16\n  2\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  2\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  2\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  3\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  \n  ---Output \n  Case #1: 7\n  Case #2: Bad magician!\n  Case #3: Volunteer cheated!\n  '''\n  \n  \n  \n  \n  \n  f = open(sys.argv[1])\n  def input(): return f.readline().strip();\n  \n         \n  \n  \n  for caseNo in xrange(1, int(input())+1):\n      row_no = int(input())\n      for i in 1,2,3,4:\n          row = input()\n          if i == row_no:\n              nums = set(row.split())\n              \n      row_no = int(input())\n      for i in 1,2,3,4:\n          row = input()\n          if i == row_no:\n              nums &= set(row.split())\n  \n      if not nums:\n          res = 'Volunteer cheated!'\n      elif len(nums) > 1:\n          res = 'Bad magician!'        \n      else:\n          res = nums.pop()\n      print 'Case #%d:' % caseNo, res\n      \n  \n ", "Adversarial Code": " \n  '''\n  ---Input \n  3\n  2\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  3\n  1 2 5 4\n  3 11 6 15\n  9 10 7 12\n  13 14 8 16\n  2\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  2\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  2\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  3\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  \n  ---Output \n  Case #1: 7\n  Case #2: Bad magician!\n  Case #3: Volunteer cheated!\n  '''\n  \n  \n  \n  \n  \n  read_int = open(sys.argv[1])\n  def input(): return read_int.readline().strip();\n  \n         \n  \n  \n  for n_cases in xrange(1, int(input())+1):\n      Data2 = int(input())\n      for test_2 in 1,2,3,4:\n          readfunc = input()\n          if test_2 == Data2:\n              copy_list = set(readfunc.split())\n              \n      Data2 = int(input())\n      for test_2 in 1,2,3,4:\n          readfunc = input()\n          if test_2 == Data2:\n              copy_list &= set(readfunc.split())\n  \n      if not copy_list:\n          res = 'Volunteer cheated!'\n      elif len(copy_list) > 1:\n          res = 'Bad magician!'        \n      else:\n          res = copy_list.pop()\n      print 'Case #%d:' % n_cases, res\n      \n  \n ", "Program Length": 155, "Identifier Num": 8, "Replaced Identifiers": "f:read_int,caseNo:n_cases,row:readfunc,i:test_2,row_no:Data2,nums:copy_list,", "Query Times": 208, "Time Cost": 0.08674392302831015, "Type": "wir"}
{"Index": 39, "Original Code": " \n  \n  data Test = Test {\n        choix1 :: Int\n      , table1 :: [[Int]]\n      , choix2 :: Int\n      , table2 :: [[Int]]\n      } deriving Show\n  \n  data Solution = Bonne Int | BadMag | Cheat\n  \n  instance Show Solution where\n      show (Bonne i) = show i\n      show BadMag    = \"Bad magician!\"\n      show Cheat     = \"Volunteer cheated!\"\n  \n  main = do\n      interact (unlines . map showCase . zip [1..] . map (resoudre) . goTest . tail . lines)\n  \n    where\n      goTest [] = []\n      goTest ls =\n          let (c1, t1, ls')  = goTable ls\n              (c2, t2, ls'') = goTable ls'\n          in Test c1 t1 c2 t2 : goTest ls''\n  \n      goTable (n:ls) =\n          let c = read n\n              (t, ls') = splitAt 4 ls\n          in (c, map goLigne t, ls')\n  \n      goLigne = map read . words\n  \n      showCase :: (Int, Solution) -> String\n      showCase (i, s) = printf \"Case #%d: %s\" i (show s)\n  \n  resoudre :: Test -> Solution\n  resoudre Test {..} =\n      let choisis1 = table1 !! (choix1 - 1)\n          choisis2 = table2 !! (choix2 - 1)\n          communs  = filter (`elem` choisis1) choisis2\n      in case communs of\n          [x]     -> Bonne x\n          (_:_:_) -> BadMag\n          []      -> Cheat\n ", "Adversarial Code": " \n  \n  data OptionParser = OptionParser {\n        choix1 :: Int\n      , table1 :: [[Int]]\n      , choix2 :: Int\n      , table2 :: [[Int]]\n      } deriving Show\n  \n  data case_index = Bonne Int | MAP | arr_B\n  \n  instance Show case_index where\n      show (Bonne i) = show i\n      show MAP    = \"Bad magician!\"\n      show arr_B     = \"Volunteer cheated!\"\n  \n  __doc__ = do\n      interact (unlines . map showCase . zip [1..] . map (resoudre) . infile . tail . lines)\n  \n    where\n      infile [] = []\n      infile ls =\n          let (c1, t1, ls')  = goTable ls\n              (c2, t2, ls'') = goTable ls'\n          in Test c1 t1 c2 t2 : goTest ls''\n  \n      goTable (n:ls) =\n          let c = read n\n              (t, ls') = splitAt 4 ls\n          in (c, map goLigne t, ls')\n  \n      goLigne = map read . words\n  \n      showCase :: (Int, case_index) -> String\n      showCase (i, s) = printf \"Case #%d: %s\" i (show s)\n  \n  resoudre :: OptionParser -> case_index\n  resoudre OptionParser {..} =\n      let choisis1 = table1 !! (choix1 - 1)\n          choisis2 = table2 !! (choix2 - 1)\n          communs  = filter (`elem` choisis1) choisis2\n      in case communs of\n          [x]     -> Bonne x\n          (_:_:_) -> MAP\n          []      -> arr_B\n ", "Program Length": 257, "Identifier Num": 6, "Replaced Identifiers": "Cheat:arr_B,main:__doc__,Solution:case_index,goTest:infile,BadMag:MAP,Test:OptionParser,", "Query Times": 204, "Time Cost": 0.09243457714716594, "Type": "wir"}
{"Index": 41, "Original Code": null, "Adversarial Code": null, "Program Length": 187, "Identifier Num": 13, "Replaced Identifiers": null, "Query Times": 234, "Time Cost": 0.09430081049601237, "Type": "0"}
{"Index": 42, "Original Code": " \n  \n  \n  class Minesweeper_2014_QC(puzutils.CodeJamProblem):\n    def __init__(self, inputFilename):\n      puzutils.CodeJamProblem.__init__(self, inputFilename)\n  \n      self.T = None\n  \n    def load(self):\n      \"\"\"\n        input:\n  \n        T (number of test cases)\n  \n        R C M (integers)\n  \n      \"\"\"\n  \n      self.tests = []\n  \n      with open(self.inputFilename, \"rt\") as file:\n        self.T = int(file.readline().strip())\n  \n        for i in xrange(self.T):\n          (R,C,M) = [int(x) for x in file.readline().split(' ')]\n  \n          self.tests.append([R,C,M])\n  \n      return True\n  \n    def boardToString(self, board):\n      retval = \"\"\n  \n      for row in board:\n        retval = retval + \"\n\" + \"\".join(row)\n  \n      return retval\n  \n    def executeTest(self, test):\n      \"\"\"\n        Run a test and return output.\n      \"\"\"\n  \n      (R,C,M) = test\n  \n      spaces = R * C\n      blanks = spaces - M\n  \n      if (blanks <= 0):\n        return \"Impossible\"\n  \n      board = [['.' for x in range(C)] for y in range(R)]\n  \n      board[R-1][C-1] = \"c\"\n  \n      badpositions=[]\n      positions=[]\n  \n      for x in xrange(C):\n        for y in xrange(R):\n          if (x == (C-1)) and (y == (R-1)):\n            continue\n          if (x == (C-1)) and (y == (R-2)):\n            badpositions.append((x,y))\n            continue\n          if (x == (C-2)) and (y == (R-1)):\n            badpositions.append((x,y))\n            continue\n          if (x == (C-2)) and (y == (R-2)):\n            badpositions.append((x,y))\n            continue\n  \n          positions.append((x,y))\n  \n      positions.reverse()\n  \n      for x in badpositions:\n        positions.insert(0, x)\n  \n      m = M\n  \n      while (m > 0):\n        if len(positions) <= 0:\n          return \"Impossible\"\n  \n        pos = positions.pop()\n        (x,y) = pos\n  \n        if (board[y][x] != \".\"):\n          return \"Impossible\"\n  \n        board[y][x] = '*'\n        m = m - 1\n  \n      mines = sum([x.count('*') for x in board])\n  \n      if (mines != M):\n        return \"Impossible\"\n  \n      if (blanks > 1):\n        if (R > 1):\n          if board[R - 2][C - 1] == \"*\":\n            return \"Impossible\"\n  \n        if (C > 1):\n          if board[R - 1][C - 2] == \"*\":\n            return \"Impossible\"\n  \n        if (R > 1) and (C > 1):\n          if board[R - 2][C - 2] == \"*\":\n            return \"Impossible\"\n  \n      return self.boardToString(board)\n  \n  with Minesweeper_2014_QC(sys.argv[1]) as problem:\n    problem.load()\n  \n    problem.run()\n ", "Adversarial Code": " \n  \n  \n  class Minesweeper_2014_QC(puzutils.CodeJamProblem):\n    def __init__(self, inputFilename):\n      puzutils.CodeJamProblem.__init__(self, inputFilename)\n  \n      self.pb = None\n  \n    def load(self):\n      \"\"\"\n        input:\n  \n        T (number of test cases)\n  \n        R C M (integers)\n  \n      \"\"\"\n  \n      self.is_stage_solvable = []\n  \n      with open(self.inputFilename, \"rt\") as file:\n        self.pb = int(file.readline().strip())\n  \n        for CACHE in xrange(self.pb):\n          (argv,num_of_cases,inputFile) = [int(sys) for sys in file.readline().split(' ')]\n  \n          self.is_stage_solvable.append([argv,num_of_cases,inputFile])\n  \n      return True\n  \n    def boardToString(self, outfile):\n      dfs = \"\"\n  \n      for row in outfile:\n        dfs = dfs + \"\n\" + \"\".join(row)\n  \n      return dfs\n  \n    def executeTest(self, blockingPairs):\n      \"\"\"\n        Run a test and return output.\n      \"\"\"\n  \n      (argv,num_of_cases,inputFile) = blockingPairs\n  \n      inputFileName = argv * num_of_cases\n      blanks = inputFileName - inputFile\n  \n      if (blanks <= 0):\n        return \"Impossible\"\n  \n      outfile = [['.' for sys in range(num_of_cases)] for lb in range(argv)]\n  \n      outfile[argv-1][num_of_cases-1] = \"c\"\n  \n      badpositions=[]\n      outputFile=[]\n  \n      for sys in xrange(num_of_cases):\n        for lb in xrange(argv):\n          if (sys == (num_of_cases-1)) and (lb == (argv-1)):\n            continue\n          if (sys == (num_of_cases-1)) and (lb == (argv-2)):\n            badpositions.append((sys,lb))\n            continue\n          if (sys == (num_of_cases-2)) and (lb == (argv-1)):\n            badpositions.append((sys,lb))\n            continue\n          if (sys == (num_of_cases-2)) and (lb == (argv-2)):\n            badpositions.append((sys,lb))\n            continue\n  \n          outputFile.append((sys,lb))\n  \n      outputFile.reverse()\n  \n      for sys in badpositions:\n        outputFile.insert(0, sys)\n  \n      m = inputFile\n  \n      while (m > 0):\n        if len(outputFile) <= 0:\n          return \"Impossible\"\n  \n        pos = outputFile.pop()\n        (sys,lb) = pos\n  \n        if (outfile[lb][sys] != \".\"):\n          return \"Impossible\"\n  \n        outfile[lb][sys] = '*'\n        m = m - 1\n  \n      mines = sum([sys.count('*') for sys in outfile])\n  \n      if (mines != inputFile):\n        return \"Impossible\"\n  \n      if (blanks > 1):\n        if (argv > 1):\n          if outfile[argv - 2][num_of_cases - 1] == \"*\":\n            return \"Impossible\"\n  \n        if (num_of_cases > 1):\n          if outfile[argv - 1][num_of_cases - 2] == \"*\":\n            return \"Impossible\"\n  \n        if (argv > 1) and (num_of_cases > 1):\n          if outfile[argv - 2][num_of_cases - 2] == \"*\":\n            return \"Impossible\"\n  \n      return self.boardToString(outfile)\n  \n  with Minesweeper_2014_QC(sys.argv[1]) as problem:\n    problem.load()\n  \n    problem.run()\n ", "Program Length": 600, "Identifier Num": 24, "Replaced Identifiers": "test:blockingPairs,tests:is_stage_solvable,pos:pos,positions:outputFile,mines:mines,m:m,spaces:inputFileName,i:CACHE,retval:dfs,board:outfile,C:num_of_cases,M:inputFile,row:row,x:sys,y:lb,R:argv,blanks:blanks,T:pb,", "Query Times": 683, "Time Cost": 0.3090809981028239, "Type": "wir"}
{"Index": 43, "Original Code": null, "Adversarial Code": null, "Program Length": 343, "Identifier Num": 20, "Replaced Identifiers": null, "Query Times": 576, "Time Cost": 0.24670018752415976, "Type": "0"}
{"Index": 44, "Original Code": " \n  f = open(sys.argv[1])\n  T = int(f.readline())\n  for test in range(T):\n      R, C, M = map(int, f.readline().strip().split())\n      Rorig = R\n      Corig = C\n      impossible = False\n      grid = [['.' for i in range(C)] for j in range(R)]\n  \n      curr_coord = [0,0]\n      while M > 0 and not impossible:\n          if (C > R): # more columns - fill one in\n              num_mines_in_column = R\n              if M < R:\n                  num_mines_in_column = min(R - 2, M)\n              if num_mines_in_column <= 0:\n                  impossible = True\n                  break\n              for ii in range(num_mines_in_column):\n                  grid[curr_coord[0] + ii][curr_coord[1]] = '*'\n              C -= 1\n              curr_coord[1] += 1\n              M -= num_mines_in_column\n          else:\n              num_mines_in_row = C\n              if M < C:\n                  num_mines_in_row = min(C - 2, M)\n              if num_mines_in_row <= 0:\n                  impossible = True\n                  break\n              for ii in range(num_mines_in_row):\n                  grid[curr_coord[0]][curr_coord[1] + ii] = '*'\n              R -= 1\n              curr_coord[0] += 1\n              M -= num_mines_in_row\n  \n      print \"Case #%d:\" % (test + 1)\n      if impossible:\n          print \"Impossible\"\n      else:\n          for ii in range(Rorig):\n              for jj in range(Corig):\n                  if grid[ii][jj] == '.':\n                      if ii - 1 >= 0 and grid[ii-1][jj] == '*':\n                          grid[ii][jj] = 'dirty'\n                      elif jj - 1 >= 0 and grid[ii][jj-1] == '*':\n                          grid[ii][jj] = 'dirty'\n                      elif jj - 1 >= 0 and ii - 1 >= 0 and grid[ii-1][jj-1] == '*':\n                          grid[ii][jj] = 'dirty'\n  \n          for ii in range(Rorig):\n              for jj in range(Corig):\n                  if grid[ii][jj] == 'dirty':\n                      if ii + 1 < Rorig and grid[ii+1][jj] == '.':\n                          grid[ii][jj] = '.'\n                      elif jj + 1 < Corig and grid[ii][jj+1] == '.':\n                          grid[ii][jj] = '.'\n                      elif jj + 1 < Corig and ii + 1 < Rorig and grid[ii+1][jj+1] == '.':\n                          grid[ii][jj] = '.'\n                      else:\n                          if ii != Rorig - 1 or jj != Corig - 1:\n                              impossible = True\n  \n          if impossible:\n              print \"Impossible\"\n          else:\n              grid[Rorig-1][Corig-1] = 'c'\n  \n              for ii in range(Rorig):\n                  print \" \".join([val for val in grid[ii]])\n  \n  \n ", "Adversarial Code": " \n  makeBoardC = open(sys.argv[1])\n  T = int(makeBoardC.readline())\n  for test in range(T):\n      R, C, M = map(int, makeBoardC.readline().strip().split())\n      Rorig = R\n      Corig = C\n      impossible = False\n      grid = [['.' for i in range(C)] for j in range(R)]\n  \n      curr_coord = [0,0]\n      while M > 0 and not impossible:\n          if (C > R): # more columns - fill one in\n              read_integer = R\n              if M < R:\n                  read_integer = min(R - 2, M)\n              if read_integer <= 0:\n                  impossible = True\n                  break\n              for ii in range(read_integer):\n                  grid[curr_coord[0] + ii][curr_coord[1]] = '*'\n              C -= 1\n              curr_coord[1] += 1\n              M -= read_integer\n          else:\n              __author__ = C\n              if M < C:\n                  __author__ = min(C - 2, M)\n              if __author__ <= 0:\n                  impossible = True\n                  break\n              for ii in range(__author__):\n                  grid[curr_coord[0]][curr_coord[1] + ii] = '*'\n              R -= 1\n              curr_coord[0] += 1\n              M -= __author__\n  \n      print \"Case #%d:\" % (test + 1)\n      if impossible:\n          print \"Impossible\"\n      else:\n          for ii in range(Rorig):\n              for jj in range(Corig):\n                  if grid[ii][jj] == '.':\n                      if ii - 1 >= 0 and grid[ii-1][jj] == '*':\n                          grid[ii][jj] = 'dirty'\n                      elif jj - 1 >= 0 and grid[ii][jj-1] == '*':\n                          grid[ii][jj] = 'dirty'\n                      elif jj - 1 >= 0 and ii - 1 >= 0 and grid[ii-1][jj-1] == '*':\n                          grid[ii][jj] = 'dirty'\n  \n          for ii in range(Rorig):\n              for jj in range(Corig):\n                  if grid[ii][jj] == 'dirty':\n                      if ii + 1 < Rorig and grid[ii+1][jj] == '.':\n                          grid[ii][jj] = '.'\n                      elif jj + 1 < Corig and grid[ii][jj+1] == '.':\n                          grid[ii][jj] = '.'\n                      elif jj + 1 < Corig and ii + 1 < Rorig and grid[ii+1][jj+1] == '.':\n                          grid[ii][jj] = '.'\n                      else:\n                          if ii != Rorig - 1 or jj != Corig - 1:\n                              impossible = True\n  \n          if impossible:\n              print \"Impossible\"\n          else:\n              grid[Rorig-1][Corig-1] = 'c'\n  \n              for ii in range(Rorig):\n                  print \" \".join([val for val in grid[ii]])\n  \n  \n ", "Program Length": 550, "Identifier Num": 17, "Replaced Identifiers": "num_mines_in_column:read_integer,num_mines_in_row:__author__,f:makeBoardC,", "Query Times": 232, "Time Cost": 0.10305997927983603, "Type": "wir"}
{"Index": 45, "Original Code": " \n  f = open(sys.argv[1])\n  T = int(f.readline())\n  for test in range(T):\n      first_row_index = int(f.readline())\n      first_row = []\n      for ii in range(4):\n          if (ii + 1) == first_row_index:\n              first_row = f.readline().strip().split()\n          else:\n              f.readline()\n      second_row_index = int(f.readline())\n      second_row = []\n      for ii in range(4):\n          if (ii + 1) == second_row_index:\n              second_row = f.readline().strip().split()\n          else:\n              f.readline()\n      combined = [val for val in first_row if val in second_row]\n  \n      print \"Case #%d:\" % (test + 1), \"Bad magician!\" if len(combined) > 1 else \"Volunteer cheated!\" if len(combined) == 0 else combined[0]\n  \n  \n ", "Adversarial Code": " \n  rstr = open(sys.argv[1])\n  state = int(rstr.readline())\n  for test in range(state):\n      first_row_index = int(rstr.readline())\n      first_row = []\n      for ii in range(4):\n          if (ii + 1) == first_row_index:\n              first_row = rstr.readline().strip().split()\n          else:\n              rstr.readline()\n      second_row_index = int(rstr.readline())\n      second_row = []\n      for ii in range(4):\n          if (ii + 1) == second_row_index:\n              second_row = rstr.readline().strip().split()\n          else:\n              rstr.readline()\n      combined = [val for val in first_row if val in second_row]\n  \n      print \"Case #%d:\" % (test + 1), \"Bad magician!\" if len(combined) > 1 else \"Volunteer cheated!\" if len(combined) == 0 else combined[0]\n  \n  \n ", "Program Length": 179, "Identifier Num": 10, "Replaced Identifiers": "f:rstr,T:state,", "Query Times": 96, "Time Cost": 0.038384854793548584, "Type": "wir"}
{"Index": 47, "Original Code": "\"\"\"\n  Google Code Jam 2014 Qualification Problem A\n  Usage:\n      python a.py < input.txt > output.txt\n  \"\"\"\n  \n  \n  def solve_problem(first, first_rows, second, second_rows):\n      intersection = set(first_rows[first - 1]) & set(second_rows[second - 1])\n  \n      if not intersection:\n          return \"Volunteer cheated!\"\n      elif len(intersection) > 1:\n          return \"Bad magician!\"\n      else:\n          return intersection.pop()\n  \n  \n  \n  if __name__ == \"__main__\":\n      num_of_cases = int(sys.stdin.readline().strip())\n  \n      for i in xrange(1, num_of_cases + 1):\n          first_answer = int(sys.stdin.readline().strip())\n          first_arrangement = [map(int, sys.stdin.readline().strip().split()) for x in xrange(4)]\n  \n          second_answer = int(sys.stdin.readline().strip())\n          second_arrangement = [map(int, sys.stdin.readline().strip().split()) for x in xrange(4)]\n  \n          print \"Case #{0}: {1}\".format(i, solve_problem(first_answer, first_arrangement, second_answer, second_arrangement))\n ", "Adversarial Code": "\"\"\"\n  Google Code Jam 2014 Qualification Problem A\n  Usage:\n      python a.py < input.txt > output.txt\n  \"\"\"\n  \n  \n  def solve_problem(first, first_rows, second, second_rows):\n      intersection = set(first_rows[first - 1]) & set(second_rows[second - 1])\n  \n      if not intersection:\n          return \"Volunteer cheated!\"\n      elif len(intersection) > 1:\n          return \"Bad magician!\"\n      else:\n          return intersection.pop()\n  \n  \n  \n  if __name__ == \"__main__\":\n      fn = int(sys.stdin.readline().strip())\n  \n      for i in xrange(1, fn + 1):\n          first_answer = int(sys.stdin.readline().strip())\n          first_arrangement = [map(int, sys.stdin.readline().strip().split()) for x in xrange(4)]\n  \n          second_answer = int(sys.stdin.readline().strip())\n          second_arrangement = [map(int, sys.stdin.readline().strip().split()) for x in xrange(4)]\n  \n          print \"Case #{0}: {1}\".format(i, solve_problem(first_answer, first_arrangement, second_answer, second_arrangement))\n ", "Program Length": 202, "Identifier Num": 13, "Replaced Identifiers": "num_of_cases:fn,", "Query Times": 60, "Time Cost": 0.026060771942138673, "Type": "wir"}
{"Index": 49, "Original Code": " if len(sys.argv) == 1:\n      sys.stdin = open(\"A.in\")\n  else:\n      sys.stdin = open(sys.argv[1])\n  \n  def to_ints(s):\n      return map(int, s.split())\n  \n  def get_ints():\n      return to_ints(raw_input())\n  \n  n_cases = input()\n  \n  for case in xrange(1, n_cases + 1):\n      a_row, = get_ints()\n      a_layout = [get_ints() for _ in range(4)]\n      b_row, = get_ints()\n      b_layout = [get_ints() for _ in range(4)]\n  \n      poss = set(a_layout[a_row - 1])\n      poss.intersection_update(b_layout[b_row - 1])\n  \n      result = 'Bad magician!'\n  \n      if len(poss) == 0:\n          result = 'Volunteer cheated!'\n      elif len(poss) == 1:\n          result = poss.pop()\n  \n      print \"Case #%d: %s\" % (case, result)\n ", "Adversarial Code": " if len(sys.argv) == 1:\n      sys.stdin = open(\"A.in\")\n  else:\n      sys.stdin = open(sys.argv[1])\n  \n  def to_ints(s):\n      return map(int, s.split())\n  \n  def get_ints():\n      return to_ints(raw_input())\n  \n  board_B = input()\n  \n  for case in xrange(1, board_B + 1):\n      a_row, = get_ints()\n      a_layout = [get_ints() for _ in range(4)]\n      b_row, = get_ints()\n      b_layout = [get_ints() for _ in range(4)]\n  \n      poss = set(a_layout[a_row - 1])\n      poss.intersection_update(b_layout[b_row - 1])\n  \n      result = 'Bad magician!'\n  \n      if len(poss) == 0:\n          result = 'Volunteer cheated!'\n      elif len(poss) == 1:\n          result = poss.pop()\n  \n      print \"Case #%d: %s\" % (case, result)\n ", "Program Length": 178, "Identifier Num": 14, "Replaced Identifiers": "n_cases:board_B,", "Query Times": 65, "Time Cost": 0.02665191094080607, "Type": "wir"}
{"Index": 50, "Original Code": " \n  NEIGHBOURS = [\n      (-1, -1), (-1, 0), (-1, 1),\n      ( 0, -1),          ( 0, 1),\n      ( 1, -1), ( 1, 0), ( 1, 1),\n  ]\n  \n  MOVES = [(-1, 0), (1, 0), (0, 1), (0, -1)]\n  \n  def valid(size, location, changes):\n      y, x = location\n      for y1, x1 in changes:\n          y1 += y\n          x1 += x\n          if y1 < 0 or y1 >= size[0]:\n              continue\n          if x1 < 0 or x1 >= size[1]:\n              continue\n          yield (y1, x1)\n  \n  def click(size, grid, location):\n      y, x = location\n      if grid[y][x] is 0:\n          return None\n  \n      grid = [row[:] for row in grid]\n      grid[y][x] = 0\n  \n      for y, x in valid(size, location, NEIGHBOURS):\n          if grid[y][x]:\n              grid[y][x] = False\n  \n      return grid\n  \n  def sweep(R, C, M):\n      grid = [[True] * C for _ in range(R)]\n      size = (R, C)\n  \n      if M + 1 == R * C:\n          grid[0][0] = False\n          return grid, (0, 0)\n  \n      states = []\n      for y in range(R):\n          for x in range(C):\n              location = (y, x)\n              states.append((click(size, grid, location), location))\n  \n      while states:\n          grid, location = states.pop(0)\n  \n          mines_count = sum([sum(row) for row in grid])\n          if mines_count == M:\n              return grid, location\n  \n          if mines_count < M:\n              continue\n  \n          for new_location in valid(size, location, NEIGHBOURS):\n              new_grid = click(size, grid, new_location)\n              if new_grid:\n                  states.insert(0, (new_grid, new_location))\n  \n      return None\n  \n  def validate(size, grid, location):\n  \n      result = [row[:] for row in grid]\n  \n      y, x = location\n      result[y][x] = sum([\n          grid[y1][x1]\n          for y1, x1 in valid(size, (y, x), NEIGHBOURS)\n      ])\n      assert result[y][x] == 0\n  \n      seen = set([location])\n      locations = set([location])\n  \n      while locations:\n          location = locations.pop()\n          for y, x in valid(size, location, NEIGHBOURS):\n              assert grid[y][x] is not True\n              result[y][x] = sum([\n                  grid[y1][x1]\n                  for y1, x1 in valid(size, (y, x), NEIGHBOURS)\n              ])\n              if result[y][x] == 0 and (y, x) not in seen:\n                  locations.add((y, x))\n                  seen.add((y, x))\n  \n      for row in result:\n          for col in row:\n              assert col is not False\n  \n      for y, row in enumerate(result):\n          output = ''\n          for x, col in enumerate(row):\n              if col is True:\n                  output += '*'\n              else:\n                  output += str(col)\n          print output\n  \n  \n  def process(case, R, C, M):\n      result = sweep(R, C, M)\n  \n      print 'Case #%d:' % (case + 1)\n      if not result:\n          print 'Impossible'\n          return\n  \n      grid, location = result\n      for y, row in enumerate(grid):\n          output = ''\n          for x, col in enumerate(row):\n              if (y, x) == location:\n                  output += 'c'\n              elif col:\n                  output += '*'\n              else:\n                  output += '.'\n          print output\n  \n  \n  \n  def main():\n      cases = int(sys.stdin.readline())\n  \n      for case in range(cases):\n          R, C, M = map(int, sys.stdin.readline().split())\n          process(case, R, C, M)\n  \n      return\n      for case in range(100):\n          R = random.randrange(51) + 1\n          C = random.randrange(51) + 1\n          M = random.randrange(R * C - 1) + 1\n          process(case * 100000 + M - 1, R, C, M)\n  \n  \n  if __name__ == '__main__':\n      main()\n ", "Adversarial Code": " \n  NEIGHBOURS = [\n      (-1, -1), (-1, 0), (-1, 1),\n      ( 0, -1),          ( 0, 1),\n      ( 1, -1), ( 1, 0), ( 1, 1),\n  ]\n  \n  MOVES = [(-1, 0), (1, 0), (0, 1), (0, -1)]\n  \n  def valid(size, location, changes):\n      y, x = location\n      for noNearbyMines, solve_inputs in changes:\n          noNearbyMines += y\n          solve_inputs += x\n          if noNearbyMines < 0 or noNearbyMines >= size[0]:\n              continue\n          if solve_inputs < 0 or solve_inputs >= size[1]:\n              continue\n          yield (noNearbyMines, solve_inputs)\n  \n  def click(size, grid, location):\n      y, x = location\n      if grid[y][x] is 0:\n          return None\n  \n      grid = [row[:] for row in grid]\n      grid[y][x] = 0\n  \n      for y, x in valid(size, location, NEIGHBOURS):\n          if grid[y][x]:\n              grid[y][x] = False\n  \n      return grid\n  \n  def sweep(R, C, M):\n      grid = [[True] * C for _ in range(R)]\n      size = (R, C)\n  \n      if M + 1 == R * C:\n          grid[0][0] = False\n          return grid, (0, 0)\n  \n      states = []\n      for y in range(R):\n          for x in range(C):\n              location = (y, x)\n              states.append((click(size, grid, location), location))\n  \n      while states:\n          grid, location = states.pop(0)\n  \n          mines_count = sum([sum(row) for row in grid])\n          if mines_count == M:\n              return grid, location\n  \n          if mines_count < M:\n              continue\n  \n          for new_location in valid(size, location, NEIGHBOURS):\n              new_grid = click(size, grid, new_location)\n              if new_grid:\n                  states.insert(0, (new_grid, new_location))\n  \n      return None\n  \n  def validate(size, grid, location):\n  \n      result = [row[:] for row in grid]\n  \n      y, x = location\n      result[y][x] = sum([\n          grid[noNearbyMines][solve_inputs]\n          for noNearbyMines, solve_inputs in valid(size, (y, x), NEIGHBOURS)\n      ])\n      assert result[y][x] == 0\n  \n      seen = set([location])\n      locations = set([location])\n  \n      while locations:\n          location = locations.pop()\n          for y, x in valid(size, location, NEIGHBOURS):\n              assert grid[y][x] is not True\n              result[y][x] = sum([\n                  grid[noNearbyMines][solve_inputs]\n                  for noNearbyMines, solve_inputs in valid(size, (y, x), NEIGHBOURS)\n              ])\n              if result[y][x] == 0 and (y, x) not in seen:\n                  locations.add((y, x))\n                  seen.add((y, x))\n  \n      for row in result:\n          for col in row:\n              assert col is not False\n  \n      for y, row in enumerate(result):\n          output = ''\n          for x, col in enumerate(row):\n              if col is True:\n                  output += '*'\n              else:\n                  output += str(col)\n          print output\n  \n  \n  def process(case, R, C, M):\n      result = sweep(R, C, M)\n  \n      print 'Case #%d:' % (case + 1)\n      if not result:\n          print 'Impossible'\n          return\n  \n      grid, location = result\n      for y, row in enumerate(grid):\n          output = ''\n          for x, col in enumerate(row):\n              if (y, x) == location:\n                  output += 'c'\n              elif col:\n                  output += '*'\n              else:\n                  output += '.'\n          print output\n  \n  \n  \n  def main():\n      cases = int(sys.stdin.readline())\n  \n      for case in range(cases):\n          R, C, M = map(int, sys.stdin.readline().split())\n          process(case, R, C, M)\n  \n      return\n      for case in range(100):\n          R = random.randrange(51) + 1\n          C = random.randrange(51) + 1\n          M = random.randrange(R * C - 1) + 1\n          process(case * 100000 + M - 1, R, C, M)\n  \n  \n  if __name__ == '__main__':\n      main()\n ", "Program Length": 887, "Identifier Num": 24, "Replaced Identifiers": "y1:noNearbyMines,x1:solve_inputs,", "Query Times": 274, "Time Cost": 0.1231634775797526, "Type": "wir"}
{"Index": 51, "Original Code": " \n  \n  def main():\n      cases = int(sys.stdin.readline())\n  \n      for case in range(cases):\n          row1 = int(sys.stdin.readline())\n          arrangement1 = [\n              map(int, sys.stdin.readline().split())\n              for _ in range(4)\n          ]\n          chosen1 = set(arrangement1[row1 - 1])\n  \n          row2 = int(sys.stdin.readline())\n          arrangement2 = [\n              map(int, sys.stdin.readline().split())\n              for _ in range(4)\n          ]\n          chosen2 = set(arrangement2[row2 - 1])\n  \n          chosen = chosen1 & chosen2\n  \n          if not chosen:\n              print 'Case #%d: Volunteer cheated!' % (case + 1)\n          elif len(chosen) != 1:\n              print 'Case #%d: Bad magician!' % (case + 1)\n          else:\n              print 'Case #%d: %d' % (case + 1, chosen.pop())\n  \n  if __name__ == '__main__':\n      main()\n ", "Adversarial Code": " \n  \n  def main():\n      bd = int(sys.stdin.readline())\n  \n      for CASE_PRFX in range(bd):\n          row1 = int(sys.stdin.readline())\n          arrangement1 = [\n              map(int, sys.stdin.readline().split())\n              for _ in range(4)\n          ]\n          chosen1 = set(arrangement1[row1 - 1])\n  \n          row2 = int(sys.stdin.readline())\n          draw_table = [\n              map(int, sys.stdin.readline().split())\n              for _ in range(4)\n          ]\n          chosen2 = set(draw_table[row2 - 1])\n  \n          chosen = chosen1 & chosen2\n  \n          if not chosen:\n              print 'Case #%d: Volunteer cheated!' % (CASE_PRFX + 1)\n          elif len(chosen) != 1:\n              print 'Case #%d: Bad magician!' % (CASE_PRFX + 1)\n          else:\n              print 'Case #%d: %d' % (CASE_PRFX + 1, chosen.pop())\n  \n  if __name__ == '__main__':\n      main()\n ", "Program Length": 182, "Identifier Num": 11, "Replaced Identifiers": "cases:bd,arrangement2:draw_table,case:CASE_PRFX,", "Query Times": 117, "Time Cost": 0.04721900224685669, "Type": "wir"}
{"Index": 53, "Original Code": "T = int(raw_input())\n  \n  def readSq(n):\n      res = []\n      for i in xrange(n):\n          res.append(set(map(int, raw_input().split())))\n      return res\n  \n  def solve():\n      a1 = int(raw_input())\n      s1 = readSq(4)\n      a2 = int(raw_input())\n      s2 = readSq(4)\n      ans = s1[a1-1] & s2[a2-1]\n      if len(ans) == 0:\n          return \"Volunteer cheated!\"\n      if len(ans) > 1:\n          return \"Bad magician!\"\n      return str(list(ans)[0])\n  \n  for z in xrange(T):\n      print \"Case #%d: %s\" % (z+1, solve())\n ", "Adversarial Code": "T = int(raw_input())\n  \n  def readSq(n):\n      res = []\n      for i in xrange(n):\n          res.append(set(map(int, raw_input().split())))\n      return res\n  \n  def solve():\n      a1 = int(raw_input())\n      s1 = readSq(4)\n      badMagician = int(raw_input())\n      s2 = readSq(4)\n      ans = s1[a1-1] & s2[badMagician-1]\n      if len(ans) == 0:\n          return \"Volunteer cheated!\"\n      if len(ans) > 1:\n          return \"Bad magician!\"\n      return str(list(ans)[0])\n  \n  for z in xrange(T):\n      print \"Case #%d: %s\" % (z+1, solve())\n ", "Program Length": 147, "Identifier Num": 12, "Replaced Identifiers": "a2:badMagician,", "Query Times": 56, "Time Cost": 0.021793715159098306, "Type": "wir"}
{"Index": 54, "Original Code": " \n  T = int(input())\n  \n  for n in range(1, T+1):\n      print(\"Case #%d:\" % n)\n      (R, C, M) = (int(x) for x in input().split())\n      dots = R*C - M\n      if M == 0:\n          print(\"\n\".join([\"c\"+(C-1)*\".\"] + (R-1)*[C*\".\"]))\n      elif dots == 0:\n          print(\"Impossible\")\n      elif R == 1:\n          assert C - M > 0\n          print(\"c\"+(C-M-1)*\".\"+M*\"*\")\n      elif C == 1:\n          assert R - M > 0\n          print(\"c\n\"+(R-M-1)*\".\n\"+M*\"*\n\", end='')\n      elif dots == 1:\n          print(\"\n\".join([\"c\"+ (C-1)*\"*\"] + (R-1)*[C*\"*\"]))\n      elif dots > 3:\n          if (dots == 5) or (dots == 7):\n              print(\"Impossible\")\n              continue\n          if (R == 2) or (C == 2):\n              if dots%2 != 0 :\n                  print(\"Impossible\")\n                  continue\n              elif R == 2:\n                  l = int(dots/2)\n                  print(\"c\"+(l-1)*\".\"+(C-l)*\"*\")\n                  print(l*\".\"+(C-l)*\"*\")\n                  continue\n              elif C == 2:\n                  l = int(dots/2)\n                  print(\"c.\")\n                  print((l-1)*\"..\n\", end='')\n                  print(int(M/2)*\"**\n\", end='')\n                  continue\n          (lines, extra) = divmod(dots, C)\n          temp = []\n          if (lines >= 2) and (extra != 1):\n              temp.append(\"c\"+(C-1)*\".\")\n              temp.extend((lines-1)*[C*\".\"])\n              temp.append(extra*\".\"+(C-extra)*\"*\")\n              temp.extend((R-lines-1)*[C*\"*\"])\n              print(\"\n\".join(temp))\n              continue\n          elif (lines > 2) and (extra == 1):\n              temp.append(\"c\"+(C-1)*\".\")\n              temp.extend((lines-2)*[C*\".\"])\n              temp.append((C-1)*\".\"+\"*\")\n              temp.append(\"..\"+ (C-2)*\"*\")\n              temp.extend((R-lines-1)*[C*\"*\"])\n              print(\"\n\".join(temp))\n              continue\n          elif (lines == 2) and (extra == 1):\n              temp.append(\"c\"+(C-2)*\".\"+\"*\")\n              temp.append((C-1)*\".\"+\"*\")\n              temp.append(3*\".\"+(C-3)*\"*\")\n              temp.extend((R-3)*[C*\"*\"])\n              print(\"\n\".join(temp))\n              continue\n          elif lines < 2:\n              (l, rem) = divmod(dots, 2)\n              if rem == 1:\n                  l -= 1\n                  rem += 2\n              temp.append(\"c\"+(l-1)*\".\"+(C-l)*\"*\")\n              temp.append(l*\".\"+(C-l)*\"*\")\n              temp.append(rem*\".\"+(C-rem)*\"*\")\n              temp.extend( (R-3)*[ C*\"*\" ])\n              print(\"\n\".join(temp))\n              continue\n      else:\n          print(\"Impossible\")\n  \n ", "Adversarial Code": " \n  safe_cols = int(input())\n  \n  for n in range(1, safe_cols+1):\n      print(\"Case #%d:\" % n)\n      (R, C, M) = (int(x) for x in input().split())\n      dots = R*C - M\n      if M == 0:\n          print(\"\n\".join([\"c\"+(C-1)*\".\"] + (R-1)*[C*\".\"]))\n      elif dots == 0:\n          print(\"Impossible\")\n      elif R == 1:\n          assert C - M > 0\n          print(\"c\"+(C-M-1)*\".\"+M*\"*\")\n      elif C == 1:\n          assert R - M > 0\n          print(\"c\n\"+(R-M-1)*\".\n\"+M*\"*\n\", end='')\n      elif dots == 1:\n          print(\"\n\".join([\"c\"+ (C-1)*\"*\"] + (R-1)*[C*\"*\"]))\n      elif dots > 3:\n          if (dots == 5) or (dots == 7):\n              print(\"Impossible\")\n              continue\n          if (R == 2) or (C == 2):\n              if dots%2 != 0 :\n                  print(\"Impossible\")\n                  continue\n              elif R == 2:\n                  l = int(dots/2)\n                  print(\"c\"+(l-1)*\".\"+(C-l)*\"*\")\n                  print(l*\".\"+(C-l)*\"*\")\n                  continue\n              elif C == 2:\n                  l = int(dots/2)\n                  print(\"c.\")\n                  print((l-1)*\"..\n\", end='')\n                  print(int(M/2)*\"**\n\", end='')\n                  continue\n          (lines, extra) = divmod(dots, C)\n          splitext = []\n          if (lines >= 2) and (extra != 1):\n              splitext.append(\"c\"+(C-1)*\".\")\n              splitext.extend((lines-1)*[C*\".\"])\n              splitext.append(extra*\".\"+(C-extra)*\"*\")\n              splitext.extend((R-lines-1)*[C*\"*\"])\n              print(\"\n\".join(splitext))\n              continue\n          elif (lines > 2) and (extra == 1):\n              splitext.append(\"c\"+(C-1)*\".\")\n              splitext.extend((lines-2)*[C*\".\"])\n              splitext.append((C-1)*\".\"+\"*\")\n              splitext.append(\"..\"+ (C-2)*\"*\")\n              splitext.extend((R-lines-1)*[C*\"*\"])\n              print(\"\n\".join(splitext))\n              continue\n          elif (lines == 2) and (extra == 1):\n              splitext.append(\"c\"+(C-2)*\".\"+\"*\")\n              splitext.append((C-1)*\".\"+\"*\")\n              splitext.append(3*\".\"+(C-3)*\"*\")\n              splitext.extend((R-3)*[C*\"*\"])\n              print(\"\n\".join(splitext))\n              continue\n          elif lines < 2:\n              (l, rem) = divmod(dots, 2)\n              if rem == 1:\n                  l -= 1\n                  rem += 2\n              splitext.append(\"c\"+(l-1)*\".\"+(C-l)*\"*\")\n              splitext.append(l*\".\"+(C-l)*\"*\")\n              splitext.append(rem*\".\"+(C-rem)*\"*\")\n              splitext.extend( (R-3)*[ C*\"*\" ])\n              print(\"\n\".join(splitext))\n              continue\n      else:\n          print(\"Impossible\")\n  \n ", "Program Length": 742, "Identifier Num": 10, "Replaced Identifiers": "temp:splitext,T:safe_cols,", "Query Times": 169, "Time Cost": 0.07413768768310547, "Type": "wir"}
{"Index": 57, "Original Code": " \n  \n  def read_row(fin, n):\n      rows = [set(map(int, fin.readline().strip().split())) for i in xrange(4)]\n      return rows[n-1]\n  \n  def solve(rowa, rowb):\n      both = rowa & rowb\n      if len(both) == 1:\n          return list(both)[0]\n      elif len(both) > 1:\n          return \"Bad magician!\"\n      elif not both:\n          return \"Volunteer cheated!\"\n  \n  if __name__ == '__main__':\n      fin = open(sys.argv[1], 'rU') if sys.argv[1:] else sys.stdin\n      fout = open(sys.argv[2], 'w') if sys.argv[2:] else sys.stdout\n      with fin, fout:\n          T = int(fin.readline())\n          for case in xrange(1, T+1):\n              n = int(fin.readline())\n              rowa = read_row(fin, n)\n              n = int(fin.readline())\n              rowb = read_row(fin, n)\n              soln = solve(rowa, rowb)\n              print >> fout, \"Case #{0}: {1}\".format(case, soln)\n  \n ", "Adversarial Code": " \n  \n  def read_row(M1, ans2):\n      card = [set(map(int, M1.readline().strip().split())) for write_case in xrange(4)]\n      return card[ans2-1]\n  \n  def solve(elems, rowb):\n      solveEq = elems & rowb\n      if len(solveEq) == 1:\n          return list(solveEq)[0]\n      elif len(solveEq) > 1:\n          return \"Bad magician!\"\n      elif not solveEq:\n          return \"Volunteer cheated!\"\n  \n  if __name__ == '__main__':\n      M1 = open(sys.argv[1], 'rU') if sys.argv[1:] else sys.stdin\n      last_board = open(sys.argv[2], 'w') if sys.argv[2:] else sys.stdout\n      with M1, last_board:\n          T = int(M1.readline())\n          for inputFileName in xrange(1, T+1):\n              ans2 = int(M1.readline())\n              elems = read_row(M1, ans2)\n              ans2 = int(M1.readline())\n              rowb = read_row(M1, ans2)\n              soln = solve(elems, rowb)\n              print >> last_board, \"Case #{0}: {1}\".format(inputFileName, soln)\n  \n ", "Program Length": 230, "Identifier Num": 13, "Replaced Identifiers": "fin:M1,n:ans2,both:solveEq,rows:card,case:inputFileName,rowa:elems,i:write_case,fout:last_board,", "Query Times": 285, "Time Cost": 0.1150863250096639, "Type": "wir"}
{"Index": 58, "Original Code": " \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n   \n  \n  \n  \n  \n  def debug(*args):\n      print(*args, file=sys.stderr)\n  \n  fin = sys.stdin\n  T = int(fin.readline())\n  for case in range(1, T + 1):\n      RR, CC, M = map(int, fin.readline().split())\n      R, C = None, None\n      blocks = RR*CC - M\n      inverse = False\n      if RR > CC:\n          inverse = True\n          R, C = CC, RR\n      else:\n          R, C = RR, CC\n      result = None\n      if R == 1:\n          result = [('.' * blocks) + ('*' * M)]\n      elif R == 2:\n          if blocks == 1:\n              result = ['.' + ('*' * (C-1)), '*' * C]\n          elif blocks % 2 == 0 and blocks != 2:\n              cc = blocks // 2\n              result = [('.' * cc) + ('*' * (C - cc)), ('.' * cc) + ('*' * (C - cc))] \n          else:\n              result = None\n      else:\n          if blocks == 1:\n              result = ['*' * C] * R\n          elif blocks == 4:\n              result = ['..' + (C-2)*'*']*2\n              result += ['*'*C] * (R-2)\n          elif blocks == 6:\n              result = ['...' + (C-3)*'*']*2\n              result += ['*'*C] * (R-2)\n          for rows in range(3, R+1):\n              for columns in range(rows, C+1):\n                  size = rows * columns\n                  if size - blocks >= 0:\n                      if size - blocks <= columns - 2: \n                          result = []\n                          for r in range(rows):\n                              if r < rows - 1:\n                                  result.append(('.' * columns) + ('*' * (C - columns)))\n                              else:\n                                  cc = columns - (size - blocks)\n                                  result.append(('.' * cc) + ('*' * (C - cc)))\n                          for r in range(R - rows):\n                              result.append('*' * C)\n                      elif size - blocks == columns - 1 and rows >= 4:\n                          result = []\n                          for r in range(rows):\n                              if r < rows - 2:\n                                  result.append(('.' * columns) + ('*' * (C - columns)))\n                              elif r == rows - 2:\n                                  cc = columns - 1\n                                  result.append(('.' * cc) + ('*' * (C - cc)))\n                              else:\n                                  cc = 2\n                                  result.append(('.' * cc) + ('*' * (C - cc)))\n                          for r in range(R - rows):\n                              result.append('*' * C)\n                      \n  \n  \n  \n      print(\"Case #%d: \" % (case))\n      if result is None:\n          debug('impossible', blocks, RR, CC)\n          print(\"Impossible\")\n      else:\n          mines = 0\n          for r in range(RR):\n              row = ''\n              for c in range(CC):\n                  rr, cc = r, c\n                  if inverse:\n                      rr, cc = c, r\n                  if rr == 0 and cc == 0:\n                      row += 'c'\n                  else:\n                      row += result[rr][cc]\n                      if result[rr][cc] == '*':\n                          mines += 1\n              print(row)\n          if mines != M:\n              raise Exception(\"%d != %d %d x %d\" % (mines, M, RR, CC))\n              \n  \n  \n ", "Adversarial Code": " \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n   \n  \n  \n  \n  \n  def debug(*args):\n      print(*args, file=sys.stderr)\n  \n  fn = sys.stdin\n  T = int(fn.readline())\n  for case in range(1, T + 1):\n      RR, CC, M = map(int, fn.readline().split())\n      R, C = None, None\n      blocks = RR*CC - M\n      inverse = False\n      if RR > CC:\n          inverse = True\n          R, C = CC, RR\n      else:\n          R, C = RR, CC\n      result = None\n      if R == 1:\n          result = [('.' * blocks) + ('*' * M)]\n      elif R == 2:\n          if blocks == 1:\n              result = ['.' + ('*' * (C-1)), '*' * C]\n          elif blocks % 2 == 0 and blocks != 2:\n              cc = blocks // 2\n              result = [('.' * cc) + ('*' * (C - cc)), ('.' * cc) + ('*' * (C - cc))] \n          else:\n              result = None\n      else:\n          if blocks == 1:\n              result = ['*' * C] * R\n          elif blocks == 4:\n              result = ['..' + (C-2)*'*']*2\n              result += ['*'*C] * (R-2)\n          elif blocks == 6:\n              result = ['...' + (C-3)*'*']*2\n              result += ['*'*C] * (R-2)\n          for rows in range(3, R+1):\n              for columns in range(rows, C+1):\n                  size = rows * columns\n                  if size - blocks >= 0:\n                      if size - blocks <= columns - 2: \n                          result = []\n                          for r in range(rows):\n                              if r < rows - 1:\n                                  result.append(('.' * columns) + ('*' * (C - columns)))\n                              else:\n                                  cc = columns - (size - blocks)\n                                  result.append(('.' * cc) + ('*' * (C - cc)))\n                          for r in range(R - rows):\n                              result.append('*' * C)\n                      elif size - blocks == columns - 1 and rows >= 4:\n                          result = []\n                          for r in range(rows):\n                              if r < rows - 2:\n                                  result.append(('.' * columns) + ('*' * (C - columns)))\n                              elif r == rows - 2:\n                                  cc = columns - 1\n                                  result.append(('.' * cc) + ('*' * (C - cc)))\n                              else:\n                                  cc = 2\n                                  result.append(('.' * cc) + ('*' * (C - cc)))\n                          for r in range(R - rows):\n                              result.append('*' * C)\n                      \n  \n  \n  \n      print(\"Case #%d: \" % (case))\n      if result is None:\n          debug('impossible', blocks, RR, CC)\n          print(\"Impossible\")\n      else:\n          mines = 0\n          for r in range(RR):\n              row = ''\n              for c in range(CC):\n                  rr, cc = r, c\n                  if inverse:\n                      rr, cc = c, r\n                  if rr == 0 and cc == 0:\n                      row += 'c'\n                  else:\n                      row += result[rr][cc]\n                      if result[rr][cc] == '*':\n                          mines += 1\n              print(row)\n          if mines != M:\n              raise Exception(\"%d != %d %d x %d\" % (mines, M, RR, CC))\n              \n  \n  \n ", "Program Length": 685, "Identifier Num": 17, "Replaced Identifiers": "fin:fn,", "Query Times": 186, "Time Cost": 0.08217812379201253, "Type": "wir"}
{"Index": 59, "Original Code": " \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  def debug(*args):\n      print(*args, file=sys.stderr)\n  \n  fin = sys.stdin\n  T = int(fin.readline())\n  for case in range(1, T + 1):\n      answer1 = int(fin.readline())\n      rows1 = []\n      for i in range(4):\n          rows1.append(set(map(int, fin.readline().split())))\n      answer2 = int(fin.readline())\n      rows2 = []\n      for i in range(4):\n          rows2.append(set(map(int, fin.readline().split())))\n  \n      possibilities1 = rows1[answer1-1]\n      possibilities2 = rows2[answer2-1]\n  \n      numbers = possibilities1.intersection(possibilities2)\n      result = None\n      if len(numbers) == 1:\n          result = list(numbers)[0]\n      elif len(numbers) == 0:\n          result = 'Volunteer cheated!'\n      else:\n          result = 'Bad magician!'\n  \n  \n      print(\"Case #%d: %s\" % (case, result))\n  \n ", "Adversarial Code": " \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  def debug(*args):\n      print(*args, file=sys.stderr)\n  \n  CURSEUR = sys.stdin\n  T = int(CURSEUR.readline())\n  for case in range(1, T + 1):\n      answer1 = int(CURSEUR.readline())\n      rows1 = []\n      for i in range(4):\n          rows1.append(set(map(int, CURSEUR.readline().split())))\n      answer2 = int(CURSEUR.readline())\n      rows2 = []\n      for i in range(4):\n          rows2.append(set(map(int, CURSEUR.readline().split())))\n  \n      possibilities1 = rows1[answer1-1]\n      possibilities2 = rows2[answer2-1]\n  \n      numbers = possibilities1.intersection(possibilities2)\n      result = None\n      if len(numbers) == 1:\n          result = list(numbers)[0]\n      elif len(numbers) == 0:\n          result = 'Volunteer cheated!'\n      else:\n          result = 'Bad magician!'\n  \n  \n      print(\"Case #%d: %s\" % (case, result))\n  \n ", "Program Length": 203, "Identifier Num": 13, "Replaced Identifiers": "fin:CURSEUR,", "Query Times": 68, "Time Cost": 0.028337053457895913, "Type": "wir"}
{"Index": 61, "Original Code": " \n  def read_row():\n  \ta = int(sys.stdin.readline().strip())\n  \tfor j in range(a - 1):\n  \t\tsys.stdin.readline()\n  \tread_set = set(sys.stdin.readline().strip().split(\" \"))\n  \tfor j in range(5 - a - 1):\n  \t\tsys.stdin.readline()\n  \t\t\n  \treturn read_set\n  \n  \n  t = int(sys.stdin.readline().strip())\n  \n  for i in range(t):\n  \tprint \"Case #\" + str(i + 1) + \":\",\n  \n  \tset1 = read_row()\n  \tset2 = read_row()\n  \t\n  \tintersect = set1.intersection(set2)\n  \t\n  \tif 1 == len(intersect):\n  \t\tprint intersect.pop()\n  \telif 0 == len(intersect):\n  \t\tprint \"Volunteer cheated!\"\n  \telse:\n  \t\tprint \"Bad magician!\"\n ", "Adversarial Code": " \n  def read_row():\n  \ta = int(sys.stdin.readline().strip())\n  \tfor j in range(a - 1):\n  \t\tsys.stdin.readline()\n  \tread_set = set(sys.stdin.readline().strip().split(\" \"))\n  \tfor j in range(5 - a - 1):\n  \t\tsys.stdin.readline()\n  \t\t\n  \treturn read_set\n  \n  \n  myCases = int(sys.stdin.readline().strip())\n  \n  for i in range(myCases):\n  \tprint \"Case #\" + str(i + 1) + \":\",\n  \n  \tset1 = read_row()\n  \tset2 = read_row()\n  \t\n  \tintersect = set1.intersection(set2)\n  \t\n  \tif 1 == len(intersect):\n  \t\tprint intersect.pop()\n  \telif 0 == len(intersect):\n  \t\tprint \"Volunteer cheated!\"\n  \telse:\n  \t\tprint \"Bad magician!\"\n ", "Program Length": 162, "Identifier Num": 9, "Replaced Identifiers": "t:myCases,", "Query Times": 53, "Time Cost": 0.021165804068247477, "Type": "wir"}
{"Index": 62, "Original Code": "directory = 'C:/users/me/desktop/google code jam/2014/qualification/C/'\n  \n  \n  \n  def solve_one_case (R,C,M):\n          l = []\n          for i in range(R):\n              for j in range(C):\n                  l.append((i,j))\n  \n          empty_mat = []\n          for i in range(R):\n              empty_mat.append(['.']*C)\n  \n          found = False\n  \n          assert (0,0) in l\n          l = l[1:]\n          l = l[::-1]\n          assert (0,0) not in l\n          \n          output = ''\n          \n          for mine_placement in itertools.combinations(l,M):\n              mat = deepcopy(empty_mat)\n              for cell in mine_placement:\n                  mat[cell[0]][cell[1]] = '*'\n              if isOneClick(mat, R, C, M):\n                  mat[0][0] = 'c'\n                  for line in mat:\n                      output += ''.join(line) + '\n'\n                  found = True\n                  return output\n              \n          if not found:\n              return 'Impossible\n'\n          \n          assert ValueError()\n          \n  def solve (f_in, f_out):\n      T = int(f_in.readline())\n      for testcase in range(1,T+1):\n          line = f_in.readline()\n          R,C,M = [int(q) for q in line.split()]\n          print (testcase,R,C,M)\n  \n          output = solve_one_case (R,C,M)\n          f_out.write('Case #' + str(testcase) + ':\n')\n          f_out.write(output)\n  \n          \n  \n  \n  def isOneClick (mat, R, C, M):\n  \n      mat_cpy = deepcopy(mat)\n      oneclickcells = [(0,0)]\n      while oneclickcells:\n          node = oneclickcells.pop()\n          mat_cpy[node[0]][node[1]] = 'v'\n          if noNearbyMines(mat_cpy,node):\n              oneclickcells.extend(getNearbyUnvisited(mat_cpy, node))\n  \n      return sum([l.count('.') for l in mat_cpy]) == 0\n      \n  \n  def getNearbyUnvisited(mat, node):\n      R = len(mat)\n      C = len(mat[0])\n      deltas_r = [0]\n      deltas_c = [0]\n      if node[0] > 0:\n          deltas_r.append(-1)\n      if node[1] > 0:\n          deltas_c.append(-1)\n      if node[0] < R-1:\n          deltas_r.append(1)\n      if node[1] < C-1:\n          deltas_c.append(1)\n  \n      ret_list = []\n      for delta_r in deltas_r:\n          for delta_c in deltas_c:\n              next_node = (node[0]+delta_r, node[1] + delta_c)\n              if mat[next_node[0]][next_node[1]] not in ['*','v']:\n                  ret_list.append((next_node[0],next_node[1]))\n  \n      return ret_list\n  \n  def noNearbyMines(mat,node):\n      R = len(mat)\n      C = len(mat[0])\n      deltas_r = [0]\n      deltas_c = [0]\n      if node[0] > 0:\n          deltas_r.append(-1)\n      if node[1] > 0:\n          deltas_c.append(-1)\n      if node[0] < R-1:\n          deltas_r.append(1)\n      if node[1] < C-1:\n          deltas_c.append(1)\n  \n      for delta_r in deltas_r:\n          for delta_c in deltas_c:\n              if mat[node[0] + delta_r][node[1] + delta_c] == '*':\n                  return False\n      return True\n      \n  def main_run():\n      filenames = [x for x in os.listdir (directory)]\n      filenames = [x for x in filenames if x.endswith('.in')]\n      l1 = [(os.stat(directory+x).st_mtime, x) for x in filenames]\n      chosen_filename =  sorted(l1)[-1][1][:-3]\n  \n      print ('Directory : ', directory)\n      print ('Chosen Filename : ',chosen_filename)\n      print()\n      print ('Start : ', time.ctime())\n      print()\n      \n      f_in = open(directory+chosen_filename+'.in')\n      f_out = open(directory+chosen_filename+'.out', 'w')\n      solve(f_in,f_out)\n      f_in.close()\n      f_out.close()\n  \n      print ()\n      print ('End : ', time.ctime())\n  \n  \n  main_run()\n  \n ", "Adversarial Code": "test_1 = 'C:/users/me/desktop/google code jam/2014/qualification/C/'\n  \n  \n  \n  def solve_one_case (R,C,M):\n          l = []\n          for i in range(R):\n              for j in range(C):\n                  l.append((i,j))\n  \n          empty_mat = []\n          for i in range(R):\n              empty_mat.append(['.']*C)\n  \n          found = False\n  \n          assert (0,0) in l\n          l = l[1:]\n          l = l[::-1]\n          assert (0,0) not in l\n          \n          output = ''\n          \n          for mine_placement in itertools.combinations(l,M):\n              mat = deepcopy(empty_mat)\n              for cell in mine_placement:\n                  mat[cell[0]][cell[1]] = '*'\n              if isOneClick(mat, R, C, M):\n                  mat[0][0] = 'c'\n                  for line in mat:\n                      output += ''.join(line) + '\n'\n                  found = True\n                  return output\n              \n          if not found:\n              return 'Impossible\n'\n          \n          assert ValueError()\n          \n  def solve (f_in, readSq):\n      T = int(f_in.readline())\n      for testcase in range(1,T+1):\n          line = f_in.readline()\n          R,C,M = [int(q) for q in line.split()]\n          print (testcase,R,C,M)\n  \n          output = solve_one_case (R,C,M)\n          readSq.write('Case #' + str(testcase) + ':\n')\n          readSq.write(output)\n  \n          \n  \n  \n  def isOneClick (mat, R, C, M):\n  \n      mat_cpy = deepcopy(mat)\n      oneclickcells = [(0,0)]\n      while oneclickcells:\n          node = oneclickcells.pop()\n          mat_cpy[node[0]][node[1]] = 'v'\n          if noNearbyMines(mat_cpy,node):\n              oneclickcells.extend(getNearbyUnvisited(mat_cpy, node))\n  \n      return sum([l.count('.') for l in mat_cpy]) == 0\n      \n  \n  def getNearbyUnvisited(mat, node):\n      R = len(mat)\n      C = len(mat[0])\n      deltas_r = [0]\n      deltas_c = [0]\n      if node[0] > 0:\n          deltas_r.append(-1)\n      if node[1] > 0:\n          deltas_c.append(-1)\n      if node[0] < R-1:\n          deltas_r.append(1)\n      if node[1] < C-1:\n          deltas_c.append(1)\n  \n      ret_list = []\n      for delta_r in deltas_r:\n          for delta_c in deltas_c:\n              next_node = (node[0]+delta_r, node[1] + delta_c)\n              if mat[next_node[0]][next_node[1]] not in ['*','v']:\n                  ret_list.append((next_node[0],next_node[1]))\n  \n      return ret_list\n  \n  def noNearbyMines(mat,node):\n      R = len(mat)\n      C = len(mat[0])\n      deltas_r = [0]\n      deltas_c = [0]\n      if node[0] > 0:\n          deltas_r.append(-1)\n      if node[1] > 0:\n          deltas_c.append(-1)\n      if node[0] < R-1:\n          deltas_r.append(1)\n      if node[1] < C-1:\n          deltas_c.append(1)\n  \n      for delta_r in deltas_r:\n          for delta_c in deltas_c:\n              if mat[node[0] + delta_r][node[1] + delta_c] == '*':\n                  return False\n      return True\n      \n  def main_run():\n      filenames = [x for x in os.listdir (test_1)]\n      filenames = [x for x in filenames if x.endswith('.in')]\n      l1 = [(os.stat(test_1+x).st_mtime, x) for x in filenames]\n      chosen_filename =  sorted(l1)[-1][1][:-3]\n  \n      print ('Directory : ', test_1)\n      print ('Chosen Filename : ',chosen_filename)\n      print()\n      print ('Start : ', time.ctime())\n      print()\n      \n      f_in = open(test_1+chosen_filename+'.in')\n      readSq = open(test_1+chosen_filename+'.out', 'w')\n      solve(f_in,readSq)\n      f_in.close()\n      readSq.close()\n  \n      print ()\n      print ('End : ', time.ctime())\n  \n  \n  main_run()\n  \n ", "Program Length": 835, "Identifier Num": 24, "Replaced Identifiers": "directory:test_1,f_out:readSq,", "Query Times": 230, "Time Cost": 0.10693428119023642, "Type": "wir"}
{"Index": 63, "Original Code": "directory = 'C:/users/me/desktop/google code jam/2014/qualification/A/'\n  \n  \n  \n  def solve (f_in, f_out):\n      T = int(f_in.readline())\n      for testcase in range(1,T+1):\n          \n          c1 = int(f_in.readline())\n          l1 = []\n          for i in range(4):\n              l1.append(f_in.readline())\n          \n          c2 = int(f_in.readline())\n          l2 = []\n          for i in range(4):\n              l2.append(f_in.readline())\n  \n          d1 = l1[c1-1].split()\n          d2 = l2[c2-1].split()\n  \n          foundFlag = False\n          chosenCard = None\n          badMagician = False\n          for card in d1:\n              if card in d2:\n                  if not foundFlag:\n                      foundFlag = True\n                      chosenCard = card\n                  else:\n                      badMagician = True\n  \n          f_out.write('Case #' + str(testcase) + ': ')\n          if badMagician:\n              f_out.write('Bad magician!\n')\n          elif not foundFlag:\n              f_out.write('Volunteer cheated!\n')\n          else:\n              f_out.write(chosenCard + '\n')\n  \n  \n  \n  \n  def main_run():\n      filenames = [x for x in os.listdir (directory)]\n      filenames = [x for x in filenames if x.endswith('.in')]\n      l1 = [(os.stat(directory+x).st_mtime, x) for x in filenames]\n      chosen_filename =  sorted(l1)[-1][1][:-3]\n  \n      print ('Directory : ', directory)\n      print ('Chosen Filename : ',chosen_filename)\n      print()\n      print ('Start : ', time.ctime())\n      print()\n      \n      f_in = open(directory+chosen_filename+'.in')\n      f_out = open(directory+chosen_filename+'.out', 'w')\n      solve(f_in,f_out)\n      f_in.close()\n      f_out.close()\n  \n      print ()\n      print ('End : ', time.ctime())\n  \n  \n  main_run()\n ", "Adversarial Code": "directory = 'C:/users/me/desktop/google code jam/2014/qualification/A/'\n  \n  \n  \n  def solve (f_in, f_out):\n      T = int(f_in.readline())\n      for testcase in range(1,T+1):\n          \n          iterate_cases_1lpc = int(f_in.readline())\n          l1 = []\n          for tCase in range(4):\n              l1.append(f_in.readline())\n          \n          case_line_cnt = int(f_in.readline())\n          __doc__ = []\n          for tCase in range(4):\n              __doc__.append(f_in.readline())\n  \n          run_tests = l1[iterate_cases_1lpc-1].split()\n          test_case_n = __doc__[case_line_cnt-1].split()\n  \n          NUM_PROCESSES = False\n          chosenCard = None\n          str_out = False\n          for raw_input in run_tests:\n              if raw_input in test_case_n:\n                  if not NUM_PROCESSES:\n                      NUM_PROCESSES = True\n                      chosenCard = raw_input\n                  else:\n                      str_out = True\n  \n          f_out.write('Case #' + str(testcase) + ': ')\n          if str_out:\n              f_out.write('Bad magician!\n')\n          elif not NUM_PROCESSES:\n              f_out.write('Volunteer cheated!\n')\n          else:\n              f_out.write(chosenCard + '\n')\n  \n  \n  \n  \n  def main_run():\n      L = [x for x in os.listdir (directory)]\n      L = [x for x in L if x.endswith('.in')]\n      l1 = [(os.stat(directory+x).st_mtime, x) for x in L]\n      do_trial =  sorted(l1)[-1][1][:-3]\n  \n      print ('Directory : ', directory)\n      print ('Chosen Filename : ',do_trial)\n      print()\n      print ('Start : ', time.ctime())\n      print()\n      \n      f_in = open(directory+do_trial+'.in')\n      f_out = open(directory+do_trial+'.out', 'w')\n      solve(f_in,f_out)\n      f_in.close()\n      f_out.close()\n  \n      print ()\n      print ('End : ', time.ctime())\n  \n  \n  main_run()\n ", "Program Length": 363, "Identifier Num": 21, "Replaced Identifiers": "d1:run_tests,d2:test_case_n,l2:__doc__,foundFlag:NUM_PROCESSES,c2:case_line_cnt,badMagician:str_out,i:tCase,c1:iterate_cases_1lpc,card:raw_input,chosen_filename:do_trial,filenames:L,", "Query Times": 407, "Time Cost": 0.17936639388402303, "Type": "wir"}
{"Index": 65, "Original Code": " \n  \n  \n  def read_grid(f):\n  \treturn [\n  \t\t[int(x) for x in line.split()]\n  \t\tfor line in [f.readline() for _ in range(4)]\n  \t]\n  \n  def read_case(f):\n  \tanswer1 = int(f.readline())\n  \tgrid1 = read_grid(f)\n  \tanswer2 = int(f.readline())\n  \tgrid2 = read_grid(f)\n  \treturn (grid1[answer1 - 1], grid2[answer2 - 1])\n  \n  \n  def solve(r1, r2):\n  \tres = set(r1) & set(r2)\n  \tif len(res) == 0:\n  \t\treturn 'Volunteer cheated!'\n  \tif len(res) == 1:\n  \t\treturn list(res)[0]\n  \treturn 'Bad magician!'\n  \n  \n  \n  def main():\n  \tfn = sys.argv[1]\n  \twith open(fn, encoding='utf-8') as f:\n  \t\tncases = int(f.readline())\n  \t\tfor case in range(1, ncases + 1):\n  \t\t\trow1, row2 = read_case(f)\n  \t\t\tsolution = solve(row1, row2)\n  \t\t\tprint('Case #{}: {}'.format(case, solution))\n  \n  \n  if __name__ == '__main__':\n  \tmain()\n ", "Adversarial Code": " \n  \n  \n  def read_grid(rm):\n  \treturn [\n  \t\t[int(x) for x in line.split()]\n  \t\tfor line in [rm.readline() for _ in range(4)]\n  \t]\n  \n  def read_case(rm):\n  \tanswer1 = int(rm.readline())\n  \tgrid1 = read_grid(rm)\n  \tanswer2 = int(rm.readline())\n  \tgrid2 = read_grid(rm)\n  \treturn (grid1[answer1 - 1], grid2[answer2 - 1])\n  \n  \n  def solve(r1, r2):\n  \tres = set(r1) & set(r2)\n  \tif len(res) == 0:\n  \t\treturn 'Volunteer cheated!'\n  \tif len(res) == 1:\n  \t\treturn list(res)[0]\n  \treturn 'Bad magician!'\n  \n  \n  \n  def main():\n  \tfn = sys.argv[1]\n  \twith open(fn, encoding='utf-8') as rm:\n  \t\tncases = int(rm.readline())\n  \t\tfor case in range(1, ncases + 1):\n  \t\t\trow1, row2 = read_case(rm)\n  \t\t\tsolution = solve(row1, row2)\n  \t\t\tprint('Case #{}: {}'.format(case, solution))\n  \n  \n  if __name__ == '__main__':\n  \tmain()\n ", "Program Length": 223, "Identifier Num": 21, "Replaced Identifiers": "f:rm,", "Query Times": 77, "Time Cost": 0.031052509943644207, "Type": "wir"}
{"Index": 66, "Original Code": " \n  lines = [line.strip() for line in open(sys.argv[1])]\n  count = int(lines[0])\n  \n  for i in xrange(count):\n      R,C,M = map(int, lines[i+1].split())\n      print \"Case #%s:\" % (i+1)\n  \n      w = max(R,C)\n      h = min(R,C)\n      X = R*C - M\n      assert X > 0\n  \n      if X == 1:\n          rows = ['c' + ('*' * (w-1))] + (h-1) * ['*' * w]\n      elif h == 1:\n          rows = ['c' + '.' * (X-1) + '*' * M]\n      elif X == 4:\n              rows = [\n                  'c.' + '*' * (w-2),\n                  '..' + '*' * (w-2),\n              ] + ['*' * w] * (h-2)\n      elif h == 2:\n          if X%2 == 1 or X == 2:\n              rows = None\n          else:\n              rows = [\n                  'c' + '.' * (X/2-1) + '*' * (M/2),\n                  '.' + '.' * (X/2-1) + '*' * (M/2)\n              ]\n      elif X <= 5 or X == 7:\n          rows = None\n  \n      elif X%2 == 0 and X <= w*2:\n          r = X/2\n          rows = [\n              'c' + '.' * (r - 1) + '*' * (w-r),\n                    '.' * r       + '*' * (w-r),\n          ] + ['*' * w] * (h-2)\n  \n      elif X <= w*3 and (X % 3) != 1:\n          n = (X+1) / 3\n          t = X - 2*n\n          rows = [\n              'c' + '.' * (n-1) + '*' * (w-n),\n                    '.' * n     + '*' * (w-n),\n                    '.' * t     + '*' * (w-t)\n          ] + ['*' * w] * (h-3)\n      else:\n          n = X / w\n          t = X % w\n          if t == 1:\n              rows = (\n                      ['c' + (w-1) * '.']\n                  +   ['.' * w] * (n-2)\n                  +   ['.' * (w-1) + '*']\n                  +   ['..' + '*' * (w-2)]\n                  +   ['*' * w] * (h - n - 1)\n              )\n          else:\n              k = 1 if t == 0 else 0\n              rows = (\n                      ['c' + (w-1) * '.']\n                  +   ['.' * w] * (n-1)\n                  +   ['.' * t + '*' * (w-t)] * (1 - k)\n                  +   ['*' * w] * (h - n - 1 + k)\n              )\n  \n      if rows:\n          if R > C:\n              rows = [\"\".join(row[i] for row in rows) for i in xrange(R)]\n  \n          for row in rows:\n              print row\n  \n          assert len(rows) == R\n          assert len(rows[0]) == C\n          assert sum(1 for row in rows for col in row if col == '*') == M\n  \n      else:\n          print \"Impossible\"\n  \n ", "Adversarial Code": " \n  lines = [line.strip() for line in open(sys.argv[1])]\n  count = int(lines[0])\n  \n  for i in xrange(count):\n      R,C,M = map(int, lines[i+1].split())\n      print \"Case #%s:\" % (i+1)\n  \n      cardsY = max(R,C)\n      h = min(R,C)\n      X = R*C - M\n      assert X > 0\n  \n      if X == 1:\n          rows = ['c' + ('*' * (cardsY-1))] + (h-1) * ['*' * cardsY]\n      elif h == 1:\n          rows = ['c' + '.' * (X-1) + '*' * M]\n      elif X == 4:\n              rows = [\n                  'c.' + '*' * (cardsY-2),\n                  '..' + '*' * (cardsY-2),\n              ] + ['*' * cardsY] * (h-2)\n      elif h == 2:\n          if X%2 == 1 or X == 2:\n              rows = None\n          else:\n              rows = [\n                  'c' + '.' * (X/2-1) + '*' * (M/2),\n                  '.' + '.' * (X/2-1) + '*' * (M/2)\n              ]\n      elif X <= 5 or X == 7:\n          rows = None\n  \n      elif X%2 == 0 and X <= cardsY*2:\n          r = X/2\n          rows = [\n              'c' + '.' * (r - 1) + '*' * (cardsY-r),\n                    '.' * r       + '*' * (cardsY-r),\n          ] + ['*' * cardsY] * (h-2)\n  \n      elif X <= cardsY*3 and (X % 3) != 1:\n          n = (X+1) / 3\n          t = X - 2*n\n          rows = [\n              'c' + '.' * (n-1) + '*' * (cardsY-n),\n                    '.' * n     + '*' * (cardsY-n),\n                    '.' * t     + '*' * (cardsY-t)\n          ] + ['*' * cardsY] * (h-3)\n      else:\n          n = X / cardsY\n          t = X % cardsY\n          if t == 1:\n              rows = (\n                      ['c' + (cardsY-1) * '.']\n                  +   ['.' * cardsY] * (n-2)\n                  +   ['.' * (cardsY-1) + '*']\n                  +   ['..' + '*' * (cardsY-2)]\n                  +   ['*' * cardsY] * (h - n - 1)\n              )\n          else:\n              k = 1 if t == 0 else 0\n              rows = (\n                      ['c' + (cardsY-1) * '.']\n                  +   ['.' * cardsY] * (n-1)\n                  +   ['.' * t + '*' * (cardsY-t)] * (1 - k)\n                  +   ['*' * cardsY] * (h - n - 1 + k)\n              )\n  \n      if rows:\n          if R > C:\n              rows = [\"\".join(row[i] for row in rows) for i in xrange(R)]\n  \n          for row in rows:\n              print row\n  \n          assert len(rows) == R\n          assert len(rows[0]) == C\n          assert sum(1 for row in rows for col in row if col == '*') == M\n  \n      else:\n          print \"Impossible\"\n  \n ", "Program Length": 652, "Identifier Num": 14, "Replaced Identifiers": "w:cardsY,", "Query Times": 163, "Time Cost": 0.06958202918370565, "Type": "wir"}
{"Index": 67, "Original Code": " \n  \n  lines = [map(int, line.strip().split(\" \")) for line in open(sys.argv[1]).readlines()]\n  [count] = lines[0]\n  assert count * 10 + 1 == len(lines)\n  \n  for i in xrange(count):\n      base = i*10\n      [n1] = lines[base+1]\n      [n2] = lines[base+6]\n      row1 = set(lines[base+1+n1])\n      row2 = set(lines[base+6+n2])\n      common = row1.intersection(row2)\n      print \"Case #%s:\" % (i+1),\n      if len(common) == 1:\n          print list(common)[0]\n      elif not common:\n          print \"Volunteer cheated!\"\n      else:\n          print \"Bad magician!\"\n ", "Adversarial Code": " \n  \n  __str__ = [map(int, line.strip().split(\" \")) for line in open(sys.argv[1]).readlines()]\n  [Fill] = __str__[0]\n  assert Fill * 10 + 1 == len(__str__)\n  \n  for i in xrange(Fill):\n      base = i*10\n      [n1] = __str__[base+1]\n      [n2] = __str__[base+6]\n      row1 = set(__str__[base+1+n1])\n      row2 = set(__str__[base+6+n2])\n      common = row1.intersection(row2)\n      print \"Case #%s:\" % (i+1),\n      if len(common) == 1:\n          print list(common)[0]\n      elif not common:\n          print \"Volunteer cheated!\"\n      else:\n          print \"Bad magician!\"\n ", "Program Length": 156, "Identifier Num": 10, "Replaced Identifiers": "count:Fill,lines:__str__,", "Query Times": 95, "Time Cost": 0.038331127166748045, "Type": "wir"}
{"Index": 69, "Original Code": null, "Adversarial Code": null, "Program Length": 359, "Identifier Num": 28, "Replaced Identifiers": null, "Query Times": 764, "Time Cost": 0.32765655517578124, "Type": "0"}
{"Index": 70, "Original Code": " \n  lines = iter('''\n  13\n  5 5 23\n  3 1 1\n  1 3 1\n  2 2 1\n  4 7 3\n  10 10 82\n  10 1 4\n  1 10 5\n  2 10 8\n  10 2 8\n  2 10 9\n  10 2 7\n  5 3 3\n  '''.splitlines(False)[1:])\n  out = sys.stdout\n  \n  sys.setrecursionlimit(1500)\n  \n  \n  class MyException(Exception):\n  \tpass\n  lines = iter(open(r'C-small-attempt7.in').readlines(False))\n  out = open('c-small.answer', 'w')\n  \n  def solve(C, R, M):\n  \tboard = [['.']*C for _ in range(R)]\n  \tboard[-1][-1] = 'c'\n  \ttry:\n  \t\tfor r in range(R-2):\n  \t\t\tfor c in range(C-2):\n  \t\t\t\tif r == R-3 and c == C-3:\n  \t\t\t\t\traise StopIteration()\n  \t\t\t\tboard[r][c] = '*'\n  \t\t\t\tM -= 1\n  \t\t\t\tif M == 0:\n  \t\t\t\t\treturn board \n  \texcept StopIteration:\n  \t\tpass\n  \t\t\n  \tif M % 2 == 0:\n  \t\tfor r in range(R-3):\n  \t\t\tboard[r][C-1] = '*'\n  \t\t\tboard[r][C-2] = '*'\n  \t\t\tM -= 2\n  \t\t\tif M == 0:\n  \t\t\t\treturn board\n  \t\tfor c in range(C-3):\n  \t\t\tboard[R-1][c] = '*'\n  \t\t\tboard[R-2][c] = '*'\n  \t\t\tM -= 2\n  \t\t\tif M == 0:\n  \t\t\t\treturn board\n  \t\t\n  \t\t\n  \t\traise MyException()\n  \telse:\n  \t\tboard[R-3][C-3] = '*'\n  \t\tM -= 1\n  \t\tif M == 0:\n  \t\t\treturn board\n  \t\tfor r in range(R-2):\n  \t\t\tboard[r][C-1] = '*'\n  \t\t\tboard[r][C-2] = '*'\n  \t\t\tM -= 2\n  \t\t\tif M == 0:\n  \t\t\t\treturn board\n  \t\tfor c in range(C-2):\n  \t\t\tboard[R-1][c] = '*'\n  \t\t\tboard[R-2][c] = '*'\n  \t\t\tM -= 2\n  \t\t\tif M == 0:\n  \t\t\t\treturn board\n  \t\t\n  \t\traise MyException()\n  \t\t\n  \t\n  caseCnt = int(next(lines))\n  \n  for case in range(1, caseCnt+1):\n  \tR,C,M = map(int, next(lines).split())\n  \t\n  \tprint('Case #%d:'%case, file=out)\n  \tif M == 0:\n  \t\tprint('c' + '.'*(C-1), file=out)\n  \t\tfor _ in range(R-1):\n  \t\t\tprint('.'*C, file=out)\n  \telif R*C==M+1:\n  \t\tprint('c' + '*'*(C-1), file=out)\n  \t\tfor _ in range(R-1):\n  \t\t\tprint('*'*C, file=out)\n  \telif C == 1 and R == 1:\n  \t\tprint('Impossible', file=out)\n  \telif C == 1:\n  \t\tif M > R-1:\n  \t\t\tprint('Impossible', file=out)\n  \t\telse:\n  \t\t\tprint('c', file=out)\n  \t\t\tfor _ in range(R-M-1):\n  \t\t\t\tprint('.', file=out)\n  \t\t\tfor _ in range(M):\n  \t\t\t\tprint('*', file=out)\n  \telif R == 1:\n  \t\tif M > C-1:\n  \t\t\tprint('Impossible', file=out)\n  \t\telse:\n  \t\t\tprint('c' + '.'*(C-M-1) + '*'*M, file=out)\n  \telif C == 2:\n  \t\tif M %2 or M//2 > R-2:\n  \t\t\tprint('Impossible', file=out)\n  \t\telse:\n  \t\t\tprint('c.', file=out)\n  \t\t\tfor _ in range(R-M//2-1):\n  \t\t\t\tprint('..', file=out)\n  \t\t\tfor _ in range(M//2):\n  \t\t\t\tprint('**', file=out)\n  \telif R == 2:\n  \t\tif M %2 or M//2 > C-2:\n  \t\t\tprint('Impossible', file=out)\n  \t\telse:\n  \t\t\tprint('c' + '.'*(C-M//2-1) + '*'*(M//2), file=out)\n  \t\t\tprint(      '.'*(C-M//2)   + '*'*(M//2), file=out)\n  \telif M > R*C-4:\n  \t\tprint('Impossible', file=out)\n  \telse:\n  \t\ttry:\n  \t\t\tboard = solve(C, R, M)\n  \t\t\tfor line in board:\n  \t\t\t\tprint(''.join(line), file=out)\n  \t\texcept MyException:\n  \t\t\tprint('Impossible', file=out)\n  \t\n  \t\n ", "Adversarial Code": " \n  Data1 = iter('''\n  13\n  5 5 23\n  3 1 1\n  1 3 1\n  2 2 1\n  4 7 3\n  10 10 82\n  10 1 4\n  1 10 5\n  2 10 8\n  10 2 8\n  2 10 9\n  10 2 7\n  5 3 3\n  '''.splitlines(False)[1:])\n  out = sys.stdout\n  \n  sys.setrecursionlimit(1500)\n  \n  \n  class MyException(Exception):\n  \tpass\n  Data1 = iter(open(r'C-small-attempt7.in').readlines(False))\n  out = open('c-small.answer', 'w')\n  \n  def solve(C, __init__, M):\n  \tboard = [['.']*C for read_string_stack in range(__init__)]\n  \tboard[-1][-1] = 'c'\n  \ttry:\n  \t\tfor read in range(__init__-2):\n  \t\t\tfor MAP in range(C-2):\n  \t\t\t\tif read == __init__-3 and MAP == C-3:\n  \t\t\t\t\traise StopIteration()\n  \t\t\t\tboard[read][MAP] = '*'\n  \t\t\t\tM -= 1\n  \t\t\t\tif M == 0:\n  \t\t\t\t\treturn board \n  \texcept StopIteration:\n  \t\tpass\n  \t\t\n  \tif M % 2 == 0:\n  \t\tfor read in range(__init__-3):\n  \t\t\tboard[read][C-1] = '*'\n  \t\t\tboard[read][C-2] = '*'\n  \t\t\tM -= 2\n  \t\t\tif M == 0:\n  \t\t\t\treturn board\n  \t\tfor MAP in range(C-3):\n  \t\t\tboard[__init__-1][MAP] = '*'\n  \t\t\tboard[__init__-2][MAP] = '*'\n  \t\t\tM -= 2\n  \t\t\tif M == 0:\n  \t\t\t\treturn board\n  \t\t\n  \t\t\n  \t\traise MyException()\n  \telse:\n  \t\tboard[__init__-3][C-3] = '*'\n  \t\tM -= 1\n  \t\tif M == 0:\n  \t\t\treturn board\n  \t\tfor read in range(__init__-2):\n  \t\t\tboard[read][C-1] = '*'\n  \t\t\tboard[read][C-2] = '*'\n  \t\t\tM -= 2\n  \t\t\tif M == 0:\n  \t\t\t\treturn board\n  \t\tfor MAP in range(C-2):\n  \t\t\tboard[__init__-1][MAP] = '*'\n  \t\t\tboard[__init__-2][MAP] = '*'\n  \t\t\tM -= 2\n  \t\t\tif M == 0:\n  \t\t\t\treturn board\n  \t\t\n  \t\traise MyException()\n  \t\t\n  \t\n  caseCnt = int(next(Data1))\n  \n  for case in range(1, caseCnt+1):\n  \t__init__,C,M = map(int, next(Data1).split())\n  \t\n  \tprint('Case #%d:'%case, file=out)\n  \tif M == 0:\n  \t\tprint('c' + '.'*(C-1), file=out)\n  \t\tfor read_string_stack in range(__init__-1):\n  \t\t\tprint('.'*C, file=out)\n  \telif __init__*C==M+1:\n  \t\tprint('c' + '*'*(C-1), file=out)\n  \t\tfor read_string_stack in range(__init__-1):\n  \t\t\tprint('*'*C, file=out)\n  \telif C == 1 and __init__ == 1:\n  \t\tprint('Impossible', file=out)\n  \telif C == 1:\n  \t\tif M > __init__-1:\n  \t\t\tprint('Impossible', file=out)\n  \t\telse:\n  \t\t\tprint('c', file=out)\n  \t\t\tfor read_string_stack in range(__init__-M-1):\n  \t\t\t\tprint('.', file=out)\n  \t\t\tfor read_string_stack in range(M):\n  \t\t\t\tprint('*', file=out)\n  \telif __init__ == 1:\n  \t\tif M > C-1:\n  \t\t\tprint('Impossible', file=out)\n  \t\telse:\n  \t\t\tprint('c' + '.'*(C-M-1) + '*'*M, file=out)\n  \telif C == 2:\n  \t\tif M %2 or M//2 > __init__-2:\n  \t\t\tprint('Impossible', file=out)\n  \t\telse:\n  \t\t\tprint('c.', file=out)\n  \t\t\tfor read_string_stack in range(__init__-M//2-1):\n  \t\t\t\tprint('..', file=out)\n  \t\t\tfor read_string_stack in range(M//2):\n  \t\t\t\tprint('**', file=out)\n  \telif __init__ == 2:\n  \t\tif M %2 or M//2 > C-2:\n  \t\t\tprint('Impossible', file=out)\n  \t\telse:\n  \t\t\tprint('c' + '.'*(C-M//2-1) + '*'*(M//2), file=out)\n  \t\t\tprint(      '.'*(C-M//2)   + '*'*(M//2), file=out)\n  \telif M > __init__*C-4:\n  \t\tprint('Impossible', file=out)\n  \telse:\n  \t\ttry:\n  \t\t\tboard = solve(C, __init__, M)\n  \t\t\tfor line in board:\n  \t\t\t\tprint(''.join(line), file=out)\n  \t\texcept MyException:\n  \t\t\tprint('Impossible', file=out)\n  \t\n  \t\n ", "Program Length": 842, "Identifier Num": 12, "Replaced Identifiers": "_:read_string_stack,case:case,caseCnt:caseCnt,r:read,c:MAP,lines:Data1,R:__init__,", "Query Times": 376, "Time Cost": 0.17504864931106567, "Type": "wir"}
{"Index": 71, "Original Code": " \n  input = open(r'C:\\MyDocument\\home\\gcj\\2014-04-12\\A-small-attempt0.in')\n  caseCnt = int(input.readline())\n  for caseNo in range(1, caseCnt+1):\n  \tans1 = int(input.readline())\n  \tfor i in range(1, 5):\n  \t\tline = input.readline()\n  \t\tif ans1 == i:\n  \t\t\tcandidates = set(map(int, line.split()))\n  \t\t\n  \tans2 = int(input.readline())\n  \tfor i in range(1, 5):\n  \t\tline = input.readline()\n  \t\tif ans2 == i:\n  \t\t\tanswers = candidates.intersection(set(map(int, line.split())))\n  \t\t\n  \tif len(answers) == 0:\n  \t\tprint('Case #%d: Volunteer cheated!'%caseNo)\n  \telif len(answers) > 1:\n  \t\tprint('Case #%d: Bad magician!'%caseNo)\n  \telif len(answers) == 1:\n  \t\tanswer = answers.pop()\n  \t\tprint('Case #%d: %d'%(caseNo, answer))\n ", "Adversarial Code": " \n  input = open(r'C:\\MyDocument\\home\\gcj\\2014-04-12\\A-small-attempt0.in')\n  n_cases = int(input.readline())\n  for caseNo in range(1, n_cases+1):\n  \t__init__ = int(input.readline())\n  \tfor test_case in range(1, 5):\n  \t\tline = input.readline()\n  \t\tif __init__ == test_case:\n  \t\t\tfname = set(map(int, line.split()))\n  \t\t\n  \tget_max_array_on_index = int(input.readline())\n  \tfor test_case in range(1, 5):\n  \t\tline = input.readline()\n  \t\tif get_max_array_on_index == test_case:\n  \t\t\tanswers = fname.intersection(set(map(int, line.split())))\n  \t\t\n  \tif len(answers) == 0:\n  \t\tprint('Case #%d: Volunteer cheated!'%caseNo)\n  \telif len(answers) > 1:\n  \t\tprint('Case #%d: Bad magician!'%caseNo)\n  \telif len(answers) == 1:\n  \t\tf_out = answers.pop()\n  \t\tprint('Case #%d: %d'%(caseNo, f_out))\n ", "Program Length": 180, "Identifier Num": 10, "Replaced Identifiers": "ans2:get_max_array_on_index,answer:f_out,candidates:fname,i:test_case,ans1:__init__,caseCnt:n_cases,", "Query Times": 216, "Time Cost": 0.08971522251764934, "Type": "wir"}
{"Index": 72, "Original Code": null, "Adversarial Code": null, "Program Length": 1789, "Identifier Num": 19, "Replaced Identifiers": null, "Query Times": 763, "Time Cost": 0.4580862720807393, "Type": "0"}
{"Index": 73, "Original Code": null, "Adversarial Code": null, "Program Length": 863, "Identifier Num": 19, "Replaced Identifiers": null, "Query Times": 750, "Time Cost": 0.376059619585673, "Type": "0"}
{"Index": 75, "Original Code": " \n  \n  def Solve(F1,r1,F2,r2):\n      s1=set(F1[r1-1])\n      s2=set(F2[r2-1])\n      sx=s1.intersection(s2)\n      if len(sx)>1:\n          return \"Bad magician!\"\n      elif len(sx)==0:\n          return \"Volunteer cheated!\"\n      else:\n          return sx.__iter__().next()\n  \n  \n  \n  def parse(infile):\n      r1=int(infile.readline().strip())\n      F1=[]\n      for i in xrange(4):\n          F1.append( map(int, infile.readline().split() ))\n      r2=int(infile.readline().strip())\n      F2=[]\n      for i in xrange(4):\n          F2.append( map(int, infile.readline().split() ))\n      return F1,r1,F2,r2\n  \n  \n  \n  class GCJ_Parser( object ):\n      def __init__(self,fname):\n          self.infile=open(fname,'r')\n          self.NumCases=int(self.infile.readline().strip() )\n          self.caseNum=0\n  \n      def __iter__(self): return self\n  \n      def next(self):\n          if self.caseNum==self.NumCases: raise StopIteration\n          self.caseNum += 1\n          args=parse(self.infile)\n          return self.caseNum , args\n  \n  \n  def runmain():\n      myCases=GCJ_Parser(sys.argv[1])\n  \n      outname=sys.argv[1].rstrip('.in')+'.out'\n      if os.path.isfile(outname):\n          oldout=outname+'.old'\n          ii=0\n          while os.path.isfile(oldout):\n              ii+=1\n              oldout=outname+'.old'+str(ii)\n          os.rename(outname,oldout)\n          print 'Rename: %s -> %s'%(outname,oldout)   \n   \n      outfile=open(outname,'w')\n  \n      for iCase, args in myCases:\n          answer=Solve(*args)\n  \n          print 'Case #'+str(iCase)+':',answer\n          print >> outfile, 'Case #'+str(iCase)+':',answer\n  \n  \n  \n  \n  if __name__=='__main__':\n      runmain()\n ", "Adversarial Code": " \n  \n  def Solve(goTest,r1,__name__,MyException):\n      s1=set(goTest[r1-1])\n      s2=set(__name__[MyException-1])\n      sx=s1.intersection(s2)\n      if len(sx)>1:\n          return \"Bad magician!\"\n      elif len(sx)==0:\n          return \"Volunteer cheated!\"\n      else:\n          return sx.__iter__().next()\n  \n  \n  \n  def parse(infile):\n      r1=int(infile.readline().strip())\n      goTest=[]\n      for i in xrange(4):\n          goTest.append( map(int, infile.readline().split() ))\n      MyException=int(infile.readline().strip())\n      __name__=[]\n      for i in xrange(4):\n          __name__.append( map(int, infile.readline().split() ))\n      return goTest,r1,__name__,MyException\n  \n  \n  \n  class GCJ_Parser( object ):\n      def __init__(self,fname):\n          self.infile=open(fname,'r')\n          self.process_case=int(self.infile.readline().strip() )\n          self.makesample=0\n  \n      def __iter__(self): return self\n  \n      def next(self):\n          if self.makesample==self.process_case: raise StopIteration\n          self.makesample += 1\n          args=parse(self.infile)\n          return self.makesample , args\n  \n  \n  def runmain():\n      cards2=GCJ_Parser(sys.argv[1])\n  \n      b_row=sys.argv[1].rstrip('.in')+'.out'\n      if os.path.isfile(b_row):\n          row_index_1=b_row+'.old'\n          ii=0\n          while os.path.isfile(row_index_1):\n              ii+=1\n              row_index_1=b_row+'.old'+str(ii)\n          os.rename(b_row,row_index_1)\n          print 'Rename: %s -> %s'%(b_row,row_index_1)   \n   \n      outfile=open(b_row,'w')\n  \n      for iCase, args in cards2:\n          answer=Solve(*args)\n  \n          print 'Case #'+str(iCase)+':',answer\n          print >> outfile, 'Case #'+str(iCase)+':',answer\n  \n  \n  \n  \n  if __name__=='__main__':\n      runmain()\n ", "Program Length": 412, "Identifier Num": 27, "Replaced Identifiers": "outname:b_row,oldout:row_index_1,F1:goTest,F2:__name__,myCases:cards2,r2:MyException,r1:r1,caseNum:makesample,NumCases:process_case,", "Query Times": 360, "Time Cost": 0.1551034728686015, "Type": "wir"}
{"Index": 76, "Original Code": "f = open('input.in')\n  g = open('output', 'w')\n  \n  T = int(f.readline()[:-1])\n  \n  for case in xrange(T) :\n      R, C, M = map(int, f.readline()[:-1].split())\n      FREE = R*C - M\n      if FREE == 0 : res = '\nImpossible'\n      elif FREE != 1 and M > 0 and (R == 2 or C == 2) and (FREE == 2 or FREE % 2 == 1) : res = '\nImpossible'\n      elif R > 2 and C > 2 and FREE in (2, 3, 5, 7) : res = '\nImpossible'\n      else :\n          MAP = [['.' for c in range(C)] for r in range(R)]\n          MAP[0][0] = 'c'\n          if R == 1 :\n              for i in range(C-1, C-M-1, -1) : MAP[0][i] = '*'\n          elif C == 1 :\n              for i in range(R-1, R-M-1, -1) : MAP[i][0] = '*'\n          elif R == 2 :\n              for i in range(C-1, C-M/2-1, -1) : MAP[0][i], MAP[1][i] = '*', '*'\n              if FREE == 1 : MAP[1][0] = '*'\n          elif C == 2 :\n              for i in range(R-1, R-M/2-1, -1) : MAP[i][0], MAP[i][1] = '*', '*'\n              if FREE == 1 : MAP[0][1] = '*'\n          else :\n              com = M / C\n              for i in range(R-1, max(R-com-1, 2), -1) :\n                  MAP[i] = ['*' for j in range(C)]\n                  M -= C\n              I = max([i for i, j in enumerate(MAP) if j[0] == '.'])\n              if I == 2 :\n                  com = M / 3\n                  if com == 0 : i = C\n                  for i in range(C-1, C-com-1, -1) :\n                      MAP[0][i], MAP[1][i], MAP[2][i] = '*', '*', '*'\n                      M -= 3\n                  if M >= 1 : MAP[2][i-1] = '*'\n                  if M >= 2 :\n                      if i != 1 : MAP[2][i-2] = '*'\n                      else : MAP[1][0] = '*'\n              else :\n                  for i in range(C-1, C-M-1, -1) : MAP[I][i] = '*'\n                  if i == 1 :\n                      MAP[I][i] = '.'\n                      MAP[I-1][C-1] = '*'\n          res = '\n' + '\n'.join([''.join(i) for i in MAP])\n      output = 'Case #' + str(case + 1) + ': ' + str(res)\n      g.write(output + '\n')\n      print output\n  \n  f.close()\n  g.close()\n ", "Adversarial Code": "f = open('input.in')\n  g = open('output', 'w')\n  \n  T = int(f.readline()[:-1])\n  \n  for case in xrange(T) :\n      R, C, M = map(int, f.readline()[:-1].split())\n      FREE = R*C - M\n      if FREE == 0 : res = '\nImpossible'\n      elif FREE != 1 and M > 0 and (R == 2 or C == 2) and (FREE == 2 or FREE % 2 == 1) : res = '\nImpossible'\n      elif R > 2 and C > 2 and FREE in (2, 3, 5, 7) : res = '\nImpossible'\n      else :\n          solve_inputs = [['.' for c in range(C)] for r in range(R)]\n          solve_inputs[0][0] = 'c'\n          if R == 1 :\n              for input_string_stack in range(C-1, C-M-1, -1) : solve_inputs[0][input_string_stack] = '*'\n          elif C == 1 :\n              for input_string_stack in range(R-1, R-M-1, -1) : solve_inputs[input_string_stack][0] = '*'\n          elif R == 2 :\n              for input_string_stack in range(C-1, C-M/2-1, -1) : solve_inputs[0][input_string_stack], solve_inputs[1][input_string_stack] = '*', '*'\n              if FREE == 1 : solve_inputs[1][0] = '*'\n          elif C == 2 :\n              for input_string_stack in range(R-1, R-M/2-1, -1) : solve_inputs[input_string_stack][0], solve_inputs[input_string_stack][1] = '*', '*'\n              if FREE == 1 : solve_inputs[0][1] = '*'\n          else :\n              com = M / C\n              for input_string_stack in range(R-1, max(R-com-1, 2), -1) :\n                  solve_inputs[input_string_stack] = ['*' for j in range(C)]\n                  M -= C\n              I = max([input_string_stack for input_string_stack, j in enumerate(solve_inputs) if j[0] == '.'])\n              if I == 2 :\n                  com = M / 3\n                  if com == 0 : input_string_stack = C\n                  for input_string_stack in range(C-1, C-com-1, -1) :\n                      solve_inputs[0][input_string_stack], solve_inputs[1][input_string_stack], solve_inputs[2][input_string_stack] = '*', '*', '*'\n                      M -= 3\n                  if M >= 1 : solve_inputs[2][input_string_stack-1] = '*'\n                  if M >= 2 :\n                      if input_string_stack != 1 : solve_inputs[2][input_string_stack-2] = '*'\n                      else : solve_inputs[1][0] = '*'\n              else :\n                  for input_string_stack in range(C-1, C-M-1, -1) : solve_inputs[I][input_string_stack] = '*'\n                  if input_string_stack == 1 :\n                      solve_inputs[I][input_string_stack] = '.'\n                      solve_inputs[I-1][C-1] = '*'\n          res = '\n' + '\n'.join([''.join(input_string_stack) for input_string_stack in solve_inputs])\n      output = 'Case #' + str(case + 1) + ': ' + str(res)\n      g.write(output + '\n')\n      print output\n  \n  f.close()\n  g.close()\n ", "Program Length": 656, "Identifier Num": 16, "Replaced Identifiers": "i:input_string_stack,MAP:solve_inputs,", "Query Times": 199, "Time Cost": 0.08509234189987183, "Type": "wir"}
{"Index": 77, "Original Code": "f = open('input.in')\n  g = open('output', 'w')\n  \n  T = int(f.readline()[:-1])\n  \n  for case in xrange(T) :\n      a1 = int(f.readline()[:-1])\n      M1 = [map(int, f.readline()[:-1].split()) for i in range(4)]\n      a2 = int(f.readline()[:-1])\n      M2 = [map(int, f.readline()[:-1].split()) for i in range(4)]\n      r1 = M1[a1-1]\n      r2 = M2[a2-1]\n      res = set(r1).intersection(set(r2))\n      if len(res) == 1 : res = res.pop()\n      elif len(res) == 0 : res = 'Volunteer cheated!'\n      else : res = 'Bad magician!'\n      output = 'Case #' + str(case + 1) + ': ' + str(res)\n      g.write(output + '\n')\n      print output\n  \n  f.close()\n  g.close()\n ", "Adversarial Code": "infile = open('input.in')\n  input_gen = open('output', 'w')\n  \n  T = int(infile.readline()[:-1])\n  \n  for case in xrange(T) :\n      a1 = int(infile.readline()[:-1])\n      M1 = [map(int, infile.readline()[:-1].split()) for i in range(4)]\n      a2 = int(infile.readline()[:-1])\n      M2 = [map(int, infile.readline()[:-1].split()) for i in range(4)]\n      r1 = M1[a1-1]\n      r2 = M2[a2-1]\n      res = set(r1).intersection(set(r2))\n      if len(res) == 1 : res = res.pop()\n      elif len(res) == 0 : res = 'Volunteer cheated!'\n      else : res = 'Bad magician!'\n      output = 'Case #' + str(case + 1) + ': ' + str(res)\n      input_gen.write(output + '\n')\n      print output\n  \n  infile.close()\n  input_gen.close()\n ", "Program Length": 225, "Identifier Num": 13, "Replaced Identifiers": "g:input_gen,f:infile,", "Query Times": 102, "Time Cost": 0.04127804040908813, "Type": "wir"}
{"Index": 78, "Original Code": " \n  \n  '''\n  ...\n  ...\n  ...\n  ...\n  ...\n  '''\n  \n  for i in range(int(input())):\n  \n      r, c, m = tuple(map(int, str.split(input())))\n      count = r * c - m\n      field = dict(map(lambda c: (c, \"*\"), itertools.product(range(c), range(r))))\n      answer = \"Impossible\"\n  \n      if m == 0:\n  \n          answer = field\n  \n      elif 1 in (r, c):\n  \n          for p in itertools.islice(itertools.product(range(c), range(r)), count):\n  \n              field[p] = \".\"\n  \n          answer = field\n  \n      elif count in (0, 2, 3, 5, 7):\n  \n          pass\n  \n      elif count == 1:\n  \n          answer = field\n  \n      elif count // 2 < c or count == c * 2 + 1:\n  \n          if count % 2 != 0:\n  \n              tail = 3\n              ncount = count - 3\n  \n          else:\n  \n              tail = 0\n              ncount = count\n  \n          for x in range(ncount // 2):\n  \n              field[(x, 0)] = field[(x, 1)] = \".\"\n  \n          for x in range(tail):\n  \n              field[(x, 2)] = \".\"\n  \n          answer = field\n  \n      elif not (c == 2 and count % c == 1):\n  \n          for x in range(c):\n  \n              field[(x, 0)] = field[(x, 1)] = \".\"\n  \n          count -= 2 * c\n          tail = 0\n          if count % c == 1:\n  \n              tail = 2\n              count -= 1\n  \n          y = 2\n          while count > 0:\n  \n              rx = min(count, c)\n              for x in range(rx):\n  \n                  field[(x, y)] = \".\"\n  \n              count -= rx\n              y += 1\n  \n          for x in range(tail):\n  \n              field[(x, y)] = \".\"\n  \n          answer = field\n  \n      field[(0, 0)] = \"c\"\n      print(str.format(\"Case #{}:\", i + 1))\n      if isinstance(answer, dict):\n  \n          for y in range(r):\n  \n              print(str.join(\"\", map(lambda x: field[(x, y)], range(c))))\n  \n      else:\n  \n          print(answer)\n ", "Adversarial Code": " \n  \n  '''\n  ...\n  ...\n  ...\n  ...\n  ...\n  '''\n  \n  for i in range(int(input())):\n  \n      r, c, m = tuple(map(int, str.split(input())))\n      answer2 = r * c - m\n      make_string = dict(map(lambda c: (c, \"*\"), itertools.product(range(c), range(r))))\n      answer = \"Impossible\"\n  \n      if m == 0:\n  \n          answer = make_string\n  \n      elif 1 in (r, c):\n  \n          for p in itertools.islice(itertools.product(range(c), range(r)), answer2):\n  \n              make_string[p] = \".\"\n  \n          answer = make_string\n  \n      elif answer2 in (0, 2, 3, 5, 7):\n  \n          pass\n  \n      elif answer2 == 1:\n  \n          answer = make_string\n  \n      elif answer2 // 2 < c or answer2 == c * 2 + 1:\n  \n          if answer2 % 2 != 0:\n  \n              tail = 3\n              ncount = answer2 - 3\n  \n          else:\n  \n              tail = 0\n              ncount = answer2\n  \n          for x in range(ncount // 2):\n  \n              make_string[(x, 0)] = make_string[(x, 1)] = \".\"\n  \n          for x in range(tail):\n  \n              make_string[(x, 2)] = \".\"\n  \n          answer = make_string\n  \n      elif not (c == 2 and answer2 % c == 1):\n  \n          for x in range(c):\n  \n              make_string[(x, 0)] = make_string[(x, 1)] = \".\"\n  \n          answer2 -= 2 * c\n          tail = 0\n          if answer2 % c == 1:\n  \n              tail = 2\n              answer2 -= 1\n  \n          y = 2\n          while answer2 > 0:\n  \n              rx = min(answer2, c)\n              for x in range(rx):\n  \n                  make_string[(x, y)] = \".\"\n  \n              answer2 -= rx\n              y += 1\n  \n          for x in range(tail):\n  \n              make_string[(x, y)] = \".\"\n  \n          answer = make_string\n  \n      make_string[(0, 0)] = \"c\"\n      print(str.format(\"Case #{}:\", i + 1))\n      if isinstance(answer, dict):\n  \n          for y in range(r):\n  \n              print(str.join(\"\", map(lambda x: make_string[(x, y)], range(c))))\n  \n      else:\n  \n          print(answer)\n ", "Program Length": 436, "Identifier Num": 13, "Replaced Identifiers": "field:make_string,count:answer2,", "Query Times": 164, "Time Cost": 0.06968142588933308, "Type": "wir"}
{"Index": 79, "Original Code": "def read_case():\n  \n      answer = int(input())\n      lines = tuple(map(lambda _: set(str.split(input())), range(4)))\n      return lines[answer - 1]\n  \n  \n  for i in range(int(input())):\n  \n      intersection = read_case() & read_case()\n      count = len(intersection)\n      if count == 1:\n  \n          answer = intersection.pop()\n  \n      elif count > 1:\n  \n          answer = \"Bad magician!\"\n  \n      elif count < 1:\n  \n          answer = \"Volunteer cheated!\"\n  \n      print(str.format(\"Case #{}: {}\", i + 1, answer))\n ", "Adversarial Code": "def read_case():\n  \n      answer = int(input())\n      lines = tuple(map(lambda _: set(str.split(input())), range(4)))\n      return lines[answer - 1]\n  \n  \n  for i in range(int(input())):\n  \n      intersection = read_case() & read_case()\n      map = len(intersection)\n      if map == 1:\n  \n          answer = intersection.pop()\n  \n      elif map > 1:\n  \n          answer = \"Bad magician!\"\n  \n      elif map < 1:\n  \n          answer = \"Volunteer cheated!\"\n  \n      print(str.format(\"Case #{}: {}\", i + 1, answer))\n ", "Program Length": 118, "Identifier Num": 6, "Replaced Identifiers": "count:map,", "Query Times": 50, "Time Cost": 0.020698189735412598, "Type": "wir"}
{"Index": 81, "Original Code": " \n  class Solver(object):\n      def __init__(self):\n          pass\n      \n      def solve(self, inputs):\n          r1 = int(inputs[0])\n          cs1 = set([int(x) for x in inputs[r1].split()])\n          r2 = int(inputs[5])\n          cs2 = set([int(x) for x in inputs[5+r2].split()])\n          r = cs1.intersection(cs2)\n          cnt = len(r)\n          if 1 == cnt:\n              return max(r)\n          elif 0 == cnt:\n              return 'Volunteer cheated!'\n          else:\n              return 'Bad magician!'\n          pass\n      \n      def feed(self, inputs):\n          lines = [x.strip() for x in inputs]\n          outputs = []\n          test_case_n = int(lines[0])\n          cur = 1\n          for i in range(test_case_n):\n              i = i\n              case_line_cnt = 10\n              case_inputs = lines[cur:cur+case_line_cnt]\n              cur += case_line_cnt\n              outputs.append(self.solve(case_inputs))\n          return outputs\n  \n  if __name__ == '__main__':\n      iname = 'A-small-attempt0.in'\n      sample_in = '''\n      3\n  2\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  3\n  1 2 5 4\n  3 11 6 15\n  9 10 7 12\n  13 14 8 16\n  2\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  2\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  2\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  3\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n      '''\n      sample_out = '''\n   Case #1: 7\n  Case #2: Bad magician!\n  Case #3: Volunteer cheated!\n      '''\n      if os.path.exists(iname):\n          with open(iname) as f:\n              inputs = f.readlines()\n      else:\n          inputs = [x.strip() for x in sample_in.split('\n') if x.strip()]\n      solver = Solver()\n      outputs = solver.feed(inputs)\n      fail_flag = False\n      if os.path.exists(iname):\n          with open(iname+'.out', 'w') as f:\n              for i, v in enumerate(outputs):\n                  print >> f, 'Case #%d: %s'%(i+1, str(v))\n      else:\n          ans = set([x.strip() for x in sample_out.split('\n') if x.strip()])\n          for i, v in enumerate(outputs):\n              t = 'Case #%d: %s'%(i+1, str(v))\n              if t not in ans:\n                  print '!!! Wrong:', t\n                  fail_flag = True\n      print '===================================================='\n      for i, v in enumerate(outputs):\n          print 'Case #%d: %s'%(i+1, str(v))\n      print '===================================================='\n      print 'done' if not fail_flag else 'fail'\n      pass\n ", "Adversarial Code": " \n  class Solver(object):\n      def __init__(self):\n          pass\n      \n      def solve(self, parse_single):\n          r1 = int(parse_single[0])\n          cs1 = set([int(x) for x in parse_single[r1].split()])\n          r2 = int(parse_single[5])\n          cs2 = set([int(x) for x in parse_single[5+r2].split()])\n          r = cs1.intersection(cs2)\n          cnt = len(r)\n          if 1 == cnt:\n              return max(r)\n          elif 0 == cnt:\n              return 'Volunteer cheated!'\n          else:\n              return 'Bad magician!'\n          pass\n      \n      def feed(self, parse_single):\n          do_trial = [x.strip() for x in parse_single]\n          outputs = []\n          test_case_n = int(do_trial[0])\n          cur = 1\n          for i in range(test_case_n):\n              i = i\n              case_line_cnt = 10\n              case_inputs = do_trial[cur:cur+case_line_cnt]\n              cur += case_line_cnt\n              outputs.append(self.solve(case_inputs))\n          return outputs\n  \n  if __name__ == '__main__':\n      __author__ = 'A-small-attempt0.in'\n      sample_in = '''\n      3\n  2\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  3\n  1 2 5 4\n  3 11 6 15\n  9 10 7 12\n  13 14 8 16\n  2\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  2\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  2\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  3\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n      '''\n      sample_out = '''\n   Case #1: 7\n  Case #2: Bad magician!\n  Case #3: Volunteer cheated!\n      '''\n      if os.path.exists(__author__):\n          with open(__author__) as f:\n              parse_single = f.readlines()\n      else:\n          parse_single = [x.strip() for x in sample_in.split('\n') if x.strip()]\n      solver = Solver()\n      outputs = solver.feed(parse_single)\n      fail_flag = False\n      if os.path.exists(__author__):\n          with open(__author__+'.out', 'w') as f:\n              for i, v in enumerate(outputs):\n                  print >> f, 'Case #%d: %s'%(i+1, str(v))\n      else:\n          ans = set([x.strip() for x in sample_out.split('\n') if x.strip()])\n          for i, v in enumerate(outputs):\n              t = 'Case #%d: %s'%(i+1, str(v))\n              if t not in ans:\n                  print '!!! Wrong:', t\n                  fail_flag = True\n      print '===================================================='\n      for i, v in enumerate(outputs):\n          print 'Case #%d: %s'%(i+1, str(v))\n      print '===================================================='\n      print 'done' if not fail_flag else 'fail'\n      pass\n ", "Program Length": 428, "Identifier Num": 24, "Replaced Identifiers": "inputs:parse_single,iname:__author__,lines:do_trial,", "Query Times": 189, "Time Cost": 0.08181853294372558, "Type": "wir"}
{"Index": 82, "Original Code": "'''\n  Created on Apr 12, 2014\n  \n  @author: mostasem\n  '''\n  \n  def getFloorRoots(m):\n      r1 = -1 + math.sqrt(1 + (8 * m))/2\n      r2 = -1 - math.sqrt(1 + (8 * m))/2\n      return int(math.floor(r1))\n      \n  def boardHasZero(R,C,M):\n      if(R > 1 and C > 1):\n          S = M/C\n          Sr = M % C\n          print S,Sr\n          return R >= S+3 or (R == S+2 and ((Sr % 2) == 0 or (((C + Sr) % 3 == 0) and (2*C >= (C + Sr + 4))))) or (R == S+1  and (C + Sr) % 2 == 0 and (2*C >= (C + Sr + 4)))  #M <= ((R*C) - 4)\n      else :\n          return M <= ((R*C) - 2)\n  \n  \n  def generateMineSweeperCase(R,C,M):\n  \n      board = \"\"\n  \n      if( R > 1 and C > 1 ): # generate special\n          S = M/C\n          Sr = M % C\n          print S,Sr\n          if(S): # all rows of *\n              board +=\"\n\"\n              if(R >= S+3 or (R == S+2 and Sr % 2 == 0)):\n                  board += (S - 1) * ((C*\"*\") + \"\n\")\n              else:\n                  board += (S - 2) * ((C*\"*\") + \"\n\")\n              board +=  ((C*\"*\"))\n              \n          if(R >= S+3):\n              if(Sr):\n                  board +=\"\n\"\n                  board += ((Sr *\"*\") + ((C - Sr) *\".\"))\n              Rm = R - (S + 1)\n              if(Rm):\n                  board +=\"\n\"\n                  board += (Rm - 1) * ((C*\".\") + \"\n\")\n                  board +=  ((C*\".\"))\n                  \n          elif(R == S + 2):\n              Sm = 0\n              if(Sr % 2 == 0):\n                  board +=\"\n\"\n                  board += (((Sr / 2) *\"*\") + ((C - (Sr / 2)) *\".\") +\"\n\")\n                  board += ((Sr / 2) *\"*\") + ((C - (Sr / 2)) *\".\")\n              else:\n                  board +=\"\n\"\n                  board += (((Sr / 3) *\"*\") + ((C - (Sr / 3)) *\".\") +\"\n\")\n                  board += ((Sr / 3) *\"*\") + ((C - (Sr / 3)) *\".\")\n          else :\n              Sm = Sr + C\n              board +=\"\n\"\n              board += (((Sm / 2) *\"*\") + ((C - (Sm / 2)) *\".\") +\"\n\")\n              board += ((Sm / 2) *\"*\") + ((C - (Sm / 2)) *\".\")\n                  \n          list_board = list(board)\n          list_board[len(list_board) - 1] = 'c'\n          board = \"\".join(list_board)\n      else:\n          board +=\"\n\"\n          if(C == 1):\n              board += M * \"*\n\"\n              board += (R-M-1) * \".\n\"\n              board +=  \"c\"\n          else:\n              board += M * \"*\"\n              board += (C-M-1) * \".\"\n              board += \"c\"\n              \n      return board\n         \n         \n         \n  \n  f_r = open('C.in',\"r\")\n  n_test=int(f_r.readline().strip()) \n  f_w = open(\"C.out\", \"w\")\n  result = \"\"\n  for i in range(n_test):\n      R,C,M = map(int,f_r.readline().split())\n      print R,C,M\n      if(boardHasZero(R,C,M)):\n          result = generateMineSweeperCase(R,C,M)\n      else :\n          result =\"\nImpossible\"\n      print result\n      output_str='Case #{itr}:{res}'.format(itr=(i+1),res=result)\n      f_w.write(output_str+'\n')\n      \n  f_r.close()\n ", "Adversarial Code": "'''\n  Created on Apr 12, 2014\n  \n  @author: mostasem\n  '''\n  \n  def getFloorRoots(input_gen):\n      parseInput = -1 + math.sqrt(1 + (8 * input_gen))/2\n      readfunc = -1 - math.sqrt(1 + (8 * input_gen))/2\n      return int(math.floor(parseInput))\n      \n  def boardHasZero(R,C,M):\n      if(R > 1 and C > 1):\n          S = M/C\n          Sr = M % C\n          print S,Sr\n          return R >= S+3 or (R == S+2 and ((Sr % 2) == 0 or (((C + Sr) % 3 == 0) and (2*C >= (C + Sr + 4))))) or (R == S+1  and (C + Sr) % 2 == 0 and (2*C >= (C + Sr + 4)))  #M <= ((R*C) - 4)\n      else :\n          return M <= ((R*C) - 2)\n  \n  \n  def generateMineSweeperCase(R,C,M):\n  \n      input_reader = \"\"\n  \n      if( R > 1 and C > 1 ): # generate special\n          S = M/C\n          Sr = M % C\n          print S,Sr\n          if(S): # all rows of *\n              input_reader +=\"\n\"\n              if(R >= S+3 or (R == S+2 and Sr % 2 == 0)):\n                  input_reader += (S - 1) * ((C*\"*\") + \"\n\")\n              else:\n                  input_reader += (S - 2) * ((C*\"*\") + \"\n\")\n              input_reader +=  ((C*\"*\"))\n              \n          if(R >= S+3):\n              if(Sr):\n                  input_reader +=\"\n\"\n                  input_reader += ((Sr *\"*\") + ((C - Sr) *\".\"))\n              casenmbr = R - (S + 1)\n              if(casenmbr):\n                  input_reader +=\"\n\"\n                  input_reader += (casenmbr - 1) * ((C*\".\") + \"\n\")\n                  input_reader +=  ((C*\".\"))\n                  \n          elif(R == S + 2):\n              Sm = 0\n              if(Sr % 2 == 0):\n                  input_reader +=\"\n\"\n                  input_reader += (((Sr / 2) *\"*\") + ((C - (Sr / 2)) *\".\") +\"\n\")\n                  input_reader += ((Sr / 2) *\"*\") + ((C - (Sr / 2)) *\".\")\n              else:\n                  input_reader +=\"\n\"\n                  input_reader += (((Sr / 3) *\"*\") + ((C - (Sr / 3)) *\".\") +\"\n\")\n                  input_reader += ((Sr / 3) *\"*\") + ((C - (Sr / 3)) *\".\")\n          else :\n              Sm = Sr + C\n              input_reader +=\"\n\"\n              input_reader += (((Sm / 2) *\"*\") + ((C - (Sm / 2)) *\".\") +\"\n\")\n              input_reader += ((Sm / 2) *\"*\") + ((C - (Sm / 2)) *\".\")\n                  \n          list_board = list(input_reader)\n          list_board[len(list_board) - 1] = 'c'\n          input_reader = \"\".join(list_board)\n      else:\n          input_reader +=\"\n\"\n          if(C == 1):\n              input_reader += M * \"*\n\"\n              board += (R-M-1) * \".\n\"\n              board +=  \"c\"\n          else:\n              input_reader += M * \"*\"\n              input_reader += (C-M-1) * \".\"\n              input_reader += \"c\"\n              \n      return input_reader\n         \n         \n         \n  \n  f_r = open('C.in',\"r\")\n  n_test=int(f_r.readline().strip()) \n  f_w = open(\"C.out\", \"w\")\n  result = \"\"\n  for i in range(n_test):\n      R,C,M = map(int,f_r.readline().split())\n      print R,C,M\n      if(boardHasZero(R,C,M)):\n          result = generateMineSweeperCase(R,C,M)\n      else :\n          result =\"\nImpossible\"\n      print result\n      output_str='Case #{itr}:{res}'.format(itr=(i+1),res=result)\n      f_w.write(output_str+'\n')\n      \n  f_r.close()\n ", "Program Length": 782, "Identifier Num": 14, "Replaced Identifiers": "Sm:Sm,r1:parseInput,r2:readfunc,m:input_gen,Rm:casenmbr,board:input_reader,", "Query Times": 330, "Time Cost": 0.15473045508066813, "Type": "wir"}
{"Index": 83, "Original Code": "'''\n  Created on Apr 11, 2014\n  \n  @author: mostasem\n  '''\n  \n  \n  \n  def getIntersection(A,B):\n      intersect_list = []\n      dict = {};\n      for i in range(4):\n          if(dict.get(A[i]) <> None):\n              dict[A[i]] += 1\n              if(intersect_list.count(A[i]) == 0):\n                  intersect_list.append(A[i])\n          else:\n              dict[A[i]] = 1\n          if(dict.get(B[i]) <> None):\n              dict[B[i]] += 1\n              if(intersect_list.count(B[i]) == 0):\n                  intersect_list.append(B[i])\n          else:\n              dict[B[i]] = 1\n  \n      return intersect_list\n  \n  f_r = open('A.in',\"r\")\n  n_test=int(f_r.readline().strip()) \n  f_w = open(\"A.out\", \"w\")\n  result = \"\"\n  for i in range(n_test):\n      cards1 = []\n      row_index_1 = int(f_r.readline()) - 1\n      for j in range(4):\n          cards1.append(map(int,f_r.readline().split()))\n      cards2 = []\n      row_index_2 = int(f_r.readline()) - 1\n      for j in range(4):\n          cards2.append(map(int,f_r.readline().split())) \n      int_list =  getIntersection(cards1[row_index_1], cards2[row_index_2])\n      result = \"\"\n      if(len(int_list) == 0):\n          result = \"Volunteer cheated!\"\n      elif(len(int_list)  == 1):\n          result = str(int_list[0])\n      else:\n          result = \"Bad magician!\"\n      output_str='Case #{itr}: {res}'.format(itr=(i+1),res=result)\n      print output_str\n      f_w.write(output_str+'\n')\n  f_r.close()\n  f_w.close()\n ", "Adversarial Code": "'''\n  Created on Apr 11, 2014\n  \n  @author: mostasem\n  '''\n  \n  \n  \n  def getIntersection(test,ncases):\n      intersect_list = []\n      dict = {};\n      for optimize in range(4):\n          if(dict.get(test[optimize]) <> None):\n              dict[test[optimize]] += 1\n              if(intersect_list.count(test[optimize]) == 0):\n                  intersect_list.append(test[optimize])\n          else:\n              dict[test[optimize]] = 1\n          if(dict.get(ncases[optimize]) <> None):\n              dict[ncases[optimize]] += 1\n              if(intersect_list.count(ncases[optimize]) == 0):\n                  intersect_list.append(ncases[optimize])\n          else:\n              dict[ncases[optimize]] = 1\n  \n      return intersect_list\n  \n  input = open('A.in',\"r\")\n  n_test=int(input.readline().strip()) \n  f_w = open(\"A.out\", \"w\")\n  result = \"\"\n  for optimize in range(n_test):\n      cards1 = []\n      row_index_1 = int(input.readline()) - 1\n      for j in range(4):\n          cards1.append(map(int,input.readline().split()))\n      cards2 = []\n      row_index_2 = int(input.readline()) - 1\n      for j in range(4):\n          cards2.append(map(int,input.readline().split())) \n      outputFile =  getIntersection(cards1[row_index_1], cards2[row_index_2])\n      result = \"\"\n      if(len(outputFile) == 0):\n          result = \"Volunteer cheated!\"\n      elif(len(outputFile)  == 1):\n          result = str(outputFile[0])\n      else:\n          result = \"Bad magician!\"\n      output_str='Case #{itr}: {res}'.format(itr=(optimize+1),res=result)\n      print output_str\n      f_w.write(output_str+'\n')\n  input.close()\n  f_w.close()\n ", "Program Length": 364, "Identifier Num": 17, "Replaced Identifiers": "f_r:input,i:optimize,B:ncases,A:test,int_list:outputFile,", "Query Times": 228, "Time Cost": 0.09714143673578898, "Type": "wir"}
{"Index": 84, "Original Code": " \n  FILE_NAME_BASE = 'C-small-attempt0'\n  NUM_PROCESSES = 0\n  MEM_LIMIT_GB = 1.5 # per worker process\n  RECURSION_LIMIT = 1000\n  \n  def parse(inp):\n  \trows, cols, mines = (int(x) for x in inp.readline().split())\n  \treturn rows, cols, mines\n  \n  def search(rows, cols, mines):\n  \n  \tassert 0 <= mines < rows * cols\n  \tif mines == 0:\n  \t\treturn ['c' + '.' * (cols - 1)] + ['.' * cols] * (rows - 1)\n  \tif mines == rows * cols - 1:\n  \t\treturn ['c' + '*' * (cols - 1)] + ['*' * cols] * (rows - 1)\n  \n  \tif rows == 1:\n  \t\treturn ['c' + '.' * (cols - 1 - mines) + '*' * mines]\n  \tif cols == 1:\n  \t\treturn ['c'] + ['.'] * (rows - 1 - mines) + ['*'] * mines\n  \n  \tif mines > rows * cols - 4:\n  \t\treturn None\n  \n  \n  \treturn None\n  \n  class SearchBoard(object):\n  \n  \tdef __init__(self, rows, cols):\n  \t\tself.counts = [[0] * (cols + 2) for _ in xrange(rows + 2)]\n  \t\tself.mineCount = 0\n  \n  \tdef addMine(self, row, col):\n  \t\tcounts = self.counts\n  \t\tassert counts[row + 1][col + 1] < 10\n  \t\ttop = counts[row + 0]\n  \t\ttop[col + 0] += 1\n  \t\ttop[col + 1] += 1\n  \t\ttop[col + 2] += 1\n  \t\tmid = counts[row + 1]\n  \t\tmid[col + 0] += 1\n  \t\tmid[col + 1] += 10\n  \t\tmid[col + 2] += 1\n  \t\tbot = counts[row + 2]\n  \t\tbot[col + 0] += 1\n  \t\tbot[col + 1] += 1\n  \t\tbot[col + 2] += 1\n  \t\tself.mineCount += 1\n  \n  \tdef removeMine(self, row, col):\n  \t\tcounts = self.counts\n  \t\tassert counts[row + 1][col + 1] >= 10\n  \t\ttop = counts[row + 0]\n  \t\ttop[col + 0] -= 1\n  \t\ttop[col + 1] -= 1\n  \t\ttop[col + 2] -= 1\n  \t\tmid = counts[row + 1]\n  \t\tmid[col + 0] -= 1\n  \t\tmid[col + 1] -= 10\n  \t\tmid[col + 2] -= 1\n  \t\tbot = counts[row + 2]\n  \t\tbot[col + 0] -= 1\n  \t\tbot[col + 1] -= 1\n  \t\tbot[col + 2] -= 1\n  \t\tself.mineCount -= 1\n  \n  \tdef checkConnected(self):\n  \t\tcounts = self.counts\n  \t\tcols = len(counts[0]) - 2\n  \t\trows = len(counts) - 2\n  \n  \t\tfor rowIdx, row in enumerate(counts):\n  \t\t\tif rowIdx == 0 or rowIdx > rows:\n  \t\t\t\tcontinue\n  \t\t\ttry:\n  \t\t\t\tcolIdx = row.index(0, 1, -1)\n  \t\t\texcept ValueError:\n  \t\t\t\tpass\n  \t\t\telse:\n  \t\t\t\tclick = (rowIdx, colIdx)\n  \t\t\t\tbreak\n  \t\telse:\n  \t\t\treturn None\n  \n  \t\trevealed = set()\n  \t\tdef reveal(row, col):\n  \t\t\tif 1 <= row <= rows and 1 <= col <= cols:\n  \t\t\t\tpos = (row, col)\n  \t\t\t\tif pos not in revealed:\n  \t\t\t\t\trevealed.add(pos)\n  \t\t\t\t\tcount = counts[row][col]\n  \t\t\t\t\tif count == 0:\n  \t\t\t\t\t\tfor dr in (-1, 0, 1):\n  \t\t\t\t\t\t\tfor dc in (-1, 0, 1):\n  \t\t\t\t\t\t\t\tif dr != 0 or dc != 0:\n  \t\t\t\t\t\t\t\t\treveal(row + dr, col + dc)\n  \t\t\t\t\telse:\n  \t\t\t\t\t\tassert count < 10\n  \t\treveal(*click)\n  \t\tnumNonMines = rows * cols - self.mineCount\n  \t\tif len(revealed) != numNonMines:\n  \t\t\tassert len(revealed) < numNonMines\n  \t\t\treturn None\n  \n  \t\tboard = [\n  \t\t\t\t['.' if cell < 10 else '*' for cell in row[1 : -1]]\n  \t\t\t\tfor row in counts[1 : -1]\n  \t\t\t\t]\n  \t\tboard[click[0] - 1][click[1] - 1] = 'c'\n  \t\treturn [''.join(row) for row in board]\n  \n  def searchBruteForce(rows, cols, mines):\n  \tif mines == rows * cols - 1:\n  \t\treturn ['c' + '*' * (cols - 1)] + ['*' * cols] * (rows - 1)\n  \n  \tsearchBoard = SearchBoard(rows, cols)\n  \n  \tdef searchRec(idx, remaining):\n  \t\tif remaining == 0:\n  \t\t\treturn searchBoard.checkConnected()\n  \t\telif idx < remaining:\n  \t\t\treturn None\n  \t\telse:\n  \t\t\tpos = divmod(idx, cols)\n  \t\t\tsearchBoard.addMine(*pos)\n  \t\t\tfound = searchRec(idx - 1, remaining - 1)\n  \t\t\tsearchBoard.removeMine(*pos)\n  \t\t\tif found is not None:\n  \t\t\t\treturn found\n  \t\t\treturn searchRec(idx - 1, remaining)\n  \n  \treturn searchRec(rows * cols - 1, mines)\n  \n  def solve(rows, cols, mines):\n  \tboard = search(rows, cols, mines)\n  \n  \tif board is None:\n  \t\tboard = searchBruteForce(rows, cols, mines)\n  \t\tif board is None:\n  \t\t\treturn '\n' + 'Impossible'\n  \t\tprint 'ERROR: fast search missed solution for %dx%d board, %d mines:' \\\n  \t\t\t\t% (rows, cols, mines)\n  \t\tfor row in board:\n  \t\t\tprint row\n  \t\tprint\n  \n  \tassert len(board) == rows\n  \tassert all(len(row) == cols for row in board)\n  \tcounts = { 'c': 0, '.': 0, '*': 0 }\n  \tfor row in board:\n  \t\tfor cell in row:\n  \t\t\tcounts[cell] += 1\n  \tassert counts['c'] == 1\n  \tassert counts['*'] == mines\n  \n  \tflowBoard = [\n  \t\t\t['.' if cell == 'c' else cell for cell in row]\n  \t\t\tfor row in board\n  \t\t\t]\n  \tdef countMinesOn(row, col):\n  \t\tif 0 <= row < rows and 0 <= col < cols:\n  \t\t\treturn 1 if flowBoard[row][col] == '*' else 0\n  \t\telse:\n  \t\t\treturn 0\n  \tdef countMinesNear(row, col):\n  \t\treturn sum(\n  \t\t\tcountMinesOn(row + dr, col + dc)\n  \t\t\tfor dr in (-1, 0, 1)\n  \t\t\tfor dc in (-1, 0, 1)\n  \t\t\t)\n  \tdef reveal(row, col):\n  \t\tif 0 <= row < rows and 0 <= col < cols:\n  \t\t\tassert flowBoard[row][col] != '*'\n  \t\t\tif flowBoard[row][col] == '.':\n  \t\t\t\tcount = countMinesNear(row, col)\n  \t\t\t\tflowBoard[row][col] = str(count)\n  \t\t\t\tif count == 0:\n  \t\t\t\t\tfor dr in (-1, 0, 1):\n  \t\t\t\t\t\tfor dc in (-1, 0, 1):\n  \t\t\t\t\t\t\treveal(row + dr, col + dc)\n  \tclickRow, = [i for i, row in enumerate(board) if 'c' in row]\n  \tclickCol = board[clickRow].index('c')\n  \treveal(clickRow, clickCol)\n  \tassert all('.' not in row for row in flowBoard), flowBoard\n  \n  \tassert all(type(row) == str for row in board)\n  \treturn '\n' + ''.join('\n' + ''.join(row) for row in board)\n  \n  def main():\n  \tsys.setrecursionlimit(RECURSION_LIMIT)\n  \n  \tsoft, hard = resource.getrlimit(resource.RLIMIT_AS)\n  \tresource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))\n  \n  \tinp = open(FILE_NAME_BASE + '.in', 'r')\n  \tnumCases = int(inp.readline())\n  \tif NUM_PROCESSES == 0:\n  \t\tresults = [\n  \t\t\tsolve(*parse(inp))\n  \t\t\tfor _ in range(numCases)\n  \t\t\t]\n  \telse:\n  \t\tpool = Pool(NUM_PROCESSES)\n  \t\tresults = [\n  \t\t\tpool.apply_async(solve, parse(inp))\n  \t\t\tfor _ in range(numCases)\n  \t\t\t]\n  \tinp.close()\n  \tout = open(FILE_NAME_BASE + '.out', 'w')\n  \tfor case, result in enumerate(results):\n  \t\tvalue = result if NUM_PROCESSES == 0 else result.get()\n  \t\tout.write('Case #%d: %s\n' % (case + 1, value))\n  \t\tout.flush()\n  \tout.close()\n  \n  if __name__ == '__main__':\n  \tmain()\n ", "Adversarial Code": " \n  row_index2 = 'C-small-attempt0'\n  edge_row_idx = 0\n  MEM_LIMIT_GB = 1.5 # per worker process\n  memoizeit = 1000\n  \n  def parse(__init__):\n  \trows, cols, row_A_selected = (int(x) for x in __init__.readline().split())\n  \treturn rows, cols, row_A_selected\n  \n  def search(rows, cols, row_A_selected):\n  \n  \tassert 0 <= row_A_selected < rows * cols\n  \tif row_A_selected == 0:\n  \t\treturn ['c' + '.' * (cols - 1)] + ['.' * cols] * (rows - 1)\n  \tif row_A_selected == rows * cols - 1:\n  \t\treturn ['c' + '*' * (cols - 1)] + ['*' * cols] * (rows - 1)\n  \n  \tif rows == 1:\n  \t\treturn ['c' + '.' * (cols - 1 - row_A_selected) + '*' * row_A_selected]\n  \tif cols == 1:\n  \t\treturn ['c'] + ['.'] * (rows - 1 - row_A_selected) + ['*'] * row_A_selected\n  \n  \tif row_A_selected > rows * cols - 4:\n  \t\treturn None\n  \n  \n  \treturn None\n  \n  class SearchBoard(object):\n  \n  \tdef __init__(self, rows, cols):\n  \t\tself.counts = [[0] * (cols + 2) for _ in xrange(rows + 2)]\n  \t\tself.mineCount = 0\n  \n  \tdef addMine(self, row, col):\n  \t\tcounts = self.counts\n  \t\tassert counts[row + 1][col + 1] < 10\n  \t\ttop = counts[row + 0]\n  \t\ttop[col + 0] += 1\n  \t\ttop[col + 1] += 1\n  \t\ttop[col + 2] += 1\n  \t\tmid = counts[row + 1]\n  \t\tmid[col + 0] += 1\n  \t\tmid[col + 1] += 10\n  \t\tmid[col + 2] += 1\n  \t\tbot = counts[row + 2]\n  \t\tbot[col + 0] += 1\n  \t\tbot[col + 1] += 1\n  \t\tbot[col + 2] += 1\n  \t\tself.mineCount += 1\n  \n  \tdef removeMine(self, row, col):\n  \t\tcounts = self.counts\n  \t\tassert counts[row + 1][col + 1] >= 10\n  \t\ttop = counts[row + 0]\n  \t\ttop[col + 0] -= 1\n  \t\ttop[col + 1] -= 1\n  \t\ttop[col + 2] -= 1\n  \t\tmid = counts[row + 1]\n  \t\tmid[col + 0] -= 1\n  \t\tmid[col + 1] -= 10\n  \t\tmid[col + 2] -= 1\n  \t\tbot = counts[row + 2]\n  \t\tbot[col + 0] -= 1\n  \t\tbot[col + 1] -= 1\n  \t\tbot[col + 2] -= 1\n  \t\tself.mineCount -= 1\n  \n  \tdef checkConnected(self):\n  \t\tcounts = self.counts\n  \t\tcols = len(counts[0]) - 2\n  \t\trows = len(counts) - 2\n  \n  \t\tfor rowIdx, row in enumerate(counts):\n  \t\t\tif rowIdx == 0 or rowIdx > rows:\n  \t\t\t\tcontinue\n  \t\t\ttry:\n  \t\t\t\tcolIdx = row.index(0, 1, -1)\n  \t\t\texcept ValueError:\n  \t\t\t\tpass\n  \t\t\telse:\n  \t\t\t\tclick = (rowIdx, colIdx)\n  \t\t\t\tbreak\n  \t\telse:\n  \t\t\treturn None\n  \n  \t\trevealed = set()\n  \t\tdef reveal(row, col):\n  \t\t\tif 1 <= row <= rows and 1 <= col <= cols:\n  \t\t\t\tpos = (row, col)\n  \t\t\t\tif pos not in revealed:\n  \t\t\t\t\trevealed.add(pos)\n  \t\t\t\t\tcount = counts[row][col]\n  \t\t\t\t\tif count == 0:\n  \t\t\t\t\t\tfor dr in (-1, 0, 1):\n  \t\t\t\t\t\t\tfor dc in (-1, 0, 1):\n  \t\t\t\t\t\t\t\tif dr != 0 or dc != 0:\n  \t\t\t\t\t\t\t\t\treveal(row + dr, col + dc)\n  \t\t\t\t\telse:\n  \t\t\t\t\t\tassert count < 10\n  \t\treveal(*click)\n  \t\tnumNonMines = rows * cols - self.mineCount\n  \t\tif len(revealed) != numNonMines:\n  \t\t\tassert len(revealed) < numNonMines\n  \t\t\treturn None\n  \n  \t\tboard = [\n  \t\t\t\t['.' if cell < 10 else '*' for cell in row[1 : -1]]\n  \t\t\t\tfor row in counts[1 : -1]\n  \t\t\t\t]\n  \t\tboard[click[0] - 1][click[1] - 1] = 'c'\n  \t\treturn [''.join(row) for row in board]\n  \n  def searchBruteForce(rows, cols, row_A_selected):\n  \tif row_A_selected == rows * cols - 1:\n  \t\treturn ['c' + '*' * (cols - 1)] + ['*' * cols] * (rows - 1)\n  \n  \tsearchBoard = SearchBoard(rows, cols)\n  \n  \tdef searchRec(idx, remaining):\n  \t\tif remaining == 0:\n  \t\t\treturn searchBoard.checkConnected()\n  \t\telif idx < remaining:\n  \t\t\treturn None\n  \t\telse:\n  \t\t\tpos = divmod(idx, cols)\n  \t\t\tsearchBoard.addMine(*pos)\n  \t\t\tfound = searchRec(idx - 1, remaining - 1)\n  \t\t\tsearchBoard.removeMine(*pos)\n  \t\t\tif found is not None:\n  \t\t\t\treturn found\n  \t\t\treturn searchRec(idx - 1, remaining)\n  \n  \treturn searchRec(rows * cols - 1, row_A_selected)\n  \n  def solve(rows, cols, row_A_selected):\n  \tboard = search(rows, cols, row_A_selected)\n  \n  \tif board is None:\n  \t\tboard = searchBruteForce(rows, cols, row_A_selected)\n  \t\tif board is None:\n  \t\t\treturn '\n' + 'Impossible'\n  \t\tprint 'ERROR: fast search missed solution for %dx%d board, %d mines:' \\\n  \t\t\t\t% (rows, cols, row_A_selected)\n  \t\tfor row in board:\n  \t\t\tprint row\n  \t\tprint\n  \n  \tassert len(board) == rows\n  \tassert all(len(row) == cols for row in board)\n  \tcounts = { 'c': 0, '.': 0, '*': 0 }\n  \tfor row in board:\n  \t\tfor cell in row:\n  \t\t\tcounts[cell] += 1\n  \tassert counts['c'] == 1\n  \tassert counts['*'] == row_A_selected\n  \n  \tflowBoard = [\n  \t\t\t['.' if cell == 'c' else cell for cell in row]\n  \t\t\tfor row in board\n  \t\t\t]\n  \tdef countMinesOn(row, col):\n  \t\tif 0 <= row < rows and 0 <= col < cols:\n  \t\t\treturn 1 if flowBoard[row][col] == '*' else 0\n  \t\telse:\n  \t\t\treturn 0\n  \tdef countMinesNear(row, col):\n  \t\treturn sum(\n  \t\t\tcountMinesOn(row + dr, col + dc)\n  \t\t\tfor dr in (-1, 0, 1)\n  \t\t\tfor dc in (-1, 0, 1)\n  \t\t\t)\n  \tdef reveal(row, col):\n  \t\tif 0 <= row < rows and 0 <= col < cols:\n  \t\t\tassert flowBoard[row][col] != '*'\n  \t\t\tif flowBoard[row][col] == '.':\n  \t\t\t\tcount = countMinesNear(row, col)\n  \t\t\t\tflowBoard[row][col] = str(count)\n  \t\t\t\tif count == 0:\n  \t\t\t\t\tfor dr in (-1, 0, 1):\n  \t\t\t\t\t\tfor dc in (-1, 0, 1):\n  \t\t\t\t\t\t\treveal(row + dr, col + dc)\n  \tclickRow, = [i for i, row in enumerate(board) if 'c' in row]\n  \tclickCol = board[clickRow].index('c')\n  \treveal(clickRow, clickCol)\n  \tassert all('.' not in row for row in flowBoard), flowBoard\n  \n  \tassert all(type(row) == str for row in board)\n  \treturn '\n' + ''.join('\n' + ''.join(row) for row in board)\n  \n  def main():\n  \tsys.setrecursionlimit(memoizeit)\n  \n  \tsoft, hard = resource.getrlimit(resource.RLIMIT_AS)\n  \tresource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))\n  \n  \t__init__ = open(row_index2 + '.in', 'r')\n  \tnumCases = int(__init__.readline())\n  \tif edge_row_idx == 0:\n  \t\tresults = [\n  \t\t\tsolve(*parse(__init__))\n  \t\t\tfor _ in range(numCases)\n  \t\t\t]\n  \telse:\n  \t\tpool = Pool(edge_row_idx)\n  \t\tresults = [\n  \t\t\tpool.apply_async(solve, parse(__init__))\n  \t\t\tfor _ in range(numCases)\n  \t\t\t]\n  \t__init__.close()\n  \tout = open(row_index2 + '.out', 'w')\n  \tfor case, result in enumerate(results):\n  \t\tvalue = result if edge_row_idx == 0 else result.get()\n  \t\tout.write('Case #%d: %s\n' % (case + 1, value))\n  \t\tout.flush()\n  \tout.close()\n  \n  if __name__ == '__main__':\n  \tmain()\n ", "Program Length": 1529, "Identifier Num": 23, "Replaced Identifiers": "FILE_NAME_BASE:row_index2,NUM_PROCESSES:edge_row_idx,mines:row_A_selected,RECURSION_LIMIT:memoizeit,inp:__init__,", "Query Times": 406, "Time Cost": 0.21215587854385376, "Type": "wir"}
{"Index": 85, "Original Code": " \n  FILE_NAME_BASE = 'A-small-attempt0'\n  NUM_PROCESSES = 0\n  MEM_LIMIT_GB = 1.5 # per worker process\n  RECURSION_LIMIT = 1000\n  \n  def parseBoard(inp):\n  \trowSel, = (int(x) for x in inp.readline().split())\n  \tboard = tuple(\n  \t\ttuple(int(x) for x in inp.readline().split())\n  \t\tfor _ in xrange(4)\n  \t\t)\n  \treturn board, rowSel - 1\n  \n  def parse(inp):\n  \tbefore, beforeSel = parseBoard(inp)\n  \tafter, afterSel = parseBoard(inp)\n  \treturn before, beforeSel, after, afterSel\n  \n  def solve(before, beforeSel, after, afterSel):\n  \tcandidates = set(before[beforeSel]) & set(after[afterSel])\n  \n  \tif len(candidates) == 0:\n  \t\treturn \"Volunteer cheated!\"\n  \telif len(candidates) == 1:\n  \t\treturn candidates.pop()\n  \telse:\n  \t\treturn \"Bad magician!\"\n  \n  def main():\n  \tsys.setrecursionlimit(RECURSION_LIMIT)\n  \n  \tsoft, hard = resource.getrlimit(resource.RLIMIT_AS)\n  \tresource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))\n  \n  \tinp = open(FILE_NAME_BASE + '.in', 'r')\n  \tnumCases = int(inp.readline())\n  \tif NUM_PROCESSES == 0:\n  \t\tresults = [\n  \t\t\tsolve(*parse(inp))\n  \t\t\tfor _ in range(numCases)\n  \t\t\t]\n  \telse:\n  \t\tpool = Pool(NUM_PROCESSES)\n  \t\tresults = [\n  \t\t\tpool.apply_async(solve, parse(inp))\n  \t\t\tfor _ in range(numCases)\n  \t\t\t]\n  \tinp.close()\n  \tout = open(FILE_NAME_BASE + '.out', 'w')\n  \tfor case, result in enumerate(results):\n  \t\tvalue = result if NUM_PROCESSES == 0 else result.get()\n  \t\tout.write('Case #%d: %s\n' % (case + 1, value))\n  \t\tout.flush()\n  \tout.close()\n  \n  if __name__ == '__main__':\n  \tmain()\n ", "Adversarial Code": " \n  cleared = 'A-small-attempt0'\n  process = 0\n  f_w = 1.5 # per worker process\n  iterate_cases_nlpc = 1000\n  \n  def parseBoard(inp):\n  \toutFileName, = (int(x) for x in inp.readline().split())\n  \tr_file = tuple(\n  \t\ttuple(int(x) for x in inp.readline().split())\n  \t\tfor tests in xrange(4)\n  \t\t)\n  \treturn r_file, outFileName - 1\n  \n  def parse(inp):\n  \txr, bw = parseBoard(inp)\n  \tparseBoard, clickRow = parseBoard(inp)\n  \treturn xr, bw, parseBoard, clickRow\n  \n  def solve(xr, bw, parseBoard, clickRow):\n  \tdirectory = set(xr[bw]) & set(parseBoard[clickRow])\n  \n  \tif len(directory) == 0:\n  \t\treturn \"Volunteer cheated!\"\n  \telif len(directory) == 1:\n  \t\treturn directory.pop()\n  \telse:\n  \t\treturn \"Bad magician!\"\n  \n  def main():\n  \tsys.setrecursionlimit(iterate_cases_nlpc)\n  \n  \tseen, solution = resource.getrlimit(resource.RLIMIT_AS)\n  \tresource.setrlimit(resource.RLIMIT_AS, (f_w * 1024 ** 3, solution))\n  \n  \tinp = open(cleared + '.in', 'r')\n  \tnumCases = int(inp.readline())\n  \tif process == 0:\n  \t\telement = [\n  \t\t\tsolve(*parse(inp))\n  \t\t\tfor tests in range(numCases)\n  \t\t\t]\n  \telse:\n  \t\tcur = Pool(process)\n  \t\telement = [\n  \t\t\tcur.apply_async(solve, parse(inp))\n  \t\t\tfor tests in range(numCases)\n  \t\t\t]\n  \tinp.close()\n  \tout = open(cleared + '.out', 'w')\n  \tfor test_3, place_mine in enumerate(element):\n  \t\tsys = place_mine if process == 0 else place_mine.get()\n  \t\tout.write('Case #%d: %s\n' % (test_3 + 1, sys))\n  \t\tout.flush()\n  \tout.close()\n  \n  if __name__ == '__main__':\n  \tmain()\n ", "Program Length": 350, "Identifier Num": 27, "Replaced Identifiers": "NUM_PROCESSES:process,FILE_NAME_BASE:cleared,pool:cur,soft:seen,value:sys,case:test_3,result:place_mine,rowSel:outFileName,board:r_file,_:tests,RECURSION_LIMIT:iterate_cases_nlpc,results:element,afterSel:clickRow,beforeSel:bw,candidates:directory,MEM_LIMIT_GB:f_w,after:parseBoard,before:xr,hard:solution,", "Query Times": 648, "Time Cost": 0.2841207027435303, "Type": "wir"}
{"Index": 86, "Original Code": "T = int(raw_input().strip())\n  misses = set()\n  \n  for i in xrange(T):\n  \tR, C, M = map(int, raw_input().strip().split(' '))\n  \tF = R * C - M\n  \timpossible = False\n  \tif F == 1:\n  \t\tmatrix = [\"c\" + \"*\" * (C - 1)]\n  \t\tfor _ in xrange(R - 1):\n  \t\t\tmatrix.append(\"*\" * C)\n  \telif R == 1:\n  \t\tmatrix = [\"c\" + \".\" * (F - 1) + \"*\" * (C - F)]\n  \telif C == 1:\n  \t\tmatrix = [\"c\"]\n  \t\tfor _ in xrange(F - 1):\n  \t\t\tmatrix.append(\".\")\n  \t\tfor _ in xrange(R - F):\n  \t\t\tmatrix.append(\"*\")\n  \telif R == 2:\n  \t\tif F % 2 == 0 and (C > 1 and F != 2 or C == 1 and F <= 2):\n  \t\t\tmatrix = [\n  \t\t\t\t\"c\" + \".\" * (F / 2 - 1) + \"*\" * (C - F / 2),\t\n  \t\t\t\t\".\" * (F / 2) + \"*\" * (C - F / 2)\n  \t\t\t]\n  \t\telse:\n  \t\t\tmatrix = []\n  \t\t\timpossible = True\n  \telse:\n  \t\tstack = []\n  \t\tmatrix = []\n  \t\tfor j in xrange(C, 1, -1):\n  \t\t\tif F - 2 * j >= 0 and (R - 2) * j >= F - 2 * j:\n  \t\t\t\tstack.append([j, j])\n  \n  \t\twhile stack:\n  \t\t\telems = stack.pop()\n  \t\t\tse = sum(elems)\n  \t\t\tif se == F:\n  \t\t\t\tfor count in elems:\n  \t\t\t\t\tmatrix.append(\".\" * count + \"*\" * (C - count))\n  \t\t\t\tfor _ in xrange(R - len(elems)):\n  \t\t\t\t\tmatrix.append(\"*\" * C)\n  \t\t\t\tmatrix[0] = \"c\" + matrix[0][1:]\n  \t\t\t\tbreak\n  \t\t\telif len(elems) < R:\n  \t\t\t\tfor j in xrange(elems[-1], 1, -1):\n  \t\t\t\t\tif F - se - j >= 0 and (R - len(elems)) * j >= F - se:\n  \t\t\t\t\t\tstack.append(elems[::] + [j])\n  \n  \t\tif matrix == []:\n  \t\t\timpossible =True\n  \n  \tprint \"Case #%s:\" % (i + 1)\n  \tif impossible:\n  \t\tprint \"Impossible\"\n  \telse:\n  \t\tfor row in matrix:\n  \t\t\tprint row\n ", "Adversarial Code": "input_file = int(raw_input().strip())\n  misses = set()\n  \n  for i in xrange(input_file):\n  \tR, C, M = map(int, raw_input().strip().split(' '))\n  \tF = R * C - M\n  \timpossible = False\n  \tif F == 1:\n  \t\tmatrix = [\"c\" + \"*\" * (C - 1)]\n  \t\tfor _ in xrange(R - 1):\n  \t\t\tmatrix.append(\"*\" * C)\n  \telif R == 1:\n  \t\tmatrix = [\"c\" + \".\" * (F - 1) + \"*\" * (C - F)]\n  \telif C == 1:\n  \t\tmatrix = [\"c\"]\n  \t\tfor _ in xrange(F - 1):\n  \t\t\tmatrix.append(\".\")\n  \t\tfor _ in xrange(R - F):\n  \t\t\tmatrix.append(\"*\")\n  \telif R == 2:\n  \t\tif F % 2 == 0 and (C > 1 and F != 2 or C == 1 and F <= 2):\n  \t\t\tmatrix = [\n  \t\t\t\t\"c\" + \".\" * (F / 2 - 1) + \"*\" * (C - F / 2),\t\n  \t\t\t\t\".\" * (F / 2) + \"*\" * (C - F / 2)\n  \t\t\t]\n  \t\telse:\n  \t\t\tmatrix = []\n  \t\t\timpossible = True\n  \telse:\n  \t\tstack = []\n  \t\tmatrix = []\n  \t\tfor j in xrange(C, 1, -1):\n  \t\t\tif F - 2 * j >= 0 and (R - 2) * j >= F - 2 * j:\n  \t\t\t\tstack.append([j, j])\n  \n  \t\twhile stack:\n  \t\t\telems = stack.pop()\n  \t\t\tse = sum(elems)\n  \t\t\tif se == F:\n  \t\t\t\tfor count in elems:\n  \t\t\t\t\tmatrix.append(\".\" * count + \"*\" * (C - count))\n  \t\t\t\tfor _ in xrange(R - len(elems)):\n  \t\t\t\t\tmatrix.append(\"*\" * C)\n  \t\t\t\tmatrix[0] = \"c\" + matrix[0][1:]\n  \t\t\t\tbreak\n  \t\t\telif len(elems) < R:\n  \t\t\t\tfor j in xrange(elems[-1], 1, -1):\n  \t\t\t\t\tif F - se - j >= 0 and (R - len(elems)) * j >= F - se:\n  \t\t\t\t\t\tstack.append(elems[::] + [j])\n  \n  \t\tif matrix == []:\n  \t\t\timpossible =True\n  \n  \tprint \"Case #%s:\" % (i + 1)\n  \tif impossible:\n  \t\tprint \"Impossible\"\n  \telse:\n  \t\tfor row in matrix:\n  \t\t\tprint row\n ", "Program Length": 475, "Identifier Num": 14, "Replaced Identifiers": "T:input_file,", "Query Times": 131, "Time Cost": 0.056612213452657066, "Type": "wir"}
{"Index": 87, "Original Code": "T = int(raw_input().strip())\n  \n  for j in xrange(T):\n  \trow_num1 = int(raw_input().strip())\n  \tfor i in xrange(4):\n  \t\tif i + 1 == row_num1:\n  \t\t\trow1 = set(map(int, raw_input().strip().split(' ')))\n  \t\telse:\n  \t\t\traw_input()\n  \trow_num2 = int(raw_input().strip())\n  \tfor i in xrange(4):\n  \t\tif i + 1 == row_num2:\n  \t\t\trow2 = set(map(int, raw_input().strip().split(' ')))\n  \t\telse:\n  \t\t\traw_input()\n  \tcommon = row1 & row2\n  \tlc = len(common)\n  \tif lc == 1:\n  \t\tstuff = list(common)[0]\n  \telif lc > 1:\n  \t\tstuff = \"Bad magician!\"\n  \telse:\n  \t\tstuff = \"Volunteer cheated!\"\n  \n  \tprint \"Case #%s: %s\" % (j + 1, stuff)\n ", "Adversarial Code": "T = int(raw_input().strip())\n  \n  for test_case_n in xrange(T):\n  \trow_num1 = int(raw_input().strip())\n  \tfor i in xrange(4):\n  \t\tif i + 1 == row_num1:\n  \t\t\trow1 = set(map(int, raw_input().strip().split(' ')))\n  \t\telse:\n  \t\t\traw_input()\n  \trow_num2 = int(raw_input().strip())\n  \tfor i in xrange(4):\n  \t\tif i + 1 == row_num2:\n  \t\t\trow2 = set(map(int, raw_input().strip().split(' ')))\n  \t\telse:\n  \t\t\traw_input()\n  \tcommon = row1 & row2\n  \tlc = len(common)\n  \tif lc == 1:\n  \t\tstuff = list(common)[0]\n  \telif lc > 1:\n  \t\tstuff = \"Bad magician!\"\n  \telse:\n  \t\tstuff = \"Volunteer cheated!\"\n  \n  \tprint \"Case #%s: %s\" % (test_case_n + 1, stuff)\n ", "Program Length": 176, "Identifier Num": 8, "Replaced Identifiers": "j:test_case_n,", "Query Times": 55, "Time Cost": 0.022461811701456707, "Type": "wir"}
{"Index": 88, "Original Code": " \n  \n  f = open(sys.argv[1],'r')\n  \n  num = int(f.readline())\n  \n  def count(z, r, c):\n      return len(z_and_nei(z,r,c))\n  \n  def nei(z, r, c):\n      s = z_and_nei(z, r, c)\n      s -= set(z)\n      return s\n  \n  def z_and_nei(z, r, c):\n      s = set()\n      for x in z:\n          s.add(x)\n          s.add((x[0]-1,x[1]-1))\n          s.add((x[0]-1,x[1]))\n          s.add((x[0]-1,x[1]+1))\n          s.add((x[0],x[1]-1))\n          s.add((x[0],x[1]+1))\n          s.add((x[0]+1,x[1]-1))\n          s.add((x[0]+1,x[1]))\n          s.add((x[0]+1,x[1]+1))\n      o = set()\n      for x in s:\n          if x[0] < 0 or x[0] > r-1 or x[1] < 0 or x[1] > c-1:\n              o.add(x)\n      s-=o\n      return s\n  \n  def find_config(z, r, c, t):\n      if count(z,r,c) == t:\n          return z\n      if count(z,r,c) > t:\n          return []\n      n = nei(z,r,c)\n      for x in n:\n          z.append(x)\n          if find_config(z,r,c,t) != []:\n              return z\n          z.pop()\n      return []\n  \n  for i in range(num):\n      print 'Case #{}:'.format(i+1)\n      r, c, m = [int(x) for x in f.readline().split()]\n      if r*c-m == 1:\n          print 'c' + '*'*(c-1)\n          for i in range(r-1):\n              print '*'*c\n      else:\n          z = find_config([(0,0)], c, r, c*r-m)\n          if z == []:\n              print \"Impossible\"\n          else:\n              s = z_and_nei(z, c, r)\n              for j in range(r):\n                  for k in range(c):\n                      if j == 0 and k == 0:\n                          print 'c',\n                      elif (k,j) in s:\n                          print '.',\n                      else:\n                          print '*',\n                  print\n  \n  \n ", "Adversarial Code": " \n  \n  f = open(sys.argv[1],'r')\n  \n  num = int(f.readline())\n  \n  def count(z, r, c):\n      return len(z_and_nei(z,r,c))\n  \n  def nei(z, r, c):\n      s = z_and_nei(z, r, c)\n      s -= set(z)\n      return s\n  \n  def z_and_nei(z, r, c):\n      s = set()\n      for str_out in z:\n          s.add(str_out)\n          s.add((str_out[0]-1,str_out[1]-1))\n          s.add((str_out[0]-1,str_out[1]))\n          s.add((str_out[0]-1,str_out[1]+1))\n          s.add((str_out[0],str_out[1]-1))\n          s.add((str_out[0],str_out[1]+1))\n          s.add((str_out[0]+1,str_out[1]-1))\n          s.add((str_out[0]+1,str_out[1]))\n          s.add((str_out[0]+1,str_out[1]+1))\n      o = set()\n      for str_out in s:\n          if str_out[0] < 0 or str_out[0] > r-1 or str_out[1] < 0 or str_out[1] > c-1:\n              o.add(str_out)\n      s-=o\n      return s\n  \n  def find_config(z, r, c, t):\n      if count(z,r,c) == t:\n          return z\n      if count(z,r,c) > t:\n          return []\n      n = nei(z,r,c)\n      for str_out in n:\n          z.append(str_out)\n          if find_config(z,r,c,t) != []:\n              return z\n          z.pop()\n      return []\n  \n  for i in range(num):\n      print 'Case #{}:'.format(i+1)\n      r, c, m = [int(str_out) for str_out in f.readline().split()]\n      if r*c-m == 1:\n          print 'c' + '*'*(c-1)\n          for i in range(r-1):\n              print '*'*c\n      else:\n          z = find_config([(0,0)], c, r, c*r-m)\n          if z == []:\n              print \"Impossible\"\n          else:\n              s = z_and_nei(z, c, r)\n              for j in range(r):\n                  for k in range(c):\n                      if j == 0 and k == 0:\n                          print 'c',\n                      elif (k,j) in s:\n                          print '.',\n                      else:\n                          print '*',\n                  print\n  \n  \n ", "Program Length": 556, "Identifier Num": 16, "Replaced Identifiers": "x:str_out,", "Query Times": 155, "Time Cost": 0.06587442954381308, "Type": "wir"}
{"Index": 89, "Original Code": " \n  \n  f = open(sys.argv[1],'r')\n  \n  num = int(f.readline())\n  \n  for i in range(num):\n      q1 = int(f.readline())\n      for j in range(4):\n          if j+1 == q1:\n              line1 = f.readline()\n          else:\n              f.readline()\n      q2 = int(f.readline())\n      for j in range(4):\n          if j+1 == q2:\n              line2 = f.readline()\n          else:\n              f.readline()\n      line1 = [int(x) for x in line1.split()]\n      line2 = [int(x) for x in line2.split()]\n      count = 0\n      for x in line1:\n          if x in line2:\n              count += 1\n              y = x\n      if count == 0:\n          print 'Case #{}: Volunteer cheated!'.format(i+1)\n      elif count == 1:\n          print 'Case #{}: {}'.format(i+1, y)\n      else:\n          print 'Case #{}: Bad magician!'.format(i+1)\n ", "Adversarial Code": " \n  \n  dfs = open(sys.argv[1],'r')\n  \n  num = int(dfs.readline())\n  \n  for i in range(num):\n      q1 = int(dfs.readline())\n      for j in range(4):\n          if j+1 == q1:\n              line1 = dfs.readline()\n          else:\n              dfs.readline()\n      q2 = int(dfs.readline())\n      for j in range(4):\n          if j+1 == q2:\n              line2 = dfs.readline()\n          else:\n              dfs.readline()\n      line1 = [int(x) for x in line1.split()]\n      line2 = [int(x) for x in line2.split()]\n      count = 0\n      for x in line1:\n          if x in line2:\n              count += 1\n              y = x\n      if count == 0:\n          print 'Case #{}: Volunteer cheated!'.format(i+1)\n      elif count == 1:\n          print 'Case #{}: {}'.format(i+1, y)\n      else:\n          print 'Case #{}: Bad magician!'.format(i+1)\n ", "Program Length": 201, "Identifier Num": 11, "Replaced Identifiers": "f:dfs,", "Query Times": 76, "Time Cost": 0.03046151002248128, "Type": "wir"}
{"Index": 90, "Original Code": " \n  def check_bounds(state, coord):\n      if coord[0] < 0 or coord[1] < 0:\n          return False\n      elif coord[0] > (len(state) - 1):\n          return False\n      elif coord[1] > (len(state[coord[0]]) - 1):\n          return False\n      else:\n          return True\n  \n  def clear(state, coord):\n      for r in range(-1,2):\n          for c in range(-1,2):\n              row = coord[0] + r\n              col = coord[1] + c\n              if check_bounds(state, (row, col)):\n                  state[row][col] = 0\n  \n  def count(state):\n      return sum([sum(x) for x in state])\n  \n  def state_print(state):\n      print(\"c\" + \"\".join([\"*\"  if x else \".\" for x in state[0][1:]]))\n      for line in state[1:]:\n          print(\"\".join([\"*\"  if x else \".\" for x in line]))\n  \n  def solve(state, mines):\n      prev_state = deepcopy(state)\n      for row in range(len(state)):\n          for col in range(len(state[row])):\n              new_state = deepcopy(state)\n              clear(new_state, (row, col))\n              c = count(new_state)\n              if(c < mines):\n                  state = prev_state\n              elif( c == mines):\n                  state_print(new_state)\n                  return True\n              else:\n                  if col == len(state[row]) -2:\n                      prev_state = deepcopy(state)\n                  state = new_state\n      print(\"Impossible\")\n      return False\n  \n  \n  \n  \n  def main():\n      filename = \"C-small-attempt0.in\"\n  \n  \n      inp = open(filename, \"rU\")\n  \n      n = int(inp.readline().strip())\n  \n      for case in range(1, n + 1):\n          R, C, M = map(int, inp.readline().strip().split(\" \"))\n          state = [[1 for x in range(C)] for y in range(R)]\n          print(\"Case #{}:\".format(case))\n          solve(state, M)\n  \n  main()\n ", "Adversarial Code": " \n  def check_bounds(state, coord):\n      if coord[0] < 0 or coord[1] < 0:\n          return False\n      elif coord[0] > (len(state) - 1):\n          return False\n      elif coord[1] > (len(state[coord[0]]) - 1):\n          return False\n      else:\n          return True\n  \n  def clear(state, coord):\n      for r in range(-1,2):\n          for c in range(-1,2):\n              row = coord[0] + r\n              col = coord[1] + c\n              if check_bounds(state, (row, col)):\n                  state[row][col] = 0\n  \n  def count(state):\n      return sum([sum(x) for x in state])\n  \n  def state_print(state):\n      print(\"c\" + \"\".join([\"*\"  if x else \".\" for x in state[0][1:]]))\n      for line in state[1:]:\n          print(\"\".join([\"*\"  if x else \".\" for x in line]))\n  \n  def solve(state, mines):\n      prev_state = deepcopy(state)\n      for row in range(len(state)):\n          for col in range(len(state[row])):\n              new_state = deepcopy(state)\n              clear(new_state, (row, col))\n              c = count(new_state)\n              if(c < mines):\n                  state = prev_state\n              elif( c == mines):\n                  state_print(new_state)\n                  return True\n              else:\n                  if col == len(state[row]) -2:\n                      prev_state = deepcopy(state)\n                  state = new_state\n      print(\"Impossible\")\n      return False\n  \n  \n  \n  \n  def main():\n      RECURSION_LIMIT = \"C-small-attempt0.in\"\n  \n  \n      first_row_index = open(RECURSION_LIMIT, \"rU\")\n  \n      n = int(first_row_index.readline().strip())\n  \n      for case in range(1, n + 1):\n          R, C, M = map(int, first_row_index.readline().strip().split(\" \"))\n          state = [[1 for x in range(C)] for y in range(R)]\n          print(\"Case #{}:\".format(case))\n          solve(state, M)\n  \n  main()\n ", "Program Length": 438, "Identifier Num": 25, "Replaced Identifiers": "filename:RECURSION_LIMIT,inp:first_row_index,", "Query Times": 150, "Time Cost": 0.06412407954533896, "Type": "wir"}
{"Index": 91, "Original Code": " \n  filename = \"A-small-attempt0.in\"\n  \n  inp = open(filename, \"rU\")\n  \n  n = int(inp.readline().strip())\n  \n  for case in range(1, n+1):\n      gr = lambda x: [list(map(int, inp.readline().strip().split(\" \"))) for p in range(4)][x-1]\n      ans1 = int(inp.readline().strip())\n      row1 = set(gr(ans1))\n      ans2 = int(inp.readline().strip())\n      row2 = set(gr(ans2))\n      sect = row1 & row2\n      if len(sect) <= 0:\n          print(\"Case #{}: Volunteer cheated!\".format(case))\n      elif len(sect) == 1:\n          print(\"Case #{}: {}\".format(case, sect.pop()))\n      elif len(sect) > 1:\n          print(\"Case #{}: Bad magician!\".format(case))\n      else:\n          print(\"ERROR\")\n ", "Adversarial Code": " \n  answers = \"A-small-attempt0.in\"\n  \n  with = open(answers, \"rU\")\n  \n  n = int(with.readline().strip())\n  \n  for case in range(1, n+1):\n      gr = lambda x: [list(map(int, with.readline().strip().split(\" \"))) for p in range(4)][x-1]\n      ans1 = int(with.readline().strip())\n      row1 = set(gr(ans1))\n      ans2 = int(with.readline().strip())\n      row2 = set(gr(ans2))\n      sect = row1 & row2\n      if len(sect) <= 0:\n          print(\"Case #{}: Volunteer cheated!\".format(case))\n      elif len(sect) == 1:\n          print(\"Case #{}: {}\".format(case, sect.pop()))\n      elif len(sect) > 1:\n          print(\"Case #{}: Bad magician!\".format(case))\n      else:\n          print(\"ERROR\")\n ", "Program Length": 192, "Identifier Num": 11, "Replaced Identifiers": "filename:answers,inp:with,", "Query Times": 93, "Time Cost": 0.03838431437810262, "Type": "wir"}
{"Index": 92, "Original Code": " \n  def transpose(result, R, C):\n  \tresultSplitted = result.split(\"\n\")\n  \taux = R*[\"\"]\n  \tfor i in xrange(R):\n  \t\tfor j in xrange(C):\n  \t\t    aux[i] += resultSplitted[j][i]\n  \t\taux[i] += \"\n\"\n  \tresult = \"\"\n  \tfor item in aux:\n  \t\tresult += item + \"\n\"\n  \treturn result.strip()\n  \n  \n  inputFileName = sys.argv[1]\n  \n  f = file(inputFileName)\n  fout = file(\"output.txt\", \"w\")\n  \n  T = int(f.readline())\n  \n  for case in xrange(T):\n  \tdata = f.readline().strip().split(\" \")\n  \tR = int(data[0])\n  \tC = int(data[1])\n  \tM = int(data[2])\n  \n  \tresult = \"\"\n  \n  \tx = min(R,C)\n  \ty = max(R,C)\n  \n  \tif M > (y - 2)*x and M != y*x - 1:\n  \t\tN = M - (y-2)*x\n  \t\tif N%2 == 1 or y*x - M == 2:\n  \t\t\tresult = \"Impossible\"\n  \tif result != \"Impossible\":\n  \t\ti = 0\n  \t\twhile M > 0: # 2\n  \t\t\tif i < y - 2:\n  \t\t\t\tif M >= x:\n  \t\t\t\t\tresult += x*\"*\" + \"\n\"\n  \t\t\t\t\tM -= x\n  \t\t\t\t\ti += 1\n  \t\t\t\telif M <= x - 2:\n  \t\t\t\t\tresult += M*\"*\" + (x - M) * \".\" + \"\n\"\n  \t\t\t\t\tM = 0\n  \t\t\t\t\ti += 1\n  \t\t\t\telif i + 2 < y - 1:\n  \t\t\t\t\tresult += (M-1)*\"*\" + (x - M + 1) * \".\" + \"\n\" + \"*\" + (x-1)*\".\" + \"\n\"\n  \t\t\t\t\tM = 0\n  \t\t\t\t\ti += 2\n  \t\t\t\telse:\n  \t\t\t\t\tresult = \"Impossible\"\n  \t\t\t\t\tbreak\n  \t\t\telse:\n  \t\t\t\tif M%2 != 0:\n  \t\t\t\t\tresult += x*\"*\" + \"\n\"\n  \t\t\t\t\tresult += (x-1)*\"*\" + \"c\"\n  \t\t\t\telse:\n  \t\t\t\t\tn = M/2\n  \t\t\t\t\tresult += n*\"*\" + (x-n)*\".\" + \"\n\"\n  \t\t\t\t\tresult += n*\"*\" + (x-n-1)*\".\" + \"c\"\n  \t\t\t\tM = 0\n  \t\t\t\ti += 2\n  \t\t\t\t\t\n  \t\twhile i <= y - 1 and result != \"Impossible\":\n  \t\t\tif i == y - 1:\n  \t\t\t\tresult += (x-1)*\".\" + \"c\"\n  \t\t\telse:\n  \t\t\t\tresult += x*\".\" + \"\n\"\n  \t\t\ti += 1\n  \t\n  \tif R < C and result != \"Impossible\":\n  \t\tresult = transpose(result, R, C)\n  \n  \tfout.write(\"Case #%d:\n%s\n\" %(case + 1, result))\n ", "Adversarial Code": " \n  def transpose(result, R, C):\n  \tiCase = result.split(\"\n\")\n  \taux = R*[\"\"]\n  \tfor i in xrange(R):\n  \t\tfor j in xrange(C):\n  \t\t    aux[i] += iCase[j][i]\n  \t\taux[i] += \"\n\"\n  \tresult = \"\"\n  \tfor item in aux:\n  \t\tresult += item + \"\n\"\n  \treturn result.strip()\n  \n  \n  RECURSION_LIMIT = sys.argv[1]\n  \n  do_trial = file(RECURSION_LIMIT)\n  answer1 = file(\"output.txt\", \"w\")\n  \n  T = int(do_trial.readline())\n  \n  for case in xrange(T):\n  \tdata = do_trial.readline().strip().split(\" \")\n  \tR = int(data[0])\n  \tC = int(data[1])\n  \tM = int(data[2])\n  \n  \tresult = \"\"\n  \n  \tx = min(R,C)\n  \ty = max(R,C)\n  \n  \tif M > (y - 2)*x and M != y*x - 1:\n  \t\tN = M - (y-2)*x\n  \t\tif N%2 == 1 or y*x - M == 2:\n  \t\t\tresult = \"Impossible\"\n  \tif result != \"Impossible\":\n  \t\ti = 0\n  \t\twhile M > 0: # 2\n  \t\t\tif i < y - 2:\n  \t\t\t\tif M >= x:\n  \t\t\t\t\tresult += x*\"*\" + \"\n\"\n  \t\t\t\t\tM -= x\n  \t\t\t\t\ti += 1\n  \t\t\t\telif M <= x - 2:\n  \t\t\t\t\tresult += M*\"*\" + (x - M) * \".\" + \"\n\"\n  \t\t\t\t\tM = 0\n  \t\t\t\t\ti += 1\n  \t\t\t\telif i + 2 < y - 1:\n  \t\t\t\t\tresult += (M-1)*\"*\" + (x - M + 1) * \".\" + \"\n\" + \"*\" + (x-1)*\".\" + \"\n\"\n  \t\t\t\t\tM = 0\n  \t\t\t\t\ti += 2\n  \t\t\t\telse:\n  \t\t\t\t\tresult = \"Impossible\"\n  \t\t\t\t\tbreak\n  \t\t\telse:\n  \t\t\t\tif M%2 != 0:\n  \t\t\t\t\tresult += x*\"*\" + \"\n\"\n  \t\t\t\t\tresult += (x-1)*\"*\" + \"c\"\n  \t\t\t\telse:\n  \t\t\t\t\tn = M/2\n  \t\t\t\t\tresult += n*\"*\" + (x-n)*\".\" + \"\n\"\n  \t\t\t\t\tresult += n*\"*\" + (x-n-1)*\".\" + \"c\"\n  \t\t\t\tM = 0\n  \t\t\t\ti += 2\n  \t\t\t\t\t\n  \t\twhile i <= y - 1 and result != \"Impossible\":\n  \t\t\tif i == y - 1:\n  \t\t\t\tresult += (x-1)*\".\" + \"c\"\n  \t\t\telse:\n  \t\t\t\tresult += x*\".\" + \"\n\"\n  \t\t\ti += 1\n  \t\n  \tif R < C and result != \"Impossible\":\n  \t\tresult = transpose(result, R, C)\n  \n  \tanswer1.write(\"Case #%d:\n%s\n\" %(case + 1, result))\n ", "Program Length": 498, "Identifier Num": 20, "Replaced Identifiers": "inputFileName:RECURSION_LIMIT,fout:answer1,resultSplitted:iCase,f:do_trial,", "Query Times": 252, "Time Cost": 0.1091114640235901, "Type": "wir"}
{"Index": 93, "Original Code": " \n  inputFileName = sys.argv[1]\n  \n  f = file(inputFileName)\n  fout = file(\"output.txt\", \"w\")\n  \n  T = eval(f.readline())\n  \n  for case in xrange(T):\n  \n  \tA1 = int(f.readline().strip())\n  \n  \tfor i in xrange(4):\n  \t\tif i == A1 - 1:\n  \t\t\tpossibles1 = f.readline().strip().split(\" \")\n  \t\telse:\n  \t\t\tf.readline().strip().split(\" \")\n  \n  \tA2 = int(f.readline().strip())\n  \n  \tfor i in xrange(4):\n  \t\tif i == A2 - 1:\n  \t\t\tpossibles2 = f.readline().strip().split(\" \")\n  \t\telse:\n  \t\t\tf.readline().strip().split(\" \")\n  \n  \tfinal = []\n  \tfor item in possibles2:\n  \t\tif item in possibles1:\n  \t\t\tfinal.append(item)\n  \n  \tif len(final) == 0:\t\n  \t\tfout.write(\"Case #%d: Volunteer cheated!\n\" %(case + 1))\n  \telif len(final) == 1:\n  \t\tfout.write(\"Case #%d: %s\n\" %(case + 1, final[0]))\n  \telse:\n  \t\tfout.write(\"Case #%d: Bad magician!\n\" %(case + 1))\n ", "Adversarial Code": " \n  outfile = sys.argv[1]\n  \n  f = file(outfile)\n  fout = file(\"output.txt\", \"w\")\n  \n  answer = eval(f.readline())\n  \n  for case in xrange(answer):\n  \n  \tA1 = int(f.readline().strip())\n  \n  \tfor i in xrange(4):\n  \t\tif i == A1 - 1:\n  \t\t\tpossibles1 = f.readline().strip().split(\" \")\n  \t\telse:\n  \t\t\tf.readline().strip().split(\" \")\n  \n  \tA2 = int(f.readline().strip())\n  \n  \tfor i in xrange(4):\n  \t\tif i == A2 - 1:\n  \t\t\tpossibles2 = f.readline().strip().split(\" \")\n  \t\telse:\n  \t\t\tf.readline().strip().split(\" \")\n  \n  \tfinal = []\n  \tfor item in possibles2:\n  \t\tif item in possibles1:\n  \t\t\tfinal.append(item)\n  \n  \tif len(final) == 0:\t\n  \t\tfout.write(\"Case #%d: Volunteer cheated!\n\" %(case + 1))\n  \telif len(final) == 1:\n  \t\tfout.write(\"Case #%d: %s\n\" %(case + 1, final[0]))\n  \telse:\n  \t\tfout.write(\"Case #%d: Bad magician!\n\" %(case + 1))\n ", "Program Length": 248, "Identifier Num": 10, "Replaced Identifiers": "inputFileName:outfile,T:answer,", "Query Times": 99, "Time Cost": 0.04111156066258748, "Type": "wir"}
{"Index": 94, "Original Code": " \n  \n  EOL = \"\n\"\n  \n  \n  def is_equal_approx(x, y, epsilon=1e-6):\n      \"\"\"Returns True iff y is within relative or absolute 'epsilon' of x.\n      \n      By default, 'epsilon' is 1e-6.\n      \"\"\"\n      if -epsilon <= x - y <= epsilon:\n          return True\n  \n      if -epsilon <= x <= epsilon or -epsilon <= y <= epsilon:\n          return False\n  \n      return (-epsilon <= (x - y) / x <= epsilon\n          or -epsilon <= (x - y) / y <= epsilon)\n    \n  def read_syms(fd):\n      \"\"\"Read a line of whitespace separated symbols.\"\"\"\n      return fd.readline().strip().split()\n  \n  def read_ints(fd):\n      \"\"\"Read a line of whitespace separated integers.\"\"\"\n      return [int(p) for p in read_syms(fd)]\n  \n  def read_floats(fd):\n      \"\"\"Read a line of whitespace separated floats.\"\"\"\n      return [float(p) for p in read_syms(fd)]\n  \n  \n  class Mtrx(object):\n      \"\"\"A matrix object.\"\"\"\n      \n      def __init__(self, rows, cols, data):\n          assert len(data) == rows * cols\n          self.rows = rows\n          self.cols = cols\n          self.data = data\n          \n      def cell(self, r, c):\n          return self.data[r * self.cols + c]\n      \n      def getrow(self, i):\n          return [self.cell(i, c) for c in xrange(self.cols)]\n  \n      def getcol(self, i):\n          return [self.cell(c, i) for c in xrange(self.rows)]\n      \n      @classmethod\n      def readfromfile(cls, fd, readfunc, rows=None, cols=None):\n          \"\"\"Read matrix from file, assuming first line at location is `R C`.\n          \n          Return a new Mtrx object. Reading values is performed by the `readfunc`.\n          Pre-determined size can be passed using `rows` and `cols`.\n          \"\"\"\n          data = []\n          if rows is None:\n              assert cols is None\n              rows, cols = read_ints(fd)\n          else:\n              assert cols is not None\n          for _ in range(rows):\n              line = readfunc(fd)\n              assert len(line) == cols\n              data.extend(line)\n          return Mtrx(rows, cols, data)\n              \n      @classmethod\n      def read_int_matrix(cls, fd, rows=None, cols=None):\n          return cls.readfromfile(fd, read_ints, rows, cols)\n              \n      @classmethod\n      def read_sym_matrix(cls, fd, rows=None, cols=None):\n          return cls.readfromfile(fd, read_syms, rows, cols)\n              \n      def __str__(self):\n          res = \"\"\n          for i in xrange(self.rows):\n              res += str(self.getrow(i)) + EOL\n          return res\n      \n      def __repr__(self):\n          return \"{}({}, {}, {})\".format(self.__class__.__name__, self.rows,\n                                         self.cols, self.data)\n  \n  \n  cachetotals = 0\n  cachemisses = 0\n  \n  def statreset():\n      global cachemisses, cachetotals\n      cachemisses = 0\n      cachetotals = 0\n  \n  class memoizeit(object):\n      \"\"\"Decorator. Caches a function's return value each time it is called.\n      \n      If called later with the same arguments, the cached value is returned \n      (not reevaluated).\n      \"\"\"\n      \n      def __init__(self, func):\n          self.func = func\n          self.cache = {}\n          \n      def __call__(self, *args):\n          \n          global cachetotals, cachemisses\n          cachetotals += 1\n          \n          try:\n              return self.cache[args]\n          except KeyError:\n              \n              cachemisses += 1\n              \n              value = self.func(*args)\n              self.cache[args] = value\n              return value\n          except TypeError:\n  \n              cachemisses += 1\n  \n              return self.func(*args)\n      \n      @property\n      def __name__(self):\n          return self.func.__name__\n      \n      def __get__(self, obj, objtype):\n          \"\"\"Support instance methods.\"\"\"\n          return functools.partial(self.__call__, obj)\n  \n  \n  class timeit(object):\n      \"\"\"Decorator that times a function.\n      \n      When function ends, print name, runtime, return value and cache stats.\n      \"\"\"\n      \n      def __init__(self, func):\n          self.func = func\n          \n      def __call__(self, *args):\n          start = time.time()\n          value = self.func(*args)\n          delta = time.time() - start\n          cachedata = (1 - cachemisses/(cachetotals * 1.0)) if \\\n              cachetotals else 0\n          print self.func.__name__, \"{:7.3f}s, (res: {}, cache: {:.2%})\".format(\n              delta, value, cachedata)\n          return value\n      \n      def __get__(self, obj, objtype):\n          return functools.partial(self.__call__, obj)\n  \n  \n  def read_input(filename):\n      data = []\n      with open(filename, \"r\") as f:\n          cases = read_ints(f)[0]\n          for _ in xrange(cases):\n              case = {}\n              case[\"R\"], case[\"C\"], case[\"M\"] = read_ints(f)\n              data.append(case)\n      return data\n  \n  def make_output(fname, output):\n      CASE_PRFX = \"Case #%s: \"\n      fname = fname + time.strftime(\"%H%M%S\") + \".out\"\n      with open(fname, \"w\") as f:\n          restext = []\n          print \"Output content ===============\"\n          for i, outdata in enumerate(output):\n              line = CASE_PRFX % (i + 1,) + EOL + str(outdata) + EOL\n              print line,\n              restext.append(line)\n          print \"=\" * 30\n          f.writelines(restext)\n  \n  \n  MINE = \"*\"\n  CLICK = \"c\"\n  UNK = \".\"\n  \n  class Board(object):\n      \n      def __init__(self, r, c):\n          self.rows = r\n          self.cols = c\n          self.edge_row_idx = self.rows - 1\n          self.edge_col_idx = self.cols - 1\n          self.board = [[UNK for _ in xrange(c)] for _ in xrange(r)]\n          self.board[0][0] = CLICK\n  \n      def fill_edge_row(self, m):\n          i = self.edge_col_idx\n          while m > 0 and i >= 0:\n              self.board[self.edge_row_idx][i] = MINE\n              i -= 1\n              m -= 1\n          self.edge_row_idx -= 1\n  \n      def fill_edge_col(self, m):\n          i = self.edge_row_idx\n          while m > 0 and i >= 0:\n              self.board[i][self.edge_col_idx] = MINE\n              i -= 1\n              m -= 1\n          self.edge_col_idx -= 1\n  \n      def __str__(self):\n          return EOL.join([\"\".join(r) for r in self.board])\n  \n  @memoizeit\n  def is_stage_solvable(rows, cols, mines):\n      \"\"\"Return True iff stage is solvable. \n      Also return fill instruction:\n      0 if impossible/dontcare, 1 to fill row, 2 to fill column, \n      3 for row special (most in the row), 4 for col special (most in the col)\n      \"\"\"\n      rc = rows * cols\n      \n      if mines == rc:\n          return False, 0\n  \n      if rows == 1:\n          return mines <= rc - 1, 2\n      if cols == 1:\n          return mines <= rc - 1, 1\n      \n      if mines == rc - 1:\n          return True, 1  # doesn't matter what to fill\n      \n      if mines > rc - 4:\n          return False, 0\n      \n      if rows == 2:\n          return (False, 0) if mines == 1 else (True, 2)\n      if cols == 2:\n          return (False, 0) if mines == 1 else (True, 1)\n          \n      if rows <= cols:\n          if mines >= rows:\n              return True, 2\n          if mines == rows - 1:\n              if mines == cols - 1:\n                  if rows == 3:\n                      return False, 0\n                  return True, 4 # L shape fill, most in the column\n              else:\n                  return True, 1 # fill row\n          return True, 2 \n      else:\n          if mines >= cols:\n              return True, 1\n          if mines == cols - 1:\n              if mines == rows - 1:\n                  if cols == 3:\n                      return False, 0\n                  return True, 3 # L shape fill, most in the row\n              else:\n                  return True, 2 # fill column\n          return True, 1 \n  \n  @timeit\n  def solveit(case):\n      rows = case[\"R\"]\n      cols = case[\"C\"]\n      mines = case[\"M\"]\n      \n      b = Board(rows, cols)\n      r, c, m = rows, cols, mines\n      \n      while m >= 0:\n          okgo, howtofill = is_stage_solvable(r, c, m)\n          if not okgo:\n              return \"Impossible\"\n          if howtofill == 1: # fill row\n              b.fill_edge_row(m)\n              if m <= c:\n                  break # fill and done\n              m -= c\n              r -= 1\n          elif howtofill == 2: # fill column\n              b.fill_edge_col(m)\n              if m <= r:\n                  break # fill and done\n              m -= r\n              c -= 1\n          elif howtofill == 3: # L shape fill, most in the row\n              b.fill_edge_row(m - 1)\n              b.fill_edge_col(1)\n              break # fill and done\n          elif howtofill == 4: # L shape fill, most in the column\n              b.fill_edge_col(m - 1)\n              b.fill_edge_row(1)\n              break # fill and done\n          else:\n              assert False\n  \n      return str(b) \n  \n  \n  \n  @timeit\n  def main(fname):\n      data = read_input(fname)\n      output = []\n      for case in data:\n          statreset() # reset cache stats\n          res = solveit(case)\n          output.append(res)\n      make_output(fname, output)\n  \n  \n  if __name__ == '__main__':\n      main(\"C-small-attempt0.in\")\n ", "Adversarial Code": " \n  \n  EOL = \"\n\"\n  \n  \n  def is_equal_approx(x, y, epsilon=1e-6):\n      \"\"\"Returns True iff y is within relative or absolute 'epsilon' of x.\n      \n      By default, 'epsilon' is 1e-6.\n      \"\"\"\n      if -epsilon <= x - y <= epsilon:\n          return True\n  \n      if -epsilon <= x <= epsilon or -epsilon <= y <= epsilon:\n          return False\n  \n      return (-epsilon <= (x - y) / x <= epsilon\n          or -epsilon <= (x - y) / y <= epsilon)\n    \n  def read_syms(lp):\n      \"\"\"Read a line of whitespace separated symbols.\"\"\"\n      return lp.readline().strip().split()\n  \n  def read_ints(lp):\n      \"\"\"Read a line of whitespace separated integers.\"\"\"\n      return [int(subboard) for subboard in read_syms(lp)]\n  \n  def read_floats(lp):\n      \"\"\"Read a line of whitespace separated floats.\"\"\"\n      return [float(subboard) for subboard in read_syms(lp)]\n  \n  \n  class Mtrx(object):\n      \"\"\"A matrix object.\"\"\"\n      \n      def __init__(self, try, over_three_line_builder, Bad):\n          assert len(Bad) == try * over_three_line_builder\n          self.try = try\n          self.over_three_line_builder = over_three_line_builder\n          self.Bad = Bad\n          \n      def cell(self, test_case, c):\n          return self.Bad[test_case * self.over_three_line_builder + c]\n      \n      def getrow(self, myCases):\n          return [self.cell(myCases, c) for c in xrange(self.over_three_line_builder)]\n  \n      def getcol(self, myCases):\n          return [self.cell(c, myCases) for c in xrange(self.try)]\n      \n      @classmethod\n      def readfromfile(answer_cells, lp, readfunc, try=None, over_three_line_builder=None):\n          \"\"\"Read matrix from file, assuming first line at location is `R C`.\n          \n          Return a new Mtrx object. Reading values is performed by the `readfunc`.\n          Pre-determined size can be passed using `rows` and `cols`.\n          \"\"\"\n          Bad = []\n          if try is None:\n              assert over_three_line_builder is None\n              try, over_three_line_builder = read_ints(lp)\n          else:\n              assert over_three_line_builder is not None\n          for _ in range(try):\n              line = readfunc(lp)\n              assert len(line) == over_three_line_builder\n              Bad.extend(line)\n          return Mtrx(try, over_three_line_builder, Bad)\n              \n      @classmethod\n      def read_int_matrix(answer_cells, lp, try=None, over_three_line_builder=None):\n          return answer_cells.readfromfile(lp, read_ints, try, over_three_line_builder)\n              \n      @classmethod\n      def read_sym_matrix(answer_cells, lp, try=None, over_three_line_builder=None):\n          return answer_cells.readfromfile(lp, read_syms, try, over_three_line_builder)\n              \n      def __str__(self):\n          res = \"\"\n          for myCases in xrange(self.try):\n              res += str(self.getrow(myCases)) + EOL\n          return res\n      \n      def __repr__(self):\n          return \"{}({}, {}, {})\".format(self.__class__.__name__, self.try,\n                                         self.over_three_line_builder, self.Bad)\n  \n  \n  cachetotals = 0\n  cachemisses = 0\n  \n  def statreset():\n      global cachemisses, cachetotals\n      cachemisses = 0\n      cachetotals = 0\n  \n  class memoizeit(object):\n      \"\"\"Decorator. Caches a function's return value each time it is called.\n      \n      If called later with the same arguments, the cached value is returned \n      (not reevaluated).\n      \"\"\"\n      \n      def __init__(self, func):\n          self.func = func\n          self.cache = {}\n          \n      def __call__(self, *args):\n          \n          global cachetotals, cachemisses\n          cachetotals += 1\n          \n          try:\n              return self.cache[args]\n          except KeyError:\n              \n              cachemisses += 1\n              \n              value = self.func(*args)\n              self.cache[args] = value\n              return value\n          except TypeError:\n  \n              cachemisses += 1\n  \n              return self.func(*args)\n      \n      @property\n      def __name__(self):\n          return self.func.__name__\n      \n      def __get__(self, obj, objtype):\n          \"\"\"Support instance methods.\"\"\"\n          return functools.partial(self.__call__, obj)\n  \n  \n  class timeit(object):\n      \"\"\"Decorator that times a function.\n      \n      When function ends, print name, runtime, return value and cache stats.\n      \"\"\"\n      \n      def __init__(self, func):\n          self.func = func\n          \n      def __call__(self, *args):\n          start = time.time()\n          value = self.func(*args)\n          delta = time.time() - start\n          cachedata = (1 - cachemisses/(cachetotals * 1.0)) if \\\n              cachetotals else 0\n          print self.func.__name__, \"{:7.3f}s, (res: {}, cache: {:.2%})\".format(\n              delta, value, cachedata)\n          return value\n      \n      def __get__(self, obj, objtype):\n          return functools.partial(self.__call__, obj)\n  \n  \n  def read_input(filename):\n      Bad = []\n      with open(filename, \"r\") as f:\n          cases = read_ints(f)[0]\n          for _ in xrange(cases):\n              case = {}\n              case[\"R\"], case[\"C\"], case[\"M\"] = read_ints(f)\n              Bad.append(case)\n      return Bad\n  \n  def make_output(fname, output):\n      CASE_PRFX = \"Case #%s: \"\n      fname = fname + time.strftime(\"%H%M%S\") + \".out\"\n      with open(fname, \"w\") as f:\n          restext = []\n          print \"Output content ===============\"\n          for myCases, outdata in enumerate(output):\n              line = CASE_PRFX % (myCases + 1,) + EOL + str(outdata) + EOL\n              print line,\n              restext.append(line)\n          print \"=\" * 30\n          f.writelines(restext)\n  \n  \n  MINE = \"*\"\n  CLICK = \"c\"\n  UNK = \".\"\n  \n  class Board(object):\n      \n      def __init__(self, test_case, c):\n          self.try = test_case\n          self.over_three_line_builder = c\n          self.edge_row_idx = self.try - 1\n          self.edge_col_idx = self.over_three_line_builder - 1\n          self.board = [[UNK for _ in xrange(c)] for _ in xrange(test_case)]\n          self.board[0][0] = CLICK\n  \n      def fill_edge_row(self, m):\n          myCases = self.edge_col_idx\n          while m > 0 and myCases >= 0:\n              self.board[self.edge_row_idx][myCases] = MINE\n              myCases -= 1\n              m -= 1\n          self.edge_row_idx -= 1\n  \n      def fill_edge_col(self, m):\n          myCases = self.edge_row_idx\n          while m > 0 and myCases >= 0:\n              self.board[myCases][self.edge_col_idx] = MINE\n              myCases -= 1\n              m -= 1\n          self.edge_col_idx -= 1\n  \n      def __str__(self):\n          return EOL.join([\"\".join(test_case) for test_case in self.board])\n  \n  @memoizeit\n  def is_stage_solvable(try, over_three_line_builder, mines):\n      \"\"\"Return True iff stage is solvable. \n      Also return fill instruction:\n      0 if impossible/dontcare, 1 to fill row, 2 to fill column, \n      3 for row special (most in the row), 4 for col special (most in the col)\n      \"\"\"\n      rc = try * over_three_line_builder\n      \n      if mines == rc:\n          return False, 0\n  \n      if try == 1:\n          return mines <= rc - 1, 2\n      if over_three_line_builder == 1:\n          return mines <= rc - 1, 1\n      \n      if mines == rc - 1:\n          return True, 1  # doesn't matter what to fill\n      \n      if mines > rc - 4:\n          return False, 0\n      \n      if try == 2:\n          return (False, 0) if mines == 1 else (True, 2)\n      if over_three_line_builder == 2:\n          return (False, 0) if mines == 1 else (True, 1)\n          \n      if try <= over_three_line_builder:\n          if mines >= try:\n              return True, 2\n          if mines == try - 1:\n              if mines == over_three_line_builder - 1:\n                  if try == 3:\n                      return False, 0\n                  return True, 4 # L shape fill, most in the column\n              else:\n                  return True, 1 # fill row\n          return True, 2 \n      else:\n          if mines >= over_three_line_builder:\n              return True, 1\n          if mines == over_three_line_builder - 1:\n              if mines == try - 1:\n                  if over_three_line_builder == 3:\n                      return False, 0\n                  return True, 3 # L shape fill, most in the row\n              else:\n                  return True, 2 # fill column\n          return True, 1 \n  \n  @timeit\n  def solveit(case):\n      try = case[\"R\"]\n      over_three_line_builder = case[\"C\"]\n      mines = case[\"M\"]\n      \n      b = Board(try, over_three_line_builder)\n      test_case, c, m = try, over_three_line_builder, mines\n      \n      while m >= 0:\n          okgo, howtofill = is_stage_solvable(test_case, c, m)\n          if not okgo:\n              return \"Impossible\"\n          if howtofill == 1: # fill row\n              b.fill_edge_row(m)\n              if m <= c:\n                  break # fill and done\n              m -= c\n              test_case -= 1\n          elif howtofill == 2: # fill column\n              b.fill_edge_col(m)\n              if m <= test_case:\n                  break # fill and done\n              m -= test_case\n              c -= 1\n          elif howtofill == 3: # L shape fill, most in the row\n              b.fill_edge_row(m - 1)\n              b.fill_edge_col(1)\n              break # fill and done\n          elif howtofill == 4: # L shape fill, most in the column\n              b.fill_edge_col(m - 1)\n              b.fill_edge_row(1)\n              break # fill and done\n          else:\n              assert False\n  \n      return str(b) \n  \n  \n  \n  @timeit\n  def main(fname):\n      Bad = read_input(fname)\n      output = []\n      for case in Bad:\n          statreset() # reset cache stats\n          res = solveit(case)\n          output.append(res)\n      make_output(fname, output)\n  \n  \n  if __name__ == '__main__':\n      main(\"C-small-attempt0.in\")\n ", "Program Length": 1508, "Identifier Num": 28, "Replaced Identifiers": "cols:over_three_line_builder,cls:answer_cells,data:Bad,rows:try,i:myCases,fd:lp,p:subboard,r:test_case,", "Query Times": 516, "Time Cost": 0.28497207164764404, "Type": "wir"}
{"Index": 95, "Original Code": null, "Adversarial Code": null, "Program Length": 717, "Identifier Num": 28, "Replaced Identifiers": null, "Query Times": 843, "Time Cost": 0.40188370148340863, "Type": "0"}
{"Index": 97, "Original Code": null, "Adversarial Code": null, "Program Length": 102, "Identifier Num": 7, "Replaced Identifiers": null, "Query Times": 102, "Time Cost": 0.03950364589691162, "Type": "0"}
{"Index": 98, "Original Code": " \n  \n  ncases = int(sys.stdin.readline().strip())\n  \n  def print_board(r, c, free):\n      board = {}\n      for row in range(0, r):\n          board[row] = {}\n          for col in range(0, c):\n              board[row][col] = '*'\n  \n      pending = free\n  \n      if free == 1:\n          board[0][0] = '.'\n      elif r == 1 or c == 1:\n          for row in range(0, r):\n              for col in range(0, c):\n                  if pending > 0:\n                      pending -= 1\n                      board[row][col] = '.'\n      else:\n          for row in range(0,2):\n              for col in range(0,2):\n                  board[row][col] = '.'\n          pending -= 4\n          col=2\n          row=2\n  \n          while pending >= 2 and (col<c or row<r):\n              if pending >= 2 and col<c:\n                  board[0][col] = '.'\n                  board[1][col] = '.'\n                  col += 1\n                  pending -= 2\n              if pending >= 2 and row<r:\n                  board[row][0] = '.'\n                  board[row][1] = '.'\n                  row += 1\n                  pending -= 2\n  \n          for row in range(2, r):\n              for col in range(2, c):\n                  if pending > 0:\n                      board[row][col] = '.'\n                      pending -= 1\n  \n      board[0][0] = 'c'\n  \n      for row in range(0, r):\n          line = ''\n          for col in range(0, c):\n              line += board[row][col]\n          print(line)\n  \n  \n  for t in range(1, ncases+1):\n      values = sys.stdin.readline().strip().split()\n      r = int(values[0])\n      c = int(values[1])\n      m = int(values[2])\n  \n      cells = r * c\n      free = cells - m\n  \n      possible = False\n  \n      if r == 1 or c == 1:\n          if free >= 1:\n              possible = True\n      elif r == 2 or c == 2:\n          if free == 1 or (free >= 4 and free%2 == 0):\n              possible = True\n      else:\n          if free == 1 or (free >= 4 and free != 5 and free != 7):\n              possible = True\n  \n      print(\"Case #{0}:\".format(t))\n  \n      if possible:\n          print_board(r, c, free)\n      else:\n          print(\"Impossible\")\n ", "Adversarial Code": " \n  \n  lastRowNum = int(sys.stdin.readline().strip())\n  \n  def print_board(r, c, free):\n      board = {}\n      for row in range(0, r):\n          board[row] = {}\n          for col in range(0, c):\n              board[row][col] = '*'\n  \n      pending = free\n  \n      if free == 1:\n          board[0][0] = '.'\n      elif r == 1 or c == 1:\n          for row in range(0, r):\n              for col in range(0, c):\n                  if pending > 0:\n                      pending -= 1\n                      board[row][col] = '.'\n      else:\n          for row in range(0,2):\n              for col in range(0,2):\n                  board[row][col] = '.'\n          pending -= 4\n          col=2\n          row=2\n  \n          while pending >= 2 and (col<c or row<r):\n              if pending >= 2 and col<c:\n                  board[0][col] = '.'\n                  board[1][col] = '.'\n                  col += 1\n                  pending -= 2\n              if pending >= 2 and row<r:\n                  board[row][0] = '.'\n                  board[row][1] = '.'\n                  row += 1\n                  pending -= 2\n  \n          for row in range(2, r):\n              for col in range(2, c):\n                  if pending > 0:\n                      board[row][col] = '.'\n                      pending -= 1\n  \n      board[0][0] = 'c'\n  \n      for row in range(0, r):\n          line = ''\n          for col in range(0, c):\n              line += board[row][col]\n          print(line)\n  \n  \n  for t in range(1, lastRowNum+1):\n      values = sys.stdin.readline().strip().split()\n      r = int(values[0])\n      c = int(values[1])\n      m = int(values[2])\n  \n      cells = r * c\n      free = cells - m\n  \n      possible = False\n  \n      if r == 1 or c == 1:\n          if free >= 1:\n              possible = True\n      elif r == 2 or c == 2:\n          if free == 1 or (free >= 4 and free%2 == 0):\n              possible = True\n      else:\n          if free == 1 or (free >= 4 and free != 5 and free != 7):\n              possible = True\n  \n      print(\"Case #{0}:\".format(t))\n  \n      if possible:\n          print_board(r, c, free)\n      else:\n          print(\"Impossible\")\n ", "Program Length": 497, "Identifier Num": 15, "Replaced Identifiers": "ncases:lastRowNum,", "Query Times": 149, "Time Cost": 0.062181520462036136, "Type": "wir"}
{"Index": 99, "Original Code": " \n  \n  ncases = int(sys.stdin.readline().strip())\n  \n  def read_arrangement():\n      arr = []\n      for row in range(0,4):\n          arr.append(sys.stdin.readline().strip().split(' '))\n      return arr\n  \n  for t in range(1, ncases+1):\n      answer1 = int(sys.stdin.readline().strip())\n      arrang1 = read_arrangement()\n      answer2 = int(sys.stdin.readline().strip())\n      arrang2 = read_arrangement()\n  \n      row1 = arrang1[answer1-1]\n      row2 = arrang2[answer2-1]\n  \n      intersect = set(row1) & set(row2)\n  \n      if len(intersect) == 1:\n          print(\"Case #{0}: {1}\".format(t, intersect.pop()))\n      elif len(intersect) == 0:\n          print(\"Case #{0}: Volunteer cheated!\".format(t))\n      else:\n          print(\"Case #{0}: Bad magician!\".format(t))\n ", "Adversarial Code": " \n  \n  arguments = int(sys.stdin.readline().strip())\n  \n  def read_arrangement():\n      arr = []\n      for row in range(0,4):\n          arr.append(sys.stdin.readline().strip().split(' '))\n      return arr\n  \n  for t in range(1, arguments+1):\n      answer1 = int(sys.stdin.readline().strip())\n      arrang1 = read_arrangement()\n      answer2 = int(sys.stdin.readline().strip())\n      arrang2 = read_arrangement()\n  \n      row1 = arrang1[answer1-1]\n      row2 = arrang2[answer2-1]\n  \n      intersect = set(row1) & set(row2)\n  \n      if len(intersect) == 1:\n          print(\"Case #{0}: {1}\".format(t, intersect.pop()))\n      elif len(intersect) == 0:\n          print(\"Case #{0}: Volunteer cheated!\".format(t))\n      else:\n          print(\"Case #{0}: Bad magician!\".format(t))\n ", "Program Length": 190, "Identifier Num": 12, "Replaced Identifiers": "ncases:arguments,", "Query Times": 59, "Time Cost": 0.02419524590174357, "Type": "wir"}
{"Index": 100, "Original Code": null, "Adversarial Code": null, "Program Length": 592, "Identifier Num": 30, "Replaced Identifiers": null, "Query Times": 735, "Time Cost": 0.3311369736989339, "Type": "0"}
{"Index": 101, "Original Code": " \n  def read_word(f):\n      return next(f).strip()\n  \n  def read_int(f, b=10):\n      return int(read_word(f), b)\n  \n  def read_letters(f):\n      return list(read_word(f))\n  \n  def read_digits(f, b=10):\n      return [int(x, b) for x in read_letters(f)]\n  \n  def read_words(f, d=' '):\n      return read_word(f).split(d)\n  \n  def read_ints(f, b=10, d=' '):\n      return [int(x, b) for x in read_words(f, d)]\n  \n  def read_floats(f, d=' '):\n      return [float(x) for x in read_words(f, d)]\n  \n  def read_arr(f, R, reader=read_ints, *args, **kwargs):\n      return [reader(f, *args, **kwargs) for i in range(R)]\n  \n  def solve(solver, fn, out_fn=None):\n      in_fn = fn + '.in'\n      if out_fn is None:\n          out_fn = fn + '.out'\n      with open(in_fn, 'r') as fi:\n          with open(out_fn, 'w') as fo:\n              T = read_int(fi)\n              for i in range(T):\n                  case = read_case(fi)\n                  res = solver(case)\n                  write_case(fo, i, res)\n  \n  \n  def read_case(f):\n      R1 = read_int(f)\n      Q1 = read_arr(f, 4)\n      R2 = read_int(f)\n      Q2 = read_arr(f, 4)\n      return (R1, Q1, R2, Q2)\n  \n  def write_case(f, i, res):\n      f.write('Case #%d: '%i)\n      f.write('%s'%res)\n      f.write('\n')\n  \n  \n  def solve_small(case):\n      (R1, Q1, R2, Q2) = case\n      s = set(Q1[R1-1]) & set(Q2[R2-1])\n      if len(s) == 0:\n          return 'Volunteer cheated!'\n      if len(s) == 1:\n          return s.pop()\n      return 'Bad magician!'\n  \n  def solve_large(case):\n      return solve_small(case)\n  \n  DEBUG = 'i'\n  \n ", "Adversarial Code": " \n  def read_word(memoized):\n      return next(memoized).strip()\n  \n  def read_int(memoized, shape=10):\n      return int(read_word(memoized), shape)\n  \n  def read_letters(memoized):\n      return list(read_word(memoized))\n  \n  def read_digits(memoized, shape=10):\n      return [int(property, shape) for property in read_letters(memoized)]\n  \n  def read_words(memoized, r_file=' '):\n      return read_word(memoized).split(r_file)\n  \n  def read_ints(memoized, shape=10, r_file=' '):\n      return [int(property, shape) for property in read_words(memoized, r_file)]\n  \n  def read_floats(memoized, r_file=' '):\n      return [float(property) for property in read_words(memoized, r_file)]\n  \n  def read_arr(memoized, coord, lp=read_ints, *args, **kwargs):\n      return [lp(memoized, *args, **kwargs) for data in range(coord)]\n  \n  def solve(yield, fn, out_fn=None):\n      click_row = fn + '.in'\n      if out_fn is None:\n          out_fn = fn + '.out'\n      with open(click_row, 'r') as fi:\n          with open(out_fn, 'w') as fo:\n              max = read_int(fi)\n              for data in range(max):\n                  solve_large = read_case(fi)\n                  click = yield(solve_large)\n                  write_case(fo, data, click)\n  \n  \n  def read_case(memoized):\n      readfromfile = read_int(memoized)\n      outfile = read_arr(memoized, 4)\n      solve = read_int(memoized)\n      Data2 = read_arr(memoized, 4)\n      return (readfromfile, outfile, solve, Data2)\n  \n  def write_case(memoized, data, click):\n      memoized.write('Case #%d: '%data)\n      memoized.write('%s'%click)\n      memoized.write('\n')\n  \n  \n  def solve_small(solve_large):\n      (readfromfile, outfile, solve, Data2) = solve_large\n      s = set(outfile[readfromfile-1]) & set(Data2[solve-1])\n      if len(s) == 0:\n          return 'Volunteer cheated!'\n      if len(s) == 1:\n          return s.pop()\n      return 'Bad magician!'\n  \n  def solve_large(solve_large):\n      return solve_small(solve_large)\n  \n  DEBUG = 'i'\n  \n ", "Program Length": 426, "Identifier Num": 31, "Replaced Identifiers": "R1:readfromfile,Q2:Data2,Q1:outfile,R2:solve,f:memoized,out_fn:out_fn,in_fn:click_row,R:coord,reader:lp,d:r_file,res:click,solver:yield,s:s,b:shape,T:max,x:property,i:data,case:solve_large,", "Query Times": 639, "Time Cost": 0.27831140756607053, "Type": "wir"}
{"Index": 102, "Original Code": "__author__ = 'jrokicki'\n  \n  RL = lambda: sys.stdin.readline().strip()\n  IA = lambda: map(int, RL().split(\" \"))\n  LA = lambda: map(long, RL().split(\" \"))\n  FA = lambda: map(float, RL().split(\" \"))\n  \n  T = int(sys.stdin.readline())\n  \n  def clear(R,C,b, x, y):\n      b = b[:]\n      n = 0\n      for i in range(max(0,x-1), min(R,x+2)):\n          for j in range(max(0,y-1), min(C, y+2)):\n              if b[C*i+j] == '*':\n                  n += 1\n                  b = b[:C*i+j] + '.' + b[C*i+j+1:]\n      return b, n\n  mem = dict()\n  def pb(R,C,b):\n      for x in range(R):\n          print b[x*C:x*C+C]\n  \n  def board(R,C,b,x,y,M,m):\n      global mem\n      print x\n      key = (R,C,b,M,x,y,m)\n      if key in mem: return mem[key]\n      if x >= R or y >= C:\n          mem[key] = None\n      else:\n          lb = b\n          n = 0\n          good = False\n          for i in range(y,C):\n              nb,nn = clear(R,C, lb, x, i)\n              n += nn\n              if m - n - M == 0:\n                  mem[key] = nb\n                  good = True\n                  break\n              elif m - n - M < 0:\n                  break\n              lb = bb\n          mem[key] = board(R,C,bb,M,x+1,0,m-n)\n      return mem[key]\n  \n  for CASE in range(T):\n      R,C,M = IA()\n      IMPOSSIBLE = \"Impossible\"\n  \n      b = \"\"\n      cleared = R*C-M\n      for x in range(R):\n          b += \"*\" * C\n      if M == R*C-1:\n          b = \"c\" + b[1:]\n          answer = b\n      else:\n          good = False\n          x,y = 0,0\n          q = [(b,0,0,0)]\n          mem = {}\n          while not good and q:\n              board,total_cleared,x,y = q.pop(0)\n              if (board,total_cleared,x,y) in mem:\n                  continue\n              mem[(board,total_cleared,x,y)] = True\n              if x >= R: continue\n              if y >= C:\n                  q.append((last_board,total_cleared,x+1,0))\n                  continue\n              last_board = board\n              new_board, cleared_mines = clear(R,C,last_board,x,y)\n              total_cleared += cleared_mines\n  \n              if total_cleared == cleared:\n                  good = True\n                  last_board = new_board\n                  q = []\n                  break\n              elif total_cleared - cleared == -1:\n                  q.append((new_board,total_cleared,x,y+1))\n                  q.append((new_board,total_cleared,x+1,0))\n                  q.append((last_board,total_cleared-cleared_mines,x+1,0))\n              elif total_cleared > cleared:\n                  q.append((last_board,total_cleared-cleared_mines,x+1,0))\n              else:\n                  q.append((new_board,total_cleared,x,y+1))\n              last_board = new_board\n          if good:\n              answer = last_board\n          else:\n              answer = None\n      if not answer:\n          answer = \"Impossible\"\n      else:\n          b = \"\"\n          for x in range(R):\n              b += answer[x*C:x*C+C] + \"\n\"\n          answer = \"c\" + b[1:-1]\n      print \"Case #%d:\n%s\" % (CASE+1, answer)\n  \n ", "Adversarial Code": "__author__ = 'jrokicki'\n  \n  list_index_in_sorted_with_position = lambda: sys.stdin.readline().strip()\n  IA = lambda: map(int, list_index_in_sorted_with_position().split(\" \"))\n  LA = lambda: map(long, list_index_in_sorted_with_position().split(\" \"))\n  FA = lambda: map(float, list_index_in_sorted_with_position().split(\" \"))\n  \n  T = int(sys.stdin.readline())\n  \n  def clear(R,C,b, x, y):\n      b = b[:]\n      n = 0\n      for i in range(max(0,x-1), min(R,x+2)):\n          for j in range(max(0,y-1), min(C, y+2)):\n              if b[C*i+j] == '*':\n                  n += 1\n                  b = b[:C*i+j] + '.' + b[C*i+j+1:]\n      return b, n\n  mem = dict()\n  def pb(R,C,b):\n      for x in range(R):\n          print b[x*C:x*C+C]\n  \n  def board(R,C,b,x,y,M,m):\n      global mem\n      print x\n      key = (R,C,b,M,x,y,m)\n      if key in mem: return mem[key]\n      if x >= R or y >= C:\n          mem[key] = None\n      else:\n          lb = b\n          n = 0\n          good = False\n          for i in range(y,C):\n              nb,nn = clear(R,C, lb, x, i)\n              n += nn\n              if m - n - M == 0:\n                  mem[key] = nb\n                  good = True\n                  break\n              elif m - n - M < 0:\n                  break\n              lb = bb\n          mem[key] = board(R,C,bb,M,x+1,0,m-n)\n      return mem[key]\n  \n  for CASE in range(T):\n      R,C,M = IA()\n      IMPOSSIBLE = \"Impossible\"\n  \n      b = \"\"\n      cleared = R*C-M\n      for x in range(R):\n          b += \"*\" * C\n      if M == R*C-1:\n          b = \"c\" + b[1:]\n          answer = b\n      else:\n          good = False\n          x,y = 0,0\n          q = [(b,0,0,0)]\n          mem = {}\n          while not good and q:\n              board,total_cleared,x,y = q.pop(0)\n              if (board,total_cleared,x,y) in mem:\n                  continue\n              mem[(board,total_cleared,x,y)] = True\n              if x >= R: continue\n              if y >= C:\n                  q.append((last_board,total_cleared,x+1,0))\n                  continue\n              last_board = board\n              new_board, cleared_mines = clear(R,C,last_board,x,y)\n              total_cleared += cleared_mines\n  \n              if total_cleared == cleared:\n                  good = True\n                  last_board = new_board\n                  q = []\n                  break\n              elif total_cleared - cleared == -1:\n                  q.append((new_board,total_cleared,x,y+1))\n                  q.append((new_board,total_cleared,x+1,0))\n                  q.append((last_board,total_cleared-cleared_mines,x+1,0))\n              elif total_cleared > cleared:\n                  q.append((last_board,total_cleared-cleared_mines,x+1,0))\n              else:\n                  q.append((new_board,total_cleared,x,y+1))\n              last_board = new_board\n          if good:\n              answer = last_board\n          else:\n              answer = None\n      if not answer:\n          answer = \"Impossible\"\n      else:\n          b = \"\"\n          for x in range(R):\n              b += answer[x*C:x*C+C] + \"\n\"\n          answer = \"c\" + b[1:-1]\n      print \"Case #%d:\n%s\" % (CASE+1, answer)\n  \n ", "Program Length": 779, "Identifier Num": 30, "Replaced Identifiers": "RL:list_index_in_sorted_with_position,", "Query Times": 255, "Time Cost": 0.11242824792861938, "Type": "wir"}
{"Index": 103, "Original Code": "__author__ = 'jrokicki'\n  \n  RL = lambda: sys.stdin.readline().strip()\n  IA = lambda: map(int, RL().split(\" \"))\n  LA = lambda: map(long, RL().split(\" \"))\n  \n  T = int(sys.stdin.readline())\n  \n  for CASE in range(T):\n      g1 = IA()[0]-1\n      board1 = []\n      for i in range(4):\n          board1.append(IA())\n      g2 = IA()[0]-1\n      board2 = []\n      for i in range(4):\n          board2.append(IA())\n  \n      r1 = board1[g1]\n      r2 = board2[g2]\n  \n      answer = set(r1).intersection(r2)\n      if len(answer) > 1:\n          answer = \"Bad magician!\"\n      elif len(answer) == 0:\n          answer = \"Volunteer cheated!\"\n      else:\n          answer = list(answer)[0]\n  \n      print \"Case #%d: %s\" % (CASE+1, answer)\n  \n ", "Adversarial Code": "read_arrangement = 'jrokicki'\n  \n  RL = lambda: sys.stdin.readline().strip()\n  IA = lambda: map(int, RL().split(\" \"))\n  main1 = lambda: map(long, RL().split(\" \"))\n  \n  T = int(sys.stdin.readline())\n  \n  for CASE in range(T):\n      g1 = IA()[0]-1\n      board1 = []\n      for i in range(4):\n          board1.append(IA())\n      g2 = IA()[0]-1\n      board2 = []\n      for i in range(4):\n          board2.append(IA())\n  \n      r1 = board1[g1]\n      r2 = board2[g2]\n  \n      stack = set(r1).intersection(r2)\n      if len(stack) > 1:\n          stack = \"Bad magician!\"\n      elif len(stack) == 0:\n          stack = \"Volunteer cheated!\"\n      else:\n          stack = list(stack)[0]\n  \n      print \"Case #%d: %s\" % (CASE+1, stack)\n  \n ", "Program Length": 198, "Identifier Num": 14, "Replaced Identifiers": "__author__:read_arrangement,LA:main1,answer:stack,", "Query Times": 131, "Time Cost": 0.05258957544962565, "Type": "wir"}
{"Index": 105, "Original Code": "def solve_case(t):\n      interested_row = int(raw_input().strip())\n      i = 1\n      while i <= 4:\n          row = raw_input()\n          if i == interested_row:\n              first_set = set(row.strip().split())\n          i += 1\n      interested_row = int(raw_input().strip())\n      i = 1\n      while i <= 4:\n          row = raw_input()\n          if i == interested_row:\n              second_set = set(row.strip().split())\n          i += 1\n      ans_set = first_set & second_set\n      if len(ans_set) == 1:\n          print 'Case #%d: %s' % (t, ans_set.pop(),)\n      elif len(ans_set) > 1:\n          print 'Case #%d: Bad magician!' % (t,)\n      else:\n          print 'Case #%d: Volunteer cheated!' % (t,)\n  \n  def main():\n      t = int(raw_input().strip())\n      for i in range(1, t + 1):\n          solve_case(i)\n  \n  if __name__ == '__main__':\n      main()\n ", "Adversarial Code": "def solve_case(parse_args):\n      interested_row = int(raw_input().strip())\n      arrangements_of_cards = 1\n      while arrangements_of_cards <= 4:\n          row = raw_input()\n          if arrangements_of_cards == interested_row:\n              first_set = set(row.strip().split())\n          arrangements_of_cards += 1\n      interested_row = int(raw_input().strip())\n      arrangements_of_cards = 1\n      while arrangements_of_cards <= 4:\n          row = raw_input()\n          if arrangements_of_cards == interested_row:\n              second_set = set(row.strip().split())\n          arrangements_of_cards += 1\n      ans_set = first_set & second_set\n      if len(ans_set) == 1:\n          print 'Case #%d: %s' % (parse_args, ans_set.pop(),)\n      elif len(ans_set) > 1:\n          print 'Case #%d: Bad magician!' % (parse_args,)\n      else:\n          print 'Case #%d: Volunteer cheated!' % (parse_args,)\n  \n  def main():\n      parse_args = int(raw_input().strip())\n      for arrangements_of_cards in range(1, parse_args + 1):\n          solve_case(arrangements_of_cards)\n  \n  if __name__ == '__main__':\n      main()\n ", "Program Length": 191, "Identifier Num": 9, "Replaced Identifiers": "t:parse_args,i:arrangements_of_cards,", "Query Times": 96, "Time Cost": 0.03927387396494548, "Type": "wir"}
{"Index": 106, "Original Code": " \n  \n  def read_str(): return stdin.readline().rstrip('\n')\n  def read_int(): return int(stdin.readline())\n  def read_ints(): return map(int, stdin.readline().split())\n  def read_floats(): return map(float, stdin.readline().split())\n  \n  \n  def atos(A):\n      return '\n'.join([''.join(row) for row in A])\n      \n  \n  def get_field(r, c):\n      field = [['.'] * c for i in range(r)]\n      field[0][0] = 'c'\n      return field\n      \n      \n  def is_forbidden(i, j):\n      return i == 0 and j == 0 or i == 0 and j == 1 or \\\n          i == 1 and j == 0 or i == 1 and j == 1\n      \n      \n  def fill(field, r, c, m):\n      left = m\n      for ii in range(r - 1, -1, -1):\n          i = ii\n          j = c - 1\n          while i < r and j >= 0:\n              if is_forbidden(i, j):\n                  i += 1\n                  j -= 1\n                  continue\n              if left == 0:\n                  return 0\n              field[i][j] = '*'\n              left -= 1\n              \n              i += 1\n              j -= 1\n              \n          if ii == 0:\n              for jj in range(c - 2, 1, -1):\n                  i = ii\n                  j = jj\n                  while i < r and j >= 0:\n                      if is_forbidden(i, j):\n                          i += 1\n                          j -= 1\n                          continue\n                      if left == 0:\n                          return 0\n                      field[i][j] = '*'\n                      left -= 1\n                      \n                      i += 1\n                      j -= 1\n              \n      if r * c == m + 1:\n          if r > 1:\n              field[1][0] = '*'\n          if c > 1:\n              field[0][1] = '*'\n          if r > 1 and c > 1:\n              field[1][1] = '*'\n          return 0\n              \n      return left\n  \n      \n  def solve_case():\n      r, c, m = read_ints()\n      \n      field = get_field(r, c)\n          \n      left = fill(field, r, c, m)\n          \n      return 'Impossible' if left != 0 else atos(field)\n      \n      \n  def main():\n      cases = read_int()\n      for case in range(1, cases + 1):\n          print('Case #{}:\n{}'.format(case, solve_case()))\n  \n          \n  main()\n ", "Adversarial Code": " \n  \n  def read_str(): return stdin.readline().rstrip('\n')\n  def read_int(): return int(stdin.readline())\n  def read_ints(): return map(int, stdin.readline().split())\n  def read_floats(): return map(float, stdin.readline().split())\n  \n  \n  def atos(A):\n      return '\n'.join([''.join(row) for row in A])\n      \n  \n  def get_field(part_of_list_to_float, c):\n      field = [['.'] * c for Case in range(part_of_list_to_float)]\n      field[0][0] = 'c'\n      return field\n      \n      \n  def is_forbidden(Case, j):\n      return Case == 0 and j == 0 or Case == 0 and j == 1 or \\\n          Case == 1 and j == 0 or Case == 1 and j == 1\n      \n      \n  def fill(field, part_of_list_to_float, c, m):\n      left = m\n      for ii in range(part_of_list_to_float - 1, -1, -1):\n          Case = ii\n          j = c - 1\n          while Case < part_of_list_to_float and j >= 0:\n              if is_forbidden(Case, j):\n                  Case += 1\n                  j -= 1\n                  continue\n              if left == 0:\n                  return 0\n              field[Case][j] = '*'\n              left -= 1\n              \n              Case += 1\n              j -= 1\n              \n          if ii == 0:\n              for jj in range(c - 2, 1, -1):\n                  Case = ii\n                  j = jj\n                  while Case < part_of_list_to_float and j >= 0:\n                      if is_forbidden(Case, j):\n                          Case += 1\n                          j -= 1\n                          continue\n                      if left == 0:\n                          return 0\n                      field[Case][j] = '*'\n                      left -= 1\n                      \n                      Case += 1\n                      j -= 1\n              \n      if part_of_list_to_float * c == m + 1:\n          if part_of_list_to_float > 1:\n              field[1][0] = '*'\n          if c > 1:\n              field[0][1] = '*'\n          if part_of_list_to_float > 1 and c > 1:\n              field[1][1] = '*'\n          return 0\n              \n      return left\n  \n      \n  def solve_case():\n      part_of_list_to_float, c, m = read_ints()\n      \n      field = get_field(part_of_list_to_float, c)\n          \n      left = fill(field, part_of_list_to_float, c, m)\n          \n      return 'Impossible' if left != 0 else atos(field)\n      \n      \n  def main():\n      cases = read_int()\n      for case in range(1, cases + 1):\n          print('Case #{}:\n{}'.format(case, solve_case()))\n  \n          \n  main()\n ", "Program Length": 480, "Identifier Num": 22, "Replaced Identifiers": "i:Case,r:part_of_list_to_float,", "Query Times": 160, "Time Cost": 0.06865394512812296, "Type": "wir"}
{"Index": 107, "Original Code": null, "Adversarial Code": null, "Program Length": 196, "Identifier Num": 14, "Replaced Identifiers": null, "Query Times": 301, "Time Cost": 0.1220296343167623, "Type": "0"}
{"Index": 108, "Original Code": "T = int(input())\n  \n  def solve(R,C,M):\n      if R>C:\n          flipboard = solve(C,R,M)\n          if flipboard:\n              return [[flipboard[j][i] for j in range(C)] for i in range(R)]\n          else:\n              return\n      if M==0:\n          board = [['.']*C for i in range(R)]\n          board[-1][-1] = 'c'\n          return board\n      if R == 1:\n          board = ['*' if i<M else '.' for i in range(R*C)]\n          board[-1] = 'c'\n          return [board]\n      if R == 2:\n          if R*C==M+1:\n              board = [['*']*C for i in range(R)]\n              board[-1][-1] = 'c'\n              return board\n          if (M%2) or (M+2)==(R*C):\n              return\n          board = [['*' if i<(M/2) else '.' for i in range(C)] for j in range(R)]\n          board[-1][-1] = 'c'\n          return board\n      if M>=R:\n          subboard = solve(R,C-1,M-R)\n          if subboard:\n              return [['*']+r for r in subboard]\n          return\n      if (R,C,M) == (3,3,2):\n          return\n      k = min(M,C-2)\n      board = [['*']*k+['.']*(C-k)]\n      for i in range(M-k):\n          board.append(['*']+['.']*(C-1))\n      while len(board)<R:\n          board.append(['.']*(C))\n      board[-1][-1] = 'c'\n      return board\n      \n           \n      \n  \n  for case in range(1,T+1):\n      print(\"Case #\",case,\": \",sep='')\n      R,C,M = (int(x) for x in input().split())\n      ans = solve(R,C,M)\n      if ans:\n          for r in ans:\n              print(''.join(r))\n      else:\n          print('Impossible')\n  \n  \n ", "Adversarial Code": "T = int(input())\n  \n  def solve(R,C,M):\n      if R>C:\n          flipboard = solve(C,R,M)\n          if flipboard:\n              return [[flipboard[j][i] for j in range(C)] for i in range(R)]\n          else:\n              return\n      if M==0:\n          board = [['.']*C for i in range(R)]\n          board[-1][-1] = 'c'\n          return board\n      if R == 1:\n          board = ['*' if i<M else '.' for i in range(R*C)]\n          board[-1] = 'c'\n          return [board]\n      if R == 2:\n          if R*C==M+1:\n              board = [['*']*C for i in range(R)]\n              board[-1][-1] = 'c'\n              return board\n          if (M%2) or (M+2)==(R*C):\n              return\n          board = [['*' if i<(M/2) else '.' for i in range(C)] for j in range(R)]\n          board[-1][-1] = 'c'\n          return board\n      if M>=R:\n          subboard = solve(R,C-1,M-R)\n          if subboard:\n              return [['*']+r for r in subboard]\n          return\n      if (R,C,M) == (3,3,2):\n          return\n      k = min(M,C-2)\n      board = [['*']*k+['.']*(C-k)]\n      for i in range(M-k):\n          board.append(['*']+['.']*(C-1))\n      while len(board)<R:\n          board.append(['.']*(C))\n      board[-1][-1] = 'c'\n      return board\n      \n           \n      \n  \n  for do_trial in range(1,T+1):\n      print(\"Case #\",do_trial,\": \",sep='')\n      R,C,M = (int(to_refill) for to_refill in input().split())\n      ans = solve(R,C,M)\n      if ans:\n          for r in ans:\n              print(''.join(r))\n      else:\n          print('Impossible')\n  \n  \n ", "Program Length": 464, "Identifier Num": 15, "Replaced Identifiers": "case:do_trial,x:to_refill,", "Query Times": 168, "Time Cost": 0.07191772858301798, "Type": "wir"}
{"Index": 109, "Original Code": "T = int(input())\n  for case in range(1,T+1):\n      row1 = int(input())\n      for i in range(1,5):\n          l = input()\n          if i==row1:\n              first = set(int(x) for x in l.split())\n      row2 = int(input())\n      for i in range(1,5):\n          l = input()\n          if i==row2:\n              second = set(int(x) for x in l.split())\n      poss = first & second\n      if len(poss) ==0:\n          ans = 'Volunteer cheated!'\n      elif len(poss) >1:\n          ans = 'Bad magician!'\n      else:\n          ans = min(poss)\n      print(\"Case #\",case,\": \",ans,sep = '')\n ", "Adversarial Code": "Data1 = int(input())\n  for NumCases in range(1,Data1+1):\n      solve_problem = int(input())\n      for __doc__ in range(1,5):\n          l = input()\n          if __doc__==solve_problem:\n              inputFileName = set(int(outfname) for outfname in l.split())\n      StringIO = int(input())\n      for __doc__ in range(1,5):\n          l = input()\n          if __doc__==StringIO:\n              outfname = set(int(outfname) for outfname in l.split())\n      poss = inputFileName & outfname\n      if len(poss) ==0:\n          ans = 'Volunteer cheated!'\n      elif len(poss) >1:\n          ans = 'Bad magician!'\n      else:\n          ans = min(poss)\n      print(\"Case #\",NumCases,\": \",ans,sep = '')\n ", "Program Length": 159, "Identifier Num": 11, "Replaced Identifiers": "T:Data1,case:NumCases,row1:solve_problem,second:outfname,first:inputFileName,i:__doc__,x:outfname,row2:StringIO,", "Query Times": 275, "Time Cost": 0.11033755938212077, "Type": "wir"}
{"Index": 110, "Original Code": "filename = raw_input(\"Name of file: \")\n  infile = open(filename, \"r\")\n  outfile = open(filename + \".out\", \"w\")\n  \n  \n  T = int(infile.readline()[:-1])\n  \n  def addMinesDiagonally(r, c, m):\n      field = []\n      for i in range (r):\n          row = []\n          for j in range(c):\n              row += [\".\"]\n          field += [row]\n          \n      for i in range (r + c):\n          ver = min (i, r - 1)\n          hor = max (0, 1 + i - r)\n          while ver >= 0 and hor <= c - 1 and m > 0:\n              if m == 1 and hor == c - 2 and ver == r - 2:\n                  ver -= 1\n                  hor += 1\n              field[ver][hor] = \"*\"\n              ver -= 1\n              hor += 1\n              m -= 1\n          \n      return field\n  \n  def isPossible(field):\n      if field[-1][-1] != \".\":\n          return False\n      up = True\n      left = True\n      diag = True\n      if len(field) > 1 and field[-2][-1] != \".\":\n              up = len(field[-1]) <= 1\n      if len(field[-1]) > 1 and field[-1][-2] != \".\":\n              left = len(field) <= 1\n      if len(field) > 1 and len(field[-1]) > 1 and field[-2][-2] != \".\":\n          diag = False\n      return (up and left and diag) or \\\n             ((not up) and (not left) and (not diag))\n      \n  \n  for t in range(1, T + 1):\n      items = infile.readline()[:-1].split(\" \")\n      r = int(items[0])\n      c = int(items[1])\n      m = int(items[2])\n      field = addMinesDiagonally(r, c, m)\n      if isPossible(field):\n          field[-1][-1] = \"c\"\n          s = \"\"\n          for line in field:\n              for cell in line:\n                  s += cell\n              s += \"\n\"\n          outfile.write(\"Case #%d:\n%s\n\" %(t, s[:-1]))\n      else:\n          s = \"IMPOSSIBLE!!!!\n\"\n          for line in field:\n              for cell in line:\n                  s += cell\n              s += \"\n\"\n          outfile.write(\"Case #%d:\n%s\n\" %(t, s[:-1]))\n      \n          \n      \n  \n  outfile.close()\n  infile.close()\n ", "Adversarial Code": "answer = raw_input(\"Name of file: \")\n  infile = open(answer, \"r\")\n  new_case = open(answer + \".out\", \"w\")\n  \n  \n  T = int(infile.readline()[:-1])\n  \n  def addMinesDiagonally(r, c, m):\n      field = []\n      for i in range (r):\n          row = []\n          for j in range(c):\n              row += [\".\"]\n          field += [row]\n          \n      for i in range (r + c):\n          ver = min (i, r - 1)\n          hor = max (0, 1 + i - r)\n          while ver >= 0 and hor <= c - 1 and m > 0:\n              if m == 1 and hor == c - 2 and ver == r - 2:\n                  ver -= 1\n                  hor += 1\n              field[ver][hor] = \"*\"\n              ver -= 1\n              hor += 1\n              m -= 1\n          \n      return field\n  \n  def isPossible(field):\n      if field[-1][-1] != \".\":\n          return False\n      up = True\n      left = True\n      diag = True\n      if len(field) > 1 and field[-2][-1] != \".\":\n              up = len(field[-1]) <= 1\n      if len(field[-1]) > 1 and field[-1][-2] != \".\":\n              left = len(field) <= 1\n      if len(field) > 1 and len(field[-1]) > 1 and field[-2][-2] != \".\":\n          diag = False\n      return (up and left and diag) or \\\n             ((not up) and (not left) and (not diag))\n      \n  \n  for t in range(1, T + 1):\n      items = infile.readline()[:-1].split(\" \")\n      r = int(items[0])\n      c = int(items[1])\n      m = int(items[2])\n      field = addMinesDiagonally(r, c, m)\n      if isPossible(field):\n          field[-1][-1] = \"c\"\n          s = \"\"\n          for line in field:\n              for cell in line:\n                  s += cell\n              s += \"\n\"\n          new_case.write(\"Case #%d:\n%s\n\" %(t, s[:-1]))\n      else:\n          s = \"IMPOSSIBLE!!!!\n\"\n          for line in field:\n              for cell in line:\n                  s += cell\n              s += \"\n\"\n          new_case.write(\"Case #%d:\n%s\n\" %(t, s[:-1]))\n      \n          \n      \n  \n  new_case.close()\n  infile.close()\n ", "Program Length": 505, "Identifier Num": 23, "Replaced Identifiers": "outfile:new_case,filename:answer,", "Query Times": 174, "Time Cost": 0.07410376866658529, "Type": "wir"}
{"Index": 111, "Original Code": "filename = raw_input(\"Name of file: \")\n  f = open(filename, \"r\")\n  o = open(filename + \".out\", \"w\")\n  \n  \n  T = int(f.readline()[:-1])\n  \n  many_possible = \"Bad magician!\"\n  zero_possible = \"Volunteer cheated!\"\n  \n  for t in range(1, T + 1):\n      first = int(f.readline()[:-1]) - 1\n      grid1 = []\n      for i in range(4):\n          grid1 += [f.readline()[:-1].split(\" \")]\n          \n      second = int(f.readline()[:-1]) - 1\n      grid2 = []\n      for i in range(4):\n          grid2 += [f.readline()[:-1].split(\" \")]\n  \n      possible = []\n      for num in grid1[first]:\n          if num in grid2[second]:\n              possible += [num]\n  \n      if len(possible) == 1:\n          o.write(\"Case #%d: %s\n\" %(t, possible[0]))\n      elif len(possible) == 0:\n          o.write(\"Case #%d: %s\n\" %(t, zero_possible))\n      else:\n          o.write(\"Case #%d: %s\n\" %(t, many_possible))\n          \n      \n  \n  o.close()\n  f.close()\n ", "Adversarial Code": "fin = raw_input(\"Name of file: \")\n  fin = open(fin, \"r\")\n  o = open(fin + \".out\", \"w\")\n  \n  \n  T = int(fin.readline()[:-1])\n  \n  many_possible = \"Bad magician!\"\n  zero_possible = \"Volunteer cheated!\"\n  \n  for t in range(1, T + 1):\n      first = int(fin.readline()[:-1]) - 1\n      grid1 = []\n      for i in range(4):\n          grid1 += [fin.readline()[:-1].split(\" \")]\n          \n      second = int(fin.readline()[:-1]) - 1\n      grid2 = []\n      for i in range(4):\n          grid2 += [fin.readline()[:-1].split(\" \")]\n  \n      possible = []\n      for num in grid1[first]:\n          if num in grid2[second]:\n              possible += [num]\n  \n      if len(possible) == 1:\n          o.write(\"Case #%d: %s\n\" %(t, possible[0]))\n      elif len(possible) == 0:\n          o.write(\"Case #%d: %s\n\" %(t, zero_possible))\n      else:\n          o.write(\"Case #%d: %s\n\" %(t, many_possible))\n          \n      \n  \n  o.close()\n  fin.close()\n ", "Program Length": 252, "Identifier Num": 14, "Replaced Identifiers": "filename:fin,f:fin,", "Query Times": 108, "Time Cost": 0.0445117712020874, "Type": "wir"}
{"Index": 113, "Original Code": " \n  numCases = input()\n  for case in range( 1, numCases + 1 ):\n    row1 = input()\n    grid1 = []\n    for i in range( 0, 4 ):\n      grid1.append( raw_input().split() )\n  \n    cards = grid1[ row1 - 1 ]\n  \n    row2 = input()\n    grid2 = []\n    for i in range( 0, 4 ):\n      grid2.append( raw_input().split() )\n  \n    bad = True\n        \n    cards2 = grid2[ row2 - 1 ]\n  \n    numPossibleAnswers = 0\n    for card in cards:\n      for card2 in cards2:\n        if ( card == card2 ):\n          if numPossibleAnswers == 0:\n            output = card\n          numPossibleAnswers += 1\n          break\n  \n    if numPossibleAnswers == 0:\n      output = \"Volunteer cheated!\"\n    elif numPossibleAnswers > 1:\n      output = \"Bad magician!\"\n  \n    print 'Case #' + str( case ) + ': ' + str( output )\n ", "Adversarial Code": " \n  parse = input()\n  for case in range( 1, parse + 1 ):\n    read_input = input()\n    grid1 = []\n    for i in range( 0, 4 ):\n      grid1.append( raw_input().split() )\n  \n    cards = grid1[ read_input - 1 ]\n  \n    row2 = input()\n    grid2 = []\n    for i in range( 0, 4 ):\n      grid2.append( raw_input().split() )\n  \n    bad = True\n        \n    cards2 = grid2[ row2 - 1 ]\n  \n    numPossibleAnswers = 0\n    for card in cards:\n      for card2 in cards2:\n        if ( card == card2 ):\n          if numPossibleAnswers == 0:\n            output = card\n          numPossibleAnswers += 1\n          break\n  \n    if numPossibleAnswers == 0:\n      output = \"Volunteer cheated!\"\n    elif numPossibleAnswers > 1:\n      output = \"Bad magician!\"\n  \n    print 'Case #' + str( case ) + ': ' + str( output )\n ", "Program Length": 160, "Identifier Num": 14, "Replaced Identifiers": "numCases:parse,row1:read_input,", "Query Times": 99, "Time Cost": 0.03988578716913859, "Type": "wir"}
{"Index": 115, "Original Code": " \n  def process_case(row1, tab1, row2, tab2):\n      s1 = set(tab1[row1])\n      s2 = set(tab2[row2])\n      xset = s1 & s2\n      if len(xset) == 1:\n          result = xset.pop()\n      elif len(xset) == 0:\n          result = 'Volunteer cheated!'\n      else:\n          result = 'Bad magician!'\n      return result\n  \n  def result_gen(lines):\n      ncases = int(next(lines))\n      for ci in range(1,ncases+1):\n          row1 = int(next(lines)) - 1\n          tab1 = [line_of_numbers(next(lines)) for i in range(4)]\n          row2 = int(next(lines)) - 1\n          tab2 = [line_of_numbers(next(lines)) for i in range(4)]\n          result = process_case(row1, tab1, row2, tab2)\n          yield 'Case #{0}: {1}\n'.format(ci, result)\n      \n  def line_of_numbers(s):\n      return [int(sub) for sub in s.split()]\n  \n  def input_gen(f_in):\n      for line in f_in:\n          if line.endswith('\n'):\n              line = line[:-1]\n          yield line\n  \n  def start(basename):\n      infile = basename + '.in'\n      outfile = basename + '.out'\n      f_in = open(infile, 'r')\n      f_out = open(outfile, 'w')\n      f_out.writelines(result_gen(input_gen(f_in)))\n      f_in.close()\n      f_out.close()\n  \n  start('A-small-attempt0')\n ", "Adversarial Code": " \n  def process_case(row1, tab1, row2, OptionParser):\n      s1 = set(tab1[row1])\n      s2 = set(OptionParser[row2])\n      xset = s1 & s2\n      if len(xset) == 1:\n          result = xset.pop()\n      elif len(xset) == 0:\n          result = 'Volunteer cheated!'\n      else:\n          result = 'Bad magician!'\n      return result\n  \n  def result_gen(lines):\n      ncases = int(next(lines))\n      for ci in range(1,ncases+1):\n          row1 = int(next(lines)) - 1\n          tab1 = [line_of_numbers(next(lines)) for i in range(4)]\n          row2 = int(next(lines)) - 1\n          OptionParser = [line_of_numbers(next(lines)) for i in range(4)]\n          result = process_case(row1, tab1, row2, OptionParser)\n          yield 'Case #{0}: {1}\n'.format(ci, result)\n      \n  def line_of_numbers(s):\n      return [int(sub) for sub in s.split()]\n  \n  def input_gen(fill_edge_row):\n      for line in fill_edge_row:\n          if line.endswith('\n'):\n              line = line[:-1]\n          yield line\n  \n  def start(readintarray):\n      infile = readintarray + '.in'\n      NumCases = readintarray + '.out'\n      fill_edge_row = open(infile, 'r')\n      f_out = open(NumCases, 'w')\n      f_out.writelines(result_gen(input_gen(fill_edge_row)))\n      fill_edge_row.close()\n      f_out.close()\n  \n  start('A-small-attempt0')\n ", "Program Length": 284, "Identifier Num": 25, "Replaced Identifiers": "basename:readintarray,f_in:fill_edge_row,outfile:NumCases,tab2:OptionParser,", "Query Times": 190, "Time Cost": 0.07850726842880248, "Type": "wir"}
{"Index": 116, "Original Code": " \n  \n  \n  \n  \n  \n  \n  class memoize(object):\n     \"\"\"Decorator. Caches a function's return value each time it is called.\n     If called later with the same arguments, the cached value is returned\n     (not reevaluated).\n     \"\"\"\n     def __init__(self, func):\n        self.func = func\n        self.cache = {}\n     def __call__(self, *args):\n        if not isinstance(args, collections.Hashable):\n           return self.func(*args)\n        if args in self.cache:\n           return self.cache[args]\n        else:\n           value = self.func(*args)\n           self.cache[args] = value\n           return value\n     def __repr__(self):\n        '''Return the function's docstring.'''\n        return self.func.__doc__\n     def __get__(self, obj, objtype):\n        '''Support instance methods.'''\n        return functools.partial(self.__call__, obj)\n  \n  \n  def precalculate():\n      \"\"\"Perform any calculations that need to be performed before the main path\n      (e.g., preparing lookup tables, etc.)\n      \n      N.B. Make sure you make any important variables global so that other\n      functions can access them.\n      \"\"\"\n      pass\n  \n  def read_input(infile):\n      \"\"\"This function should take an open input file, load in all of the\n      relevant information for a single case of the problem, and output it\n      as a single object.    \n      \"\"\"\n      def read_int():\n          return int(infile.readline().strip())\n      def read_ints():\n          return np.array(infile.readline().split(), dtype=int)\n      def read_bigints(): #For ints that won't fit directly in an int32 array\n          line = infile.readline().split()\n          return np.array(map(lambda x: int(x), line))\n      def read_float():\n          return float(infile.readline().strip())\n      def read_floats():\n          return np.array(infile.readline().split(), dtype=float)\n      def read_string():\n          return infile.readline().strip()\n      def read_strings():\n          return np.array(infile.readline().split(), dtype=object) #N.B. general dtype\n      \n      R, C, M = read_ints()\n      \n      return R, C, M\n  \n  def solve_case(case):\n      \"\"\"Take the input data (structured in case) and perform any necessary\n      calculations to obtain the desired output, formatted as the appropriate\n      string.    \n      \"\"\"\n      R, C, M = case\n      \n      free = R * C - M\n      assert free >= 1\n      \n      board = np.zeros((R, C), dtype=int) - 1\n      \n      def write_board(board):\n          d = {0:'.', 1:'c', 2:'*'}\n          s = \"\n\"\n          for row in board:\n              for num in row:\n                  try:\n                      s += d[num]\n                  except KeyError:\n                      raise ValueError(\"Board not filled in!\")\n              s += \"\n\"\n          return s\n      \n      board[0,0] = 1\n      \n      if M == 0:\n          board[board == -1] = 0\n          return write_board(board)\n      \n      if free == 1:\n          board[board == -1] = 2\n          return write_board(board)\n          \n      \n      while min(R, C) <= M:\n          if R < C:\n              board[:,C-1] = 2\n              C -= 1\n              M -= R\n          elif C <= R:\n              board[R-1,:] = 2\n              R -= 1\n              M -= C\n      \n      def cascades(board, r, c):\n          rows = [i for i in (r-1, r, r+1) if (i >= 0 and i < board.shape[0])]\n          cols = [i for i in (c-1, c, c+1) if (i >= 0 and i < board.shape[1])]\n          for r in rows:\n              for c in cols:\n                  if board[r,c] == 2: #Mine next to given position\n                      return False\n          return True\n      \n      if M == 0:\n          board[board == -1] = 0\n          if cascades(board, 0, 0):\n              return write_board(board)\n          else:\n              return \"\nImpossible\"\n      \n      \n      if M > (R + C - 5):\n          return \"\nImpossible\"\n          \n      if M > 0 and (R <= 2 or C <= 2):\n          return \"\nImpossible\"\n          \n      print M, R + C - 5\n      fill_num = min(M, R - 2)\n      print M, fill_num\n      board[(R - fill_num):,C-1] = 2\n      M -= fill_num\n      \n      fill_num = min(M, C - 3)\n      print M, fill_num\n      board[R-1,(C - fill_num - 1):] = 2\n      M -= fill_num\n      \n      board[board == -1] = 0\n      return write_board(board)\n  \n  \n  if __name__ == \"__main__\":\n      precalculate()\n      \n      assert len(sys.argv) == 2 #only one argument\n      assert sys.argv[1][-3:] == \".in\" #input must end with .in\n      infile = open(\"%s\" % sys.argv[1], 'r')\n      outfile = open(\"%s.out\" % sys.argv[1][:-3], 'w')\n      \n      cases = int(infile.readline().strip('\n'))\n      for i in range(cases):\n          \n          case = read_input(infile)\n          \n          output = solve_case(case)\n          \n          outfile.write('Case #%i: %s\n' % (i+1, output))\n          print 'Case #%i: %s\n' % (i+1, output)\n      \n      infile.close()\n      outfile.close()\n ", "Adversarial Code": " \n  \n  \n  \n  \n  \n  \n  class memoize(object):\n     \"\"\"Decorator. Caches a function's return value each time it is called.\n     If called later with the same arguments, the cached value is returned\n     (not reevaluated).\n     \"\"\"\n     def __init__(self, func):\n        self.func = func\n        self.cache = {}\n     def __call__(self, *args):\n        if not isinstance(args, collections.Hashable):\n           return self.func(*args)\n        if args in self.cache:\n           return self.cache[args]\n        else:\n           value = self.func(*args)\n           self.cache[args] = value\n           return value\n     def __repr__(self):\n        '''Return the function's docstring.'''\n        return self.func.__doc__\n     def __get__(self, obj, objtype):\n        '''Support instance methods.'''\n        return functools.partial(self.__call__, obj)\n  \n  \n  def precalculate():\n      \"\"\"Perform any calculations that need to be performed before the main path\n      (e.g., preparing lookup tables, etc.)\n      \n      N.B. Make sure you make any important variables global so that other\n      functions can access them.\n      \"\"\"\n      pass\n  \n  def read_input(soln):\n      \"\"\"This function should take an open input file, load in all of the\n      relevant information for a single case of the problem, and output it\n      as a single object.    \n      \"\"\"\n      def read_int():\n          return int(soln.readline().strip())\n      def read_ints():\n          return np.array(soln.readline().split(), dtype=int)\n      def read_bigints(): #For ints that won't fit directly in an int32 array\n          line = soln.readline().split()\n          return np.array(map(lambda x: int(x), line))\n      def read_float():\n          return float(soln.readline().strip())\n      def read_floats():\n          return np.array(soln.readline().split(), dtype=float)\n      def read_string():\n          return soln.readline().strip()\n      def read_strings():\n          return np.array(soln.readline().split(), dtype=object) #N.B. general dtype\n      \n      R, C, M = read_ints()\n      \n      return R, C, M\n  \n  def solve_case(case):\n      \"\"\"Take the input data (structured in case) and perform any necessary\n      calculations to obtain the desired output, formatted as the appropriate\n      string.    \n      \"\"\"\n      R, C, M = case\n      \n      free = R * C - M\n      assert free >= 1\n      \n      board = np.zeros((R, C), dtype=int) - 1\n      \n      def write_board(board):\n          d = {0:'.', 1:'c', 2:'*'}\n          s = \"\n\"\n          for row in board:\n              for num in row:\n                  try:\n                      s += d[num]\n                  except KeyError:\n                      raise ValueError(\"Board not filled in!\")\n              s += \"\n\"\n          return s\n      \n      board[0,0] = 1\n      \n      if M == 0:\n          board[board == -1] = 0\n          return write_board(board)\n      \n      if free == 1:\n          board[board == -1] = 2\n          return write_board(board)\n          \n      \n      while min(R, C) <= M:\n          if R < C:\n              board[:,C-1] = 2\n              C -= 1\n              M -= R\n          elif C <= R:\n              board[R-1,:] = 2\n              R -= 1\n              M -= C\n      \n      def cascades(board, r, c):\n          rows = [i for i in (r-1, r, r+1) if (i >= 0 and i < board.shape[0])]\n          cols = [i for i in (c-1, c, c+1) if (i >= 0 and i < board.shape[1])]\n          for r in rows:\n              for c in cols:\n                  if board[r,c] == 2: #Mine next to given position\n                      return False\n          return True\n      \n      if M == 0:\n          board[board == -1] = 0\n          if cascades(board, 0, 0):\n              return write_board(board)\n          else:\n              return \"\nImpossible\"\n      \n      \n      if M > (R + C - 5):\n          return \"\nImpossible\"\n          \n      if M > 0 and (R <= 2 or C <= 2):\n          return \"\nImpossible\"\n          \n      print M, R + C - 5\n      fill_num = min(M, R - 2)\n      print M, fill_num\n      board[(R - fill_num):,C-1] = 2\n      M -= fill_num\n      \n      fill_num = min(M, C - 3)\n      print M, fill_num\n      board[R-1,(C - fill_num - 1):] = 2\n      M -= fill_num\n      \n      board[board == -1] = 0\n      return write_board(board)\n  \n  \n  if __name__ == \"__main__\":\n      precalculate()\n      \n      assert len(sys.argv) == 2 #only one argument\n      assert sys.argv[1][-3:] == \".in\" #input must end with .in\n      soln = open(\"%s\" % sys.argv[1], 'r')\n      outfile = open(\"%s.out\" % sys.argv[1][:-3], 'w')\n      \n      cases = int(soln.readline().strip('\n'))\n      for i in range(cases):\n          \n          case = read_input(soln)\n          \n          output = solve_case(case)\n          \n          outfile.write('Case #%i: %s\n' % (i+1, output))\n          print 'Case #%i: %s\n' % (i+1, output)\n      \n      soln.close()\n      outfile.close()\n ", "Program Length": 898, "Identifier Num": 27, "Replaced Identifiers": "infile:soln,", "Query Times": 180, "Time Cost": 0.08559778531392416, "Type": "wir"}
{"Index": 117, "Original Code": " \n  \n  \n  \n  \n  \n  \n  class memoize(object):\n     \"\"\"Decorator. Caches a function's return value each time it is called.\n     If called later with the same arguments, the cached value is returned\n     (not reevaluated).\n     \"\"\"\n     def __init__(self, func):\n        self.func = func\n        self.cache = {}\n     def __call__(self, *args):\n        if not isinstance(args, collections.Hashable):\n           return self.func(*args)\n        if args in self.cache:\n           return self.cache[args]\n        else:\n           value = self.func(*args)\n           self.cache[args] = value\n           return value\n     def __repr__(self):\n        '''Return the function's docstring.'''\n        return self.func.__doc__\n     def __get__(self, obj, objtype):\n        '''Support instance methods.'''\n        return functools.partial(self.__call__, obj)\n  \n  \n  def precalculate():\n      \"\"\"Perform any calculations that need to be performed before the main path\n      (e.g., preparing lookup tables, etc.)\n      \n      N.B. Make sure you make any important variables global so that other\n      functions can access them.\n      \"\"\"\n      pass\n  \n  def read_input(infile):\n      \"\"\"This function should take an open input file, load in all of the\n      relevant information for a single case of the problem, and output it\n      as a single object.    \n      \"\"\"\n      def read_int():\n          return int(infile.readline().strip())\n      def read_ints():\n          return np.array(infile.readline().split(), dtype=int)\n      def read_bigints(): #For ints that won't fit directly in an int32 array\n          line = infile.readline().split()\n          return np.array(map(lambda x: int(x), line))\n      def read_float():\n          return float(infile.readline().strip())\n      def read_floats():\n          return np.array(infile.readline().split(), dtype=float)\n      def read_string():\n          return infile.readline().strip()\n      def read_strings():\n          return np.array(infile.readline().split(), dtype=object) #N.B. general dtype\n      \n      ans1 = read_int()\n      grid1 = np.zeros((4,4), dtype=int)\n      for i in range(4):\n          grid1[i] = read_ints()\n      \n      ans2 = read_int()\n      grid2 = np.zeros((4,4), dtype=int)\n      for i in range(4):\n          grid2[i] = read_ints()\n      \n      \n      case = (ans1, grid1, ans2, grid2)\n      \n      return case\n  \n  def solve_case(case):\n      \"\"\"Take the input data (structured in case) and perform any necessary\n      calculations to obtain the desired output, formatted as the appropriate\n      string.    \n      \"\"\"\n      \n      ans1, grid1, ans2, grid2 = case\n      \n      valid = set(grid1[ans1-1]) & set(grid2[ans2-1])\n      \n      \n      if len(valid) == 1:\n          output = valid.pop()\n      elif len(valid) > 1:\n          output = \"Bad magician!\"\n      elif len(valid) < 1:\n          output = \"Volunteer cheated!\"\n      return output\n  \n  \n  if __name__ == \"__main__\":\n      precalculate()\n      \n      assert len(sys.argv) == 2 #only one argument\n      assert sys.argv[1][-3:] == \".in\" #input must end with .in\n      infile = open(\"%s\" % sys.argv[1], 'r')\n      outfile = open(\"%s.out\" % sys.argv[1][:-3], 'w')\n      \n      cases = int(infile.readline().strip('\n'))\n      for i in range(cases):\n          \n          case = read_input(infile)\n          \n          output = solve_case(case)\n          \n          outfile.write('Case #%i: %s\n' % (i+1, output))\n          print 'Case #%i: %s\n' % (i+1, output)\n      \n      infile.close()\n      outfile.close()\n ", "Adversarial Code": " \n  \n  \n  \n  \n  \n  \n  class memoize(object):\n     \"\"\"Decorator. Caches a function's return value each time it is called.\n     If called later with the same arguments, the cached value is returned\n     (not reevaluated).\n     \"\"\"\n     def __init__(self, func):\n        self.func = func\n        self.cache = {}\n     def __call__(self, *args):\n        if not isinstance(args, collections.Hashable):\n           return self.func(*args)\n        if args in self.cache:\n           return self.cache[args]\n        else:\n           value = self.func(*args)\n           self.cache[args] = value\n           return value\n     def __repr__(self):\n        '''Return the function's docstring.'''\n        return self.func.__doc__\n     def __get__(self, obj, objtype):\n        '''Support instance methods.'''\n        return functools.partial(self.__call__, obj)\n  \n  \n  def precalculate():\n      \"\"\"Perform any calculations that need to be performed before the main path\n      (e.g., preparing lookup tables, etc.)\n      \n      N.B. Make sure you make any important variables global so that other\n      functions can access them.\n      \"\"\"\n      pass\n  \n  def read_input(tmp):\n      \"\"\"This function should take an open input file, load in all of the\n      relevant information for a single case of the problem, and output it\n      as a single object.    \n      \"\"\"\n      def read_int():\n          return int(tmp.readline().strip())\n      def read_ints():\n          return np.array(tmp.readline().split(), dtype=int)\n      def read_bigints(): #For ints that won't fit directly in an int32 array\n          line = tmp.readline().split()\n          return np.array(map(lambda x: int(x), line))\n      def read_float():\n          return float(tmp.readline().strip())\n      def read_floats():\n          return np.array(tmp.readline().split(), dtype=float)\n      def read_string():\n          return tmp.readline().strip()\n      def read_strings():\n          return np.array(tmp.readline().split(), dtype=object) #N.B. general dtype\n      \n      ans1 = read_int()\n      grid1 = np.zeros((4,4), dtype=int)\n      for i in range(4):\n          grid1[i] = read_ints()\n      \n      ans2 = read_int()\n      grid2 = np.zeros((4,4), dtype=int)\n      for i in range(4):\n          grid2[i] = read_ints()\n      \n      \n      case = (ans1, grid1, ans2, grid2)\n      \n      return case\n  \n  def solve_case(case):\n      \"\"\"Take the input data (structured in case) and perform any necessary\n      calculations to obtain the desired output, formatted as the appropriate\n      string.    \n      \"\"\"\n      \n      ans1, grid1, ans2, grid2 = case\n      \n      valid = set(grid1[ans1-1]) & set(grid2[ans2-1])\n      \n      \n      if len(valid) == 1:\n          output = valid.pop()\n      elif len(valid) > 1:\n          output = \"Bad magician!\"\n      elif len(valid) < 1:\n          output = \"Volunteer cheated!\"\n      return output\n  \n  \n  if __name__ == \"__main__\":\n      precalculate()\n      \n      assert len(sys.argv) == 2 #only one argument\n      assert sys.argv[1][-3:] == \".in\" #input must end with .in\n      tmp = open(\"%s\" % sys.argv[1], 'r')\n      outfile = open(\"%s.out\" % sys.argv[1][:-3], 'w')\n      \n      cases = int(tmp.readline().strip('\n'))\n      for i in range(cases):\n          \n          case = read_input(tmp)\n          \n          output = solve_case(case)\n          \n          outfile.write('Case #%i: %s\n' % (i+1, output))\n          print 'Case #%i: %s\n' % (i+1, output)\n      \n      tmp.close()\n      outfile.close()\n ", "Program Length": 591, "Identifier Num": 30, "Replaced Identifiers": "infile:tmp,", "Query Times": 129, "Time Cost": 0.05621089140574138, "Type": "wir"}
{"Index": 118, "Original Code": " \n  T = int(raw_input())\n  for test_case in xrange(1, T + 1):\n      R, C, M = map(int, raw_input().split())\n      N = R * C\n      B = N - M\n  \n      W, H = (C, R) if R <= C else (R, C)\n  \n      if H == 1:\n          answer = [['c'] + ['.'] * (B - 1) + ['*'] * M]\n      elif M == N - 1:\n          answer = [['*'] * W for r in xrange(H)]\n          answer[0][0] = 'c'\n      elif B < 4 or B in (5, 7):\n          answer = None\n      elif H == 2:\n          if M % 2 == 0:\n              bw = B / 2\n              answer = [\n                  ['c'] + ['.'] * (bw - 1) + ['*'] * (W - bw),\n                  ['.'] * bw + ['*'] * (W - bw),\n              ]\n          else:\n              answer = None\n      else:\n          answer = [['*'] * W for y in xrange(H)]\n          answer[0][0] = 'c'\n          answer[0][1] = answer[1][0] = answer[1][1] = '.'\n          left = B - 4\n          if 2 <= left:\n              answer[0][2] = answer[1][2] = '.'\n              left -= 2\n          if 2 <= left:\n              answer[2][0] = answer[2][1] = '.'\n              left -= 2\n  \n          x = y = 3\n          while (x < W or y < H) and 2 <= left:\n              if x < W and 2 <= left:\n                  answer[0][x] = answer[1][x] = '.'\n                  left -= 2\n                  x += 1\n              if y < H and 2 <= left:\n                  answer[y][0] = answer[y][1] = '.'\n                  left -= 2\n                  y += 1\n  \n          y = 2\n          while 0 < left and y < H:\n              x = 2\n              while 0 < left and x < W:\n                  answer[y][x] = '.'\n                  left -= 1\n                  x += 1\n              y += 1\n  \n      if answer is None:\n          answer = 'Impossible'\n      else:\n          if W == R:\n              answer = map(list, zip(*answer))\n          assert len(answer) == R\n          assert len(answer[0]) == C\n          assert sum(row.count('*') for row in answer) == M\n          answer = '\n'.join([''.join(row) for row in answer])\n      print 'Case #{}:\n{}'.format(test_case, answer)\n ", "Adversarial Code": " \n  T = int(raw_input())\n  for oldout in xrange(1, T + 1):\n      R, C, M = map(int, raw_input().split())\n      N = R * C\n      B = N - M\n  \n      W, H = (C, R) if R <= C else (R, C)\n  \n      if H == 1:\n          answer = [['c'] + ['.'] * (B - 1) + ['*'] * M]\n      elif M == N - 1:\n          answer = [['*'] * W for r in xrange(H)]\n          answer[0][0] = 'c'\n      elif B < 4 or B in (5, 7):\n          answer = None\n      elif H == 2:\n          if M % 2 == 0:\n              bw = B / 2\n              answer = [\n                  ['c'] + ['.'] * (bw - 1) + ['*'] * (W - bw),\n                  ['.'] * bw + ['*'] * (W - bw),\n              ]\n          else:\n              answer = None\n      else:\n          answer = [['*'] * W for y in xrange(H)]\n          answer[0][0] = 'c'\n          answer[0][1] = answer[1][0] = answer[1][1] = '.'\n          left = B - 4\n          if 2 <= left:\n              answer[0][2] = answer[1][2] = '.'\n              left -= 2\n          if 2 <= left:\n              answer[2][0] = answer[2][1] = '.'\n              left -= 2\n  \n          x = y = 3\n          while (x < W or y < H) and 2 <= left:\n              if x < W and 2 <= left:\n                  answer[0][x] = answer[1][x] = '.'\n                  left -= 2\n                  x += 1\n              if y < H and 2 <= left:\n                  answer[y][0] = answer[y][1] = '.'\n                  left -= 2\n                  y += 1\n  \n          y = 2\n          while 0 < left and y < H:\n              x = 2\n              while 0 < left and x < W:\n                  answer[y][x] = '.'\n                  left -= 1\n                  x += 1\n              y += 1\n  \n      if answer is None:\n          answer = 'Impossible'\n      else:\n          if W == R:\n              answer = map(list, zip(*answer))\n          assert len(answer) == R\n          assert len(answer[0]) == C\n          assert sum(row.count('*') for row in answer) == M\n          answer = '\n'.join([''.join(row) for row in answer])\n      print 'Case #{}:\n{}'.format(oldout, answer)\n ", "Program Length": 534, "Identifier Num": 15, "Replaced Identifiers": "test_case:oldout,", "Query Times": 156, "Time Cost": 0.0683397650718689, "Type": "wir"}
{"Index": 119, "Original Code": " \n  T = int(raw_input())\n  for test_case in xrange(1, T + 1):\n      N1 = int(raw_input())\n      for i in xrange(4):\n          if i + 1 == N1:\n              R1 = map(int, raw_input().split(' '))\n          else:\n              raw_input()\n      N2 = int(raw_input())\n      for i in xrange(4):\n          if i + 1 == N2:\n              R2 = map(int, raw_input().split(' '))\n          else:\n              raw_input()\n      assert 1 <= N1 <= 4\n      assert 1 <= N2 <= 4\n      assert len(R1) == len(R2) == 4\n  \n      num = set(R1) & set(R2)\n      if len(num) == 1:\n          answer = num.pop()\n      elif 1 < len(num):\n          answer = 'Bad magician!'\n      else:\n          answer = 'Volunteer cheated!'\n      print 'Case #{}: {}'.format(test_case, answer)\n ", "Adversarial Code": " \n  T = int(raw_input())\n  for shape in xrange(1, T + 1):\n      N1 = int(raw_input())\n      for i in xrange(4):\n          if i + 1 == N1:\n              R1 = map(int, raw_input().split(' '))\n          else:\n              raw_input()\n      N2 = int(raw_input())\n      for i in xrange(4):\n          if i + 1 == N2:\n              R2 = map(int, raw_input().split(' '))\n          else:\n              raw_input()\n      assert 1 <= N1 <= 4\n      assert 1 <= N2 <= 4\n      assert len(R1) == len(R2) == 4\n  \n      num = set(R1) & set(R2)\n      if len(num) == 1:\n          answer = num.pop()\n      elif 1 < len(num):\n          answer = 'Bad magician!'\n      else:\n          answer = 'Volunteer cheated!'\n      print 'Case #{}: {}'.format(shape, answer)\n ", "Program Length": 181, "Identifier Num": 9, "Replaced Identifiers": "test_case:shape,", "Query Times": 61, "Time Cost": 0.02488429148991903, "Type": "wir"}
{"Index": 120, "Original Code": " \n  def put_mines_last_step(R, C, M, grid):\n  \tif M == 0:\n  \t\treturn\n  \tR -= 1\n  \tC -= 1\n  \tgrid[R][C] = '*'\n  \tM -= 1\n  \tr = R - 1\n  \tc = C - 1\n  \twhile M > 0:\n  \t\tif r > c:\n  \t\t\tgrid[r][C] = '*'\n  \t\t\tr -= 1\n  \t\telse:\n  \t\t\tgrid[R][c] = '*'\n  \t\t\tc -= 1\n  \t\tM -= 1\n  \n  def put_mines(R, C, M, grid):\n  \tif R > C:\n  \t\tif M < C:\n  \t\t\tput_mines_last_step(R, C, M, grid)\n  \t\t\treturn\n  \t\tfor i in range(C):\n  \t\t\tgrid[R - 1][i] = '*'\n  \t\tput_mines(R - 1, C, M - C, grid)\n  \t\treturn\n  \tif M < R:\n  \t\tput_mines_last_step(R, C, M, grid)\n  \t\treturn\n  \tfor i in range(R):\n  \t\tgrid[i][C - 1] = '*'\n  \tput_mines(R, C - 1, M - R, grid)\n  \treturn\n  \n  def process(R, C, M):\n  \trlt = ''\n  \tgrid = []\n  \tfor i in range(R):\n  \t\tgrid.append(['.'] * C)\n  \tput_mines(R, C, M, grid)\n  \tif not C == 1:\n  \t\tfor i in range(R):\n  \t\t\tif not grid[i][0] == '.':\n  \t\t\t\tbreak\n  \t\t\tif not grid[i][1] == '.':\n  \t\t\t\treturn '\nImpossible'\n  \tif not R == 1:\n  \t\tfor i in range(C):\n  \t\t\tif not grid[0][i] == '.':\n  \t\t\t\tbreak\n  \t\t\tif not grid[1][i] == '.':\n  \t\t\t\treturn '\nImpossible'\n  \tgrid[0][0] = 'c'\n  \tfor i in grid:\n  \t\trlt += '\n' + ''.join(i)\n  \treturn rlt\n  \n  input_file = open(sys.argv[1], 'r')\n  T = int(input_file.readline())\n  for i in range(T):\n  \t(R, C, M) = map(int, input_file.readline().split())\n  \tprint 'Case #%d:' % (i + 1), process(R, C, M)\n ", "Adversarial Code": " \n  def put_mines_last_step(R, C, M, grid):\n  \tif M == 0:\n  \t\treturn\n  \tR -= 1\n  \tC -= 1\n  \tgrid[R][C] = '*'\n  \tM -= 1\n  \tsecond_arrangement = R - 1\n  \ttwo_columns = C - 1\n  \twhile M > 0:\n  \t\tif second_arrangement > two_columns:\n  \t\t\tgrid[second_arrangement][C] = '*'\n  \t\t\tsecond_arrangement -= 1\n  \t\telse:\n  \t\t\tgrid[R][two_columns] = '*'\n  \t\t\ttwo_columns -= 1\n  \t\tM -= 1\n  \n  def put_mines(R, C, M, grid):\n  \tif R > C:\n  \t\tif M < C:\n  \t\t\tput_mines_last_step(R, C, M, grid)\n  \t\t\treturn\n  \t\tfor i in range(C):\n  \t\t\tgrid[R - 1][i] = '*'\n  \t\tput_mines(R - 1, C, M - C, grid)\n  \t\treturn\n  \tif M < R:\n  \t\tput_mines_last_step(R, C, M, grid)\n  \t\treturn\n  \tfor i in range(R):\n  \t\tgrid[i][C - 1] = '*'\n  \tput_mines(R, C - 1, M - R, grid)\n  \treturn\n  \n  def process(R, C, M):\n  \tcase_count = ''\n  \tgrid = []\n  \tfor i in range(R):\n  \t\tgrid.append(['.'] * C)\n  \tput_mines(R, C, M, grid)\n  \tif not C == 1:\n  \t\tfor i in range(R):\n  \t\t\tif not grid[i][0] == '.':\n  \t\t\t\tbreak\n  \t\t\tif not grid[i][1] == '.':\n  \t\t\t\treturn '\nImpossible'\n  \tif not R == 1:\n  \t\tfor i in range(C):\n  \t\t\tif not grid[0][i] == '.':\n  \t\t\t\tbreak\n  \t\t\tif not grid[1][i] == '.':\n  \t\t\t\treturn '\nImpossible'\n  \tgrid[0][0] = 'c'\n  \tfor i in grid:\n  \t\tcase_count += '\n' + ''.join(i)\n  \treturn case_count\n  \n  input_file = open(sys.argv[1], 'r')\n  T = int(input_file.readline())\n  for i in range(T):\n  \t(R, C, M) = map(int, input_file.readline().split())\n  \tprint 'Case #%d:' % (i + 1), process(R, C, M)\n ", "Program Length": 425, "Identifier Num": 13, "Replaced Identifiers": "input_file:input_file,T:T,c:two_columns,r:second_arrangement,rlt:case_count,", "Query Times": 264, "Time Cost": 0.11160070101420085, "Type": "wir"}
{"Index": 121, "Original Code": " \n  \n  def process(chosen_row_1, arrange_1, chosen_row_2, arrange_2):\n  \trlt = 'Volunteer cheated!'\n  \tfound = False\n  \tfor i in arrange_1[chosen_row_1]:\n  \t\tif i in arrange_2[chosen_row_2]:\n  \t\t\tif not found:\n  \t\t\t\trlt = i\n  \t\t\t\tfound = True\n  \t\t\telse:\n  \t\t\t\trlt = 'Bad magician!'\n  \t\t\t\tbreak\n  \treturn rlt\n  \n  input_file = open(sys.argv[1], 'r')\n  T = int(input_file.readline())\n  for i in range(T):\n  \tchosen_row_1 = int(input_file.readline()) - 1\n  \tarrange_1 = []\n  \tarrange_1.append(map(int, input_file.readline().split()))\n  \tarrange_1.append(map(int, input_file.readline().split()))\n  \tarrange_1.append(map(int, input_file.readline().split()))\n  \tarrange_1.append(map(int, input_file.readline().split()))\n  \tchosen_row_2 = int(input_file.readline()) - 1\n  \tarrange_2 = []\n  \tarrange_2.append(map(int, input_file.readline().split()))\n  \tarrange_2.append(map(int, input_file.readline().split()))\n  \tarrange_2.append(map(int, input_file.readline().split()))\n  \tarrange_2.append(map(int, input_file.readline().split()))\n  \tprint 'Case #%d:' % (i + 1), process(chosen_row_1, arrange_1, chosen_row_2, arrange_2)\n ", "Adversarial Code": " \n  \n  def process(chosen_row_1, arrange_1, out, arrange_2):\n  \tsample_in = 'Volunteer cheated!'\n  \tNumCases = False\n  \tfor test_4 in arrange_1[chosen_row_1]:\n  \t\tif test_4 in arrange_2[out]:\n  \t\t\tif not NumCases:\n  \t\t\t\tsample_in = test_4\n  \t\t\t\tNumCases = True\n  \t\t\telse:\n  \t\t\t\tsample_in = 'Bad magician!'\n  \t\t\t\tbreak\n  \treturn sample_in\n  \n  r1 = open(sys.argv[1], 'r')\n  NumCases = int(r1.readline())\n  for test_4 in range(NumCases):\n  \tchosen_row_1 = int(r1.readline()) - 1\n  \tarrange_1 = []\n  \tarrange_1.append(map(int, r1.readline().split()))\n  \tarrange_1.append(map(int, r1.readline().split()))\n  \tarrange_1.append(map(int, r1.readline().split()))\n  \tarrange_1.append(map(int, r1.readline().split()))\n  \tout = int(r1.readline()) - 1\n  \tarrange_2 = []\n  \tarrange_2.append(map(int, r1.readline().split()))\n  \tarrange_2.append(map(int, r1.readline().split()))\n  \tarrange_2.append(map(int, r1.readline().split()))\n  \tarrange_2.append(map(int, r1.readline().split()))\n  \tprint 'Case #%d:' % (test_4 + 1), process(chosen_row_1, arrange_1, out, arrange_2)\n ", "Program Length": 286, "Identifier Num": 10, "Replaced Identifiers": "found:NumCases,T:NumCases,i:test_4,rlt:sample_in,chosen_row_2:out,input_file:r1,", "Query Times": 233, "Time Cost": 0.09830298821131388, "Type": "wir"}
{"Index": 122, "Original Code": "inputFile = open('C-small-attempt8.in', 'r')\n  lines = inputFile.readlines()\n  inputFile.close()\n  \n  outputFile = open('C-small-attempt8.out', 'w')\n  \n  numTests = int(lines[0])\n  \n  for i in range(1, numTests+1):\n      [r, c, m] = map(lambda x: int(x), lines[i].split())\n  \n      openCells = r*c - m\n  \n      works = False\n      matrix = [['*']*c for j in range(r)]\n      if r >= 3 and c >= 3:\n          order = [(0,0), (0,1), (1,0), (1,1), (0,2), (1,2),\n                   (2,0), (2,1)]\n          if openCells == 1 or openCells == 4 or openCells == 6:\n              works = True\n              for (x,y) in order[:openCells]:\n                  matrix[x][y] = '.'\n              matrix[0][0] = 'c'\n              \n          elif openCells >= 8:\n              works = True\n              filledRows = openCells / c\n              if filledRows >= 2:\n                  if filledRows == r:\n                      matrix = [['.']*c for j in range(r)]\n                      matrix[0][0] = 'c'\n                  else:\n                      remainder = openCells%c\n                      if not remainder == 1:\n                          for j in range(filledRows):\n                              matrix[j] = ['.']*c\n                          matrix[filledRows] = ['.']*remainder + ['*'] * (c-remainder)\n                      elif filledRows > 2:\n                          for j in range(filledRows-1):\n                              matrix[j] = ['.']*c\n                          matrix[filledRows-1] = ['.']*(c-1) + ['*']\n                          matrix[filledRows] = ['.', '.'] + ['*']*(c-2)\n                      else:\n                          matrix[0] = ['.']*(c-1) + ['*']                        \n                          matrix[1] = ['.']*(c-1) + ['*']\n                          matrix[2] = ['.', '.', '.'] + ['*']*(c-3)\n                      matrix[0][0] = 'c'\n                  \n              else:\n                  for (x,y) in order:\n                      matrix[x][y] = '.'\n                  remainingOpen = openCells - 8\n                  if remainingOpen % 2 == 0:\n                      for j in range(remainingOpen/2):\n                          matrix[0][j+3] = '.'\n                          matrix[1][j+3] = '.'\n                  else:\n                      matrix[2][2] = '.'\n                      remainingOpen -= 1\n                      for j in range(remainingOpen/2):\n                          matrix[0][j+3] = '.'\n                          matrix[1][j+3] = '.'\n                  matrix[0][0] = 'c'\n  \n      elif r == 1:\n          works = True\n          matrix[0] = ['.']*(c-m) + ['*']*m\n          matrix[0][0] = 'c'\n      elif c == 1:\n          works = True\n          for j in range(r-m):\n              matrix[j][0] = '.'\n          matrix[0][0] = 'c'\n  \n      elif r == 2 and c == 2:\n          if m == 3:\n              works = True\n              matrix[0][0] = 'c'\n          elif m == 0:\n              works = True\n              matrix = [['c', '.'], ['.', '.']]\n      elif r == 2:\n          if m % 2 == 0 and r*c-m > 2:\n              works = True\n              matrix[0] = ['.']*(c-m/2) + ['*']*(m/2)\n              matrix[1] = ['.']*(c-m/2) + ['*']*(m/2)\n              matrix[0][0] = 'c'\n          elif r*c-m == 1:\n              works = True\n              matrix[0][0] = 'c'\n      elif c == 2:\n          if m % 2 == 0 and r*c-m > 2:\n              works = True\n              for j in range((r*c-m)/2):\n                  matrix[j] = ['.', '.']\n              matrix[0][0] = 'c'\n          elif r*c-m == 1:\n              works = True\n              matrix[0][0] = 'c'\n      \n  \n      outputFile.write('Case #'+str(i)+':\n')\n      '''if len(matrix) != r:\n          print i, matrix\n      count = 0\n      for j in range(len(matrix)):\n          for k in range(len(matrix[j])):\n              if matrix[j][k] == '*':\n                  count += 1\n      if count != m:\n          print i, matrix'''\n      if not works:\n          outputFile.write('Impossible\n')\n      else:\n          for x in range(len(matrix)):\n              for y in range(len(matrix[0])):\n                  outputFile.write(matrix[x][y])\n              outputFile.write('\n')\n  outputFile.close()\n              \n ", "Adversarial Code": "solve_inputs = open('C-small-attempt8.in', 'r')\n  lines = solve_inputs.readlines()\n  solve_inputs.close()\n  \n  iterate_cases_1lpc = open('C-small-attempt8.out', 'w')\n  \n  numTests = int(lines[0])\n  \n  for i in range(1, numTests+1):\n      [r, c, m] = map(lambda x: int(x), lines[i].split())\n  \n      openCells = r*c - m\n  \n      works = False\n      matrix = [['*']*c for j in range(r)]\n      if r >= 3 and c >= 3:\n          order = [(0,0), (0,1), (1,0), (1,1), (0,2), (1,2),\n                   (2,0), (2,1)]\n          if openCells == 1 or openCells == 4 or openCells == 6:\n              works = True\n              for (x,y) in order[:openCells]:\n                  matrix[x][y] = '.'\n              matrix[0][0] = 'c'\n              \n          elif openCells >= 8:\n              works = True\n              filledRows = openCells / c\n              if filledRows >= 2:\n                  if filledRows == r:\n                      matrix = [['.']*c for j in range(r)]\n                      matrix[0][0] = 'c'\n                  else:\n                      remainder = openCells%c\n                      if not remainder == 1:\n                          for j in range(filledRows):\n                              matrix[j] = ['.']*c\n                          matrix[filledRows] = ['.']*remainder + ['*'] * (c-remainder)\n                      elif filledRows > 2:\n                          for j in range(filledRows-1):\n                              matrix[j] = ['.']*c\n                          matrix[filledRows-1] = ['.']*(c-1) + ['*']\n                          matrix[filledRows] = ['.', '.'] + ['*']*(c-2)\n                      else:\n                          matrix[0] = ['.']*(c-1) + ['*']                        \n                          matrix[1] = ['.']*(c-1) + ['*']\n                          matrix[2] = ['.', '.', '.'] + ['*']*(c-3)\n                      matrix[0][0] = 'c'\n                  \n              else:\n                  for (x,y) in order:\n                      matrix[x][y] = '.'\n                  remainingOpen = openCells - 8\n                  if remainingOpen % 2 == 0:\n                      for j in range(remainingOpen/2):\n                          matrix[0][j+3] = '.'\n                          matrix[1][j+3] = '.'\n                  else:\n                      matrix[2][2] = '.'\n                      remainingOpen -= 1\n                      for j in range(remainingOpen/2):\n                          matrix[0][j+3] = '.'\n                          matrix[1][j+3] = '.'\n                  matrix[0][0] = 'c'\n  \n      elif r == 1:\n          works = True\n          matrix[0] = ['.']*(c-m) + ['*']*m\n          matrix[0][0] = 'c'\n      elif c == 1:\n          works = True\n          for j in range(r-m):\n              matrix[j][0] = '.'\n          matrix[0][0] = 'c'\n  \n      elif r == 2 and c == 2:\n          if m == 3:\n              works = True\n              matrix[0][0] = 'c'\n          elif m == 0:\n              works = True\n              matrix = [['c', '.'], ['.', '.']]\n      elif r == 2:\n          if m % 2 == 0 and r*c-m > 2:\n              works = True\n              matrix[0] = ['.']*(c-m/2) + ['*']*(m/2)\n              matrix[1] = ['.']*(c-m/2) + ['*']*(m/2)\n              matrix[0][0] = 'c'\n          elif r*c-m == 1:\n              works = True\n              matrix[0][0] = 'c'\n      elif c == 2:\n          if m % 2 == 0 and r*c-m > 2:\n              works = True\n              for j in range((r*c-m)/2):\n                  matrix[j] = ['.', '.']\n              matrix[0][0] = 'c'\n          elif r*c-m == 1:\n              works = True\n              matrix[0][0] = 'c'\n      \n  \n      iterate_cases_1lpc.write('Case #'+str(i)+':\n')\n      '''if len(matrix) != r:\n          print i, matrix\n      count = 0\n      for j in range(len(matrix)):\n          for k in range(len(matrix[j])):\n              if matrix[j][k] == '*':\n                  count += 1\n      if count != m:\n          print i, matrix'''\n      if not works:\n          iterate_cases_1lpc.write('Impossible\n')\n      else:\n          for x in range(len(matrix)):\n              for y in range(len(matrix[0])):\n                  iterate_cases_1lpc.write(matrix[x][y])\n              iterate_cases_1lpc.write('\n')\n  iterate_cases_1lpc.close()\n              \n ", "Program Length": 946, "Identifier Num": 17, "Replaced Identifiers": "outputFile:iterate_cases_1lpc,inputFile:solve_inputs,", "Query Times": 248, "Time Cost": 0.1137211283047994, "Type": "wir"}
{"Index": 123, "Original Code": "inputFile = open('A-small-attempt0.in', 'r')\n  lines = inputFile.readlines()\n  inputFile.close()\n  \n  outputFile = open('A-small-attempt0.out', 'w')\n  \n  numTests = int(lines[0])\n  \n  \n  currLine = 1\n  for i in range(1, numTests+1):\n      firstRow = lines[int(lines[currLine])+currLine]\n      currLine += 5\n      secondRow = lines[int(lines[currLine])+currLine]\n      currLine += 5\n  \n      firstNums = map(lambda x: int(x), firstRow.split())\n      secondNums = map(lambda x: int(x), secondRow.split())\n      \n      intersect = [v for v in firstNums if v in secondNums]\n  \n      outputFile.write('Case #'+str(i)+': ')\n      if len(intersect) == 1:\n          outputFile.write(str(intersect[0])+'\n')\n      elif len(intersect) == 0:\n          outputFile.write('Volunteer cheated!\n')\n      else:\n          outputFile.write('Bad magician!\n')\n  \n  outputFile.close()\n      \n ", "Adversarial Code": "iCase = open('A-small-attempt0.in', 'r')\n  lines = iCase.readlines()\n  iCase.close()\n  \n  outputFile = open('A-small-attempt0.out', 'w')\n  \n  try_to_click = int(lines[0])\n  \n  \n  currLine = 1\n  for readf in range(1, try_to_click+1):\n      firstRow = lines[int(lines[currLine])+currLine]\n      currLine += 5\n      read_input = lines[int(lines[currLine])+currLine]\n      currLine += 5\n  \n      process = map(lambda x: int(x), firstRow.split())\n      secondNums = map(lambda x: int(x), read_input.split())\n      \n      intersect = [v for v in process if v in secondNums]\n  \n      outputFile.write('Case #'+str(readf)+': ')\n      if len(intersect) == 1:\n          outputFile.write(str(intersect[0])+'\n')\n      elif len(intersect) == 0:\n          outputFile.write('Volunteer cheated!\n')\n      else:\n          outputFile.write('Bad magician!\n')\n  \n  outputFile.close()\n      \n ", "Program Length": 206, "Identifier Num": 12, "Replaced Identifiers": "inputFile:iCase,numTests:try_to_click,i:readf,firstNums:process,secondRow:read_input,", "Query Times": 194, "Time Cost": 0.07989903291066487, "Type": "wir"}
{"Index": 124, "Original Code": " \n  INPUT = 'C-small-attempt0.in'\n  OUTPUT = 'C-small-attempt0.out'\n  \n  \n  def solve(R, C, M):\n      grid = [[0 for c in range(C)] for r in range(R)]\n  \n      def get_cell(cell_r, cell_c):\n          if not(0 <= cell_r < R):\n              return None\n          if not(0 <= cell_c < C):\n              return None\n          return grid[cell_r][cell_c]\n  \n      def for_each_neighbour(cell_r, cell_c, func):\n          ret = []\n          coords = (\n              (cell_r - 1, cell_c - 1), (cell_r - 1, cell_c), (cell_r - 1, cell_c + 1),\n              (cell_r, cell_c - 1), (cell_r, cell_c + 1),\n              (cell_r + 1, cell_c - 1), (cell_r + 1, cell_c), (cell_r + 1, cell_c + 1)\n          )\n          for nb in coords:\n              if get_cell(nb[0], nb[1]) is not None:\n                  ret.append(func(nb[0], nb[1]))\n          return ret\n  \n      def mark_dirty(cell_r, cell_c):\n          if grid[cell_r][cell_c] != '*':\n              grid[cell_r][cell_c] += 1\n      \n      def unmark_dirty(cell_r, cell_c):\n          if grid[cell_r][cell_c] != '*':\n              grid[cell_r][cell_c] -= 1\n  \n      def check_empty_neighbours(cell_r, cell_c):\n          return (0 in for_each_neighbour(cell_r, cell_c, lambda r, c: get_cell(r, c)))\n  \n      def click():\n          for i, row in enumerate(grid):\n              for j, cell in enumerate(row):\n                  if cell != '*':\n                      if cell == 0 or ((R * C - M) == 1):\n                          grid[i][j] = 'c'\n                          return\n  \n      def place_mine():\n          for i, row in enumerate(grid):\n              for j, cell in enumerate(row):\n                  if cell == '*':\n                      continue\n                  prevstate = grid[i][j]\n                  grid[i][j] = '*'\n                  for_each_neighbour(i, j, mark_dirty)\n                  if not (True in for_each_neighbour(i, j, check_empty_neighbours)):\n                      grid[i][j] = prevstate\n                      for_each_neighbour(i, j, unmark_dirty)\n                  else:\n                      return True\n          return False\n  \n      for m in range(M):\n          if not place_mine():\n              return 'Impossible\n'\n  \n      click()\n  \n      ret = ''\n      for row in grid:\n          ret = ret + ''.join(map(lambda c: '.' if isinstance(c, int) else c, row)) + '\n'\n  \n      return ret\n  \n  \n  if __name__ == '__main__':\n      inp = open(INPUT)\n      out = open(OUTPUT, 'w')\n      \n      T = int(inp.readline())\n  \n      for case in range(T):\n          sol = solve(*map(int, inp.readline().split()))\n          out.write('Case #%i:\n%s' % (case + 1, sol))\n ", "Adversarial Code": " \n  INPUT = 'C-small-attempt0.in'\n  OUTPUT = 'C-small-attempt0.out'\n  \n  \n  def solve(R, C, M):\n      grid = [[0 for c in range(C)] for r in range(R)]\n  \n      def get_cell(read_case, divmod):\n          if not(0 <= read_case < R):\n              return None\n          if not(0 <= divmod < C):\n              return None\n          return grid[read_case][divmod]\n  \n      def for_each_neighbour(read_case, divmod, func):\n          ret = []\n          coords = (\n              (read_case - 1, divmod - 1), (read_case - 1, divmod), (read_case - 1, divmod + 1),\n              (read_case, divmod - 1), (read_case, divmod + 1),\n              (read_case + 1, divmod - 1), (read_case + 1, divmod), (read_case + 1, divmod + 1)\n          )\n          for nb in coords:\n              if get_cell(nb[0], nb[1]) is not None:\n                  ret.append(func(nb[0], nb[1]))\n          return ret\n  \n      def mark_dirty(read_case, divmod):\n          if grid[read_case][divmod] != '*':\n              grid[read_case][divmod] += 1\n      \n      def unmark_dirty(read_case, divmod):\n          if grid[read_case][divmod] != '*':\n              grid[read_case][divmod] -= 1\n  \n      def check_empty_neighbours(read_case, divmod):\n          return (0 in for_each_neighbour(read_case, divmod, lambda r, c: get_cell(r, c)))\n  \n      def click():\n          for i, row in enumerate(grid):\n              for j, cell in enumerate(row):\n                  if cell != '*':\n                      if cell == 0 or ((R * C - M) == 1):\n                          grid[i][j] = 'c'\n                          return\n  \n      def place_mine():\n          for i, row in enumerate(grid):\n              for j, cell in enumerate(row):\n                  if cell == '*':\n                      continue\n                  prevstate = grid[i][j]\n                  grid[i][j] = '*'\n                  for_each_neighbour(i, j, mark_dirty)\n                  if not (True in for_each_neighbour(i, j, check_empty_neighbours)):\n                      grid[i][j] = prevstate\n                      for_each_neighbour(i, j, unmark_dirty)\n                  else:\n                      return True\n          return False\n  \n      for m in range(M):\n          if not place_mine():\n              return 'Impossible\n'\n  \n      click()\n  \n      ret = ''\n      for row in grid:\n          ret = ret + ''.join(map(lambda c: '.' if isinstance(c, int) else c, row)) + '\n'\n  \n      return ret\n  \n  \n  if __name__ == '__main__':\n      inp = open(INPUT)\n      out = open(OUTPUT, 'w')\n      \n      T = int(inp.readline())\n  \n      for case in range(T):\n          sol = solve(*map(int, inp.readline().split()))\n          out.write('Case #%i:\n%s' % (case + 1, sol))\n ", "Program Length": 581, "Identifier Num": 26, "Replaced Identifiers": "cell_c:divmod,cell_r:read_case,", "Query Times": 188, "Time Cost": 0.0819191018740336, "Type": "wir"}
{"Index": 125, "Original Code": " \n  INPUT = 'A-small-attempt0.in'\n  OUTPUT = 'A-small-attempt0.out'\n  \n  \n  def solve(answer1, arr1, answer2, arr2):\n      ret = None\n  \n      for card in arr1[answer1 - 1]:\n          if card in arr2[answer2 - 1]:\n              if ret is not None:\n                  return 'Bad magician!'\n              else:\n                  ret = card\n      if ret is None:\n          return 'Volunteer cheated!'\n      return ret\n  \n  if __name__ == '__main__':\n      inp = open(INPUT)\n      out = open(OUTPUT, 'w')\n      \n      T = int(inp.readline())\n  \n      def read_answer_and_arr():\n          answer = int(inp.readline())\n          arr = []\n          for i in range(4):\n              arr.append( map(int, inp.readline().split()) )\n          return answer, arr\n  \n      for case in range(T):\n          answer1, arr1 = read_answer_and_arr()\n          answer2, arr2 = read_answer_and_arr()\n  \n          out.write('Case #%i: %s\n' % \\\n                          (case + 1, solve(answer1, arr1, answer2, arr2)))\n ", "Adversarial Code": " \n  do_trial = 'A-small-attempt0.in'\n  OUTPUT = 'A-small-attempt0.out'\n  \n  \n  def solve(answer1, arr1, answer2, arr2):\n      ret = None\n  \n      for card in arr1[answer1 - 1]:\n          if card in arr2[answer2 - 1]:\n              if ret is not None:\n                  return 'Bad magician!'\n              else:\n                  ret = card\n      if ret is None:\n          return 'Volunteer cheated!'\n      return ret\n  \n  if __name__ == '__main__':\n      inp = open(do_trial)\n      out = open(OUTPUT, 'w')\n      \n      T = int(inp.readline())\n  \n      def read_answer_and_arr():\n          answer = int(inp.readline())\n          arr = []\n          for i in range(4):\n              arr.append( map(int, inp.readline().split()) )\n          return answer, arr\n  \n      for case in range(T):\n          answer1, arr1 = read_answer_and_arr()\n          answer2, arr2 = read_answer_and_arr()\n  \n          out.write('Case #%i: %s\n' % \\\n                          (case + 1, solve(answer1, arr1, answer2, arr2)))\n ", "Program Length": 188, "Identifier Num": 17, "Replaced Identifiers": "INPUT:do_trial,", "Query Times": 77, "Time Cost": 0.03233546813329061, "Type": "wir"}
{"Index": 127, "Original Code": " \n  \n  \n  def solve(arrange):\n      board, row = arrange[0]\n      before = board[row - 1]\n      board, row = arrange[1]\n      after = board[row - 1]\n      dup = set(before) & set(after)\n      if len(dup) == 1:\n          return dup.pop()\n      elif len(dup) >= 2:\n          return 'Bad magician!'\n      else:\n          return 'Volunteer cheated!'\n  \n  \n  def main(IN, OUT):\n      T = int(IN.readline())\n      for index in range(T):\n          arrange = []\n          for n in range(2):\n              row = int(IN.readline())\n              board = []\n              for line in range(4):\n                  board.append(map(int, IN.readline().split()))\n              arrange.append((board, row))\n          OUT.write('Case #%d: %s\n' % (index + 1, solve(arrange)))\n  \n  \n  def makesample(T=100):\n      print T\n      for index in range(T):\n          for n in range(2):\n              print random.randint(1, 4)\n              board = list(range(1, 16+1))\n              random.shuffle(board)\n              while board:\n                  print ' '.join(map(str, board[:4]))\n                  board = board[4:]\n  \n  \n  if __name__ == '__main__':\n      if '-makesample' in sys.argv[1:]:\n          makesample()\n      else:\n          main(sys.stdin, sys.stdout)\n  \n ", "Adversarial Code": " \n  \n  \n  def solve(basename):\n      edge_row_idx, makesample = basename[0]\n      problem_output = edge_row_idx[makesample - 1]\n      edge_row_idx, makesample = basename[1]\n      __init__ = edge_row_idx[makesample - 1]\n      num_mines_in_column = set(problem_output) & set(__init__)\n      if len(num_mines_in_column) == 1:\n          return num_mines_in_column.pop()\n      elif len(num_mines_in_column) >= 2:\n          return 'Bad magician!'\n      else:\n          return 'Volunteer cheated!'\n  \n  \n  def main(length_of_answer, parser):\n      parse_single = int(length_of_answer.readline())\n      for output_writer in range(parse_single):\n          basename = []\n          for answer in range(2):\n              makesample = int(length_of_answer.readline())\n              edge_row_idx = []\n              for no_mine_row_max in range(4):\n                  edge_row_idx.append(map(int, length_of_answer.readline().split()))\n              basename.append((edge_row_idx, makesample))\n          parser.write('Case #%d: %s\n' % (output_writer + 1, solve(basename)))\n  \n  \n  def makesample(parse_single=100):\n      print parse_single\n      for output_writer in range(parse_single):\n          for answer in range(2):\n              print random.randint(1, 4)\n              edge_row_idx = list(range(1, 16+1))\n              random.shuffle(edge_row_idx)\n              while edge_row_idx:\n                  print ' '.join(map(str, edge_row_idx[:4]))\n                  edge_row_idx = edge_row_idx[4:]\n  \n  \n  if __name__ == '__main__':\n      if '-makesample' in sys.argv[1:]:\n          makesample()\n      else:\n          main(sys.stdin, sys.stdout)\n  \n ", "Program Length": 297, "Identifier Num": 15, "Replaced Identifiers": "IN:length_of_answer,n:answer,line:no_mine_row_max,before:problem_output,OUT:parser,after:__init__,index:output_writer,dup:num_mines_in_column,row:makesample,T:parse_single,arrange:basename,board:edge_row_idx,", "Query Times": 414, "Time Cost": 0.17369351387023926, "Type": "wir"}
{"Index": 129, "Original Code": " \n  \n  def solve(row1, row2):\n      common = [x for x in row1 if x in row2]\n      num_common = len(common)\n      if num_common == 0:\n          return 'Volunteer cheated!'\n      elif num_common > 1:\n          return 'Bad magician!'\n      else:\n          return common[0]\n  \n  def main():\n      N = int(sys.stdin.readline()) # number of testcases\n      for i in range(N):\n          row_index1 = int(sys.stdin.readline())\n          row1 = list()\n          for j in range(4):\n              if row_index1 == j + 1:\n                  row1 = [int(x) for x in sys.stdin.readline().rstrip().split()]\n              else:\n                  sys.stdin.readline()\n  \n          row_index2 = int(sys.stdin.readline())\n          row2 = list()\n          for j in range(4):\n              if row_index2 == j + 1:\n                  row2 = [int(x) for x in sys.stdin.readline().rstrip().split()]\n              else:\n                  sys.stdin.readline()\n  \n          result = solve(row1, row2)\n          print (\"Case #%s: %s\" % (i+1, result))\n  \n  if __name__ == '__main__':\n      main()\n ", "Adversarial Code": " \n  \n  def solve(row1, row2):\n      common = [x for x in row1 if x in row2]\n      num_common = len(common)\n      if num_common == 0:\n          return 'Volunteer cheated!'\n      elif num_common > 1:\n          return 'Bad magician!'\n      else:\n          return common[0]\n  \n  def main():\n      bad = int(sys.stdin.readline()) # number of testcases\n      for i in range(bad):\n          row_index1 = int(sys.stdin.readline())\n          row1 = list()\n          for j in range(4):\n              if row_index1 == j + 1:\n                  row1 = [int(x) for x in sys.stdin.readline().rstrip().split()]\n              else:\n                  sys.stdin.readline()\n  \n          row_index2 = int(sys.stdin.readline())\n          row2 = list()\n          for j in range(4):\n              if row_index2 == j + 1:\n                  row2 = [int(x) for x in sys.stdin.readline().rstrip().split()]\n              else:\n                  sys.stdin.readline()\n  \n          result = solve(row1, row2)\n          print (\"Case #%s: %s\" % (i+1, result))\n  \n  if __name__ == '__main__':\n      main()\n ", "Program Length": 235, "Identifier Num": 13, "Replaced Identifiers": "N:bad,", "Query Times": 71, "Time Cost": 0.028970531622568765, "Type": "wir"}
{"Index": 131, "Original Code": "T = int(input())\n  \n  for i in range(T):\n      a1 = int(input())\n      mat1 = [list(map(int, input().split())) for k in range(4)]\n      a2 = int(input())\n      mat2 = [list(map(int, input().split())) for k in range(4)]\n      final_set = set(mat1[a1 - 1]) & set(mat2[a2 - 1])\n      if not len(final_set):\n          s = 'Volunteer cheated!'\n      elif len(final_set) > 1:\n          s = 'Bad magician!'\n      else:\n          s = list(final_set)[0]\n      print('Case #{}: {}'.format(i + 1, s))\n ", "Adversarial Code": "T = int(input())\n  \n  for new_state in range(T):\n      a1 = int(input())\n      mat1 = [list(map(int, input().split())) for k in range(4)]\n      a2 = int(input())\n      mat2 = [list(map(int, input().split())) for k in range(4)]\n      final_set = set(mat1[a1 - 1]) & set(mat2[a2 - 1])\n      if not len(final_set):\n          s = 'Volunteer cheated!'\n      elif len(final_set) > 1:\n          s = 'Bad magician!'\n      else:\n          s = list(final_set)[0]\n      print('Case #{}: {}'.format(new_state + 1, s))\n ", "Program Length": 150, "Identifier Num": 9, "Replaced Identifiers": "i:new_state,", "Query Times": 56, "Time Cost": 0.022659158706665038, "Type": "wir"}
