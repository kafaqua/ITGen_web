{"Index": 0, "Original Code": "\"\"\"Usage:\n      pypy X.py < X-size.in > X-size.out\n  or sometimes\n      python X.py < X-size.in > X-size.out\n  \"\"\"\n  \n  def setup(infile):\n      return locals()\n  \n  def reader(testcase, infile, C=None, **ignore):\n      P = map(int, infile.next().split())\n      return locals()\n  \n  def solver(testcase, N=None, P=None, I=None, T=None, S=None, C=None, **ignore):\n  \n      R, C, M = P\n      MM = M\n  \n      F = np.array([['.'] * C] * R)\n      while M > 0:\n          if R >= C and M >= C and R > 2:\n              M -= C\n              R -= 1\n              F[R] = '*'\n          elif C > R  and M >= R and C > 2:\n              M -= R\n              C -= 1\n              F[:, C] = '*'\n          elif R > 2 and C > 2 and (R > 3 or C > 3 or M == 1):\n              if M < C - 1:\n                  R -= 1\n                  F[R, C - M:C] = '*'\n              elif M < R - 1:\n                  C -= 1\n                  F[R - M:R, C] = '*'\n              elif M == C - 1:\n                  R -= 1\n                  F[R, C - M + 1:C] = '*'\n                  F[R - 1, C - 1] = '*'\n              else:\n                  C -= 1\n                  F[R - M + 1:R, C] = '*'\n                  F[R - 1, C - 1] = '*'\n              M = 0\n          elif M == R * C - 1:\n              F[:, :] = '*'\n              M = 0\n          else:\n              return 'Case #%s:\n%s\n' % (testcase, 'Impossible')\n  \n      F[0, 0] = 'c'\n      assert (F == '*').sum() == MM\n      return 'Case #%s:\n%s\n' % (testcase, '\n'.join(''.join(f.tolist()) for f in F))\n  \n  if __name__ == '__main__':\n      T = int(sys.stdin.next())\n      common = setup(sys.stdin)\n      for t in xrange(1, T+1):\n          sys.stdout.write(solver(**reader(t, **common)))\n ", "Adversarial Code": "\"\"\"Usage:\n      pypy X.py < X-size.in > X-size.out\n  or sometimes\n      python X.py < X-size.in > X-size.out\n  \"\"\"\n  \n  def setup(c1):\n      return locals()\n  \n  def reader(list_to_float, c1, C=None, **ignore):\n      inputFilename = map(int, c1.next().split())\n      return locals()\n  \n  def test_4(list_to_float, N=None, inputFilename=None, I=None, empty=None, S=None, C=None, **ignore):\n  \n      R, C, M = inputFilename\n      MM = M\n  \n      F = np.array([['.'] * C] * R)\n      while M > 0:\n          if R >= C and M >= C and R > 2:\n              M -= C\n              R -= 1\n              F[R] = '*'\n          elif C > R  and M >= R and C > 2:\n              M -= R\n              C -= 1\n              F[:, C] = '*'\n          elif R > 2 and C > 2 and (R > 3 or C > 3 or M == 1):\n              if M < C - 1:\n                  R -= 1\n                  F[R, C - M:C] = '*'\n              elif M < R - 1:\n                  C -= 1\n                  F[R - M:R, C] = '*'\n              elif M == C - 1:\n                  R -= 1\n                  F[R, C - M + 1:C] = '*'\n                  F[R - 1, C - 1] = '*'\n              else:\n                  C -= 1\n                  F[R - M + 1:R, C] = '*'\n                  F[R - 1, C - 1] = '*'\n              M = 0\n          elif M == R * C - 1:\n              F[:, :] = '*'\n              M = 0\n          else:\n              return 'Case #%s:\n%s\n' % (testcase, 'Impossible')\n  \n      F[0, 0] = 'c'\n      assert (F == '*').sum() == MM\n      return 'Case #%s:\n%s\n' % (testcase, '\n'.join(''.join(Solution.tolist()) for Solution in F))\n  \n  if __name__ == '__main__':\n      empty = int(sys.stdin.next())\n      common = setup(sys.stdin)\n      for t in xrange(1, empty+1):\n          sys.stdout.write(test_4(**reader(t, **common)))\n ", "Program Length": 429, "Identifier Num": 16, "Replaced Identifiers": "T:empty,solver:test_4,testcase:list_to_float,f:Solution,infile:c1,P:inputFilename,", "Query Times": 180, "Time Cost": 0.07882081270217896, "Type": "mhm"}
{"Index": 1, "Original Code": "\"\"\"Usage:\n      pypy X.py < X-size.in > X-size.out\n  or sometimes\n      python X.py < X-size.in > X-size.out\n  \"\"\"\n  \n  def setup(infile):\n      return locals()\n  \n  def reader(testcase, infile, C=None, **ignore):\n      N = int(infile.next())\n      I = [map(int, infile.next().split()) for i in range(4)]\n      T = int(infile.next())\n      S = [map(int, infile.next().split()) for i in range(4)]\n      return locals()\n  \n  def solver(testcase, N=None, P=None, I=None, T=None, S=None, C=None, **ignore):\n  \n      res = set(I[N-1]) & set(S[T-1])\n      if len(res) == 1:\n          res = res.pop()\n      elif len(res) > 1:\n          res = 'Bad magician!'\n      else:\n          res = 'Volunteer cheated!'\n      return 'Case #%s: %s\n' % (testcase, res)\n  \n  if __name__ == '__main__':\n      T = int(sys.stdin.next())\n      common = setup(sys.stdin)\n      for t in xrange(1, T+1):\n          sys.stdout.write(solver(**reader(t, **common)))\n ", "Adversarial Code": "\"\"\"Usage:\n      pypy X.py < X-size.in > X-size.out\n  or sometimes\n      python X.py < X-size.in > X-size.out\n  \"\"\"\n  \n  def mid_cells(infile):\n      return locals()\n  \n  def cnts(testcase, infile, C=None, **ignore):\n      global = int(infile.next())\n      output_str = [map(int, infile.next().split()) for cnts in range(4)]\n      filenames = int(infile.next())\n      recent = [map(int, infile.next().split()) for cnts in range(4)]\n      return locals()\n  \n  def row_string(testcase, global=None, P=None, output_str=None, filenames=None, recent=None, C=None, **ignore):\n  \n      safe_cols = set(output_str[global-1]) & set(recent[filenames-1])\n      if len(safe_cols) == 1:\n          safe_cols = safe_cols.pop()\n      elif len(safe_cols) > 1:\n          safe_cols = 'Bad magician!'\n      else:\n          safe_cols = 'Volunteer cheated!'\n      return 'Case #%s: %s\n' % (testcase, safe_cols)\n  \n  if __name__ == '__main__':\n      filenames = int(sys.stdin.next())\n      common = mid_cells(sys.stdin)\n      for stop_flag in xrange(1, filenames+1):\n          sys.stdout.write(row_string(**cnts(stop_flag, **common)))\n ", "Program Length": 249, "Identifier Num": 15, "Replaced Identifiers": "setup:mid_cells,S:recent,N:global,reader:cnts,i:cnts,res:safe_cols,t:stop_flag,solver:row_string,I:output_str,T:filenames,", "Query Times": 499, "Time Cost": 0.1902755856513977, "Type": "mhm"}
{"Index": 2, "Original Code": " def solve():\n      h, w, m = map(int, raw_input().split())\n      if h == 1:\n          print 'c' + '.' * (h * w - m - 1) + '*' * m\n      elif w == 1:\n          for c in 'c' + '.' * (h * w - m - 1) + '*' * m:\n              print c\n      elif h * w - m == 1:\n          print 'c' + '*' * (w - 1)\n          for _ in xrange(h-1):\n              print '*' * w\n      else:\n          m = h * w - m\n          for i in xrange(h-1):\n              for j in xrange(w-1):\n                  t = (i + 2) * 2 + (j + 2) * 2 - 4\n                  r = (i + 2) * (j + 2)\n                  if t <= m <= r:\n                      a = [['*'] * w for _ in xrange(h)]\n                      for k in xrange(i+2):\n                          a[k][0] = '.'\n                          a[k][1] = '.'\n                      for k in xrange(j+2):\n                          a[0][k] = '.'\n                          a[1][k] = '.'\n                      for y, x in product(range(2, i+2), range(2, j+2)):\n                          if y == 1 and x == 1:\n                              continue\n                          if t >= m:\n                              break\n                          a[y][x] = '.'\n                          t += 1\n                      a[0][0] = 'c'\n                      for s in a:\n                          print ''.join(s)\n                      return\n          print 'Impossible'\n  for t in xrange(int(raw_input())):\n      print \"Case #%d:\" % (t + 1)\n      solve()\n ", "Adversarial Code": " def solve():\n      h, w, m = map(int, raw_input().split())\n      if h == 1:\n          print 'c' + '.' * (h * w - m - 1) + '*' * m\n      elif w == 1:\n          for c in 'c' + '.' * (h * w - m - 1) + '*' * m:\n              print c\n      elif h * w - m == 1:\n          print 'c' + '*' * (w - 1)\n          for _ in xrange(h-1):\n              print '*' * w\n      else:\n          m = h * w - m\n          for __doc__ in xrange(h-1):\n              for j in xrange(w-1):\n                  t = (__doc__ + 2) * 2 + (j + 2) * 2 - 4\n                  r = (__doc__ + 2) * (j + 2)\n                  if t <= m <= r:\n                      a = [['*'] * w for _ in xrange(h)]\n                      for k in xrange(__doc__+2):\n                          a[k][0] = '.'\n                          a[k][1] = '.'\n                      for k in xrange(j+2):\n                          a[0][k] = '.'\n                          a[1][k] = '.'\n                      for y, path in product(range(2, __doc__+2), range(2, j+2)):\n                          if y == 1 and path == 1:\n                              continue\n                          if t >= m:\n                              break\n                          a[y][path] = '.'\n                          t += 1\n                      a[0][0] = 'c'\n                      for s in a:\n                          print ''.join(s)\n                      return\n          print 'Impossible'\n  for t in xrange(int(raw_input())):\n      print \"Case #%d:\" % (t + 1)\n      solve()\n ", "Program Length": 349, "Identifier Num": 15, "Replaced Identifiers": "x:path,i:__doc__,", "Query Times": 57, "Time Cost": 0.02310932477315267, "Type": "mhm"}
{"Index": 3, "Original Code": "def solve():\n      r1 = int(raw_input())\n      a1 = [map(int, raw_input().split()) for i in xrange(4)]\n      r2 = int(raw_input())\n      a2 = [map(int, raw_input().split()) for i in xrange(4)]\n      ans = -1\n      for i in xrange(1, 17):\n          if i in a1[r1-1] and i in a2[r2-1]:\n              if ans != -1:\n                  return \"Bad magician!\"\n              ans = i\n      if ans == -1:\n          return \"Volunteer cheated!\"\n      return ans\n  for t in xrange(int(raw_input())):\n      print \"Case #%d:\" % (t + 1), solve()\n ", "Adversarial Code": "def solve():\n      get_cell = int(raw_input())\n      a1 = [map(int, raw_input().split()) for mat in xrange(4)]\n      r2 = int(raw_input())\n      read_syms = [map(int, raw_input().split()) for mat in xrange(4)]\n      NumCases = -1\n      for mat in xrange(1, 17):\n          if mat in a1[get_cell-1] and mat in read_syms[r2-1]:\n              if NumCases != -1:\n                  return \"Bad magician!\"\n              NumCases = mat\n      if NumCases == -1:\n          return \"Volunteer cheated!\"\n      return NumCases\n  for generateWinBoard in xrange(int(raw_input())):\n      print \"Case #%d:\" % (generateWinBoard + 1), solve()\n ", "Program Length": 146, "Identifier Num": 8, "Replaced Identifiers": "a2:read_syms,i:mat,t:generateWinBoard,r1:get_cell,ans:NumCases,", "Query Times": 292, "Time Cost": 0.10565033356348673, "Type": "mhm"}
{"Index": 5, "Original Code": " \n  if __name__ == \"__main__\":\n  \tf = open( sys.argv[1] )\n  \tint(f.readline())\n  \t\t\n  \tnum = 1\n  \tl = f.readline()\n  \twhile l != \"\":\n  \t\trow1 = int(l)\n  \t\trows = [ f.readline() for x in range(4) ]\n  \t\trow1 = [int(x) for x in rows[row1-1].split()]\n  \n  \t\trow2 = int(f.readline())\n  \t\trows = [f.readline() for x in range(4)]\n  \t\trow2 = [int(x) for x in rows[row2-1].split()]\n  \n  \t\tresult = set(row1) & set(row2)\n  \t\tif len(result) == 1:\n  \t\t\toutput = str(result.pop())\n  \t\telif len(result) > 1:\n  \t\t\toutput = \"Bad magician!\"\n  \t\telse:\n  \t\t\toutput = \"Volunteer cheated!\"\n  \n  \t\tprint \"Case #\"+str(num)+\": \"+output\n  \t\tnum += 1\n  \t\tl = f.readline()\n  \t\t\n ", "Adversarial Code": " \n  if __name__ == \"__main__\":\n  \trowIdx = open( sys.argv[1] )\n  \tint(rowIdx.readline())\n  \t\t\n  \ttop_edge = 1\n  \tl = rowIdx.readline()\n  \twhile l != \"\":\n  \t\trow1 = int(l)\n  \t\trows = [ rowIdx.readline() for x in range(4) ]\n  \t\trow1 = [int(x) for x in rows[row1-1].split()]\n  \n  \t\trow2 = int(rowIdx.readline())\n  \t\trows = [rowIdx.readline() for x in range(4)]\n  \t\trow2 = [int(x) for x in rows[row2-1].split()]\n  \n  \t\tresult = set(row1) & set(row2)\n  \t\tif len(result) == 1:\n  \t\t\toutput = str(result.pop())\n  \t\telif len(result) > 1:\n  \t\t\toutput = \"Bad magician!\"\n  \t\telse:\n  \t\t\toutput = \"Volunteer cheated!\"\n  \n  \t\tprint \"Case #\"+str(top_edge)+\": \"+output\n  \t\ttop_edge += 1\n  \t\tl = rowIdx.readline()\n  \t\t\n ", "Program Length": 195, "Identifier Num": 9, "Replaced Identifiers": "num:top_edge,f:rowIdx,", "Query Times": 59, "Time Cost": 0.02216603755950928, "Type": "mhm"}
{"Index": 6, "Original Code": "t = int(raw_input())\n  \n  for case in range(t):\n  \tprint 'Case #'+str(case+1)+':'\n  \tr, c, m = raw_input().split()\n  \tr = int(r)\n  \tc = int(c)\n  \tm = int(m)\n  \n  \tif m==0:\n  \t\tprint 'c' + ('.'*(c-1))\n  \t\tfor i in range(r-1):\n  \t\t\tprint '.'*c\n  \telif r == 1:\n  \t\tprint 'c'+('.'*(c-m-1))+('*'*(m))\n  \telif c == 1:\n  \t\tprint 'c'\n  \t\tfor i in range(r-m-1):\n  \t\t\tprint '.'\n  \t\tfor i in range(m):\n  \t\t\tprint '*'\n  \telif r == 2:\n  \t\tif m%2==0 and c>2 and m<r*c-2:\n  \t\t\tprint 'c'+('.'*(c-m/2-1))+('*'*(m/2))\n  \t\t\tprint ('.'*(c-m/2))+('*'*(m/2))\n  \t\telif m == r*c - 1:\n  \t\t\tprint 'c'+('*'*(c-1))\n  \t\t\tprint '*'*c\n  \t\telse:\n  \t\t\tprint 'Impossible'\n  \telif c == 2:\n  \t\tif m%2==0 and r>2 and m<r*c-2:\n  \t\t\tprint 'c.'\n  \t\t\tfor i in range(r-m/2-1):\n  \t\t\t\tprint '..'\n  \t\t\tfor i in range(m/2):\n  \t\t\t\tprint '**'\n  \t\telif m == r*c - 1:\n  \t\t\tprint 'c*'\n  \t\t\tfor i in range(r-1):\n  \t\t\t\tprint '**'\n  \t\telse:\n  \t\t\tprint 'Impossible'\n  \telif c == 3 and r == 3:\n  \t\tif m == 1:\n  \t\t\tprint 'c..'\n  \t\t\tprint '...'\n  \t\t\tprint '..*'\n  \t\telif m == 2:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 3:\n  \t\t\tprint 'c..'\n  \t\t\tprint '...'\n  \t\t\tprint '***'\n  \t\telif m == 4:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 5:\n  \t\t\tprint 'c.*'\n  \t\t\tprint '..*'\n  \t\t\tprint '***'\n  \t\telif m == 6:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 7:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 8:\n  \t\t\tprint 'c**'\n  \t\t\tprint '***'\n  \t\t\tprint '***'\n  \telif c == 3 and r == 4:\n  \t\tif m == 1:\n  \t\t\tprint 'c..'\n  \t\t\tprint '...'\n  \t\t\tprint '...'\n  \t\t\tprint '..*'\n  \t\telif m == 2:\n  \t\t\tprint 'c..'\n  \t\t\tprint '...'\n  \t\t\tprint '..*'\n  \t\t\tprint '..*'\n  \t\telif m == 3:\n  \t\t\tprint 'c..'\n  \t\t\tprint '...'\n  \t\t\tprint '...'\n  \t\t\tprint '***'\n  \t\telif m == 4:\n  \t\t\tprint 'c.*'\n  \t\t\tprint '..*'\n  \t\t\tprint '..*'\n  \t\t\tprint '..*'\n  \t\telif m == 5:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 6:\n  \t\t\tprint 'c..'\n  \t\t\tprint '...'\n  \t\t\tprint '***'\n  \t\t\tprint '***'\n  \t\telif m == 7:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 8:\n  \t\t\tprint 'c.*'\n  \t\t\tprint '..*'\n  \t\t\tprint '***'\n  \t\t\tprint '***'\n  \t\telif m == 9:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 10:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 11:\n  \t\t\tprint 'c**'\n  \t\t\tprint '***'\n  \t\t\tprint '***'\n  \t\t\tprint '***'\n  \telif c == 3 and r == 5:\n  \t\tif m == 1:\n  \t\t\tprint 'c..'\n  \t\t\tprint '...'\n  \t\t\tprint '...'\n  \t\t\tprint '...'\n  \t\t\tprint '..*'\n  \t\telif m == 2:\n  \t\t\tprint 'c..'\n  \t\t\tprint '...'\n  \t\t\tprint '...'\n  \t\t\tprint '..*'\n  \t\t\tprint '..*'\n  \t\telif m == 3:\n  \t\t\tprint 'c..'\n  \t\t\tprint '...'\n  \t\t\tprint '..*'\n  \t\t\tprint '..*'\n  \t\t\tprint '..*'\n  \t\telif m == 4:\n  \t\t\tprint 'c..'\n  \t\t\tprint '...'\n  \t\t\tprint '...'\n  \t\t\tprint '..*'\n  \t\t\tprint '***'\n  \t\telif m == 5:\n  \t\t\tprint 'c.*'\n  \t\t\tprint '..*'\n  \t\t\tprint '..*'\n  \t\t\tprint '..*'\n  \t\t\tprint '..*'\n  \t\telif m == 6:\n  \t\t\tprint 'c..'\n  \t\t\tprint '...'\n  \t\t\tprint '...'\n  \t\t\tprint '***'\n  \t\t\tprint '***'\n  \t\telif m == 7:\n  \t\t\tprint 'c..'\n  \t\t\tprint '...'\n  \t\t\tprint '..*'\n  \t\t\tprint '***'\n  \t\t\tprint '***'\n  \t\telif m == 8:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 9:\n  \t\t\tprint 'c..'\n  \t\t\tprint '...'\n  \t\t\tprint '***'\n  \t\t\tprint '***'\n  \t\t\tprint '***'\n  \t\telif m == 10:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 11:\n  \t\t\tprint 'c.*'\n  \t\t\tprint '..*'\n  \t\t\tprint '***'\n  \t\t\tprint '***'\n  \t\t\tprint '***'\n  \t\telif m == 12:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 13:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 14:\n  \t\t\tprint 'c**'\n  \t\t\tprint '***'\n  \t\t\tprint '***'\n  \t\t\tprint '***'\n  \t\t\tprint '***'\n  \telif c == 4 and r == 3:\n  \t\tif m == 1:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '...*'\n  \t\telif m == 2:\n  \t\t\tprint 'c...'\n  \t\t\tprint '...*'\n  \t\t\tprint '...*'\n  \t\telif m == 3:\n  \t\t\tprint 'c..*'\n  \t\t\tprint '...*'\n  \t\t\tprint '...*'\n  \t\telif m == 4:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '****'\n  \t\telif m == 5:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 6:\n  \t\t\tprint 'c.**'\n  \t\t\tprint '..**'\n  \t\t\tprint '..**'\n  \t\telif m == 7:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 8:\n  \t\t\tprint 'c.**'\n  \t\t\tprint '..**'\n  \t\t\tprint '****'\n  \t\telif m == 9:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 10:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 11:\n  \t\t\tprint 'c***'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \telif c == 4 and r == 4:\n  \t\tif m == 1:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '....'\n  \t\t\tprint '...*'\n  \t\telif m == 2:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '....'\n  \t\t\tprint '..**'\n  \t\telif m == 3:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '...*'\n  \t\t\tprint '..**'\n  \t\telif m == 4:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '....'\n  \t\t\tprint '****'\n  \t\telif m == 5:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '...*'\n  \t\t\tprint '****'\n  \t\telif m == 6:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '..**'\n  \t\t\tprint '****'\n  \t\telif m == 7:\n  \t\t\tprint 'c..*'\n  \t\t\tprint '...*'\n  \t\t\tprint '...*'\n  \t\t\tprint '****'\n  \t\telif m == 8:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \t\telif m == 9:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 10:\n  \t\t\tprint 'c.**'\n  \t\t\tprint '..**'\n  \t\t\tprint '..**'\n  \t\t\tprint '****'\n  \t\telif m == 11:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 12:\n  \t\t\tprint 'c.**'\n  \t\t\tprint '..**'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \t\telif m == 13:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 14:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 15:\n  \t\t\tprint 'c***'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \telif c == 4 and r == 5:\n  \t\tif m == 1:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '....'\n  \t\t\tprint '....'\n  \t\t\tprint '...*'\n  \t\telif m == 2:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '....'\n  \t\t\tprint '....'\n  \t\t\tprint '..**'\n  \t\telif m == 3:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '...*'\n  \t\t\tprint '...*'\n  \t\t\tprint '...*'\n  \t\telif m == 4:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '....'\n  \t\t\tprint '....'\n  \t\t\tprint '****'\n  \t\telif m == 5:\n  \t\t\tprint 'c..*'\n  \t\t\tprint '...*'\n  \t\t\tprint '...*'\n  \t\t\tprint '...*'\n  \t\t\tprint '...*'\n  \t\telif m == 6:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '....'\n  \t\t\tprint '..**'\n  \t\t\tprint '****'\n  \t\telif m == 7:\n  \t\t\tprint 'c..*'\n  \t\t\tprint '...*'\n  \t\t\tprint '...*'\n  \t\t\tprint '..**'\n  \t\t\tprint '..**'\n  \t\telif m == 8:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '....'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \t\telif m == 9:\n  \t\t\tprint 'c..*'\n  \t\t\tprint '...*'\n  \t\t\tprint '...*'\n  \t\t\tprint '..**'\n  \t\t\tprint '****'\n  \t\telif m == 10:\n  \t\t\tprint 'c.**'\n  \t\t\tprint '..**'\n  \t\t\tprint '..**'\n  \t\t\tprint '..**'\n  \t\t\tprint '..**'\n  \t\telif m == 11:\n  \t\t\tprint 'c..*'\n  \t\t\tprint '...*'\n  \t\t\tprint '...*'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \t\telif m == 12:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \t\telif m == 13:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 14:\n  \t\t\tprint 'c..*'\n  \t\t\tprint '...*'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \t\telif m == 15:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 16:\n  \t\t\tprint 'c.**'\n  \t\t\tprint '..**'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \t\telif m == 17:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 18:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 19:\n  \t\t\tprint 'c***'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \telif c == 5 and r == 3:\n  \t\tif m == 1:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '....*'\n  \t\telif m == 2:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '...**'\n  \t\telif m == 3:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '..***'\n  \t\telif m == 4:\n  \t\t\tprint 'c...*'\n  \t\t\tprint '....*'\n  \t\t\tprint '...**'\n  \t\telif m == 5:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '*****'\n  \t\telif m == 6:\n  \t\t\tprint 'c..**'\n  \t\t\tprint '...**'\n  \t\t\tprint '...**'\n  \t\telif m == 7:\n  \t\t\tprint 'c..**'\n  \t\t\tprint '...**'\n  \t\t\tprint '..***'\n  \t\telif m == 8:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 9:\n  \t\t\tprint 'c.***'\n  \t\t\tprint '..***'\n  \t\t\tprint '..***'\n  \t\telif m == 10:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 11:\n  \t\t\tprint 'c.***'\n  \t\t\tprint '..***'\n  \t\t\tprint '*****'\n  \t\telif m == 12:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 13:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 14:\n  \t\t\tprint 'c****'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \telif c == 5 and r == 4:\n  \t\tif m == 1:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '....*'\n  \t\telif m == 2:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '...**'\n  \t\telif m == 3:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '..***'\n  \t\telif m == 4:\n  \t\t\tprint 'c...*'\n  \t\t\tprint '....*'\n  \t\t\tprint '....*'\n  \t\t\tprint '....*'\n  \t\telif m == 5:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '*****'\n  \t\telif m == 6:\n  \t\t\tprint 'c...*'\n  \t\t\tprint '....*'\n  \t\t\tprint '....*'\n  \t\t\tprint '..***'\n  \t\telif m == 7:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '...**'\n  \t\t\tprint '*****'\n  \t\telif m == 8:\n  \t\t\tprint 'c..**'\n  \t\t\tprint '...**'\n  \t\t\tprint '...**'\n  \t\t\tprint '...**'\n  \t\telif m == 9:\n  \t\t\tprint 'c...*'\n  \t\t\tprint '....*'\n  \t\t\tprint '...**'\n  \t\t\tprint '*****'\n  \t\telif m == 10:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\telif m == 11:\n  \t\t\tprint 'c..**'\n  \t\t\tprint '...**'\n  \t\t\tprint '...**'\n  \t\t\tprint '*****'\n  \t\telif m == 12:\n  \t\t\tprint 'c.***'\n  \t\t\tprint '..***'\n  \t\t\tprint '..***'\n  \t\t\tprint '..***'\n  \t\telif m == 13:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 14:\n  \t\t\tprint 'c.***'\n  \t\t\tprint '..***'\n  \t\t\tprint '..***'\n  \t\t\tprint '*****'\n  \t\telif m == 15:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 16:\n  \t\t\tprint 'c.***'\n  \t\t\tprint '..***'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\telif m == 17:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 18:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 19:\n  \t\t\tprint 'c****'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \telif c == 5 and r == 5:\n  \t\tif m == 1:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '....*'\n  \t\telif m == 2:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '...**'\n  \t\telif m == 3:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '..***'\n  \t\telif m == 4:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '...**'\n  \t\t\tprint '...**'\n  \t\telif m == 5:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '*****'\n  \t\telif m == 6:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '..***'\n  \t\t\tprint '..***'\n  \t\telif m == 7:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '...**'\n  \t\t\tprint '*****'\n  \t\telif m == 8:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '..***'\n  \t\t\tprint '*****'\n  \t\telif m == 9:\n  \t\t\tprint 'c...*'\n  \t\t\tprint '....*'\n  \t\t\tprint '....*'\n  \t\t\tprint '....*'\n  \t\t\tprint '*****'\n  \t\telif m == 10:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\telif m == 11:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '....*'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\telif m == 12:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '...**'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\telif m == 13:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '..***'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\telif m == 14:\n  \t\t\tprint 'c..**'\n  \t\t\tprint '...**'\n  \t\t\tprint '...**'\n  \t\t\tprint '..***'\n  \t\t\tprint '*****'\n  \t\telif m == 15:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\telif m == 16:\n  \t\t\tprint 'c..**'\n  \t\t\tprint '...**'\n  \t\t\tprint '...**'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\telif m == 17:\n  \t\t\tprint 'c..**'\n  \t\t\tprint '...**'\n  \t\t\tprint '..***'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\telif m == 18:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 19:\n  \t\t\tprint 'c..**'\n  \t\t\tprint '...**'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\telif m == 20:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 21:\n  \t\t\tprint 'c.***'\n  \t\t\tprint '..***'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\telif m == 22:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 23:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 24:\n  \t\t\tprint 'c****'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \telse:\n  \t\tprint 'Impossible'\n  \n ", "Adversarial Code": "t = int(raw_input())\n  \n  for case in range(t):\n  \tprint 'Case #'+str(case+1)+':'\n  \tr, makesample, m = raw_input().split()\n  \tr = int(r)\n  \tmakesample = int(makesample)\n  \tm = int(m)\n  \n  \tif m==0:\n  \t\tprint 'c' + ('.'*(makesample-1))\n  \t\tfor i in range(r-1):\n  \t\t\tprint '.'*makesample\n  \telif r == 1:\n  \t\tprint 'c'+('.'*(makesample-m-1))+('*'*(m))\n  \telif makesample == 1:\n  \t\tprint 'c'\n  \t\tfor i in range(r-m-1):\n  \t\t\tprint '.'\n  \t\tfor i in range(m):\n  \t\t\tprint '*'\n  \telif r == 2:\n  \t\tif m%2==0 and makesample>2 and m<r*makesample-2:\n  \t\t\tprint 'c'+('.'*(makesample-m/2-1))+('*'*(m/2))\n  \t\t\tprint ('.'*(makesample-m/2))+('*'*(m/2))\n  \t\telif m == r*makesample - 1:\n  \t\t\tprint 'c'+('*'*(makesample-1))\n  \t\t\tprint '*'*makesample\n  \t\telse:\n  \t\t\tprint 'Impossible'\n  \telif makesample == 2:\n  \t\tif m%2==0 and r>2 and m<r*makesample-2:\n  \t\t\tprint 'c.'\n  \t\t\tfor i in range(r-m/2-1):\n  \t\t\t\tprint '..'\n  \t\t\tfor i in range(m/2):\n  \t\t\t\tprint '**'\n  \t\telif m == r*makesample - 1:\n  \t\t\tprint 'c*'\n  \t\t\tfor i in range(r-1):\n  \t\t\t\tprint '**'\n  \t\telse:\n  \t\t\tprint 'Impossible'\n  \telif makesample == 3 and r == 3:\n  \t\tif m == 1:\n  \t\t\tprint 'c..'\n  \t\t\tprint '...'\n  \t\t\tprint '..*'\n  \t\telif m == 2:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 3:\n  \t\t\tprint 'c..'\n  \t\t\tprint '...'\n  \t\t\tprint '***'\n  \t\telif m == 4:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 5:\n  \t\t\tprint 'c.*'\n  \t\t\tprint '..*'\n  \t\t\tprint '***'\n  \t\telif m == 6:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 7:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 8:\n  \t\t\tprint 'c**'\n  \t\t\tprint '***'\n  \t\t\tprint '***'\n  \telif makesample == 3 and r == 4:\n  \t\tif m == 1:\n  \t\t\tprint 'c..'\n  \t\t\tprint '...'\n  \t\t\tprint '...'\n  \t\t\tprint '..*'\n  \t\telif m == 2:\n  \t\t\tprint 'c..'\n  \t\t\tprint '...'\n  \t\t\tprint '..*'\n  \t\t\tprint '..*'\n  \t\telif m == 3:\n  \t\t\tprint 'c..'\n  \t\t\tprint '...'\n  \t\t\tprint '...'\n  \t\t\tprint '***'\n  \t\telif m == 4:\n  \t\t\tprint 'c.*'\n  \t\t\tprint '..*'\n  \t\t\tprint '..*'\n  \t\t\tprint '..*'\n  \t\telif m == 5:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 6:\n  \t\t\tprint 'c..'\n  \t\t\tprint '...'\n  \t\t\tprint '***'\n  \t\t\tprint '***'\n  \t\telif m == 7:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 8:\n  \t\t\tprint 'c.*'\n  \t\t\tprint '..*'\n  \t\t\tprint '***'\n  \t\t\tprint '***'\n  \t\telif m == 9:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 10:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 11:\n  \t\t\tprint 'c**'\n  \t\t\tprint '***'\n  \t\t\tprint '***'\n  \t\t\tprint '***'\n  \telif makesample == 3 and r == 5:\n  \t\tif m == 1:\n  \t\t\tprint 'c..'\n  \t\t\tprint '...'\n  \t\t\tprint '...'\n  \t\t\tprint '...'\n  \t\t\tprint '..*'\n  \t\telif m == 2:\n  \t\t\tprint 'c..'\n  \t\t\tprint '...'\n  \t\t\tprint '...'\n  \t\t\tprint '..*'\n  \t\t\tprint '..*'\n  \t\telif m == 3:\n  \t\t\tprint 'c..'\n  \t\t\tprint '...'\n  \t\t\tprint '..*'\n  \t\t\tprint '..*'\n  \t\t\tprint '..*'\n  \t\telif m == 4:\n  \t\t\tprint 'c..'\n  \t\t\tprint '...'\n  \t\t\tprint '...'\n  \t\t\tprint '..*'\n  \t\t\tprint '***'\n  \t\telif m == 5:\n  \t\t\tprint 'c.*'\n  \t\t\tprint '..*'\n  \t\t\tprint '..*'\n  \t\t\tprint '..*'\n  \t\t\tprint '..*'\n  \t\telif m == 6:\n  \t\t\tprint 'c..'\n  \t\t\tprint '...'\n  \t\t\tprint '...'\n  \t\t\tprint '***'\n  \t\t\tprint '***'\n  \t\telif m == 7:\n  \t\t\tprint 'c..'\n  \t\t\tprint '...'\n  \t\t\tprint '..*'\n  \t\t\tprint '***'\n  \t\t\tprint '***'\n  \t\telif m == 8:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 9:\n  \t\t\tprint 'c..'\n  \t\t\tprint '...'\n  \t\t\tprint '***'\n  \t\t\tprint '***'\n  \t\t\tprint '***'\n  \t\telif m == 10:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 11:\n  \t\t\tprint 'c.*'\n  \t\t\tprint '..*'\n  \t\t\tprint '***'\n  \t\t\tprint '***'\n  \t\t\tprint '***'\n  \t\telif m == 12:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 13:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 14:\n  \t\t\tprint 'c**'\n  \t\t\tprint '***'\n  \t\t\tprint '***'\n  \t\t\tprint '***'\n  \t\t\tprint '***'\n  \telif makesample == 4 and r == 3:\n  \t\tif m == 1:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '...*'\n  \t\telif m == 2:\n  \t\t\tprint 'c...'\n  \t\t\tprint '...*'\n  \t\t\tprint '...*'\n  \t\telif m == 3:\n  \t\t\tprint 'c..*'\n  \t\t\tprint '...*'\n  \t\t\tprint '...*'\n  \t\telif m == 4:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '****'\n  \t\telif m == 5:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 6:\n  \t\t\tprint 'c.**'\n  \t\t\tprint '..**'\n  \t\t\tprint '..**'\n  \t\telif m == 7:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 8:\n  \t\t\tprint 'c.**'\n  \t\t\tprint '..**'\n  \t\t\tprint '****'\n  \t\telif m == 9:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 10:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 11:\n  \t\t\tprint 'c***'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \telif makesample == 4 and r == 4:\n  \t\tif m == 1:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '....'\n  \t\t\tprint '...*'\n  \t\telif m == 2:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '....'\n  \t\t\tprint '..**'\n  \t\telif m == 3:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '...*'\n  \t\t\tprint '..**'\n  \t\telif m == 4:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '....'\n  \t\t\tprint '****'\n  \t\telif m == 5:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '...*'\n  \t\t\tprint '****'\n  \t\telif m == 6:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '..**'\n  \t\t\tprint '****'\n  \t\telif m == 7:\n  \t\t\tprint 'c..*'\n  \t\t\tprint '...*'\n  \t\t\tprint '...*'\n  \t\t\tprint '****'\n  \t\telif m == 8:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \t\telif m == 9:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 10:\n  \t\t\tprint 'c.**'\n  \t\t\tprint '..**'\n  \t\t\tprint '..**'\n  \t\t\tprint '****'\n  \t\telif m == 11:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 12:\n  \t\t\tprint 'c.**'\n  \t\t\tprint '..**'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \t\telif m == 13:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 14:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 15:\n  \t\t\tprint 'c***'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \telif makesample == 4 and r == 5:\n  \t\tif m == 1:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '....'\n  \t\t\tprint '....'\n  \t\t\tprint '...*'\n  \t\telif m == 2:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '....'\n  \t\t\tprint '....'\n  \t\t\tprint '..**'\n  \t\telif m == 3:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '...*'\n  \t\t\tprint '...*'\n  \t\t\tprint '...*'\n  \t\telif m == 4:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '....'\n  \t\t\tprint '....'\n  \t\t\tprint '****'\n  \t\telif m == 5:\n  \t\t\tprint 'c..*'\n  \t\t\tprint '...*'\n  \t\t\tprint '...*'\n  \t\t\tprint '...*'\n  \t\t\tprint '...*'\n  \t\telif m == 6:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '....'\n  \t\t\tprint '..**'\n  \t\t\tprint '****'\n  \t\telif m == 7:\n  \t\t\tprint 'c..*'\n  \t\t\tprint '...*'\n  \t\t\tprint '...*'\n  \t\t\tprint '..**'\n  \t\t\tprint '..**'\n  \t\telif m == 8:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '....'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \t\telif m == 9:\n  \t\t\tprint 'c..*'\n  \t\t\tprint '...*'\n  \t\t\tprint '...*'\n  \t\t\tprint '..**'\n  \t\t\tprint '****'\n  \t\telif m == 10:\n  \t\t\tprint 'c.**'\n  \t\t\tprint '..**'\n  \t\t\tprint '..**'\n  \t\t\tprint '..**'\n  \t\t\tprint '..**'\n  \t\telif m == 11:\n  \t\t\tprint 'c..*'\n  \t\t\tprint '...*'\n  \t\t\tprint '...*'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \t\telif m == 12:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \t\telif m == 13:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 14:\n  \t\t\tprint 'c..*'\n  \t\t\tprint '...*'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \t\telif m == 15:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 16:\n  \t\t\tprint 'c.**'\n  \t\t\tprint '..**'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \t\telif m == 17:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 18:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 19:\n  \t\t\tprint 'c***'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \telif makesample == 5 and r == 3:\n  \t\tif m == 1:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '....*'\n  \t\telif m == 2:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '...**'\n  \t\telif m == 3:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '..***'\n  \t\telif m == 4:\n  \t\t\tprint 'c...*'\n  \t\t\tprint '....*'\n  \t\t\tprint '...**'\n  \t\telif m == 5:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '*****'\n  \t\telif m == 6:\n  \t\t\tprint 'c..**'\n  \t\t\tprint '...**'\n  \t\t\tprint '...**'\n  \t\telif m == 7:\n  \t\t\tprint 'c..**'\n  \t\t\tprint '...**'\n  \t\t\tprint '..***'\n  \t\telif m == 8:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 9:\n  \t\t\tprint 'c.***'\n  \t\t\tprint '..***'\n  \t\t\tprint '..***'\n  \t\telif m == 10:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 11:\n  \t\t\tprint 'c.***'\n  \t\t\tprint '..***'\n  \t\t\tprint '*****'\n  \t\telif m == 12:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 13:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 14:\n  \t\t\tprint 'c****'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \telif makesample == 5 and r == 4:\n  \t\tif m == 1:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '....*'\n  \t\telif m == 2:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '...**'\n  \t\telif m == 3:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '..***'\n  \t\telif m == 4:\n  \t\t\tprint 'c...*'\n  \t\t\tprint '....*'\n  \t\t\tprint '....*'\n  \t\t\tprint '....*'\n  \t\telif m == 5:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '*****'\n  \t\telif m == 6:\n  \t\t\tprint 'c...*'\n  \t\t\tprint '....*'\n  \t\t\tprint '....*'\n  \t\t\tprint '..***'\n  \t\telif m == 7:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '...**'\n  \t\t\tprint '*****'\n  \t\telif m == 8:\n  \t\t\tprint 'c..**'\n  \t\t\tprint '...**'\n  \t\t\tprint '...**'\n  \t\t\tprint '...**'\n  \t\telif m == 9:\n  \t\t\tprint 'c...*'\n  \t\t\tprint '....*'\n  \t\t\tprint '...**'\n  \t\t\tprint '*****'\n  \t\telif m == 10:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\telif m == 11:\n  \t\t\tprint 'c..**'\n  \t\t\tprint '...**'\n  \t\t\tprint '...**'\n  \t\t\tprint '*****'\n  \t\telif m == 12:\n  \t\t\tprint 'c.***'\n  \t\t\tprint '..***'\n  \t\t\tprint '..***'\n  \t\t\tprint '..***'\n  \t\telif m == 13:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 14:\n  \t\t\tprint 'c.***'\n  \t\t\tprint '..***'\n  \t\t\tprint '..***'\n  \t\t\tprint '*****'\n  \t\telif m == 15:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 16:\n  \t\t\tprint 'c.***'\n  \t\t\tprint '..***'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\telif m == 17:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 18:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 19:\n  \t\t\tprint 'c****'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \telif makesample == 5 and r == 5:\n  \t\tif m == 1:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '....*'\n  \t\telif m == 2:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '...**'\n  \t\telif m == 3:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '..***'\n  \t\telif m == 4:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '...**'\n  \t\t\tprint '...**'\n  \t\telif m == 5:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '*****'\n  \t\telif m == 6:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '..***'\n  \t\t\tprint '..***'\n  \t\telif m == 7:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '...**'\n  \t\t\tprint '*****'\n  \t\telif m == 8:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '..***'\n  \t\t\tprint '*****'\n  \t\telif m == 9:\n  \t\t\tprint 'c...*'\n  \t\t\tprint '....*'\n  \t\t\tprint '....*'\n  \t\t\tprint '....*'\n  \t\t\tprint '*****'\n  \t\telif m == 10:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\telif m == 11:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '....*'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\telif m == 12:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '...**'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\telif m == 13:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '..***'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\telif m == 14:\n  \t\t\tprint 'c..**'\n  \t\t\tprint '...**'\n  \t\t\tprint '...**'\n  \t\t\tprint '..***'\n  \t\t\tprint '*****'\n  \t\telif m == 15:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\telif m == 16:\n  \t\t\tprint 'c..**'\n  \t\t\tprint '...**'\n  \t\t\tprint '...**'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\telif m == 17:\n  \t\t\tprint 'c..**'\n  \t\t\tprint '...**'\n  \t\t\tprint '..***'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\telif m == 18:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 19:\n  \t\t\tprint 'c..**'\n  \t\t\tprint '...**'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\telif m == 20:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 21:\n  \t\t\tprint 'c.***'\n  \t\t\tprint '..***'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\telif m == 22:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 23:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 24:\n  \t\t\tprint 'c****'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \telse:\n  \t\tprint 'Impossible'\n  \n ", "Program Length": 2012, "Identifier Num": 6, "Replaced Identifiers": "c:makesample,", "Query Times": 31, "Time Cost": 0.026650301615397134, "Type": "mhm"}
{"Index": 7, "Original Code": "t = int(raw_input())\n  \n  for case in range(t):\n  \tr1 = int(raw_input())\n  \tc1 = []\n  \tfor j in range(4):\n  \t\tc1.append([int(i) for i in raw_input().split()])\n  \n  \tr2 = int(raw_input())\n  \tc2 = []\n  \tfor j in range(4):\n  \t\tc2.append([int(i) for i in raw_input().split()])\n  \n  \tnum = -1\n  \tpossibles = 0\n  \tfor j in c1[r1-1]:\n  \t\tif c2[r2-1].count(j) == 1:\n  \t\t\tnum = j\n  \t\t\tpossibles += 1\n  \n  \tif possibles > 1:\n  \t\tprint 'Case #'+str(case+1)+': Bad magician!'\n  \telif possibles == 0:\n  \t\tprint 'Case #'+str(case+1)+': Volunteer cheated!'\n  \telse:\n  \t\tprint 'Case #'+str(case+1)+': '+str(num)\n ", "Adversarial Code": "t = int(raw_input())\n  \n  for case in range(t):\n  \tr1 = int(raw_input())\n  \tc1 = []\n  \tfor h in range(4):\n  \t\tc1.append([int(i) for i in raw_input().split()])\n  \n  \tcounts = int(raw_input())\n  \tnum_of_cases = []\n  \tfor h in range(4):\n  \t\tnum_of_cases.append([int(i) for i in raw_input().split()])\n  \n  \tls = -1\n  \tpossibles = 0\n  \tfor h in c1[r1-1]:\n  \t\tif num_of_cases[counts-1].count(h) == 1:\n  \t\t\tls = h\n  \t\t\tpossibles += 1\n  \n  \tif possibles > 1:\n  \t\tprint 'Case #'+str(case+1)+': Bad magician!'\n  \telif possibles == 0:\n  \t\tprint 'Case #'+str(case+1)+': Volunteer cheated!'\n  \telse:\n  \t\tprint 'Case #'+str(case+1)+': '+str(ls)\n ", "Program Length": 186, "Identifier Num": 10, "Replaced Identifiers": "num:ls,r2:counts,j:h,c2:num_of_cases,", "Query Times": 115, "Time Cost": 0.04499614636103312, "Type": "mhm"}
{"Index": 8, "Original Code": "def make_string(R, C, M):\n      grid = [['.' for j in xrange(C)] for i in xrange(R)]\n      grid[-1][-1] = 'c'\n      t = M\n      for i in xrange(R):\n          for j in xrange(C):\n              if M:\n                  if forbidden(R, C, t, i, j):\n                      continue\n                  grid[i][j] = '*'\n                  M -= 1\n              else:\n                  break\n      s = ''\n      if M:\n          return 'Impossible'\n      for r in grid:\n          s += ''.join(r)+'\n'\n      return s[:-1]\n  \n  def forbidden(R, C, M, i, j):\n      a = M / C\n      b = M % C\n      if (R*C - M == 1):\n          return False\n  \n      if i >= (R-2) and j >= (C-2):\n          return True\n  \n      if i >= (R-2) and b:\n          if b % 2:\n              return True\n          if j < b/2:\n              return False\n          else:\n              return True\n      return False\n          \n  \n  f = open('Csmall.in', 'r')\n  g = open('outputC.txt', 'w')\n  \n  data = [[int(e) for e in line.strip(\"\n\").split(' ')] for line in f]\n  T = int(data.pop(0)[0])\n  for i, case in enumerate(data):\n      R, C, M = case[0], case[1], case[2]\n      num_cells = R*C\n      if (R-1) == 0 or (C-1) == 0:\n          s = make_string(R, C, M)\n          g.write('Case #%i:\n%s\n' %(i+1,s))\n          continue\n      else:\n          s = make_string(R, C, M)\n          g.write('Case #%i:\n%s\n' %(i+1, s))\n          \n  \n  f.close()\n  g.close()\n ", "Adversarial Code": "def make_string(show, filename_stem, case_inputs):\n      make_string = [['.' for Bonne in xrange(filename_stem)] for rstrip in xrange(show)]\n      make_string[-1][-1] = 'c'\n      t = case_inputs\n      for rstrip in xrange(show):\n          for Bonne in xrange(filename_stem):\n              if case_inputs:\n                  if forbidden(show, filename_stem, t, rstrip, Bonne):\n                      continue\n                  make_string[rstrip][Bonne] = '*'\n                  case_inputs -= 1\n              else:\n                  break\n      s = ''\n      if case_inputs:\n          return 'Impossible'\n      for read_syms in make_string:\n          s += ''.join(read_syms)+'\n'\n      return s[:-1]\n  \n  def forbidden(show, filename_stem, case_inputs, rstrip, Bonne):\n      a = case_inputs / filename_stem\n      b = case_inputs % filename_stem\n      if (show*filename_stem - case_inputs == 1):\n          return False\n  \n      if rstrip >= (show-2) and Bonne >= (filename_stem-2):\n          return True\n  \n      if rstrip >= (show-2) and b:\n          if b % 2:\n              return True\n          if Bonne < b/2:\n              return False\n          else:\n              return True\n      return False\n          \n  \n  get_cell = open('Csmall.in', 'r')\n  g = open('outputC.txt', 'w')\n  \n  data = [[int(e) for e in line.strip(\"\n\").split(' ')] for line in get_cell]\n  T = int(data.pop(0)[0])\n  for rstrip, cases_restantes in enumerate(data):\n      show, filename_stem, case_inputs = cases_restantes[0], cases_restantes[1], cases_restantes[2]\n      num_cells = show*filename_stem\n      if (show-1) == 0 or (filename_stem-1) == 0:\n          s = make_string(show, filename_stem, case_inputs)\n          g.write('Case #%i:\n%s\n' %(rstrip+1,s))\n          continue\n      else:\n          s = make_string(show, filename_stem, case_inputs)\n          g.write('Case #%i:\n%s\n' %(rstrip+1, s))\n          \n  \n  get_cell.close()\n  g.close()\n ", "Program Length": 392, "Identifier Num": 21, "Replaced Identifiers": "case:cases_restantes,grid:make_string,R:show,f:get_cell,j:Bonne,C:filename_stem,r:read_syms,i:rstrip,M:case_inputs,", "Query Times": 349, "Time Cost": 0.1432910680770874, "Type": "mhm"}
{"Index": 9, "Original Code": "f = open('A.in', 'r')\n  g = open('outputA.txt', 'w')\n  data = [[int(e) for e in line.strip(\"\n\").split(' ')] for line in f]\n  T = data[0][0]\n  c = 0\n  for i in xrange(1, T*10 + 1, 10):\n      c += 1\n      choice1 = data[i][0]\n      choice2 = data[i+5][0]\n      grid1, grid2 = [], []\n      for j in xrange(1,5):\n          grid1.append(data[i+j])\n  \n      for j in xrange(6, 10):\n          grid2.append(data[i+j])\n  \n      s1 = set(grid1[choice1-1])\n      s2 = set(grid2[choice2-1])\n  \n      s = s1 & s2\n      if len(s) == 1:\n          g.write(\"Case #%i: %i\n\" %(c, s.pop()))\n      elif not s:\n          g.write(\"Case #%i: Volunteer cheated!\n\" %(c))\n      else:\n          g.write(\"Case #%i: Bad magician!\n\" %(c))\n  \n  f.close()\n  g.close()\n      \n ", "Adversarial Code": "chosen1 = open('A.in', 'r')\n  g = open('outputA.txt', 'w')\n  num_of_cases = [[int(sol) for sol in line.strip(\"\n\").split(' ')] for line in chosen1]\n  T = num_of_cases[0][0]\n  get = 0\n  for i in xrange(1, T*10 + 1, 10):\n      get += 1\n      c = num_of_cases[i][0]\n      ctime = num_of_cases[i+5][0]\n      R2, grid2 = [], []\n      for splitlines in xrange(1,5):\n          R2.append(num_of_cases[i+splitlines])\n  \n      for splitlines in xrange(6, 10):\n          grid2.append(num_of_cases[i+splitlines])\n  \n      board_B = set(R2[c-1])\n      s2 = set(grid2[ctime-1])\n  \n      s = board_B & s2\n      if len(s) == 1:\n          g.write(\"Case #%i: %i\n\" %(get, s.pop()))\n      elif not s:\n          g.write(\"Case #%i: Volunteer cheated!\n\" %(get))\n      else:\n          g.write(\"Case #%i: Bad magician!\n\" %(get))\n  \n  chosen1.close()\n  g.close()\n      \n ", "Program Length": 240, "Identifier Num": 16, "Replaced Identifiers": "f:chosen1,c:get,grid1:R2,choice2:ctime,s1:board_B,data:num_of_cases,choice1:c,j:splitlines,e:sol,", "Query Times": 613, "Time Cost": 0.24033296902974446, "Type": "mhm"}
{"Index": 10, "Original Code": " \n  if __name__ == \"__main__\":\n      f = sys.stdin\n      if len(sys.argv) >= 2:\n          fn = sys.argv[1]\n          if fn != '-':\n              f = open(fn)\n  \n      T = int(f.readline())\n      for _T in xrange(T):\n          R, C, M = map(int, f.readline().split())\n  \n          print \"Case #%d:\" % (_T+1)\n  \n          left = R * C - M\n  \n          if R == 1:\n              s = 'c'\n              s += '.' * (left - 1)\n              s += '*' * M\n              print s\n              continue\n          if C == 1:\n              print 'c'\n              for i in xrange(left - 1):\n                  print '.'\n              for i in xrange(M):\n                  print '*'\n              continue\n  \n          if left == 1:\n              print 'c' + '*' * (C-1)\n              for i in xrange(R-1):\n                  print '*' * C\n              continue\n  \n          if (R == 2 or C == 2) and (M % 2 == 1 or left == 2):\n              print \"Impossible\"\n              continue\n          if R == 2:\n              assert left not in (2, 3, 5, 7)\n              assert left >= 4\n              print 'c' + '.' * (left/2 - 1) + '*' * (M/2)\n              print '.' + '.' * (left/2 - 1) + '*' * (M/2)\n              continue\n          if C == 2:\n              assert left >= 4\n              assert left not in (2, 3, 5, 7)\n              print 'c.'\n              left -= 2\n              R -= 1\n              while left:\n                  print '..'\n                  left -= 2\n                  R -= 1\n              assert R >= 0\n              while R:\n                  print '**'\n                  R -= 1\n              continue\n  \n          assert R >= 3\n          assert C >= 3\n  \n          if left == 4:\n              print 'c.' + '*' * (C-2)\n              print '..' + '*' * (C-2)\n              for i in xrange(R-2):\n                  print '*' * C\n              continue\n  \n          if left in (2, 3, 5, 7):\n              print \"Impossible\"\n              continue\n  \n          assert left >= 6\n  \n          cols = max(3, (left + R-1) // R)\n  \n          if left % cols == 1:\n              assert left >= 10\n  \n              print 'c' + '.' * (cols - 1) + '*' * (C - cols)\n              left -= cols\n              R -= 1\n  \n              while left > cols + 1:\n                  print '.' * cols + '*' * (C - cols)\n                  left -= cols\n                  R -= 1\n              assert left == cols + 1\n              print '.' * (cols - 1) + '*' * (C - cols + 1)\n              print '.' * (2) + '*' * (C - 2)\n              R -= 2\n  \n              assert R >= 0\n  \n              while R:\n                  print '*' * C\n                  R -= 1\n              continue\n          else:\n              assert left >= 6\n  \n              print 'c' + '.' * (cols - 1) + '*' * (C - cols)\n              left -= cols\n              R -= 1\n  \n              while left > cols:\n                  print '.' * cols + '*' * (C - cols)\n                  left -= cols\n                  R -= 1\n              assert left >= 2\n              print '.' * (left) + '*' * (C - left)\n              R -= 1\n  \n              assert R >= 0\n  \n              while R:\n                  print '*' * C\n                  R -= 1\n              continue\n  \n          1/0\n ", "Adversarial Code": " \n  if __name__ == \"__main__\":\n      f = sys.stdin\n      if len(sys.argv) >= 2:\n          fn = sys.argv[1]\n          if fn != '-':\n              f = open(fn)\n  \n      T = int(f.readline())\n      for _T in xrange(T):\n          R, C, n_test = map(int, f.readline().split())\n  \n          print \"Case #%d:\" % (_T+1)\n  \n          left = R * C - n_test\n  \n          if R == 1:\n              s = 'c'\n              s += '.' * (left - 1)\n              s += '*' * n_test\n              print s\n              continue\n          if C == 1:\n              print 'c'\n              for generateWinBoard in xrange(left - 1):\n                  print '.'\n              for generateWinBoard in xrange(n_test):\n                  print '*'\n              continue\n  \n          if left == 1:\n              print 'c' + '*' * (C-1)\n              for generateWinBoard in xrange(R-1):\n                  print '*' * C\n              continue\n  \n          if (R == 2 or C == 2) and (n_test % 2 == 1 or left == 2):\n              print \"Impossible\"\n              continue\n          if R == 2:\n              assert left not in (2, 3, 5, 7)\n              assert left >= 4\n              print 'c' + '.' * (left/2 - 1) + '*' * (n_test/2)\n              print '.' + '.' * (left/2 - 1) + '*' * (n_test/2)\n              continue\n          if C == 2:\n              assert left >= 4\n              assert left not in (2, 3, 5, 7)\n              print 'c.'\n              left -= 2\n              R -= 1\n              while left:\n                  print '..'\n                  left -= 2\n                  R -= 1\n              assert R >= 0\n              while R:\n                  print '**'\n                  R -= 1\n              continue\n  \n          assert R >= 3\n          assert C >= 3\n  \n          if left == 4:\n              print 'c.' + '*' * (C-2)\n              print '..' + '*' * (C-2)\n              for generateWinBoard in xrange(R-2):\n                  print '*' * C\n              continue\n  \n          if left in (2, 3, 5, 7):\n              print \"Impossible\"\n              continue\n  \n          assert left >= 6\n  \n          cols = max(3, (left + R-1) // R)\n  \n          if left % cols == 1:\n              assert left >= 10\n  \n              print 'c' + '.' * (cols - 1) + '*' * (C - cols)\n              left -= cols\n              R -= 1\n  \n              while left > cols + 1:\n                  print '.' * cols + '*' * (C - cols)\n                  left -= cols\n                  R -= 1\n              assert left == cols + 1\n              print '.' * (cols - 1) + '*' * (C - cols + 1)\n              print '.' * (2) + '*' * (C - 2)\n              R -= 2\n  \n              assert R >= 0\n  \n              while R:\n                  print '*' * C\n                  R -= 1\n              continue\n          else:\n              assert left >= 6\n  \n              print 'c' + '.' * (cols - 1) + '*' * (C - cols)\n              left -= cols\n              R -= 1\n  \n              while left > cols:\n                  print '.' * cols + '*' * (C - cols)\n                  left -= cols\n                  R -= 1\n              assert left >= 2\n              print '.' * (left) + '*' * (C - left)\n              R -= 1\n  \n              assert R >= 0\n  \n              while R:\n                  print '*' * C\n                  R -= 1\n              continue\n  \n          1/0\n ", "Program Length": 612, "Identifier Num": 11, "Replaced Identifiers": "i:generateWinBoard,M:n_test,", "Query Times": 87, "Time Cost": 0.03953495025634766, "Type": "mhm"}
{"Index": 11, "Original Code": " \n  if __name__ == \"__main__\":\n      f = sys.stdin\n      if len(sys.argv) >= 2:\n          fn = sys.argv[1]\n          if fn != '-':\n              f = open(fn)\n  \n      T = int(f.readline())\n      for _T in xrange(T):\n          a1 = int(f.readline())\n          l1 = [map(int, f.readline().split()) for _ in xrange(4)]\n          a2 = int(f.readline())\n          l2 = [map(int, f.readline().split()) for _ in xrange(4)]\n  \n          poss = list(set(l1[a1-1]) & set(l2[a2-1]))\n  \n          print \"Case #%d:\" % (_T + 1),\n          if len(poss) == 0:\n              print \"Volunteer cheated!\"\n          elif len(poss) == 1:\n              print poss[0]\n          else:\n              print \"Bad magician!\"\n ", "Adversarial Code": " \n  if __name__ == \"__main__\":\n      f = sys.stdin\n      if len(sys.argv) >= 2:\n          input_values = sys.argv[1]\n          if input_values != '-':\n              f = open(input_values)\n  \n      T = int(f.readline())\n      for num_common in xrange(T):\n          a1 = int(f.readline())\n          l1 = [map(int, f.readline().split()) for _ in xrange(4)]\n          a2 = int(f.readline())\n          __call__ = [map(int, f.readline().split()) for _ in xrange(4)]\n  \n          main1 = list(set(l1[a1-1]) & set(__call__[a2-1]))\n  \n          print \"Case #%d:\" % (num_common + 1),\n          if len(main1) == 0:\n              print \"Volunteer cheated!\"\n          elif len(main1) == 1:\n              print main1[0]\n          else:\n              print \"Bad magician!\"\n ", "Program Length": 187, "Identifier Num": 10, "Replaced Identifiers": "_T:num_common,poss:main1,l2:__call__,fn:input_values,", "Query Times": 118, "Time Cost": 0.04390550851821899, "Type": "mhm"}
{"Index": 12, "Original Code": " \n  \n  TEST_CASES = [\n      (\"\"\"5\n  5 5 23\n  3 1 1\n  2 2 1\n  4 7 3\n  10 10 82\n  \"\"\",\"\"\"Case #1:\n  Impossible\n  Case #2:\n  c\n  .\n  *\n  Case #3:\n  Impossible\n  Case #4:\n  c......\n  .......\n  .......\n  ....***\n  Case #5:\n  c........*\n  .........*\n  **********\n  **********\n  **********\n  **********\n  **********\n  **********\n  **********\n  **********\n  \"\"\"),\n      (\"\"\"3\n  5 4 3\n  5 3 8\n  5 5 14\n  \"\"\",\"\"\"Case #1:\n  c...\n  ....\n  ....\n  ...*\n  ..**\n  Case #2:\n  Impossible\n  Case #3:\n  c...*\n  ....*\n  ...**\n  *****\n  *****\n  \"\"\")\n  ]\n  \n  IMPOSSIBLE = \"Impossible\"\n  \n  \"\"\"\n  S is number of safe squares = (R*C) - M\n  If S == 1 then always possible:\n      Assume click in top left, all else mines\n  Special cases (R or C is small):\n  If R == 1 or C == 1 then always possible:\n      Assume click in top left and all safe squares in a line\n  Else if R == 2 or C == 2 then possible iff S % 2 == 0:\n      Assume click in top left and all safe squares are in a 2 * X line\n  Else if R == 3 or C == 3 then possible if S % 3 == 0 (Assume click in top left and all safe squares are in a 3 * X line)\n     OR if S % 2 == 0 \n  \"\"\"\n  \n  def parse_input(input_reader):\n      case_count = int(input_reader.readline())\n      case_idx = 0\n      while case_count > case_idx:\n          case_idx += 1\n          input_line = [int(x) for x in input_reader.readline().split()]\n          input_values = {\"case\": case_idx,\n                          \"R\": input_line[0],\n                          \"C\": input_line[1],\n                          \"M\": input_line[2]}\n          yield input_values\n  \n  \n  def solve_problem(output_writer=sys.stdout, **kwargs):\n      case = kwargs['case']\n      rows = kwargs['R']\n      cols = kwargs['C']\n      mines = kwargs['M']\n      safe_squares = ((rows * cols) - mines)\n      print >> output_writer, \"Case #%d:\" % case\n      row_string = \"{:*<%ds}\" % cols\n      impossible = False\n      if safe_squares == 1:\n          print >> output_writer, row_string.format(\"c\")\n          for row in range(1, rows):\n              print >> output_writer, row_string.format(\"\")\n      elif rows == 1:\n          safe_string = \"c\" + (\".\" * (safe_squares - 1))\n          print >> output_writer, row_string.format(safe_string)\n      elif cols == 1:\n          for row in range(rows):\n              cell = \"\"\n              if row == 0:\n                  cell = \"c\"\n              elif row < safe_squares:\n                  cell = \".\"\n              print >> output_writer, row_string.format(cell)\n      elif safe_squares == 2:\n          impossible = True\n      elif rows == 2:\n          safe_cols, remainder = divmod(safe_squares, 2)\n          if remainder == 1:\n              impossible = True\n          else:\n              safe_string = \".\" * (safe_cols - 1)\n              print >> output_writer, row_string.format(\"c%s\" % safe_string)\n              print >> output_writer, row_string.format(\".%s\" % safe_string)\n      elif cols == 2:\n          safe_rows, remainder = divmod(safe_squares, 2)\n          if remainder == 1:\n              impossible = True\n          else:\n              for row in range(rows):\n                  cells = \"\"\n                  if row == 0:\n                      cells = \"c.\"\n                  elif row < safe_rows:\n                      cells = \"..\"\n                  print >> output_writer, row_string.format(cells)\n      else:\n          safe_rows, remainder = divmod(safe_squares, cols)\n          if remainder == 1 and cols == 3 and safe_rows == 2:\n              impossible = True\n          elif safe_rows > 1:\n              if remainder == 1 and safe_rows == 2:\n                  mid_safe = \".\" * (cols-2)\n                  for row in range(rows):\n                      cell_one = \".\"\n                      mid_cells = mid_safe\n                      last_cell = \".\"\n                      if row == 0:\n                          cell_one = \"c\"\n                      elif safe_rows == 0:\n                          cell_one = \".\"\n                          mid_cells = \".\" * (remainder + 1)\n                      elif safe_rows < 0:\n                          cell_one = \"\"\n                          mid_cells = \"\"\n                      if safe_rows < 3:\n                          last_cell = \"\"\n                      print >> output_writer, row_string.format(\"%s%s%s\" % (cell_one, mid_cells, last_cell))\n                      safe_rows -= 1\n              elif remainder == 1:\n                  mid_safe = \".\" * (cols-2)\n                  for row in range(rows):\n                      cell_one = \".\"\n                      mid_cells = mid_safe\n                      last_cell = \".\"\n                      if row == 0:\n                          cell_one = \"c\"\n                      elif safe_rows == 0:\n                          cell_one = \".\"\n                          mid_cells = \".\" * remainder\n                      elif safe_rows < 0:\n                          cell_one = \"\"\n                          mid_cells = \"\"\n                      if safe_rows < 2:\n                          last_cell = \"\"\n                      print >> output_writer, row_string.format(\"%s%s%s\" % (cell_one, mid_cells, last_cell))\n                      safe_rows -= 1\n              else:\n                  full_safe = \".\" * cols\n                  for row in range(rows):\n                      cells = full_safe\n                      if row == 0:\n                          cells = \"c\" + (\".\" * (cols - 1))\n                      elif row == safe_rows:\n                          cells = \".\" * remainder\n                      elif row > safe_rows:\n                          cells = \"\"\n                      print >> output_writer, row_string.format(cells)\n          else:\n              safe_cols, remainder = divmod(safe_squares, 2)\n              if remainder == 1 and safe_cols < 4:\n                  impossible = True\n              elif remainder == 0:\n                  print >> output_writer, row_string.format(\"c%s\" % (\".\" * (safe_cols - 1)))\n                  print >> output_writer, row_string.format(\".\" * safe_cols)\n                  for row in range(2, rows):\n                      print >> output_writer, row_string.format(\"\")\n              else:\n                  safe_cols -= 1\n                  print >> output_writer, row_string.format(\"c%s\" % (\".\" * (safe_cols - 1)))\n                  print >> output_writer, row_string.format(\".\" * safe_cols)\n                  print >> output_writer, row_string.format(\"...\")\n                  for row in range(3, rows):\n                      print >> output_writer, row_string.format(\"\")\n      if impossible:\n          print >> output_writer, IMPOSSIBLE\n  \n  def solve_inputs(input_reader, output_writer):\n      \"\"\"\n      Loop through each problem input in input reader and solve it.\n  \n      Outputs responses to output_writer.\n      \"\"\"\n      for input_values in parse_input(input_reader):\n          solve_problem(output_writer=output_writer, **input_values)\n  \n  def run_tests():\n      idx = 0\n      all_pass = True\n      for problem_input, expected_output in TEST_CASES:\n          idx += 1\n          input_reader = StringIO(problem_input)\n          output_writer = StringIO()\n          solve_inputs(input_reader, output_writer)\n          problem_output = output_writer.getvalue()\n          if problem_output == expected_output:\n              print \"Test %d: Success\" % idx\n          else:\n              all_pass = False\n              print \"Test %d: Failure\" % idx\n              print problem_output\n          input_reader.close()\n          output_writer.close()\n      if all_pass:\n          print \"All tests were successful!\"\n      else:\n          print \"Something didn't match - try again.\"\n  \n  def main():\n      parser = OptionParser()\n      parser.add_option(\"-f\", \"--file\",\n                        dest=\"filename_stem\",\n                        help=\"read input from FILE.in and write to FILE.out\",\n                        metavar=\"FILE\")\n  \n      (options, args) = parser.parse_args()\n      if options.filename_stem:\n          print \"Running in file mode.\"\n          input_reader = open(\"%s.in\" % options.filename_stem, \"r\")\n          output_writer = open(\"%s.out\" % options.filename_stem, \"w\")\n          solve_inputs(input_reader, output_writer)\n      else:\n          print \"Running in test mode.\"\n          run_tests()\n  \n  if __name__ == \"__main__\":\n      main()\n ", "Adversarial Code": " \n  \n  max_sub = [\n      (\"\"\"5\n  5 5 23\n  3 1 1\n  2 2 1\n  4 7 3\n  10 10 82\n  \"\"\",\"\"\"Case #1:\n  Impossible\n  Case #2:\n  c\n  .\n  *\n  Case #3:\n  Impossible\n  Case #4:\n  c......\n  .......\n  .......\n  ....***\n  Case #5:\n  c........*\n  .........*\n  **********\n  **********\n  **********\n  **********\n  **********\n  **********\n  **********\n  **********\n  \"\"\"),\n      (\"\"\"3\n  5 4 3\n  5 3 8\n  5 5 14\n  \"\"\",\"\"\"Case #1:\n  c...\n  ....\n  ....\n  ...*\n  ..**\n  Case #2:\n  Impossible\n  Case #3:\n  c...*\n  ....*\n  ...**\n  *****\n  *****\n  \"\"\")\n  ]\n  \n  Fill = \"Impossible\"\n  \n  \"\"\"\n  S is number of safe squares = (R*C) - M\n  If S == 1 then always possible:\n      Assume click in top left, all else mines\n  Special cases (R or C is small):\n  If R == 1 or C == 1 then always possible:\n      Assume click in top left and all safe squares in a line\n  Else if R == 2 or C == 2 then possible iff S % 2 == 0:\n      Assume click in top left and all safe squares are in a 2 * X line\n  Else if R == 3 or C == 3 then possible if S % 3 == 0 (Assume click in top left and all safe squares are in a 3 * X line)\n     OR if S % 2 == 0 \n  \"\"\"\n  \n  def parse_input(RUN):\n      enum_neighbour_coords = int(RUN.readline())\n      testcase = 0\n      while enum_neighbour_coords > testcase:\n          testcase += 1\n          solveit = [int(directions) for directions in RUN.readline().split()]\n          directions = {\"case\": testcase,\n                          \"R\": solveit[0],\n                          \"C\": solveit[1],\n                          \"M\": solveit[2]}\n          yield directions\n  \n  \n  def good(read_int=sys.stdout, **kwargs):\n      nset = kwargs['case']\n      calculateOneClick = kwargs['R']\n      BadMag = kwargs['C']\n      mark_click = kwargs['M']\n      noNearbyMines = ((calculateOneClick * BadMag) - mark_click)\n      print >> read_int, \"Case #%d:\" % nset\n      testcase = \"{:*<%ds}\" % BadMag\n      possibilities2 = False\n      if noNearbyMines == 1:\n          print >> read_int, testcase.format(\"c\")\n          for load in range(1, calculateOneClick):\n              print >> read_int, testcase.format(\"\")\n      elif calculateOneClick == 1:\n          p1 = \"c\" + (\".\" * (noNearbyMines - 1))\n          print >> read_int, testcase.format(p1)\n      elif BadMag == 1:\n          for load in range(calculateOneClick):\n              cell = \"\"\n              if load == 0:\n                  cell = \"c\"\n              elif load < noNearbyMines:\n                  cell = \".\"\n              print >> read_int, testcase.format(cell)\n      elif noNearbyMines == 2:\n          possibilities2 = True\n      elif calculateOneClick == 2:\n          safe_cols, remainder = divmod(noNearbyMines, 2)\n          if remainder == 1:\n              possibilities2 = True\n          else:\n              p1 = \".\" * (safe_cols - 1)\n              print >> read_int, testcase.format(\"c%s\" % p1)\n              print >> read_int, testcase.format(\".%s\" % p1)\n      elif BadMag == 2:\n          safe_rows, remainder = divmod(noNearbyMines, 2)\n          if remainder == 1:\n              possibilities2 = True\n          else:\n              for load in range(calculateOneClick):\n                  cells = \"\"\n                  if load == 0:\n                      cells = \"c.\"\n                  elif load < safe_rows:\n                      cells = \"..\"\n                  print >> read_int, testcase.format(cells)\n      else:\n          safe_rows, remainder = divmod(noNearbyMines, BadMag)\n          if remainder == 1 and BadMag == 3 and safe_rows == 2:\n              possibilities2 = True\n          elif safe_rows > 1:\n              if remainder == 1 and safe_rows == 2:\n                  mid_safe = \".\" * (BadMag-2)\n                  for load in range(calculateOneClick):\n                      cell_one = \".\"\n                      mid_cells = mid_safe\n                      last_cell = \".\"\n                      if load == 0:\n                          cell_one = \"c\"\n                      elif safe_rows == 0:\n                          cell_one = \".\"\n                          mid_cells = \".\" * (remainder + 1)\n                      elif safe_rows < 0:\n                          cell_one = \"\"\n                          mid_cells = \"\"\n                      if safe_rows < 3:\n                          last_cell = \"\"\n                      print >> read_int, testcase.format(\"%s%s%s\" % (cell_one, mid_cells, last_cell))\n                      safe_rows -= 1\n              elif remainder == 1:\n                  mid_safe = \".\" * (BadMag-2)\n                  for load in range(calculateOneClick):\n                      cell_one = \".\"\n                      mid_cells = mid_safe\n                      last_cell = \".\"\n                      if load == 0:\n                          cell_one = \"c\"\n                      elif safe_rows == 0:\n                          cell_one = \".\"\n                          mid_cells = \".\" * remainder\n                      elif safe_rows < 0:\n                          cell_one = \"\"\n                          mid_cells = \"\"\n                      if safe_rows < 2:\n                          last_cell = \"\"\n                      print >> read_int, testcase.format(\"%s%s%s\" % (cell_one, mid_cells, last_cell))\n                      safe_rows -= 1\n              else:\n                  full_safe = \".\" * BadMag\n                  for load in range(calculateOneClick):\n                      cells = full_safe\n                      if load == 0:\n                          cells = \"c\" + (\".\" * (BadMag - 1))\n                      elif load == safe_rows:\n                          cells = \".\" * remainder\n                      elif load > safe_rows:\n                          cells = \"\"\n                      print >> read_int, testcase.format(cells)\n          else:\n              safe_cols, remainder = divmod(noNearbyMines, 2)\n              if remainder == 1 and safe_cols < 4:\n                  possibilities2 = True\n              elif remainder == 0:\n                  print >> read_int, testcase.format(\"c%s\" % (\".\" * (safe_cols - 1)))\n                  print >> read_int, testcase.format(\".\" * safe_cols)\n                  for load in range(2, calculateOneClick):\n                      print >> read_int, testcase.format(\"\")\n              else:\n                  safe_cols -= 1\n                  print >> read_int, testcase.format(\"c%s\" % (\".\" * (safe_cols - 1)))\n                  print >> read_int, testcase.format(\".\" * safe_cols)\n                  print >> read_int, testcase.format(\"...\")\n                  for load in range(3, calculateOneClick):\n                      print >> read_int, testcase.format(\"\")\n      if possibilities2:\n          print >> read_int, Fill\n  \n  def solve_inputs(RUN, read_int):\n      \"\"\"\n      Loop through each problem input in input reader and solve it.\n  \n      Outputs responses to output_writer.\n      \"\"\"\n      for directions in parse_input(RUN):\n          good(read_int=read_int, **directions)\n  \n  def run_tests():\n      idx = 0\n      all_pass = True\n      for problem_input, expected_output in max_sub:\n          idx += 1\n          RUN = StringIO(problem_input)\n          read_int = StringIO()\n          solve_inputs(RUN, read_int)\n          problem_output = read_int.getvalue()\n          if problem_output == expected_output:\n              print \"Test %d: Success\" % idx\n          else:\n              all_pass = False\n              print \"Test %d: Failure\" % idx\n              print problem_output\n          RUN.close()\n          read_int.close()\n      if all_pass:\n          print \"All tests were successful!\"\n      else:\n          print \"Something didn't match - try again.\"\n  \n  def main():\n      parser = OptionParser()\n      parser.add_option(\"-f\", \"--file\",\n                        dest=\"filename_stem\",\n                        help=\"read input from FILE.in and write to FILE.out\",\n                        metavar=\"FILE\")\n  \n      (options, directions) = parser.parse_args()\n      if options.filename_stem:\n          print \"Running in file mode.\"\n          RUN = open(\"%s.in\" % options.filename_stem, \"r\")\n          read_int = open(\"%s.out\" % options.filename_stem, \"w\")\n          solve_inputs(RUN, read_int)\n      else:\n          print \"Running in test mode.\"\n          run_tests()\n  \n  if __name__ == \"__main__\":\n      main()\n ", "Program Length": 1039, "Identifier Num": 21, "Replaced Identifiers": "case:nset,safe_string:p1,case_count:enum_neighbour_coords,mines:mark_click,x:directions,output_writer:read_int,input_values:directions,row_string:testcase,row:load,cols:BadMag,input_line:solveit,rows:calculateOneClick,solve_problem:good,impossible:possibilities2,safe_squares:noNearbyMines,IMPOSSIBLE:Fill,TEST_CASES:max_sub,input_reader:RUN,", "Query Times": 1424, "Time Cost": 0.7621471881866455, "Type": "mhm"}
{"Index": 13, "Original Code": " \n  \n  TEST_CASES = [\n      (\"\"\"3\n  2\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  3\n  1 2 5 4\n  3 11 6 15\n  9 10 7 12\n  13 14 8 16\n  2\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  2\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  2\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  3\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  \"\"\",\"\"\"Case #1: 7\n  Case #2: Bad magician!\n  Case #3: Volunteer cheated!\n  \"\"\"),\n      (\"\"\"1\n  1\n  15 9 16 5\n  6 10 1 3\n  2 4 12 11\n  13 14 8 7\n  1\n  5 10 9 6\n  12 15 1 11\n  14 16 4 2\n  13 3 8 7\"\"\",\"\"\"Case #1: Bad magician!\n  \"\"\")\n  ]\n  \n  BAD_MAGIC = \"Bad magician!\"\n  CHEATING = \"Volunteer cheated!\"\n  \n  def parse_input(input_reader):\n      case_count = int(input_reader.readline())\n      case_idx = 0\n      while case_count > case_idx:\n          case_idx += 1\n          rows = []\n          for loop_idx in (1,2):\n              row_idx = int(input_reader.readline())\n              for idx in (1,2,3,4):\n                  if idx == row_idx:\n                      rows.append(set(input_reader.readline().rstrip(\"\n\").split(\" \")))\n                  else:\n                      input_reader.readline()\n          input_values = {\"rows\":rows,\n                          \"case\":case_idx}\n          yield input_values\n  \n  \n  def solve_problem(output_writer=sys.stdout, **kwargs):\n      rows = kwargs['rows']\n      case = kwargs['case']\n      intersect = rows[0].intersection(rows[1])\n      if not intersect:\n          msg = CHEATING\n      elif len(intersect) == 1:\n          msg = intersect.pop()\n      else:\n          msg = BAD_MAGIC\n      print >>output_writer, \"Case #%d: %s\" % (case, msg)\n  \n  def solve_inputs(input_reader, output_writer):\n      \"\"\"\n      Loop through each problem input in input reader and solve it.\n  \n      Outputs responses to output_writer.\n      \"\"\"\n      for input_values in parse_input(input_reader):\n          solve_problem(output_writer=output_writer, **input_values)\n  \n  def run_tests():\n      \"\"\"\n      Check the sample input and output match.\n      \"\"\"\n      idx = 0\n      all_pass = True\n      for problem_input, expected_output in TEST_CASES:\n          idx += 1\n          input_reader = StringIO(problem_input)\n          output_writer = StringIO()\n          solve_inputs(input_reader, output_writer)\n          problem_output = output_writer.getvalue()\n          if problem_output == expected_output:\n              print \"Test %d: Success\" % idx\n          else:\n              all_pass = False\n              print \"Test %d: Failure\" % idx\n          input_reader.close()\n          output_writer.close()\n      if all_pass:\n          print \"All tests were successful!\"\n      else:\n          print \"Something didn't match - try again.\"\n          print problem_output\n  \n  def main():\n      parser = OptionParser()\n      parser.add_option(\"-f\", \"--file\",\n                        dest=\"filename_stem\",\n                        help=\"read input from FILE.in and write to FILE.out\",\n                        metavar=\"FILE\")\n  \n      (options, args) = parser.parse_args()\n      if options.filename_stem:\n          print \"Running in file mode.\"\n          input_reader = open(\"%s.in\" % options.filename_stem, \"r\")\n          output_writer = open(\"%s.out\" % options.filename_stem, \"w\")\n          solve_inputs(input_reader, output_writer)\n      else:\n          print \"Running in test mode.\"\n          run_tests()\n  \n  if __name__ == \"__main__\":\n      main()\n ", "Adversarial Code": " \n  \n  TEST_CASES = [\n      (\"\"\"3\n  2\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  3\n  1 2 5 4\n  3 11 6 15\n  9 10 7 12\n  13 14 8 16\n  2\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  2\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  2\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  3\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  \"\"\",\"\"\"Case #1: 7\n  Case #2: Bad magician!\n  Case #3: Volunteer cheated!\n  \"\"\"),\n      (\"\"\"1\n  1\n  15 9 16 5\n  6 10 1 3\n  2 4 12 11\n  13 14 8 7\n  1\n  5 10 9 6\n  12 15 1 11\n  14 16 4 2\n  13 3 8 7\"\"\",\"\"\"Case #1: Bad magician!\n  \"\"\")\n  ]\n  \n  BAD_MAGIC = \"Bad magician!\"\n  card = \"Volunteer cheated!\"\n  \n  def parse_input(r0):\n      case_count = int(r0.readline())\n      case_idx = 0\n      while case_count > case_idx:\n          case_idx += 1\n          rows = []\n          for loop_idx in (1,2):\n              row_idx = int(r0.readline())\n              for idx in (1,2,3,4):\n                  if idx == row_idx:\n                      rows.append(set(r0.readline().rstrip(\"\n\").split(\" \")))\n                  else:\n                      r0.readline()\n          input_values = {\"rows\":rows,\n                          \"case\":case_idx}\n          yield input_values\n  \n  \n  def solve_problem(output_writer=sys.stdout, **kwargs):\n      rows = kwargs['rows']\n      case = kwargs['case']\n      intersect = rows[0].intersection(rows[1])\n      if not intersect:\n          msg = card\n      elif len(intersect) == 1:\n          msg = intersect.pop()\n      else:\n          msg = BAD_MAGIC\n      print >>output_writer, \"Case #%d: %s\" % (case, msg)\n  \n  def solve_inputs(r0, output_writer):\n      \"\"\"\n      Loop through each problem input in input reader and solve it.\n  \n      Outputs responses to output_writer.\n      \"\"\"\n      for input_values in parse_input(r0):\n          solve_problem(output_writer=output_writer, **input_values)\n  \n  def run_tests():\n      \"\"\"\n      Check the sample input and output match.\n      \"\"\"\n      idx = 0\n      all_pass = True\n      for problem_input, expected_output in TEST_CASES:\n          idx += 1\n          r0 = StringIO(problem_input)\n          output_writer = StringIO()\n          solve_inputs(r0, output_writer)\n          problem_output = output_writer.getvalue()\n          if problem_output == expected_output:\n              print \"Test %d: Success\" % idx\n          else:\n              all_pass = False\n              print \"Test %d: Failure\" % idx\n          r0.close()\n          output_writer.close()\n      if all_pass:\n          print \"All tests were successful!\"\n      else:\n          print \"Something didn't match - try again.\"\n          print problem_output\n  \n  def main():\n      parser = OptionParser()\n      parser.add_option(\"-f\", \"--file\",\n                        dest=\"filename_stem\",\n                        help=\"read input from FILE.in and write to FILE.out\",\n                        metavar=\"FILE\")\n  \n      (options, args) = parser.parse_args()\n      if options.filename_stem:\n          print \"Running in file mode.\"\n          r0 = open(\"%s.in\" % options.filename_stem, \"r\")\n          output_writer = open(\"%s.out\" % options.filename_stem, \"w\")\n          solve_inputs(r0, output_writer)\n      else:\n          print \"Running in test mode.\"\n          run_tests()\n  \n  if __name__ == \"__main__\":\n      main()\n ", "Program Length": 406, "Identifier Num": 18, "Replaced Identifiers": "CHEATING:card,input_reader:r0,", "Query Times": 60, "Time Cost": 0.026473371187845866, "Type": "mhm"}
{"Index": 14, "Original Code": "__author__ = 'Jeffrey'\n  \n  inFileName = \"C:\\\\Users\\\\Jeffrey\\\\IdeaProjects\\\\Google Code Jam 2014\\\\C-small-attempt0.in\"\n  \n  outFileName = inFileName[: -2] + \"out\"\n  \n  \n  def parseInput(f):\n      T = int(f.readline())\n      L = []\n  \n      for i in range(T):\n          L.append([int(i) for i in f.readline().split()])\n  \n      return T, L\n  \n  \n  def calculateOneClick(R, C, M):\n      size = R * C\n      if R == 1 or C == 1 and M < size:\n          return generateWinBoardBaseCase(R, C, M)\n      elif size - M == 1:\n          return generateWinBoardBaseCase(R, C, M)\n      elif size - M >= 4:\n          return generateWinBoard(R, C, M)\n      return \"Impossible\"\n  \n  def generateWinBoard(R,C,M):\n      emptySpace = R * C - M - 4\n      out = \"c\"\n      if C > 1:\n          out += \".\"\n          for i in range(2,C):\n              if emptySpace > 0:\n                  out += \".\"\n                  emptySpace -= 1\n              else:\n                  out += \"*\"\n      if R > 1:\n          out += '\n'\n          out += \".\"\n          if C > 1:\n              out += \".\"\n          for i in range(2,C):\n              if emptySpace > 0:\n                  out += \".\"\n                  emptySpace -= 1\n              else:\n                  out += \"*\"\n      for r in range(2,R):\n          out += '\n'\n          for c in range(C):\n              if emptySpace > 0:\n                  out += \".\"\n                  emptySpace -= 1\n              else:\n                  out += \"*\"\n      return out\n  \n  def generateWinBoardBaseCase(R,C,M):\n      emptySpace = R * C - M - 1\n      out = \"c\"\n      if C > 1:\n          for c in range(1,C):\n              if emptySpace > 0:\n                  out += \".\"\n                  emptySpace -= 1\n              else:\n                  out += \"*\"\n      for r in range(1,R):\n          out += '\n'\n          for c in range(C):\n              if emptySpace > 0:\n                  out += \".\"\n                  emptySpace -= 1\n              else:\n                  out += \"*\"\n      return out\n  \n  \n  def playGame(T, L):\n      for i in range(T):\n          result = calculateOneClick(L[i][0], L[i][1], L[i][2])\n          yield \"Case #\" + str(i + 1) + \":\n\" + str(result)\n  \n  \n  if __name__ == \"__main__\":\n      iF = open(inFileName, 'r')\n      T, L = parseInput(iF)\n      iF.close()\n  \n      print(T)\n      print(L)\n  \n      oF = open(outFileName, \"wb\")\n      for out in playGame(T, L):\n          print(out)\n          oF.write(bytes(out + \"\n\", 'utf-8'))\n      oF.close()\n ", "Adversarial Code": "__author__ = 'Jeffrey'\n  \n  searchBoard = \"C:\\\\Users\\\\Jeffrey\\\\IdeaProjects\\\\Google Code Jam 2014\\\\C-small-attempt0.in\"\n  \n  print = searchBoard[: -2] + \"out\"\n  \n  \n  def parseInput(f):\n      T = int(f.readline())\n      L = []\n  \n      for i in range(T):\n          L.append([int(i) for i in f.readline().split()])\n  \n      return T, L\n  \n  \n  def calculateOneClick(R, C, M):\n      size = R * C\n      if R == 1 or C == 1 and M < size:\n          return generateWinBoardBaseCase(R, C, M)\n      elif size - M == 1:\n          return generateWinBoardBaseCase(R, C, M)\n      elif size - M >= 4:\n          return generateWinBoard(R, C, M)\n      return \"Impossible\"\n  \n  def generateWinBoard(R,C,M):\n      emptySpace = R * C - M - 4\n      out = \"c\"\n      if C > 1:\n          out += \".\"\n          for i in range(2,C):\n              if emptySpace > 0:\n                  out += \".\"\n                  emptySpace -= 1\n              else:\n                  out += \"*\"\n      if R > 1:\n          out += '\n'\n          out += \".\"\n          if C > 1:\n              out += \".\"\n          for i in range(2,C):\n              if emptySpace > 0:\n                  out += \".\"\n                  emptySpace -= 1\n              else:\n                  out += \"*\"\n      for r in range(2,R):\n          out += '\n'\n          for c in range(C):\n              if emptySpace > 0:\n                  out += \".\"\n                  emptySpace -= 1\n              else:\n                  out += \"*\"\n      return out\n  \n  def generateWinBoardBaseCase(R,C,M):\n      emptySpace = R * C - M - 1\n      out = \"c\"\n      if C > 1:\n          for c in range(1,C):\n              if emptySpace > 0:\n                  out += \".\"\n                  emptySpace -= 1\n              else:\n                  out += \"*\"\n      for r in range(1,R):\n          out += '\n'\n          for c in range(C):\n              if emptySpace > 0:\n                  out += \".\"\n                  emptySpace -= 1\n              else:\n                  out += \"*\"\n      return out\n  \n  \n  def playGame(T, L):\n      for i in range(T):\n          result = calculateOneClick(L[i][0], L[i][1], L[i][2])\n          yield \"Case #\" + str(i + 1) + \":\n\" + str(result)\n  \n  \n  if __name__ == \"__main__\":\n      iF = open(searchBoard, 'r')\n      T, L = parseInput(iF)\n      iF.close()\n  \n      print(T)\n      print(L)\n  \n      oF = open(print, \"wb\")\n      for out in playGame(T, L):\n          print(out)\n          oF.write(bytes(out + \"\n\", 'utf-8'))\n      oF.close()\n ", "Program Length": 510, "Identifier Num": 21, "Replaced Identifiers": "outFileName:print,inFileName:searchBoard,", "Query Times": 85, "Time Cost": 0.036907315254211426, "Type": "mhm"}
{"Index": 15, "Original Code": "__author__ = 'Jeffrey'\n  \n  inFileName = \"C:\\\\Users\\\\Jeffrey\\\\IdeaProjects\\\\Google Code Jam 2014\\\\A-small-attempt0.in\"\n  outFileName = \"C:\\\\Users\\\\Jeffrey\\\\IdeaProjects\\\\Google Code Jam 2014\\\\A-small-attempt0.out\"\n  \n  \n  def parseInput(f):\n      T = int(f.readline())\n      L = []\n  \n      for i in range(T):\n          picks = []\n          cards = []\n          for j in range(2):\n              picks.append( int(f.readline()))\n              tempL = []\n              for k in range(4):\n                  tempL.append( [int(j) for j in f.readline().split()])\n              cards.append(tempL)\n          L.append((picks, cards))\n  \n      return T, L\n  \n  \n  def performTrick(picks, cards):\n      matchFound = False\n      matchedCard = None\n      for card in cards[0][picks[0] - 1]:\n          possibleMatch = card in cards[1][picks[1] - 1]\n          if possibleMatch and matchFound:\n              return \"Bad magician!\"\n          elif possibleMatch:\n              matchFound = True\n              matchedCard = card\n      if matchFound:\n          return matchedCard\n      else:\n          return \"Volunteer cheated!\"\n  \n  \n  def playGame(T,L):\n      for i in range(T):\n          result = performTrick(L[i][0], L[i][1])\n          yield \"Case #\" + str(i + 1) + \": \" + str(result)\n  \n  \n  if __name__==\"__main__\":\n      iF = open(inFileName, 'r')\n      T, L = parseInput(iF)\n      iF.close()\n  \n      oF = open(outFileName, \"wb\")\n      for out in playGame(T, L):\n          oF.write(bytes(out + \"\n\",'utf-8'))\n      oF.close()\n ", "Adversarial Code": "board_A = 'Jeffrey'\n  \n  inFileName = \"C:\\\\Users\\\\Jeffrey\\\\IdeaProjects\\\\Google Code Jam 2014\\\\A-small-attempt0.in\"\n  mark_click = \"C:\\\\Users\\\\Jeffrey\\\\IdeaProjects\\\\Google Code Jam 2014\\\\A-small-attempt0.out\"\n  \n  \n  def isGridCorrect(row1):\n      put_mines_last_step = int(row1.readline())\n      _ = []\n  \n      for is in range(put_mines_last_step):\n          picks = []\n          cards = []\n          for arrang1 in range(2):\n              picks.append( int(row1.readline()))\n              tempL = []\n              for TestCase in range(4):\n                  tempL.append( [int(arrang1) for arrang1 in row1.readline().split()])\n              cards.append(tempL)\n          _.append((picks, cards))\n  \n      return put_mines_last_step, _\n  \n  \n  def readstring(picks, cards):\n      print_basic_board = False\n      get_max_array_on_index = None\n      for card in cards[0][picks[0] - 1]:\n          countMinesNear = card in cards[1][picks[1] - 1]\n          if countMinesNear and print_basic_board:\n              return \"Bad magician!\"\n          elif countMinesNear:\n              print_basic_board = True\n              get_max_array_on_index = card\n      if print_basic_board:\n          return get_max_array_on_index\n      else:\n          return \"Volunteer cheated!\"\n  \n  \n  def ii(put_mines_last_step,_):\n      for is in range(put_mines_last_step):\n          read_cards = readstring(_[is][0], _[is][1])\n          yield \"Case #\" + str(is + 1) + \": \" + str(read_cards)\n  \n  \n  if __name__==\"__main__\":\n      UNK = open(inFileName, 'r')\n      put_mines_last_step, _ = isGridCorrect(UNK)\n      UNK.close()\n  \n      valid1 = open(mark_click, \"wb\")\n      for RECURSION_LIMIT in ii(put_mines_last_step, _):\n          valid1.write(bytes(RECURSION_LIMIT + \"\n\",'utf-8'))\n      valid1.close()\n ", "Program Length": 306, "Identifier Num": 23, "Replaced Identifiers": "possibleMatch:countMinesNear,out:RECURSION_LIMIT,outFileName:mark_click,__author__:board_A,i:is,T:put_mines_last_step,j:arrang1,playGame:ii,result:read_cards,parseInput:isGridCorrect,k:TestCase,matchFound:print_basic_board,f:row1,oF:valid1,L:_,performTrick:readstring,matchedCard:get_max_array_on_index,iF:UNK,", "Query Times": 1043, "Time Cost": 0.41634058157602943, "Type": "mhm"}
{"Index": 17, "Original Code": " \n  def solve_case(answers, arrangements_of_cards, case_number):\n      first_candidates = arrangements_of_cards[0][answers[0] - 1]\n      second_candidates = arrangements_of_cards[1][answers[1] - 1]\n      answer = set(first_candidates) & set(second_candidates)\n      length_of_answer = len(answer)\n      if length_of_answer > 1:\n          print \"Case #%d: Bad magician!\" % case_number\n      elif length_of_answer < 1:\n          print \"Case #%d: Volunteer cheated!\" % case_number\n      else:\n          print \"Case #%d: %d\" % (case_number, answer.pop())\n  \n  r = sys.stdin\n  \n  if len(sys.argv) > 1:\n      r = open(sys.argv[1], 'r')\n  \n  total_cases = r.readline()\n  for case_number in range(1, int(total_cases) + 1):\n      answers = []\n      arrangements_of_cards = []\n      answers.append(int(r.readline()))\n      arrangements_of_cards.append([])\n      for row in range(0, 4):\n          arrangements_of_cards[0].append(map(int, r.readline().split(' ')))\n      answers.append(int(r.readline()))\n      arrangements_of_cards.append([])\n      for row in range(0, 4):\n          arrangements_of_cards[1].append(map(int, r.readline().split(' ')))\n      solve_case(answers, arrangements_of_cards, case_number)\n ", "Adversarial Code": " \n  def solve_case(answers, arrangements_of_cards, case_number):\n      first_candidates = arrangements_of_cards[0][answers[0] - 1]\n      second_candidates = arrangements_of_cards[1][answers[1] - 1]\n      answer = set(first_candidates) & set(second_candidates)\n      length_of_answer = len(answer)\n      if length_of_answer > 1:\n          print \"Case #%d: Bad magician!\" % case_number\n      elif length_of_answer < 1:\n          print \"Case #%d: Volunteer cheated!\" % case_number\n      else:\n          print \"Case #%d: %d\" % (case_number, answer.pop())\n  \n  do_trial = sys.stdin\n  \n  if len(sys.argv) > 1:\n      do_trial = open(sys.argv[1], 'r')\n  \n  total_cases = do_trial.readline()\n  for case_number in range(1, int(total_cases) + 1):\n      answers = []\n      arrangements_of_cards = []\n      answers.append(int(do_trial.readline()))\n      arrangements_of_cards.append([])\n      for row in range(0, 4):\n          arrangements_of_cards[0].append(map(int, do_trial.readline().split(' ')))\n      answers.append(int(do_trial.readline()))\n      arrangements_of_cards.append([])\n      for row in range(0, 4):\n          arrangements_of_cards[1].append(map(int, do_trial.readline().split(' ')))\n      solve_case(answers, arrangements_of_cards, case_number)\n ", "Program Length": 259, "Identifier Num": 11, "Replaced Identifiers": "r:do_trial,", "Query Times": 29, "Time Cost": 0.011408797899881999, "Type": "mhm"}
{"Index": 19, "Original Code": " \n  \n  def compute(r1, m1, r2, m2):\n      valid1 = set(m1[r1 - 1])\n      valid2 = set(m2[r2 - 1])\n      valid = valid1 & valid2\n      if len(valid) == 0:\n          return 'Volunteer cheated!'\n      if len(valid) > 1:\n          return 'Bad magician!'\n      return valid.pop()\n  \n  \n  def parse_single():\n      r = int(sys.stdin.readline().strip())\n      m = []\n      for i in xrange(4):\n          m.append(map(int, sys.stdin.readline().strip().split()))\n      return r, m\n  \n  def parse():\n      r1, m1 = parse_single()\n      r2, m2 = parse_single()\n      return r1, m1, r2, m2\n  \n  \n  if __name__ == \"__main__\":\n      sys.setrecursionlimit(100000)\n      T = int(sys.stdin.readline().strip())\n      for i in xrange(T):\n          data = parse()\n          result = compute(*data)\n          print \"Case #%d: %s\" % (i + 1, result)\n ", "Adversarial Code": " \n  \n  def compute(r1, m1, r2, m2):\n      valid1 = set(m1[r1 - 1])\n      valid2 = set(m2[r2 - 1])\n      valid = valid1 & valid2\n      if len(valid) == 0:\n          return 'Volunteer cheated!'\n      if len(valid) > 1:\n          return 'Bad magician!'\n      return valid.pop()\n  \n  \n  def parse_single():\n      r = int(sys.stdin.readline().strip())\n      m = []\n      for i in xrange(4):\n          m.append(map(int, sys.stdin.readline().strip().split()))\n      return r, m\n  \n  def parse():\n      r1, m1 = parse_single()\n      r2, m2 = parse_single()\n      return r1, m1, r2, m2\n  \n  \n  if __name__ == \"__main__\":\n      sys.setrecursionlimit(100000)\n      makesample = int(sys.stdin.readline().strip())\n      for i in xrange(makesample):\n          data = parse()\n          result = compute(*data)\n          print \"Case #%d: %s\" % (i + 1, result)\n ", "Program Length": 211, "Identifier Num": 16, "Replaced Identifiers": "T:makesample,", "Query Times": 31, "Time Cost": 0.012009998162587484, "Type": "mhm"}
{"Index": 20, "Original Code": " \n  def read_line():\n      return sys.stdin.readline().rstrip( '\n' )\n  \n  def read_integer():\n      return int( read_line() )\n  \n  def read_integers():\n      return [ int( x ) for x in read_line().split() ]\n  \n  def flip( grid ):\n      return [ bytearray( ''.join( chr( grid[ row ][ column ] ) for row in range( len( grid ) ) ) ) for column in range( len( grid[ 0 ] ) ) ]\n  \n  def grow( R, C, M ):\n      grid = [ bytearray( C*[ '*' ] ) for row in range( R ) ]\n      b = R*C - M\n      if C > R:\n          R, C, grid = C, R, flip( grid )\n          flipped = True\n      else:\n          flipped = False\n      if b < 2*C:\n          if b == 1:\n              grid[ 0 ][ 0 ] = 'c'\n          elif b == 3 and C >= 3:\n              grid[ 0 ][ : 3 ] = bytearray( '.c.' )\n          elif b % 2:\n              return\n          else:\n              grid[ 0 ][ : b//2 ] = bytearray( b//2*'.' )\n              grid[ 1 ][ : b//2 ] = bytearray( b//2*'.' )\n              grid[ 0 ][ 0 ] = 'c'\n      else:\n          r = 0\n          while b >= C:\n              grid[ r ] = bytearray( C*[ '.' ] )\n              b -= C\n              r += 1\n          if b:\n              if b >= 2:\n                  grid[ r ][ : b ] = b*'.'\n              elif C > 2 and r > 2:\n                  grid[ r - 1 ][ -1 ] = '*'\n                  grid[ r ][ : 2 ] = '..'\n              else:\n                  return\n          grid[ 0 ][ 0 ] = 'c'\n      return flip( grid ) if flipped else grid\n      \n  T = read_integer()\n  for t in range( T ):\n      print 'Case #%i:' % ( t + 1 )\n      R, C, M = read_integers()\n      grid = grow( R, C, M )\n      print '\n'.join( str( row ) for row in grid ) if grid else 'Impossible'\n ", "Adversarial Code": " \n  def read_line():\n      return sys.stdin.readline().rstrip( '\n' )\n  \n  def read_integer():\n      return int( read_line() )\n  \n  def read_integers():\n      return [ int( x ) for x in read_line().split() ]\n  \n  def flip( grid ):\n      return [ bytearray( ''.join( chr( grid[ __name__ ][ column ] ) for __name__ in range( len( grid ) ) ) ) for column in range( len( grid[ 0 ] ) ) ]\n  \n  def reveal( read_arr, C, M ):\n      grid = [ bytearray( C*[ '*' ] ) for __name__ in range( read_arr ) ]\n      row_index2 = read_arr*C - M\n      if C > read_arr:\n          read_arr, C, grid = C, read_arr, flip( grid )\n          flipped = True\n      else:\n          flipped = False\n      if row_index2 < 2*C:\n          if row_index2 == 1:\n              grid[ 0 ][ 0 ] = 'c'\n          elif row_index2 == 3 and C >= 3:\n              grid[ 0 ][ : 3 ] = bytearray( '.c.' )\n          elif row_index2 % 2:\n              return\n          else:\n              grid[ 0 ][ : row_index2//2 ] = bytearray( row_index2//2*'.' )\n              grid[ 1 ][ : row_index2//2 ] = bytearray( row_index2//2*'.' )\n              grid[ 0 ][ 0 ] = 'c'\n      else:\n          r = 0\n          while row_index2 >= C:\n              grid[ r ] = bytearray( C*[ '.' ] )\n              row_index2 -= C\n              r += 1\n          if row_index2:\n              if row_index2 >= 2:\n                  grid[ r ][ : row_index2 ] = row_index2*'.'\n              elif C > 2 and r > 2:\n                  grid[ r - 1 ][ -1 ] = '*'\n                  grid[ r ][ : 2 ] = '..'\n              else:\n                  return\n          grid[ 0 ][ 0 ] = 'c'\n      return flip( grid ) if flipped else grid\n      \n  printed_sol = read_integer()\n  for chosen in range( printed_sol ):\n      print 'Case #%i:' % ( chosen + 1 )\n      read_arr, C, M = read_integers()\n      grid = reveal( read_arr, C, M )\n      print '\n'.join( str( __name__ ) for __name__ in grid ) if grid else 'Impossible'\n ", "Program Length": 406, "Identifier Num": 17, "Replaced Identifiers": "grow:reveal,t:chosen,T:printed_sol,b:row_index2,row:__name__,R:read_arr,", "Query Times": 179, "Time Cost": 0.07344487110773722, "Type": "mhm"}
{"Index": 21, "Original Code": " \n  def read_line():\n      return sys.stdin.readline().rstrip( '\n' )\n  \n  def read_integer():\n      return int( read_line() )\n  \n  def read_integers():\n      return [ int( x ) for x in read_line().split() ]\n  \n  def read_string():\n      return read_line().strip()\n  \n  def read_strings():\n      return read_line().split()\n  \n  def input_string_stack():\n      data = []\n      for line in sys.stdin.readlines():\n          data.extend( line.split() )\n      data.reverse()\n      return data\n  \n  def input_integer_stack():\n      return [ int( x ) for x in read_string_stack() ]\n  \n  class memoized( object ):\n     def __init__( self, function ):\n        self.function = function\n        self.cache = {}\n     def __call__( self, *arguments ):\n        try:\n           return self.cache[ arguments ]\n        except KeyError:\n           value = self.function( *arguments )\n           self.cache[ arguments ] = value\n           return value\n  \n  T = read_integer()\n  for t in range( T ):\n      row = read_integer()\n      candidates = set( [ read_integers() for index in range( 4 ) ][ row - 1 ] )\n      row = read_integer()\n      candidates &= set( [ read_integers() for index in range( 4 ) ][ row - 1 ] )\n      print 'Case #%i:' % ( t + 1 ), candidates.pop() if len( candidates ) == 1 else 'Bad magician!' if len( candidates ) > 1 else 'Volunteer cheated!'\n ", "Adversarial Code": " \n  def zip():\n      return sys.stdin.readline().rstrip( '\n' )\n  \n  def badMagician():\n      return int( zip() )\n  \n  def input_line():\n      return [ int( x ) for x in zip().split() ]\n  \n  def solve_one_case():\n      return zip().strip()\n  \n  def boardHasZero():\n      return zip().split()\n  \n  def function():\n      data = []\n      for line in sys.stdin.readlines():\n          data.extend( line.split() )\n      data.reverse()\n      return data\n  \n  def input_integer_stack():\n      return [ int( x ) for x in read_string_stack() ]\n  \n  class memoized( object ):\n     def __init__( self, gridRows ):\n        self.gridRows = gridRows\n        self.lp = {}\n     def __call__( self, *Mine ):\n        try:\n           return self.lp[ Mine ]\n        except KeyError:\n           test_position = self.gridRows( *Mine )\n           self.lp[ Mine ] = test_position\n           return test_position\n  \n  T = badMagician()\n  for chosen_filename in range( T ):\n      x1 = badMagician()\n      secondRow = set( [ input_line() for grid2 in range( 4 ) ][ x1 - 1 ] )\n      x1 = badMagician()\n      secondRow &= set( [ input_line() for grid2 in range( 4 ) ][ x1 - 1 ] )\n      print 'Case #%i:' % ( chosen_filename + 1 ), secondRow.pop() if len( secondRow ) == 1 else 'Bad magician!' if len( secondRow ) > 1 else 'Volunteer cheated!'\n ", "Program Length": 297, "Identifier Num": 22, "Replaced Identifiers": "t:chosen_filename,cache:lp,candidates:secondRow,function:gridRows,read_line:zip,arguments:Mine,row:x1,read_strings:boardHasZero,value:test_position,index:grid2,read_string:solve_one_case,input_string_stack:function,read_integers:input_line,read_integer:badMagician,", "Query Times": 611, "Time Cost": 0.24005979299545288, "Type": "mhm"}
{"Index": 22, "Original Code": "def Trivial(R,C,char):\n      for i in range(R):\n          Ans = '';\n          for j in range(C):\n              if (i==j==0):\n                  Ans += 'c';\n              else:\n                  Ans += char;\n          print Ans;\n  \n  \n  def Draw1(R,C,Blank):\n      Ans = \"c\";\n      for i in range(Blank-1):\n          Ans += '.';\n      for i in range(R*C-Blank):\n          Ans += '*';\n      if (R == 1):\n          print Ans;        \n          return;\n      if (C == 1):\n          for i in range(len(Ans)):\n              print Ans[i];\n  \n  def Draw2(R,C,Blank):\n      if (Blank%2 != 0) or (Blank == 2):\n          print \"Impossible\";\n          return;\n      Row1 = '.'*(Blank/2) + '*'*(Mine/2);\n      Row0 = 'c' + Row1[1:];\n      if R==2:\n          print Row0;\n          print Row1;\n      else:\n          for i in range(len(Row0)):\n              print Row0[i]+Row1[i];\n      return;\n  \n  \n  def Generate(R, C, Blank):\n      TODO = Blank;\n      Spaces = [0]*R;\n      if TODO <= 2*C:\n          if TODO%2 == 0:\n              Spaces[0] = TODO/2;\n              Spaces[1] = TODO-Spaces[0];\n          else:\n              if (TODO == 7):\n                  Spaces[0] = 3;\n                  Spaces[1] = 2;\n                  Spaces[2] = 2;\n              else:\n                  Spaces[0] = (TODO-3)/2;\n                  Spaces[1] = (TODO-3)/2;\n                  Spaces[2] = 3;\n      else:\n          row = 0;\n          if (TODO >= 2*C+2):\n              Spaces[0] = C;\n              Spaces[1] = C;\n              TODO -= 2*C;\n              row = 2;\n              \n          while TODO > C+1:\n              if (TODO == 2*C+1) and (C != 3):\n                  Spaces[row] = C-1;\n                  Spaces[row+1] = C-1;\n                  Spaces[row+2] = 3;\n                  TODO = 0;\n              else:\n                  Spaces[row] = C;\n                  TODO -= C;\n                  row += 1;\n          if (TODO == C+1):\n              Spaces[row] += C-1;\n              Spaces[row+1] = 2;\n              TODO = 0;\n          Spaces[row] += TODO;\n  \n      for r in range(R):\n          Ans = '.'*Spaces[r] + '*'*(C-Spaces[r]);\n          if r == 0:\n              Ans = 'c'+Ans[1:];\n          print Ans;\n  \n  \n  def Solve(R, C, M):\n      Blank = R*C-M;\n      if Blank == 0:\n          print \"Impossible\";\n          return;\n  \n      if (Blank == 1):\n          Trivial(R,C,'*');\n          return\n      if (Blank == R*C):\n          Trivial(R,C,'.');\n          return\n  \n      if (R == 1) or (C == 1):\n            Draw1(R,C,Blank);\n            return\n  \n      if (R-2)*(C-2) == 0:\n          Draw2(R,C,Blank);\n          return\n  \n      if Blank in [2,3,5,7]:\n          print \"Impossible\";\n          return;\n      \n      if (R >= 3) and (C >= 3):\n          Generate(R, C, Blank);\n  \n      return;\n  \n  \n  T = int(raw_input());\n  for q in range(T):\n      [Row,Col,Mine] = map(int, raw_input().split());\n  \n      Blanks = Row*Col - Mine;\n      \n      print \"Case #%d:\" % (q+1)\n      Solve(Row, Col, Mine);\n      \n          \n ", "Adversarial Code": "def Trivial(R,C,char):\n      for i in range(R):\n          Ans = '';\n          for j in range(C):\n              if (i==j==0):\n                  Ans += 'c';\n              else:\n                  Ans += char;\n          print Ans;\n  \n  \n  def Draw1(R,C,Blank):\n      Ans = \"c\";\n      for i in range(Blank-1):\n          Ans += '.';\n      for i in range(R*C-Blank):\n          Ans += '*';\n      if (R == 1):\n          print Ans;        \n          return;\n      if (C == 1):\n          for i in range(len(Ans)):\n              print Ans[i];\n  \n  def Draw2(R,C,Blank):\n      if (Blank%2 != 0) or (Blank == 2):\n          print \"Impossible\";\n          return;\n      Row1 = '.'*(Blank/2) + '*'*(Mine/2);\n      Row0 = 'c' + Row1[1:];\n      if R==2:\n          print Row0;\n          print Row1;\n      else:\n          for i in range(len(Row0)):\n              print Row0[i]+Row1[i];\n      return;\n  \n  \n  def INPUT(R, C, Blank):\n      TODO = Blank;\n      Spaces = [0]*R;\n      if TODO <= 2*C:\n          if TODO%2 == 0:\n              Spaces[0] = TODO/2;\n              Spaces[1] = TODO-Spaces[0];\n          else:\n              if (TODO == 7):\n                  Spaces[0] = 3;\n                  Spaces[1] = 2;\n                  Spaces[2] = 2;\n              else:\n                  Spaces[0] = (TODO-3)/2;\n                  Spaces[1] = (TODO-3)/2;\n                  Spaces[2] = 3;\n      else:\n          row = 0;\n          if (TODO >= 2*C+2):\n              Spaces[0] = C;\n              Spaces[1] = C;\n              TODO -= 2*C;\n              row = 2;\n              \n          while TODO > C+1:\n              if (TODO == 2*C+1) and (C != 3):\n                  Spaces[row] = C-1;\n                  Spaces[row+1] = C-1;\n                  Spaces[row+2] = 3;\n                  TODO = 0;\n              else:\n                  Spaces[row] = C;\n                  TODO -= C;\n                  row += 1;\n          if (TODO == C+1):\n              Spaces[row] += C-1;\n              Spaces[row+1] = 2;\n              TODO = 0;\n          Spaces[row] += TODO;\n  \n      for r in range(R):\n          Ans = '.'*Spaces[r] + '*'*(C-Spaces[r]);\n          if r == 0:\n              Ans = 'c'+Ans[1:];\n          print Ans;\n  \n  \n  def Solve(R, C, M):\n      Blank = R*C-M;\n      if Blank == 0:\n          print \"Impossible\";\n          return;\n  \n      if (Blank == 1):\n          Trivial(R,C,'*');\n          return\n      if (Blank == R*C):\n          Trivial(R,C,'.');\n          return\n  \n      if (R == 1) or (C == 1):\n            Draw1(R,C,Blank);\n            return\n  \n      if (R-2)*(C-2) == 0:\n          Draw2(R,C,Blank);\n          return\n  \n      if Blank in [2,3,5,7]:\n          print \"Impossible\";\n          return;\n      \n      if (R >= 3) and (C >= 3):\n          INPUT(R, C, Blank);\n  \n      return;\n  \n  \n  T = int(raw_input());\n  for q in range(T):\n      [Row,Col,Mine] = map(int, raw_input().split());\n  \n      Blanks = Row*Col - Mine;\n      \n      print \"Case #%d:\" % (q+1)\n      Solve(Row, Col, Mine);\n      \n          \n ", "Program Length": 765, "Identifier Num": 17, "Replaced Identifiers": "Generate:INPUT,", "Query Times": 30, "Time Cost": 0.016628905137379964, "Type": "mhm"}
{"Index": 23, "Original Code": "T = int(raw_input());\n  for q in range(T):\n      R1 = int(raw_input());\n      Data1 = [];\n      for i in range(4):\n          Data1.append( map(int, raw_input().split()) );\n          \n      R2 = int(raw_input());\n      Data2 = [];\n      for i in range(4):\n          Data2.append( map(int, raw_input().split()) );\n  \n      Ans = [];\n      for entry in Data1[R1-1]:\n          if entry in Data2[R2-1]:\n              Ans.append(entry);\n  \n      print \"Case #%d:\" % (q+1),;\n  \n      if len(Ans) == 0:\n          print \"Volunteer cheated!\";\n      if len(Ans) == 1:\n          print Ans[0];\n      if len(Ans) > 1:\n          print \"Bad magician!\"\n          \n ", "Adversarial Code": "T = int(raw_input());\n  for myCases in range(T):\n      R1 = int(raw_input());\n      sol = [];\n      for answers in range(4):\n          sol.append( map(int, raw_input().split()) );\n          \n      R2 = int(raw_input());\n      getFloorRoots = [];\n      for answers in range(4):\n          getFloorRoots.append( map(int, raw_input().split()) );\n  \n      Ans = [];\n      for entry in sol[R1-1]:\n          if entry in getFloorRoots[R2-1]:\n              Ans.append(entry);\n  \n      print \"Case #%d:\" % (myCases+1),;\n  \n      if len(Ans) == 0:\n          print \"Volunteer cheated!\";\n      if len(Ans) == 1:\n          print Ans[0];\n      if len(Ans) > 1:\n          print \"Bad magician!\"\n          \n ", "Program Length": 174, "Identifier Num": 9, "Replaced Identifiers": "Data2:getFloorRoots,Data1:sol,i:answers,q:myCases,", "Query Times": 119, "Time Cost": 0.04364972511927287, "Type": "mhm"}
{"Index": 25, "Original Code": null, "Adversarial Code": null, "Program Length": 197, "Identifier Num": 13, "Replaced Identifiers": null, "Query Times": 2924, "Time Cost": 1.1112963239351907, "Type": "0"}
{"Index": 26, "Original Code": " \n  def solve(W, H, M):\n    board = [['*' for x in xrange(H)] for x in xrange(W)]\n    board[0][0] = 'c'\n    \n    S = [((H*W)-1, board, 0, 0, set())]\n    H -= 1\n    W -= 1\n    while len(S) > 0:\n      state = S.pop()\n      mines = state[0]\n      board = deepcopy(state[1])\n      x = state[2]\n      y = state[3]\n      visited = deepcopy(state[4])\n      visited.add((x, y))\n      \n      if mines == M:\n        s = ''\n        for row in board:\n          s += ''.join(row)\n          s += '\n'\n        return s\n      \n      elif mines > M:\n        if x > 0 and board[x-1][y] == '*':\n          board[x-1][y] = '.'\n          mines -= 1\n        \n        if x < W and board[x+1][y] == '*':\n          board[x+1][y] = '.'\n          mines -= 1\n        \n        if y > 0 and board[x][y-1] == '*':\n          board[x][y-1] = '.'\n          mines -= 1\n        \n        if y < H and board[x][y+1] == '*':\n          board[x][y+1] = '.'\n          mines -= 1\n        \n        if x > 0 and y > 0 and board[x-1][y-1] == '*':\n          board[x-1][y-1] = '.'\n          mines -= 1\n        \n        if x > 0 and y < H and board[x-1][y+1] == '*':\n          board[x-1][y+1] = '.'\n          mines -= 1\n        \n        if x < W and y > 0 and board[x+1][y-1] == '*':\n          board[x+1][y-1] = '.'\n          mines -= 1\n        \n        if x < W and y < H and board[x+1][y+1] == '*':\n          board[x+1][y+1] = '.'\n          mines -= 1\n        \n        if x > 0 and not (x-1, y) in visited:\n          S.append((mines, board, x-1, y, visited))\n        \n        if x < W and not (x+1, y) in visited:\n          S.append((mines, board, x+1, y, visited))\n        \n        if y > 0 and not (x, y-1) in visited:\n          S.append((mines, board, x, y-1, visited))\n        \n        if y < H and not (x, y+1) in visited:\n          S.append((mines, board, x, y+1, visited))\n        \n        if x > 0 and y > 0 and not (x-1, y-1) in visited:\n          S.append((mines, board, x-1, y-1, visited))\n        \n        if x > 0 and y < H and not (x-1, y+1) in visited:\n          S.append((mines, board, x-1, y+1, visited))\n        \n        if x < W and y > 0 and not (x+1, y-1) in visited:\n          S.append((mines, board, x+1, y-1, visited))\n        \n        if x < W and y < H and not (x+1, y+1) in visited:\n          S.append((mines, board, x+1, y+1, visited))\n    return 'Impossible'\n  \n  T = int(raw_input())\n  for t in range(T):\n    W, H, M = map(int, raw_input().split())\n    print 'Case #%i:\n%s' % (t+1, solve(W, H, M).strip())\n ", "Adversarial Code": " \n  def solve(W, H, M):\n    board = [['*' for x in xrange(H)] for x in xrange(W)]\n    board[0][0] = 'c'\n    \n    S = [((H*W)-1, board, 0, 0, set())]\n    H -= 1\n    W -= 1\n    while len(S) > 0:\n      state = S.pop()\n      mines = state[0]\n      board = deepcopy(state[1])\n      x = state[2]\n      FILE_NAME_BASE = state[3]\n      visited = deepcopy(state[4])\n      visited.add((x, FILE_NAME_BASE))\n      \n      if mines == M:\n        s = ''\n        for row in board:\n          s += ''.join(row)\n          s += '\n'\n        return s\n      \n      elif mines > M:\n        if x > 0 and board[x-1][FILE_NAME_BASE] == '*':\n          board[x-1][FILE_NAME_BASE] = '.'\n          mines -= 1\n        \n        if x < W and board[x+1][FILE_NAME_BASE] == '*':\n          board[x+1][FILE_NAME_BASE] = '.'\n          mines -= 1\n        \n        if FILE_NAME_BASE > 0 and board[x][FILE_NAME_BASE-1] == '*':\n          board[x][FILE_NAME_BASE-1] = '.'\n          mines -= 1\n        \n        if FILE_NAME_BASE < H and board[x][FILE_NAME_BASE+1] == '*':\n          board[x][FILE_NAME_BASE+1] = '.'\n          mines -= 1\n        \n        if x > 0 and FILE_NAME_BASE > 0 and board[x-1][FILE_NAME_BASE-1] == '*':\n          board[x-1][FILE_NAME_BASE-1] = '.'\n          mines -= 1\n        \n        if x > 0 and FILE_NAME_BASE < H and board[x-1][FILE_NAME_BASE+1] == '*':\n          board[x-1][FILE_NAME_BASE+1] = '.'\n          mines -= 1\n        \n        if x < W and FILE_NAME_BASE > 0 and board[x+1][FILE_NAME_BASE-1] == '*':\n          board[x+1][FILE_NAME_BASE-1] = '.'\n          mines -= 1\n        \n        if x < W and FILE_NAME_BASE < H and board[x+1][FILE_NAME_BASE+1] == '*':\n          board[x+1][FILE_NAME_BASE+1] = '.'\n          mines -= 1\n        \n        if x > 0 and not (x-1, FILE_NAME_BASE) in visited:\n          S.append((mines, board, x-1, FILE_NAME_BASE, visited))\n        \n        if x < W and not (x+1, FILE_NAME_BASE) in visited:\n          S.append((mines, board, x+1, FILE_NAME_BASE, visited))\n        \n        if FILE_NAME_BASE > 0 and not (x, FILE_NAME_BASE-1) in visited:\n          S.append((mines, board, x, FILE_NAME_BASE-1, visited))\n        \n        if FILE_NAME_BASE < H and not (x, FILE_NAME_BASE+1) in visited:\n          S.append((mines, board, x, FILE_NAME_BASE+1, visited))\n        \n        if x > 0 and FILE_NAME_BASE > 0 and not (x-1, FILE_NAME_BASE-1) in visited:\n          S.append((mines, board, x-1, FILE_NAME_BASE-1, visited))\n        \n        if x > 0 and FILE_NAME_BASE < H and not (x-1, FILE_NAME_BASE+1) in visited:\n          S.append((mines, board, x-1, FILE_NAME_BASE+1, visited))\n        \n        if x < W and FILE_NAME_BASE > 0 and not (x+1, FILE_NAME_BASE-1) in visited:\n          S.append((mines, board, x+1, FILE_NAME_BASE-1, visited))\n        \n        if x < W and FILE_NAME_BASE < H and not (x+1, FILE_NAME_BASE+1) in visited:\n          S.append((mines, board, x+1, FILE_NAME_BASE+1, visited))\n    return 'Impossible'\n  \n  T = int(raw_input())\n  for t in range(T):\n    W, H, M = map(int, raw_input().split())\n    print 'Case #%i:\n%s' % (t+1, solve(W, H, M).strip())\n ", "Program Length": 806, "Identifier Num": 13, "Replaced Identifiers": "y:FILE_NAME_BASE,", "Query Times": 31, "Time Cost": 0.01621001958847046, "Type": "mhm"}
{"Index": 27, "Original Code": "T = int(raw_input())\n  for i in range(T):\n    index = int(raw_input())\n    X = []\n    for j in range(4):\n      X.append(map(int, raw_input().split()))\n    x1 = X[index-1]\n    index = int(raw_input())\n    X = []\n    for j in range(4):\n      X.append(map(int, raw_input().split()))\n    x2 = X[index-1]\n    ans = set(x1).intersection(set(x2))\n    if len(ans) == 0:\n      print 'Case #%i: Volunteer cheated!' % (i+1)\n    elif len(ans) == 1:\n      print 'Case #%i: %i' % (i+1, ans.pop())\n    else:\n      print 'Case #%i: Bad magician!' % (i+1)\n ", "Adversarial Code": "pending = int(raw_input())\n  for numSpaces in range(pending):\n    outf = int(raw_input())\n    read_set = []\n    for __iter__ in range(4):\n      read_set.append(map(int, raw_input().split()))\n    dots = read_set[outf-1]\n    outf = int(raw_input())\n    read_set = []\n    for __iter__ in range(4):\n      read_set.append(map(int, raw_input().split()))\n    numCases = read_set[outf-1]\n    numSpaces = set(dots).intersection(set(numCases))\n    if len(numSpaces) == 0:\n      print 'Case #%i: Volunteer cheated!' % (numSpaces+1)\n    elif len(numSpaces) == 1:\n      print 'Case #%i: %i' % (numSpaces+1, numSpaces.pop())\n    else:\n      print 'Case #%i: Bad magician!' % (numSpaces+1)\n ", "Program Length": 168, "Identifier Num": 8, "Replaced Identifiers": "ans:numSpaces,i:numSpaces,x1:dots,T:pending,index:outf,X:read_set,x2:numCases,j:__iter__,", "Query Times": 338, "Time Cost": 0.1258941133817037, "Type": "mhm"}
{"Index": 29, "Original Code": "def solve(c1, g1, c2, g2):\n      row_1 = g1[c1-1]\n      row_2 = g2[c2-1]\n      inter = set(row_1) & set(row_2)\n      if len(inter) == 0:\n          return \"Volunteer cheated!\"\n      if len(inter) > 1:\n          return \"Bad magician!\"\n      return str(inter.pop())\n  \n  if __name__ == \"__main__\":\n      T = int(raw_input())\n      for i in range(1,T+1):\n          c1 = int(raw_input())\n          g1 = []\n          for j in range(4):\n              g1.append(map(int, raw_input().split()))\n          c2 = int(raw_input())\n          g2 = []\n          for j in range(4):\n              g2.append(map(int, raw_input().split()))\n          print \"Case #%d: %s\" % (i, solve(c1,g1,c2,g2)) \n          \n      \n ", "Adversarial Code": "def runmain(tCase, g1, c2, g2):\n      cont = g1[tCase-1]\n      row_2 = g2[c2-1]\n      inter = set(cont) & set(row_2)\n      if len(inter) == 0:\n          return \"Volunteer cheated!\"\n      if len(inter) > 1:\n          return \"Bad magician!\"\n      return str(inter.pop())\n  \n  if __name__ == \"__main__\":\n      T = int(raw_input())\n      for i in range(1,T+1):\n          tCase = int(raw_input())\n          g1 = []\n          for j in range(4):\n              g1.append(map(int, raw_input().split()))\n          c2 = int(raw_input())\n          g2 = []\n          for j in range(4):\n              g2.append(map(int, raw_input().split()))\n          print \"Case #%d: %s\" % (i, runmain(tCase,g1,c2,g2)) \n          \n      \n ", "Program Length": 184, "Identifier Num": 11, "Replaced Identifiers": "c1:tCase,row_1:cont,solve:runmain,", "Query Times": 121, "Time Cost": 0.04502791166305542, "Type": "mhm"}
{"Index": 30, "Original Code": " \n  \n  tCase = int(sys.stdin.readline())\n  \n  \n  def map(R, C, Bombs):\n  \tm = [[\".\" for x in xrange(C)] for x in xrange(R)]\n  \tprint Bombs\n  \tm[R-1][C-1] = 'c'\n  \tlastSkip = False\n  \tfor i in xrange(R):\n  \t\tfor j in xrange(C):\n  \t\t\tif Bombs == 0:\n  \t\t\t\tbreak\n  \t\t\t\n  \t\t\tif lastSkip:\n  \t\t\t\tm[i][j] = 'f'\n  \t\t\t\tcontinue\n  \t\t\t\n  \t\t\tif R - i == 2 or C - j == 2:\n  \t\t\t\tif Bombs == 1:\n  \t\t\t\t\tm[i][j] = 'f'\n  \t\t\t\t\tlastSkip = True\n  \t\t\t\t\tcontinue\n  \t\t\t\n  \t\t\t\t\n  \t\t\tm[i][j] = '*'\n  \t\t\tBombs -= 1\n  \t\t\tlastSkip = False\n  \t\tlastSkip = False\n  \t\t\t\t\n  \t\n  \t\n  \tfor line in m:\n  \t\tfor c in line:\n  \t\t\tprint c,\n  \t\tprint\n  \t\t\n  \t\t\n  def imprimir(m):\n  \tfor line in m:\n  \t\tfor c in line:\n  \t\t\tprint c,\n  \t\tprint\n  \t\t\n  def map2(R, C, Bombs):\n  \tm = [[\".\" for x in xrange(C)] for x in xrange(R)]\n  \tm[R-1][C-1] = 'c'\n  \tlastSkip = False\n  \t\n  \tii = 0\n  \tjj = 0\n  \twhile Bombs > 0:\n  \t\tfor j in xrange(jj, C):\n  \t\t\tif Bombs >= (C - j) or Bombs <= (C - j - 2) and Bombs > 0:\n  \t\t\t\tm[ii][j] = '*'\n  \t\t\t\tBombs -= 1\n  \t\t\telse:\n  \t\t\t\tcontinue\n  \t\t\n  \t\t\n  \t\tfor i in xrange(ii+1, R):\n  \t\t\tif Bombs >= (R - i) or Bombs <= (R - i - 2) and Bombs > 0:\n  \t\t\t\tm[i][jj] = '*'\n  \t\t\t\tBombs -= 1\n  \t\t\telse:\n  \t\t\t\tif Bombs > 0:\n  \t\t\t\t\tprint \"Impossible\"\n  \t\t\t\t\treturn\n  \t\t\t\tcontinue\n  \t\tjj += 1\n  \t\tii += 1\n  \timprimir(m)\n  \t\n  \t\t\t\t\n  \t\n  \t\n  \n  \t\t\n  def main(R, C, M):\n  \tvazios = R * C - M\n  \n  \tif R == 1 or C == 1 or vazios == 1 or vazios >= 4:\n  \t\tmap2(R, C, M)\n  \telse:\n  \t\tprint \"Impossible\"\n  \n  \treturn \"\"\n  \t\t\n   \n  if __name__ == '__main__':\n  \tfor i in xrange(tCase):\t\n  \t\t\n  \t\tR, C, M = [int(x) for x in sys.stdin.readline().split(' ')]\n  \t\tprint \"Case #%d:\" % (i + 1)\n  \t\tmain(R, C, M)\n ", "Adversarial Code": " \n  \n  tCase = int(sys.stdin.readline())\n  \n  \n  def sweep(r_file, order, lastSkip):\n  \t_t = [[\".\" for x in xrange(order)] for x in xrange(r_file)]\n  \tprint lastSkip\n  \t_t[r_file-1][order-1] = 'c'\n  \tlastSkip = False\n  \tfor diag in xrange(r_file):\n  \t\tfor card in xrange(order):\n  \t\t\tif lastSkip == 0:\n  \t\t\t\tbreak\n  \t\t\t\n  \t\t\tif lastSkip:\n  \t\t\t\t_t[diag][card] = 'f'\n  \t\t\t\tcontinue\n  \t\t\t\n  \t\t\tif r_file - diag == 2 or order - card == 2:\n  \t\t\t\tif lastSkip == 1:\n  \t\t\t\t\t_t[diag][card] = 'f'\n  \t\t\t\t\tlastSkip = True\n  \t\t\t\t\tcontinue\n  \t\t\t\n  \t\t\t\t\n  \t\t\t_t[diag][card] = '*'\n  \t\t\tlastSkip -= 1\n  \t\t\tlastSkip = False\n  \t\tlastSkip = False\n  \t\t\t\t\n  \t\n  \t\n  \tfor i in _t:\n  \t\tfor original_board in i:\n  \t\t\tprint original_board,\n  \t\tprint\n  \t\t\n  \t\t\n  def reader(_t):\n  \tfor i in _t:\n  \t\tfor original_board in i:\n  \t\t\tprint original_board,\n  \t\tprint\n  \t\t\n  def map2(r_file, order, lastSkip):\n  \t_t = [[\".\" for x in xrange(order)] for x in xrange(r_file)]\n  \t_t[r_file-1][order-1] = 'c'\n  \tlastSkip = False\n  \t\n  \tno_mine_row = 0\n  \tjj = 0\n  \twhile lastSkip > 0:\n  \t\tfor card in xrange(jj, order):\n  \t\t\tif lastSkip >= (order - card) or lastSkip <= (order - card - 2) and lastSkip > 0:\n  \t\t\t\t_t[no_mine_row][card] = '*'\n  \t\t\t\tlastSkip -= 1\n  \t\t\telse:\n  \t\t\t\tcontinue\n  \t\t\n  \t\t\n  \t\tfor diag in xrange(no_mine_row+1, r_file):\n  \t\t\tif lastSkip >= (r_file - diag) or lastSkip <= (r_file - diag - 2) and lastSkip > 0:\n  \t\t\t\t_t[diag][jj] = '*'\n  \t\t\t\tlastSkip -= 1\n  \t\t\telse:\n  \t\t\t\tif lastSkip > 0:\n  \t\t\t\t\tprint \"Impossible\"\n  \t\t\t\t\treturn\n  \t\t\t\tcontinue\n  \t\tjj += 1\n  \t\tno_mine_row += 1\n  \treader(_t)\n  \t\n  \t\t\t\t\n  \t\n  \t\n  \n  \t\t\n  def main(r_file, order, M):\n  \tvazios = r_file * order - M\n  \n  \tif r_file == 1 or order == 1 or vazios == 1 or vazios >= 4:\n  \t\tmap2(r_file, order, M)\n  \telse:\n  \t\tprint \"Impossible\"\n  \n  \treturn \"\"\n  \t\t\n   \n  if __name__ == '__main__':\n  \tfor diag in xrange(tCase):\t\n  \t\t\n  \t\tr_file, order, M = [int(x) for x in sys.stdin.readline().split(' ')]\n  \t\tprint \"Case #%d:\" % (diag + 1)\n  \t\tmain(r_file, order, M)\n ", "Program Length": 457, "Identifier Num": 19, "Replaced Identifiers": "ii:no_mine_row,i:diag,C:order,j:card,m:_t,line:i,Bombs:lastSkip,imprimir:reader,c:original_board,map:sweep,R:r_file,", "Query Times": 523, "Time Cost": 0.21524946689605712, "Type": "mhm"}
{"Index": 31, "Original Code": " \n  \n  \n  class Test(unittest.TestCase):\n  \tdef test_1(self):\n  \t\tself.assertEqual(main(5, 2, 2, [2,1]), 12)\n  \tdef test_2(self):\n  \t\tself.assertEqual(main(5,2,2,[1,2]), 12)\n  \tdef test_3(self):\n  \t\tself.assertEqual(main(3,3,4,[4,1,3,5]), 39)\n  \tdef test_4(self):\n  \t\tself.assertEqual(main(5,2,4,[5, 1, 1, 5]), 51)\n  \n  \n  tCase = int(sys.stdin.readline())\n  \n  def main(A, B, AList, BList):\n  \tresp = 0\n  \tA = A - 1\n  \tB = B - 1\n  \tAlist = AList[A*4:A*4+4]\n  \tBList = BList[B*4:B*4+4]\n  \tcont = 0\n  \tfor aa in Alist:\n  \t\tif aa in BList:\n  \t\t\tresp = aa\n  \t\t\tcont += 1\n  \t\t\n  \tif cont == 1:\n  \t\treturn resp\n  \telif cont == 0:\n  \t\treturn \"Volunteer cheated!\"\n  \telse:\n  \t\treturn \"Bad magician!\"\n  \t\t\n   \n  if __name__ == '__main__':\n  \tfor i in xrange(tCase):\t\n  \t\t\n  \t\tA = [int(x) for x in sys.stdin.readline().split(' ')][0]\n  \t\tNList = [int(x) for x in sys.stdin.readline().split(' ')]\n  \t\tNList += [int(x) for x in sys.stdin.readline().split(' ')]\n  \t\tNList += [int(x) for x in sys.stdin.readline().split(' ')]\n  \t\tNList += [int(x) for x in sys.stdin.readline().split(' ')]\n  \t\tB = [int(x) for x in sys.stdin.readline().split(' ')][0]\n  \t\tBList = [int(x) for x in sys.stdin.readline().split(' ')]\n  \t\tBList += [int(x) for x in sys.stdin.readline().split(' ')]\n  \t\tBList += [int(x) for x in sys.stdin.readline().split(' ')]\n  \t\tBList += [int(x) for x in sys.stdin.readline().split(' ')]\n  \t\tprint \"Case #%d: %s\" % (i + 1, main(A, B, NList, BList))\n ", "Adversarial Code": " \n  \n  \n  class Test(unittest.TestCase):\n  \tdef test_1(Sm):\n  \t\tSm.assertEqual(memoize(5, 2, 2, [2,1]), 12)\n  \tdef test_2(Sm):\n  \t\tSm.assertEqual(memoize(5,2,2,[1,2]), 12)\n  \tdef test_3(Sm):\n  \t\tSm.assertEqual(memoize(3,3,4,[4,1,3,5]), 39)\n  \tdef Solve(Sm):\n  \t\tSm.assertEqual(memoize(5,2,4,[5, 1, 1, 5]), 51)\n  \n  \n  num_cells = int(sys.stdin.readline())\n  \n  def memoize(A, maxGridCols, AList, nF):\n  \tMOVES = 0\n  \tA = A - 1\n  \tmaxGridCols = maxGridCols - 1\n  \tAlist = AList[A*4:A*4+4]\n  \tnF = nF[maxGridCols*4:maxGridCols*4+4]\n  \tSearchBoard = 0\n  \tfor aa in Alist:\n  \t\tif aa in nF:\n  \t\t\tMOVES = aa\n  \t\t\tSearchBoard += 1\n  \t\t\n  \tif SearchBoard == 1:\n  \t\treturn MOVES\n  \telif SearchBoard == 0:\n  \t\treturn \"Volunteer cheated!\"\n  \telse:\n  \t\treturn \"Bad magician!\"\n  \t\t\n   \n  if __name__ == '__main__':\n  \tfor remainder in xrange(num_cells):\t\n  \t\t\n  \t\tA = [int(valid1) for valid1 in sys.stdin.readline().split(' ')][0]\n  \t\tNList = [int(valid1) for valid1 in sys.stdin.readline().split(' ')]\n  \t\tNList += [int(valid1) for valid1 in sys.stdin.readline().split(' ')]\n  \t\tNList += [int(valid1) for valid1 in sys.stdin.readline().split(' ')]\n  \t\tNList += [int(valid1) for valid1 in sys.stdin.readline().split(' ')]\n  \t\tmaxGridCols = [int(valid1) for valid1 in sys.stdin.readline().split(' ')][0]\n  \t\tnF = [int(valid1) for valid1 in sys.stdin.readline().split(' ')]\n  \t\tnF += [int(valid1) for valid1 in sys.stdin.readline().split(' ')]\n  \t\tnF += [int(valid1) for valid1 in sys.stdin.readline().split(' ')]\n  \t\tnF += [int(valid1) for valid1 in sys.stdin.readline().split(' ')]\n  \t\tprint \"Case #%d: %s\" % (remainder + 1, memoize(A, maxGridCols, NList, nF))\n ", "Program Length": 494, "Identifier Num": 18, "Replaced Identifiers": "main:memoize,i:remainder,cont:SearchBoard,B:maxGridCols,resp:MOVES,self:Sm,x:valid1,test_4:Solve,BList:nF,tCase:num_cells,", "Query Times": 354, "Time Cost": 0.147846253712972, "Type": "mhm"}
{"Index": 32, "Original Code": " \n  def debug(v):\n      pass#print(v)\n  \n  def read(f):\n      t = tuple(int(v) for v in f.readline().split())\n      debug(t)\n      return t\n  \n  def readf(f):\n      t = tuple(float(v) for v in f.readline().split())\n      debug(t)\n      return t\n  \n  def answer(f, X, ans):\n      out = \"Case #{}:\n{}\".format(X, ans)\n      f.write(out)\n      f.write(\"\n\")\n      print(out)\n  \n  def answer_cells(f, X, cells):\n      out = \"Case #{}:\".format(X)\n      f.write(out)\n      f.write(\"\n\")\n      print(out)\n      for row in cells:\n          out = \"\".join(row)\n          f.write(out)\n          f.write(\"\n\")\n          print(out)\n  \n  def main(inf, outf):\n      T, = read(inf)\n      for casenmbr in range(1, T + 1):\n          R, C, M = read(inf)\n  \n          if M == 0:\n              cells = [['.'] * C for i in range(R)]\n              cells[0][0] = 'c'\n              answer_cells(outf, casenmbr, cells)\n              continue\n  \n          empty = R * C - M\n  \n          if empty == 1:\n              cells = [['*'] * C for i in range(R)]\n              cells[0][0] = 'c'\n              answer_cells(outf, casenmbr, cells)\n              continue\n  \n          if R == 1 or C == 1:\n              cells = [['.'] * C for i in range(R)]\n              m = 0\n              for r in range(R):\n                  for c in range(C):\n                      cells[r][c] = '*'\n                      m += 1\n                      if m == M:\n                          break\n                  else:\n                      continue\n                  break\n              cells[-1][-1] = 'c'\n              answer_cells(outf, casenmbr, cells)\n              continue\n  \n          if empty in (2, 3, 5, 7):\n              answer(outf, casenmbr, \"Impossible\")\n              continue\n  \n          if (R == 2 or C == 2) and empty % 2:\n              answer(outf, casenmbr, \"Impossible\")\n              continue\n  \n          cells = [['*'] * C for i in range(R)]\n  \n  \n          cells[0][0] = 'c'\n          empty -= 1\n          cc = 1\n          rr = 1\n          while empty > 0:\n              if cc < C:\n                  for r in range(rr):\n                      if empty == 2 and r == rr - 1:\n                          break\n                      cells[r][cc] = '.'\n                      empty -= 1\n                      if empty == 0:\n                          break\n                  cc += 1\n              if rr < R and empty > 0:\n                  for c in range(cc):\n                      if empty == 2 and c == cc - 1:\n                          break\n                      cells[rr][c] = '.'\n                      empty -= 1\n                      if empty == 0:\n                          break\n                  rr += 1            \n  \n          answer_cells(outf, casenmbr, cells)\n  \n  \n  if __name__==\"__main__\":\n      infname = sys.argv[1]\n      outfname = os.path.splitext(infname)[0] + \".out\"\n      with open(infname, \"r\") as inf:\n          with open(outfname, \"w\") as outf:\n              main(inf, outf)\n ", "Adversarial Code": " \n  def index(v):\n      pass#print(v)\n  \n  def read(f):\n      t = tuple(int(v) for v in f.readline().split())\n      index(t)\n      return t\n  \n  def readf(f):\n      t = tuple(float(v) for v in f.readline().split())\n      index(t)\n      return t\n  \n  def answer(f, X, ans):\n      out = \"Case #{}:\n{}\".format(X, ans)\n      f.write(out)\n      f.write(\"\n\")\n      print(out)\n  \n  def nums(f, X, cells):\n      out = \"Case #{}:\".format(X)\n      f.write(out)\n      f.write(\"\n\")\n      print(out)\n      for row in cells:\n          out = \"\".join(row)\n          f.write(out)\n          f.write(\"\n\")\n          print(out)\n  \n  def main(inf, arr1):\n      T, = read(inf)\n      for casenmbr in range(1, T + 1):\n          R, C, M = read(inf)\n  \n          if M == 0:\n              cells = [['.'] * C for i in range(R)]\n              cells[0][0] = 'c'\n              nums(arr1, casenmbr, cells)\n              continue\n  \n          empty = R * C - M\n  \n          if empty == 1:\n              cells = [['*'] * C for i in range(R)]\n              cells[0][0] = 'c'\n              nums(arr1, casenmbr, cells)\n              continue\n  \n          if R == 1 or C == 1:\n              cells = [['.'] * C for i in range(R)]\n              m = 0\n              for r2 in range(R):\n                  for c in range(C):\n                      cells[r2][c] = '*'\n                      m += 1\n                      if m == M:\n                          break\n                  else:\n                      continue\n                  break\n              cells[-1][-1] = 'c'\n              nums(arr1, casenmbr, cells)\n              continue\n  \n          if empty in (2, 3, 5, 7):\n              answer(arr1, casenmbr, \"Impossible\")\n              continue\n  \n          if (R == 2 or C == 2) and empty % 2:\n              answer(arr1, casenmbr, \"Impossible\")\n              continue\n  \n          cells = [['*'] * C for i in range(R)]\n  \n  \n          cells[0][0] = 'c'\n          empty -= 1\n          cc = 1\n          rr = 1\n          while empty > 0:\n              if cc < C:\n                  for r2 in range(rr):\n                      if empty == 2 and r2 == rr - 1:\n                          break\n                      cells[r2][cc] = '.'\n                      empty -= 1\n                      if empty == 0:\n                          break\n                  cc += 1\n              if rr < R and empty > 0:\n                  for c in range(cc):\n                      if empty == 2 and c == cc - 1:\n                          break\n                      cells[rr][c] = '.'\n                      empty -= 1\n                      if empty == 0:\n                          break\n                  rr += 1            \n  \n          nums(arr1, casenmbr, cells)\n  \n  \n  if __name__==\"__main__\":\n      infname = sys.argv[1]\n      outfname = os.path.splitext(infname)[0] + \".out\"\n      with open(infname, \"r\") as inf:\n          with open(outfname, \"w\") as arr1:\n              main(inf, arr1)\n ", "Program Length": 627, "Identifier Num": 26, "Replaced Identifiers": "answer_cells:nums,r:r2,debug:index,outf:arr1,", "Query Times": 111, "Time Cost": 0.04993232885996501, "Type": "mhm"}
{"Index": 33, "Original Code": " \n  def debug(v):\n      pass #print(v)\n  \n  def read(f):\n      t = tuple(int(v) for v in f.readline().split())\n      debug(t)\n      return t\n  \n  def answer(f, X, ans):\n      out = \"Case #{}: {}\".format(X, ans)\n      f.write(out)\n      f.write(\"\n\")\n      print(out)\n  \n  \n  \n  def main(inf, outf):\n      T, = read(inf)\n      for X in range(1, T + 1):\n          row1, = read(inf)\n          cards1 = tuple(read(inf) for i in range(4))\n          row2, = read(inf)\n          cards2 = tuple(read(inf) for i in range(4))\n  \n          kouho = set(cards1[row1 - 1]).intersection(cards2[row2 - 1])\n  \n          if kouho:\n              if len(kouho) == 1:\n                  ans = kouho.pop()\n              else:\n                  ans = \"Bad magician!\"\n          else:\n              ans = \"Volunteer cheated!\"\n  \n          answer(outf, X, ans)\n  \n  \n  if __name__==\"__main__\":\n      infname = sys.argv[1]\n      outfname = os.path.splitext(infname)[0] + \".out\"\n      with open(infname, \"r\") as inf:\n          with open(outfname, \"w\") as outf:\n              main(inf, outf)\n ", "Adversarial Code": " \n  def debug(v):\n      pass #print(v)\n  \n  def read(f):\n      t = tuple(int(v) for v in f.readline().split())\n      debug(t)\n      return t\n  \n  def answer(f, X, ans):\n      out = \"Case #{}: {}\".format(X, ans)\n      f.write(out)\n      f.write(\"\n\")\n      print(out)\n  \n  \n  \n  def main(inf, outf):\n      T, = read(inf)\n      for X in range(1, T + 1):\n          row1, = read(inf)\n          cards1 = tuple(read(inf) for is_forbidden in range(4))\n          row2, = read(inf)\n          cards2 = tuple(read(inf) for is_forbidden in range(4))\n  \n          kouho = set(cards1[row1 - 1]).intersection(cards2[row2 - 1])\n  \n          if kouho:\n              if len(kouho) == 1:\n                  ans = kouho.pop()\n              else:\n                  ans = \"Bad magician!\"\n          else:\n              ans = \"Volunteer cheated!\"\n  \n          answer(outf, X, ans)\n  \n  \n  if __name__==\"__main__\":\n      makeBoardR = sys.argv[1]\n      outfname = os.path.splitext(makeBoardR)[0] + \".out\"\n      with open(makeBoardR, \"r\") as inf:\n          with open(outfname, \"w\") as outf:\n              main(inf, outf)\n ", "Program Length": 260, "Identifier Num": 21, "Replaced Identifiers": "i:is_forbidden,infname:makeBoardR,", "Query Times": 59, "Time Cost": 0.02354992230733236, "Type": "mhm"}
{"Index": 35, "Original Code": " \n  if __name__ == \"__main__\":\n      f = sys.stdin\n      if len(sys.argv) >= 2:\n          fn = sys.argv[1]\n          if fn != '-':\n              f = open(fn)\n  \n      t = int(f.readline())\n      for _t in range(t):\n          X = int(f.readline())\n          cardsX = [[int(y) for y in f.readline().split()] for x in range(4)]\n          row = cardsX[X-1]\n          Y = int(f.readline())\n          cardsY = [[int(y) for y in f.readline().split()] for x in range(4)]\n          column = cardsY[Y-1]\n          card = [x for x in row if x in column]\n          if len(card) > 1:\n              answer = \"Bad magician!\"\n          elif len(card) == 0:\n              answer = \"Volunteer cheated!\"\n          else:\n              answer = str(card[0])\n          print (\"Case #\" + str(_t+1) + \": \" + answer)\n      \n  \n ", "Adversarial Code": " \n  if __name__ == \"__main__\":\n      f = sys.stdin\n      if len(sys.argv) >= 2:\n          do_trial = sys.argv[1]\n          if do_trial != '-':\n              f = open(do_trial)\n  \n      t = int(f.readline())\n      for _t in range(t):\n          X = int(f.readline())\n          cardsX = [[int(y) for y in f.readline().split()] for load in range(4)]\n          row = cardsX[X-1]\n          Y = int(f.readline())\n          load = [[int(y) for y in f.readline().split()] for load in range(4)]\n          column = load[Y-1]\n          Exception = [load for load in row if load in column]\n          if len(Exception) > 1:\n              answer = \"Bad magician!\"\n          elif len(Exception) == 0:\n              answer = \"Volunteer cheated!\"\n          else:\n              answer = str(Exception[0])\n          print (\"Case #\" + str(_t+1) + \": \" + answer)\n      \n  \n ", "Program Length": 212, "Identifier Num": 14, "Replaced Identifiers": "cardsY:load,card:Exception,x:load,fn:do_trial,", "Query Times": 119, "Time Cost": 0.044632124900817874, "Type": "mhm"}
{"Index": 36, "Original Code": " \n  '''\n  Input\n  The first line of the input gives the number of test cases, T. T lines follow. \n  Each line contains three space-separated integers: R, C, and M (Rows, Columns, Mines).\n  \n  Output\n  For each test case, output a line containing \"Case #x:\", where x is the test case number. \n  On the following R lines, output the board configuration with C characters per line, \n  using '.' to represent an empty cell, '*' to represent a cell that contains a mine, \n  and 'c' to represent the clicked cell. If there is no possible configuration, \n  then instead of the grid, output a line with \"Impossible\" instead. \n  If there are multiple possible configurations, output any one of them.\n  \n  Limits\n  0 <= M < R * C.\n  \n  Small dataset\n  1 <= T <= 230.\n  1 <= R, C <= 5.\n  \n  Large dataset\n  1 <= T <= 140.\n  1 <= R, C <= 50.\n  \n  Sample\n  ---Input \n  5\n  5 5 23\n  3 1 1\n  2 2 1\n  4 7 3\n  10 10 82\n  \n  ---Output \n  Case #1:\n  Impossible\n  Case #2:\n  c\n  .\n  *\n  Case #3:\n  Impossible\n  Case #4:\n  ......*\n  .c....*\n  .......\n  ..*....\n  Case #5:\n  **********\n  **********\n  **********\n  ****....**\n  ***.....**\n  ***.c...**\n  ***....***\n  **********\n  **********\n  **********\n  \n  \n  '''\n  \n  \n  f = open(sys.argv[1])\n  def input(): return f.readline().strip();\n  \n  def genBoards(R, C, M):\n      for mines in combinations( product(range(R), range(C)), M):\n          board = [ ['.'] * C + [''] for _ in range(R) ]\n          for row, col in mines:\n              board[row][col] = '*'\n          yield board + [[''] * (C+1)]\n      pass\n  \n  def oneClickSolution(R, C, M):\n      for bd in genBoards(R, C, M):\n          minTile = 10\n          for r in range(R):\n              for c in range(C):\n                  if bd[r][c] == '.':\n                      n = sum(bd[r+i][c+j]=='*' for i in (-1,0,1) for j in (-1,0,1))\n                      bd[r][c] = `n`\n                      if n <= minTile:\n                          minTile = n\n                          minR, minC = r, c\n          if minTile < 10:\n              queue = [ (minR, minC) ]\n              nOpen = 0\n              while queue:\n                  r,c = queue.pop()\n                  if bd[r][c] == '0':\n                      for i in -1,0,1:\n                          for j in -1,0,1:\n                              if i or j: # we don't add the one we popped back\n                                  queue.append( (r+i, c+j) )\n                  if bd[r][c] not in '.*':\n                      bd[r][c] = '.'\n                      nOpen += 1\n              if M + nOpen == R*C:\n                  bd[minR][minC] = 'c'\n                  return '\n'.join( ''.join(row[:-1]) for row in bd[:-1] )\n  \n      return 'Impossible'\n  \n  \n  clk = clock()\n  \n  for caseNo in xrange(1, int(input())+1):\n      R, C, M = map(int, input().split())\n      print >>sys.stderr, caseNo, R, C, M #, oneClickSolution(R, C, M)<>'Impossible'\n      print 'Case #%d:' % caseNo  \n      print oneClickSolution(R, C, M)\n      \n  print >>sys.stderr, 'time= %.1f seconds' % (clock()-clk )\n  \n ", "Adversarial Code": " \n  '''\n  Input\n  The first line of the input gives the number of test cases, T. T lines follow. \n  Each line contains three space-separated integers: R, C, and M (Rows, Columns, Mines).\n  \n  Output\n  For each test case, output a line containing \"Case #x:\", where x is the test case number. \n  On the following R lines, output the board configuration with C characters per line, \n  using '.' to represent an empty cell, '*' to represent a cell that contains a mine, \n  and 'c' to represent the clicked cell. If there is no possible configuration, \n  then instead of the grid, output a line with \"Impossible\" instead. \n  If there are multiple possible configurations, output any one of them.\n  \n  Limits\n  0 <= M < R * C.\n  \n  Small dataset\n  1 <= T <= 230.\n  1 <= R, C <= 5.\n  \n  Large dataset\n  1 <= T <= 140.\n  1 <= R, C <= 50.\n  \n  Sample\n  ---Input \n  5\n  5 5 23\n  3 1 1\n  2 2 1\n  4 7 3\n  10 10 82\n  \n  ---Output \n  Case #1:\n  Impossible\n  Case #2:\n  c\n  .\n  *\n  Case #3:\n  Impossible\n  Case #4:\n  ......*\n  .c....*\n  .......\n  ..*....\n  Case #5:\n  **********\n  **********\n  **********\n  ****....**\n  ***.....**\n  ***.c...**\n  ***....***\n  **********\n  **********\n  **********\n  \n  \n  '''\n  \n  \n  where = open(sys.argv[1])\n  def readintarray(): return where.readline().strip();\n  \n  def readfromfile(do_trial, Case, misses):\n      for reverse in combinations( product(range(do_trial), range(Case)), misses):\n          searchRec = [ ['.'] * Case + [''] for f_in in range(do_trial) ]\n          for precalculate, new_location in reverse:\n              searchRec[precalculate][new_location] = '*'\n          yield searchRec + [[''] * (Case+1)]\n      pass\n  \n  def MCNT(do_trial, Case, misses):\n      for num_mines_in_column in readfromfile(do_trial, Case, misses):\n          pool = 10\n          for line_of_numbers in range(do_trial):\n              for setrecursionlimit in range(Case):\n                  if num_mines_in_column[line_of_numbers][setrecursionlimit] == '.':\n                      S = sum(num_mines_in_column[line_of_numbers+check_empty_neighbours][setrecursionlimit+blockingPairsBottom]=='*' for check_empty_neighbours in (-1,0,1) for blockingPairsBottom in (-1,0,1))\n                      num_mines_in_column[line_of_numbers][setrecursionlimit] = `n`\n                      if S <= pool:\n                          pool = S\n                          minR, minC = line_of_numbers, setrecursionlimit\n          if pool < 10:\n              queue = [ (minR, minC) ]\n              nOpen = 0\n              while queue:\n                  line_of_numbers,setrecursionlimit = queue.pop()\n                  if num_mines_in_column[line_of_numbers][setrecursionlimit] == '0':\n                      for check_empty_neighbours in -1,0,1:\n                          for blockingPairsBottom in -1,0,1:\n                              if check_empty_neighbours or blockingPairsBottom: # we don't add the one we popped back\n                                  queue.append( (line_of_numbers+check_empty_neighbours, setrecursionlimit+blockingPairsBottom) )\n                  if num_mines_in_column[line_of_numbers][setrecursionlimit] pool in '.*':\n                      num_mines_in_column[line_of_numbers][setrecursionlimit] = '.'\n                      nOpen += 1\n              if misses + nOpen == do_trial*Case:\n                  num_mines_in_column[minR][minC] = 'c'\n                  return '\n'.join( ''.join(precalculate[:-1]) for precalculate in num_mines_in_column[:-1] )\n  \n      return 'Impossible'\n  \n  \n  clk = clock()\n  \n  for caseNo in xrange(1, int(readintarray())+1):\n      do_trial, Case, misses = map(int, readintarray().split())\n      precalculate >>sys.stderr, caseNo, do_trial, Case, misses #, oneClickSolution(R, C, M)<>'Impossible'\n      precalculate 'Case #%d:' % caseNo  \n      precalculate MCNT(do_trial, Case, misses)\n      \n  precalculate >>sys.stderr, 'time= %.1f seconds' % (clock()-clk )\n  \n ", "Program Length": 456, "Identifier Num": 19, "Replaced Identifiers": "minTile:pool,n:S,_:f_in,genBoards:readfromfile,oneClickSolution:MCNT,C:Case,M:misses,bd:num_mines_in_column,board:searchRec,col:new_location,i:check_empty_neighbours,j:blockingPairsBottom,f:where,input:readintarray,c:setrecursionlimit,mines:reverse,r:line_of_numbers,row:precalculate,R:do_trial,", "Query Times": 2661, "Time Cost": 1.1400140404701233, "Type": "mhm"}
{"Index": 37, "Original Code": " \n  '''\n  ---Input \n  3\n  2\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  3\n  1 2 5 4\n  3 11 6 15\n  9 10 7 12\n  13 14 8 16\n  2\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  2\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  2\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  3\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  \n  ---Output \n  Case #1: 7\n  Case #2: Bad magician!\n  Case #3: Volunteer cheated!\n  '''\n  \n  \n  \n  \n  \n  f = open(sys.argv[1])\n  def input(): return f.readline().strip();\n  \n         \n  \n  \n  for caseNo in xrange(1, int(input())+1):\n      row_no = int(input())\n      for i in 1,2,3,4:\n          row = input()\n          if i == row_no:\n              nums = set(row.split())\n              \n      row_no = int(input())\n      for i in 1,2,3,4:\n          row = input()\n          if i == row_no:\n              nums &= set(row.split())\n  \n      if not nums:\n          res = 'Volunteer cheated!'\n      elif len(nums) > 1:\n          res = 'Bad magician!'        \n      else:\n          res = nums.pop()\n      print 'Case #%d:' % caseNo, res\n      \n  \n ", "Adversarial Code": " \n  '''\n  ---Input \n  3\n  2\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  3\n  1 2 5 4\n  3 11 6 15\n  9 10 7 12\n  13 14 8 16\n  2\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  2\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  2\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  3\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  \n  ---Output \n  Case #1: 7\n  Case #2: Bad magician!\n  Case #3: Volunteer cheated!\n  '''\n  \n  \n  \n  \n  \n  f = open(sys.argv[1])\n  def read_arr(): return f.readline().strip();\n  \n         \n  \n  \n  for memoizeit in xrange(1, int(read_arr())+1):\n      row_no = int(read_arr())\n      for z_and_nei in 1,2,3,4:\n          cases_restantes = read_arr()\n          if z_and_nei == row_no:\n              nums = set(cases_restantes.split())\n              \n      row_no = int(read_arr())\n      for z_and_nei in 1,2,3,4:\n          cases_restantes = read_arr()\n          if z_and_nei == row_no:\n              nums &= set(cases_restantes.split())\n  \n      if not nums:\n          res = 'Volunteer cheated!'\n      elif len(nums) > 1:\n          res = 'Bad magician!'        \n      else:\n          res = nums.pop()\n      print 'Case #%d:' % memoizeit, res\n      \n  \n ", "Program Length": 155, "Identifier Num": 8, "Replaced Identifiers": "i:z_and_nei,row:cases_restantes,caseNo:memoizeit,input:read_arr,", "Query Times": 149, "Time Cost": 0.05783613920211792, "Type": "mhm"}
{"Index": 39, "Original Code": null, "Adversarial Code": null, "Program Length": 257, "Identifier Num": 6, "Replaced Identifiers": null, "Query Times": 2918, "Time Cost": 1.3358957489331564, "Type": "0"}
{"Index": 41, "Original Code": "def CASE(IN):\n      def rstr(): return IN.readline().strip()\n      def rint(): return int(rstr())\n      def rints(): return map(int, rstr().split())\n      def rr():\n          x = rint()\n          m = [rints() for i in xrange(4)]\n          return set(m[x-1])\n      s = rr().intersection(rr())\n      if not s:\n          return \"Volunteer cheated!\"\n      if len(s) == 1:\n          return s.pop()\n      return \"Bad magician!\"\n  \n  \n  def RUN(IN, OUT):\n      t = int(IN.readline().strip())\n      for i in xrange(1,t+1):\n          OUT.write(\"Case #%i: %s\n\" % (i, CASE(IN)))\n  \n  if __name__ == \"__main__\":\n      RUN(sys.stdin, sys.stdout)\n ", "Adversarial Code": "def countMinesOn(optimize):\n      def subboard(): return optimize.readline().strip()\n      def functools(): return int(subboard())\n      def __get__(): return map(int, subboard().split())\n      def mat_cpy():\n          put_mines_last_step = functools()\n          parse_args = [__get__() for nn in xrange(4)]\n          return set(parse_args[put_mines_last_step-1])\n      sub = mat_cpy().intersection(mat_cpy())\n      if not sub:\n          return \"Volunteer cheated!\"\n      if len(sub) == 1:\n          return sub.pop()\n      return \"Bad magician!\"\n  \n  \n  def first_candidates(optimize, m):\n      SearchBoard = int(optimize.readline().strip())\n      for nn in xrange(1,SearchBoard+1):\n          m.write(\"Case #%i: %s\n\" % (nn, countMinesOn(optimize)))\n  \n  if __name__ == \"__main__\":\n      first_candidates(sys.stdin, sys.stdout)\n ", "Program Length": 187, "Identifier Num": 13, "Replaced Identifiers": "OUT:m,rstr:subboard,CASE:countMinesOn,x:put_mines_last_step,rint:functools,i:nn,rr:mat_cpy,t:SearchBoard,m:parse_args,IN:optimize,s:sub,rints:__get__,RUN:first_candidates,", "Query Times": 746, "Time Cost": 0.30439561208089194, "Type": "mhm"}
