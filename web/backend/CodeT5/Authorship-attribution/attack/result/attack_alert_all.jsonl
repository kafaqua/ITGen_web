{"Index": 0, "Original Code": "\"\"\"Usage:\n      pypy X.py < X-size.in > X-size.out\n  or sometimes\n      python X.py < X-size.in > X-size.out\n  \"\"\"\n  \n  def setup(infile):\n      return locals()\n  \n  def reader(testcase, infile, C=None, **ignore):\n      P = map(int, infile.next().split())\n      return locals()\n  \n  def solver(testcase, N=None, P=None, I=None, T=None, S=None, C=None, **ignore):\n  \n      R, C, M = P\n      MM = M\n  \n      F = np.array([['.'] * C] * R)\n      while M > 0:\n          if R >= C and M >= C and R > 2:\n              M -= C\n              R -= 1\n              F[R] = '*'\n          elif C > R  and M >= R and C > 2:\n              M -= R\n              C -= 1\n              F[:, C] = '*'\n          elif R > 2 and C > 2 and (R > 3 or C > 3 or M == 1):\n              if M < C - 1:\n                  R -= 1\n                  F[R, C - M:C] = '*'\n              elif M < R - 1:\n                  C -= 1\n                  F[R - M:R, C] = '*'\n              elif M == C - 1:\n                  R -= 1\n                  F[R, C - M + 1:C] = '*'\n                  F[R - 1, C - 1] = '*'\n              else:\n                  C -= 1\n                  F[R - M + 1:R, C] = '*'\n                  F[R - 1, C - 1] = '*'\n              M = 0\n          elif M == R * C - 1:\n              F[:, :] = '*'\n              M = 0\n          else:\n              return 'Case #%s:\n%s\n' % (testcase, 'Impossible')\n  \n      F[0, 0] = 'c'\n      assert (F == '*').sum() == MM\n      return 'Case #%s:\n%s\n' % (testcase, '\n'.join(''.join(f.tolist()) for f in F))\n  \n  if __name__ == '__main__':\n      T = int(sys.stdin.next())\n      common = setup(sys.stdin)\n      for t in xrange(1, T+1):\n          sys.stdout.write(solver(**reader(t, **common)))\n ", "Adversarial Code": "\"\"\"Usage:\n      pypy X.py < X-size.in > X-size.out\n  or sometimes\n      python X.py < X-size.in > X-size.out\n  \"\"\"\n  \n  def process(inifile):\n      return locals()\n  \n  def reader(Testline, inifile, C=None, **ignore):\n      P = map(int, inifile.next().split())\n      return locals()\n  \n  def insolved(Testline, N=None, P=None, I=None, V=None, S=None, C=None, **ignore):\n  \n      R, C, M = P\n      MM = M\n  \n      F = np.array([['.'] * C] * R)\n      while M > 0:\n          if R >= C and M >= C and R > 2:\n              M -= C\n              R -= 1\n              F[R] = '*'\n          elif C > R  and M >= R and C > 2:\n              M -= R\n              C -= 1\n              F[:, C] = '*'\n          elif R > 2 and C > 2 and (R > 3 or C > 3 or M == 1):\n              if M < C - 1:\n                  R -= 1\n                  F[R, C - M:C] = '*'\n              elif M < R - 1:\n                  C -= 1\n                  F[R - M:R, C] = '*'\n              elif M == C - 1:\n                  R -= 1\n                  F[R, C - M + 1:C] = '*'\n                  F[R - 1, C - 1] = '*'\n              else:\n                  C -= 1\n                  F[R - M + 1:R, C] = '*'\n                  F[R - 1, C - 1] = '*'\n              M = 0\n          elif M == R * C - 1:\n              F[:, :] = '*'\n              M = 0\n          else:\n              return 'Case #%s:\n%s\n' % (testcase, 'Impossible')\n  \n      F[0, 0] = 'c'\n      assert (F == '*').sum() == MM\n      return 'Case #%s:\n%s\n' % (testcase, '\n'.join(''.join(f.tolist()) for f in F))\n  \n  if __name__ == '__main__':\n      V = int(sys.stdin.next())\n      common = process(sys.stdin)\n      for t in xrange(1, V+1):\n          sys.stdout.write(insolved(**reader(t, **common)))\n ", "Program Length": 429, "Identifier Num": 16, "Replaced Identifiers": "T:V,solver:insolved,setup:process,testcase:Testline,infile:inifile,", "Query Times": 233, "Time Cost": 0.1407412886619568, "Type": "Greedy"}
{"Index": 1, "Original Code": "\"\"\"Usage:\n      pypy X.py < X-size.in > X-size.out\n  or sometimes\n      python X.py < X-size.in > X-size.out\n  \"\"\"\n  \n  def setup(infile):\n      return locals()\n  \n  def reader(testcase, infile, C=None, **ignore):\n      N = int(infile.next())\n      I = [map(int, infile.next().split()) for i in range(4)]\n      T = int(infile.next())\n      S = [map(int, infile.next().split()) for i in range(4)]\n      return locals()\n  \n  def solver(testcase, N=None, P=None, I=None, T=None, S=None, C=None, **ignore):\n  \n      res = set(I[N-1]) & set(S[T-1])\n      if len(res) == 1:\n          res = res.pop()\n      elif len(res) > 1:\n          res = 'Bad magician!'\n      else:\n          res = 'Volunteer cheated!'\n      return 'Case #%s: %s\n' % (testcase, res)\n  \n  if __name__ == '__main__':\n      T = int(sys.stdin.next())\n      common = setup(sys.stdin)\n      for t in xrange(1, T+1):\n          sys.stdout.write(solver(**reader(t, **common)))\n ", "Adversarial Code": "\"\"\"Usage:\n      pypy X.py < X-size.in > X-size.out\n  or sometimes\n      python X.py < X-size.in > X-size.out\n  \"\"\"\n  \n  def setup(infile):\n      return locals()\n  \n  def author(validline, infile, Case=None, **ignore):\n      N = int(infile.next())\n      I = [map(int, infile.next().split()) for i in range(4)]\n      To = int(infile.next())\n      S = [map(int, infile.next().split()) for i in range(4)]\n      return locals()\n  \n  def  solve(validline, N=None, IP=None, I=None, To=None, S=None, Case=None, **ignore):\n  \n      res = set(I[N-1]) & set(S[To-1])\n      if len(res) == 1:\n          res = res.pop()\n      elif len(res) > 1:\n          res = 'Bad magician!'\n      else:\n          res = 'Volunteer cheated!'\n      return 'Case #%s: %s\n' % (validline, res)\n  \n  if __name__ == '__main__':\n      To = int(sys.stdin.next())\n      f = setup(sys.stdin)\n      for total in xrange(1, To+1):\n          sys.stdout.write( solve(**author(total, **f)))\n ", "Program Length": 249, "Identifier Num": 15, "Replaced Identifiers": "T:To,solver: solve,common:f,reader:author,P:IP,C:Case,testcase:validline,t:total,", "Query Times": 338, "Time Cost": 0.20063720941543578, "Type": "Greedy"}
{"Index": 2, "Original Code": " def solve():\n      h, w, m = map(int, raw_input().split())\n      if h == 1:\n          print 'c' + '.' * (h * w - m - 1) + '*' * m\n      elif w == 1:\n          for c in 'c' + '.' * (h * w - m - 1) + '*' * m:\n              print c\n      elif h * w - m == 1:\n          print 'c' + '*' * (w - 1)\n          for _ in xrange(h-1):\n              print '*' * w\n      else:\n          m = h * w - m\n          for i in xrange(h-1):\n              for j in xrange(w-1):\n                  t = (i + 2) * 2 + (j + 2) * 2 - 4\n                  r = (i + 2) * (j + 2)\n                  if t <= m <= r:\n                      a = [['*'] * w for _ in xrange(h)]\n                      for k in xrange(i+2):\n                          a[k][0] = '.'\n                          a[k][1] = '.'\n                      for k in xrange(j+2):\n                          a[0][k] = '.'\n                          a[1][k] = '.'\n                      for y, x in product(range(2, i+2), range(2, j+2)):\n                          if y == 1 and x == 1:\n                              continue\n                          if t >= m:\n                              break\n                          a[y][x] = '.'\n                          t += 1\n                      a[0][0] = 'c'\n                      for s in a:\n                          print ''.join(s)\n                      return\n          print 'Impossible'\n  for t in xrange(int(raw_input())):\n      print \"Case #%d:\" % (t + 1)\n      solve()\n ", "Adversarial Code": " def Solving():\n      h, w, m = map(int, raw_input().split())\n      if h == 1:\n          print 'c' + '.' * (h * w - m - 1) + '*' * m\n      elif w == 1:\n          for code in 'c' + '.' * (h * w - m - 1) + '*' * m:\n              print code\n      elif h * w - m == 1:\n          print 'c' + '*' * (w - 1)\n          for of in xrange(h-1):\n              print '*' * w\n      else:\n          m = h * w - m\n          for i in xrange(h-1):\n              for j in xrange(w-1):\n                  t = (i + 2) * 2 + (j + 2) * 2 - 4\n                   R = (i + 2) * (j + 2)\n                  if t <= m <=  R:\n                      a = [['*'] * w for of in xrange(h)]\n                      for k in xrange(i+2):\n                          a[k][0] = '.'\n                          a[k][1] = '.'\n                      for k in xrange(j+2):\n                          a[0][k] = '.'\n                          a[1][k] = '.'\n                      for y, x in product(range(2, i+2), range(2, j+2)):\n                          if y == 1 and x == 1:\n                              continue\n                          if t >= m:\n                              break\n                          a[y][x] = '.'\n                          t += 1\n                      a[0][0] = 'c'\n                      for services in a:\n                          print ''.join(services)\n                      return\n          print 'Impossible'\n  for t in xrange(int(raw_input())):\n      print \"Case #%d:\" % (t + 1)\n      Solving()\n ", "Program Length": 349, "Identifier Num": 15, "Replaced Identifiers": "solve:Solving,c:code,r: R,_:of,s:services,", "Query Times": 203, "Time Cost": 0.1153727134068807, "Type": "Greedy"}
{"Index": 3, "Original Code": "def solve():\n      r1 = int(raw_input())\n      a1 = [map(int, raw_input().split()) for i in xrange(4)]\n      r2 = int(raw_input())\n      a2 = [map(int, raw_input().split()) for i in xrange(4)]\n      ans = -1\n      for i in xrange(1, 17):\n          if i in a1[r1-1] and i in a2[r2-1]:\n              if ans != -1:\n                  return \"Bad magician!\"\n              ans = i\n      if ans == -1:\n          return \"Volunteer cheated!\"\n      return ans\n  for t in xrange(int(raw_input())):\n      print \"Case #%d:\" % (t + 1), solve()\n ", "Adversarial Code": "def Solver():\n      rg31 = int(raw_input())\n       a8 = [map(int, raw_input().split()) for ti in xrange(4)]\n      r2 = int(raw_input())\n      a2 = [map(int, raw_input().split()) for ti in xrange(4)]\n       means = -1\n      for ti in xrange(1, 17):\n          if ti in  a8[rg31-1] and ti in a2[r2-1]:\n              if  means != -1:\n                  return \"Bad magician!\"\n               means = ti\n      if  means == -1:\n          return \"Volunteer cheated!\"\n      return  means\n  for test in xrange(int(raw_input())):\n      print \"Case #%d:\" % (test + 1), Solver()\n ", "Program Length": 146, "Identifier Num": 8, "Replaced Identifiers": "solve:Solver,t:test,ans: means,r1:rg31,i:ti,a1: a8,", "Query Times": 235, "Time Cost": 0.13094297250111897, "Type": "Greedy"}
{"Index": 5, "Original Code": " \n  if __name__ == \"__main__\":\n  \tf = open( sys.argv[1] )\n  \tint(f.readline())\n  \t\t\n  \tnum = 1\n  \tl = f.readline()\n  \twhile l != \"\":\n  \t\trow1 = int(l)\n  \t\trows = [ f.readline() for x in range(4) ]\n  \t\trow1 = [int(x) for x in rows[row1-1].split()]\n  \n  \t\trow2 = int(f.readline())\n  \t\trows = [f.readline() for x in range(4)]\n  \t\trow2 = [int(x) for x in rows[row2-1].split()]\n  \n  \t\tresult = set(row1) & set(row2)\n  \t\tif len(result) == 1:\n  \t\t\toutput = str(result.pop())\n  \t\telif len(result) > 1:\n  \t\t\toutput = \"Bad magician!\"\n  \t\telse:\n  \t\t\toutput = \"Volunteer cheated!\"\n  \n  \t\tprint \"Case #\"+str(num)+\": \"+output\n  \t\tnum += 1\n  \t\tl = f.readline()\n  \t\t\n ", "Adversarial Code": " \n  if __name__ == \"__main__\":\n  \tf = open( sys.argv[1] )\n  \tint(f.readline())\n  \t\t\n  \tfn = 1\n  \tl = f.readline()\n  \twhile l != \"\":\n  \t\trow1 = int(l)\n  \t\traw = [ f.readline() for x in range(4) ]\n  \t\trow1 = [int(x) for x in raw[row1-1].split()]\n  \n  \t\trow2 = int(f.readline())\n  \t\traw = [f.readline() for x in range(4)]\n  \t\trow2 = [int(x) for x in raw[row2-1].split()]\n  \n  \t\tresult = set(row1) & set(row2)\n  \t\tif len(result) == 1:\n  \t\t\toutput = str(result.pop())\n  \t\telif len(result) > 1:\n  \t\t\toutput = \"Bad magician!\"\n  \t\telse:\n  \t\t\toutput = \"Volunteer cheated!\"\n  \n  \t\tprint \"Case #\"+str(fn)+\": \"+output\n  \t\tfn += 1\n  \t\tl = f.readline()\n  \t\t\n ", "Program Length": 195, "Identifier Num": 9, "Replaced Identifiers": "rows:raw,num:fn,", "Query Times": 156, "Time Cost": 0.07460705041885377, "Type": "Greedy"}
{"Index": 6, "Original Code": "t = int(raw_input())\n  \n  for case in range(t):\n  \tprint 'Case #'+str(case+1)+':'\n  \tr, c, m = raw_input().split()\n  \tr = int(r)\n  \tc = int(c)\n  \tm = int(m)\n  \n  \tif m==0:\n  \t\tprint 'c' + ('.'*(c-1))\n  \t\tfor i in range(r-1):\n  \t\t\tprint '.'*c\n  \telif r == 1:\n  \t\tprint 'c'+('.'*(c-m-1))+('*'*(m))\n  \telif c == 1:\n  \t\tprint 'c'\n  \t\tfor i in range(r-m-1):\n  \t\t\tprint '.'\n  \t\tfor i in range(m):\n  \t\t\tprint '*'\n  \telif r == 2:\n  \t\tif m%2==0 and c>2 and m<r*c-2:\n  \t\t\tprint 'c'+('.'*(c-m/2-1))+('*'*(m/2))\n  \t\t\tprint ('.'*(c-m/2))+('*'*(m/2))\n  \t\telif m == r*c - 1:\n  \t\t\tprint 'c'+('*'*(c-1))\n  \t\t\tprint '*'*c\n  \t\telse:\n  \t\t\tprint 'Impossible'\n  \telif c == 2:\n  \t\tif m%2==0 and r>2 and m<r*c-2:\n  \t\t\tprint 'c.'\n  \t\t\tfor i in range(r-m/2-1):\n  \t\t\t\tprint '..'\n  \t\t\tfor i in range(m/2):\n  \t\t\t\tprint '**'\n  \t\telif m == r*c - 1:\n  \t\t\tprint 'c*'\n  \t\t\tfor i in range(r-1):\n  \t\t\t\tprint '**'\n  \t\telse:\n  \t\t\tprint 'Impossible'\n  \telif c == 3 and r == 3:\n  \t\tif m == 1:\n  \t\t\tprint 'c..'\n  \t\t\tprint '...'\n  \t\t\tprint '..*'\n  \t\telif m == 2:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 3:\n  \t\t\tprint 'c..'\n  \t\t\tprint '...'\n  \t\t\tprint '***'\n  \t\telif m == 4:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 5:\n  \t\t\tprint 'c.*'\n  \t\t\tprint '..*'\n  \t\t\tprint '***'\n  \t\telif m == 6:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 7:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 8:\n  \t\t\tprint 'c**'\n  \t\t\tprint '***'\n  \t\t\tprint '***'\n  \telif c == 3 and r == 4:\n  \t\tif m == 1:\n  \t\t\tprint 'c..'\n  \t\t\tprint '...'\n  \t\t\tprint '...'\n  \t\t\tprint '..*'\n  \t\telif m == 2:\n  \t\t\tprint 'c..'\n  \t\t\tprint '...'\n  \t\t\tprint '..*'\n  \t\t\tprint '..*'\n  \t\telif m == 3:\n  \t\t\tprint 'c..'\n  \t\t\tprint '...'\n  \t\t\tprint '...'\n  \t\t\tprint '***'\n  \t\telif m == 4:\n  \t\t\tprint 'c.*'\n  \t\t\tprint '..*'\n  \t\t\tprint '..*'\n  \t\t\tprint '..*'\n  \t\telif m == 5:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 6:\n  \t\t\tprint 'c..'\n  \t\t\tprint '...'\n  \t\t\tprint '***'\n  \t\t\tprint '***'\n  \t\telif m == 7:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 8:\n  \t\t\tprint 'c.*'\n  \t\t\tprint '..*'\n  \t\t\tprint '***'\n  \t\t\tprint '***'\n  \t\telif m == 9:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 10:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 11:\n  \t\t\tprint 'c**'\n  \t\t\tprint '***'\n  \t\t\tprint '***'\n  \t\t\tprint '***'\n  \telif c == 3 and r == 5:\n  \t\tif m == 1:\n  \t\t\tprint 'c..'\n  \t\t\tprint '...'\n  \t\t\tprint '...'\n  \t\t\tprint '...'\n  \t\t\tprint '..*'\n  \t\telif m == 2:\n  \t\t\tprint 'c..'\n  \t\t\tprint '...'\n  \t\t\tprint '...'\n  \t\t\tprint '..*'\n  \t\t\tprint '..*'\n  \t\telif m == 3:\n  \t\t\tprint 'c..'\n  \t\t\tprint '...'\n  \t\t\tprint '..*'\n  \t\t\tprint '..*'\n  \t\t\tprint '..*'\n  \t\telif m == 4:\n  \t\t\tprint 'c..'\n  \t\t\tprint '...'\n  \t\t\tprint '...'\n  \t\t\tprint '..*'\n  \t\t\tprint '***'\n  \t\telif m == 5:\n  \t\t\tprint 'c.*'\n  \t\t\tprint '..*'\n  \t\t\tprint '..*'\n  \t\t\tprint '..*'\n  \t\t\tprint '..*'\n  \t\telif m == 6:\n  \t\t\tprint 'c..'\n  \t\t\tprint '...'\n  \t\t\tprint '...'\n  \t\t\tprint '***'\n  \t\t\tprint '***'\n  \t\telif m == 7:\n  \t\t\tprint 'c..'\n  \t\t\tprint '...'\n  \t\t\tprint '..*'\n  \t\t\tprint '***'\n  \t\t\tprint '***'\n  \t\telif m == 8:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 9:\n  \t\t\tprint 'c..'\n  \t\t\tprint '...'\n  \t\t\tprint '***'\n  \t\t\tprint '***'\n  \t\t\tprint '***'\n  \t\telif m == 10:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 11:\n  \t\t\tprint 'c.*'\n  \t\t\tprint '..*'\n  \t\t\tprint '***'\n  \t\t\tprint '***'\n  \t\t\tprint '***'\n  \t\telif m == 12:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 13:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 14:\n  \t\t\tprint 'c**'\n  \t\t\tprint '***'\n  \t\t\tprint '***'\n  \t\t\tprint '***'\n  \t\t\tprint '***'\n  \telif c == 4 and r == 3:\n  \t\tif m == 1:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '...*'\n  \t\telif m == 2:\n  \t\t\tprint 'c...'\n  \t\t\tprint '...*'\n  \t\t\tprint '...*'\n  \t\telif m == 3:\n  \t\t\tprint 'c..*'\n  \t\t\tprint '...*'\n  \t\t\tprint '...*'\n  \t\telif m == 4:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '****'\n  \t\telif m == 5:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 6:\n  \t\t\tprint 'c.**'\n  \t\t\tprint '..**'\n  \t\t\tprint '..**'\n  \t\telif m == 7:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 8:\n  \t\t\tprint 'c.**'\n  \t\t\tprint '..**'\n  \t\t\tprint '****'\n  \t\telif m == 9:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 10:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 11:\n  \t\t\tprint 'c***'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \telif c == 4 and r == 4:\n  \t\tif m == 1:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '....'\n  \t\t\tprint '...*'\n  \t\telif m == 2:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '....'\n  \t\t\tprint '..**'\n  \t\telif m == 3:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '...*'\n  \t\t\tprint '..**'\n  \t\telif m == 4:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '....'\n  \t\t\tprint '****'\n  \t\telif m == 5:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '...*'\n  \t\t\tprint '****'\n  \t\telif m == 6:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '..**'\n  \t\t\tprint '****'\n  \t\telif m == 7:\n  \t\t\tprint 'c..*'\n  \t\t\tprint '...*'\n  \t\t\tprint '...*'\n  \t\t\tprint '****'\n  \t\telif m == 8:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \t\telif m == 9:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 10:\n  \t\t\tprint 'c.**'\n  \t\t\tprint '..**'\n  \t\t\tprint '..**'\n  \t\t\tprint '****'\n  \t\telif m == 11:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 12:\n  \t\t\tprint 'c.**'\n  \t\t\tprint '..**'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \t\telif m == 13:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 14:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 15:\n  \t\t\tprint 'c***'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \telif c == 4 and r == 5:\n  \t\tif m == 1:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '....'\n  \t\t\tprint '....'\n  \t\t\tprint '...*'\n  \t\telif m == 2:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '....'\n  \t\t\tprint '....'\n  \t\t\tprint '..**'\n  \t\telif m == 3:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '...*'\n  \t\t\tprint '...*'\n  \t\t\tprint '...*'\n  \t\telif m == 4:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '....'\n  \t\t\tprint '....'\n  \t\t\tprint '****'\n  \t\telif m == 5:\n  \t\t\tprint 'c..*'\n  \t\t\tprint '...*'\n  \t\t\tprint '...*'\n  \t\t\tprint '...*'\n  \t\t\tprint '...*'\n  \t\telif m == 6:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '....'\n  \t\t\tprint '..**'\n  \t\t\tprint '****'\n  \t\telif m == 7:\n  \t\t\tprint 'c..*'\n  \t\t\tprint '...*'\n  \t\t\tprint '...*'\n  \t\t\tprint '..**'\n  \t\t\tprint '..**'\n  \t\telif m == 8:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '....'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \t\telif m == 9:\n  \t\t\tprint 'c..*'\n  \t\t\tprint '...*'\n  \t\t\tprint '...*'\n  \t\t\tprint '..**'\n  \t\t\tprint '****'\n  \t\telif m == 10:\n  \t\t\tprint 'c.**'\n  \t\t\tprint '..**'\n  \t\t\tprint '..**'\n  \t\t\tprint '..**'\n  \t\t\tprint '..**'\n  \t\telif m == 11:\n  \t\t\tprint 'c..*'\n  \t\t\tprint '...*'\n  \t\t\tprint '...*'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \t\telif m == 12:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \t\telif m == 13:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 14:\n  \t\t\tprint 'c..*'\n  \t\t\tprint '...*'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \t\telif m == 15:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 16:\n  \t\t\tprint 'c.**'\n  \t\t\tprint '..**'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \t\telif m == 17:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 18:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 19:\n  \t\t\tprint 'c***'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \telif c == 5 and r == 3:\n  \t\tif m == 1:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '....*'\n  \t\telif m == 2:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '...**'\n  \t\telif m == 3:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '..***'\n  \t\telif m == 4:\n  \t\t\tprint 'c...*'\n  \t\t\tprint '....*'\n  \t\t\tprint '...**'\n  \t\telif m == 5:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '*****'\n  \t\telif m == 6:\n  \t\t\tprint 'c..**'\n  \t\t\tprint '...**'\n  \t\t\tprint '...**'\n  \t\telif m == 7:\n  \t\t\tprint 'c..**'\n  \t\t\tprint '...**'\n  \t\t\tprint '..***'\n  \t\telif m == 8:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 9:\n  \t\t\tprint 'c.***'\n  \t\t\tprint '..***'\n  \t\t\tprint '..***'\n  \t\telif m == 10:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 11:\n  \t\t\tprint 'c.***'\n  \t\t\tprint '..***'\n  \t\t\tprint '*****'\n  \t\telif m == 12:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 13:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 14:\n  \t\t\tprint 'c****'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \telif c == 5 and r == 4:\n  \t\tif m == 1:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '....*'\n  \t\telif m == 2:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '...**'\n  \t\telif m == 3:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '..***'\n  \t\telif m == 4:\n  \t\t\tprint 'c...*'\n  \t\t\tprint '....*'\n  \t\t\tprint '....*'\n  \t\t\tprint '....*'\n  \t\telif m == 5:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '*****'\n  \t\telif m == 6:\n  \t\t\tprint 'c...*'\n  \t\t\tprint '....*'\n  \t\t\tprint '....*'\n  \t\t\tprint '..***'\n  \t\telif m == 7:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '...**'\n  \t\t\tprint '*****'\n  \t\telif m == 8:\n  \t\t\tprint 'c..**'\n  \t\t\tprint '...**'\n  \t\t\tprint '...**'\n  \t\t\tprint '...**'\n  \t\telif m == 9:\n  \t\t\tprint 'c...*'\n  \t\t\tprint '....*'\n  \t\t\tprint '...**'\n  \t\t\tprint '*****'\n  \t\telif m == 10:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\telif m == 11:\n  \t\t\tprint 'c..**'\n  \t\t\tprint '...**'\n  \t\t\tprint '...**'\n  \t\t\tprint '*****'\n  \t\telif m == 12:\n  \t\t\tprint 'c.***'\n  \t\t\tprint '..***'\n  \t\t\tprint '..***'\n  \t\t\tprint '..***'\n  \t\telif m == 13:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 14:\n  \t\t\tprint 'c.***'\n  \t\t\tprint '..***'\n  \t\t\tprint '..***'\n  \t\t\tprint '*****'\n  \t\telif m == 15:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 16:\n  \t\t\tprint 'c.***'\n  \t\t\tprint '..***'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\telif m == 17:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 18:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 19:\n  \t\t\tprint 'c****'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \telif c == 5 and r == 5:\n  \t\tif m == 1:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '....*'\n  \t\telif m == 2:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '...**'\n  \t\telif m == 3:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '..***'\n  \t\telif m == 4:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '...**'\n  \t\t\tprint '...**'\n  \t\telif m == 5:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '*****'\n  \t\telif m == 6:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '..***'\n  \t\t\tprint '..***'\n  \t\telif m == 7:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '...**'\n  \t\t\tprint '*****'\n  \t\telif m == 8:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '..***'\n  \t\t\tprint '*****'\n  \t\telif m == 9:\n  \t\t\tprint 'c...*'\n  \t\t\tprint '....*'\n  \t\t\tprint '....*'\n  \t\t\tprint '....*'\n  \t\t\tprint '*****'\n  \t\telif m == 10:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\telif m == 11:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '....*'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\telif m == 12:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '...**'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\telif m == 13:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '..***'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\telif m == 14:\n  \t\t\tprint 'c..**'\n  \t\t\tprint '...**'\n  \t\t\tprint '...**'\n  \t\t\tprint '..***'\n  \t\t\tprint '*****'\n  \t\telif m == 15:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\telif m == 16:\n  \t\t\tprint 'c..**'\n  \t\t\tprint '...**'\n  \t\t\tprint '...**'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\telif m == 17:\n  \t\t\tprint 'c..**'\n  \t\t\tprint '...**'\n  \t\t\tprint '..***'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\telif m == 18:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 19:\n  \t\t\tprint 'c..**'\n  \t\t\tprint '...**'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\telif m == 20:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 21:\n  \t\t\tprint 'c.***'\n  \t\t\tprint '..***'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\telif m == 22:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 23:\n  \t\t\tprint 'Impossible'\n  \t\telif m == 24:\n  \t\t\tprint 'c****'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \telse:\n  \t\tprint 'Impossible'\n  \n ", "Adversarial Code": "t = int(raw_input())\n  \n  for ice in range(t):\n  \tprint 'Case #'+str(ice+1)+':'\n  \terr, rc, ur = raw_input().split()\n  \terr = int(err)\n  \trc = int(rc)\n  \tur = int(ur)\n  \n  \tif ur==0:\n  \t\tprint 'c' + ('.'*(rc-1))\n  \t\tfor i in range(err-1):\n  \t\t\tprint '.'*rc\n  \telif err == 1:\n  \t\tprint 'c'+('.'*(rc-ur-1))+('*'*(ur))\n  \telif rc == 1:\n  \t\tprint 'c'\n  \t\tfor i in range(err-ur-1):\n  \t\t\tprint '.'\n  \t\tfor i in range(ur):\n  \t\t\tprint '*'\n  \telif err == 2:\n  \t\tif ur%2==0 and rc>2 and ur<err*rc-2:\n  \t\t\tprint 'c'+('.'*(rc-ur/2-1))+('*'*(ur/2))\n  \t\t\tprint ('.'*(rc-ur/2))+('*'*(ur/2))\n  \t\telif ur == err*rc - 1:\n  \t\t\tprint 'c'+('*'*(rc-1))\n  \t\t\tprint '*'*rc\n  \t\telse:\n  \t\t\tprint 'Impossible'\n  \telif rc == 2:\n  \t\tif ur%2==0 and err>2 and ur<err*rc-2:\n  \t\t\tprint 'c.'\n  \t\t\tfor i in range(err-ur/2-1):\n  \t\t\t\tprint '..'\n  \t\t\tfor i in range(ur/2):\n  \t\t\t\tprint '**'\n  \t\telif ur == err*rc - 1:\n  \t\t\tprint 'c*'\n  \t\t\tfor i in range(err-1):\n  \t\t\t\tprint '**'\n  \t\telse:\n  \t\t\tprint 'Impossible'\n  \telif rc == 3 and err == 3:\n  \t\tif ur == 1:\n  \t\t\tprint 'c..'\n  \t\t\tprint '...'\n  \t\t\tprint '..*'\n  \t\telif ur == 2:\n  \t\t\tprint 'Impossible'\n  \t\telif ur == 3:\n  \t\t\tprint 'c..'\n  \t\t\tprint '...'\n  \t\t\tprint '***'\n  \t\telif ur == 4:\n  \t\t\tprint 'Impossible'\n  \t\telif ur == 5:\n  \t\t\tprint 'c.*'\n  \t\t\tprint '..*'\n  \t\t\tprint '***'\n  \t\telif ur == 6:\n  \t\t\tprint 'Impossible'\n  \t\telif ur == 7:\n  \t\t\tprint 'Impossible'\n  \t\telif ur == 8:\n  \t\t\tprint 'c**'\n  \t\t\tprint '***'\n  \t\t\tprint '***'\n  \telif rc == 3 and err == 4:\n  \t\tif ur == 1:\n  \t\t\tprint 'c..'\n  \t\t\tprint '...'\n  \t\t\tprint '...'\n  \t\t\tprint '..*'\n  \t\telif ur == 2:\n  \t\t\tprint 'c..'\n  \t\t\tprint '...'\n  \t\t\tprint '..*'\n  \t\t\tprint '..*'\n  \t\telif ur == 3:\n  \t\t\tprint 'c..'\n  \t\t\tprint '...'\n  \t\t\tprint '...'\n  \t\t\tprint '***'\n  \t\telif ur == 4:\n  \t\t\tprint 'c.*'\n  \t\t\tprint '..*'\n  \t\t\tprint '..*'\n  \t\t\tprint '..*'\n  \t\telif ur == 5:\n  \t\t\tprint 'Impossible'\n  \t\telif ur == 6:\n  \t\t\tprint 'c..'\n  \t\t\tprint '...'\n  \t\t\tprint '***'\n  \t\t\tprint '***'\n  \t\telif ur == 7:\n  \t\t\tprint 'Impossible'\n  \t\telif ur == 8:\n  \t\t\tprint 'c.*'\n  \t\t\tprint '..*'\n  \t\t\tprint '***'\n  \t\t\tprint '***'\n  \t\telif ur == 9:\n  \t\t\tprint 'Impossible'\n  \t\telif ur == 10:\n  \t\t\tprint 'Impossible'\n  \t\telif ur == 11:\n  \t\t\tprint 'c**'\n  \t\t\tprint '***'\n  \t\t\tprint '***'\n  \t\t\tprint '***'\n  \telif rc == 3 and err == 5:\n  \t\tif ur == 1:\n  \t\t\tprint 'c..'\n  \t\t\tprint '...'\n  \t\t\tprint '...'\n  \t\t\tprint '...'\n  \t\t\tprint '..*'\n  \t\telif ur == 2:\n  \t\t\tprint 'c..'\n  \t\t\tprint '...'\n  \t\t\tprint '...'\n  \t\t\tprint '..*'\n  \t\t\tprint '..*'\n  \t\telif ur == 3:\n  \t\t\tprint 'c..'\n  \t\t\tprint '...'\n  \t\t\tprint '..*'\n  \t\t\tprint '..*'\n  \t\t\tprint '..*'\n  \t\telif ur == 4:\n  \t\t\tprint 'c..'\n  \t\t\tprint '...'\n  \t\t\tprint '...'\n  \t\t\tprint '..*'\n  \t\t\tprint '***'\n  \t\telif ur == 5:\n  \t\t\tprint 'c.*'\n  \t\t\tprint '..*'\n  \t\t\tprint '..*'\n  \t\t\tprint '..*'\n  \t\t\tprint '..*'\n  \t\telif ur == 6:\n  \t\t\tprint 'c..'\n  \t\t\tprint '...'\n  \t\t\tprint '...'\n  \t\t\tprint '***'\n  \t\t\tprint '***'\n  \t\telif ur == 7:\n  \t\t\tprint 'c..'\n  \t\t\tprint '...'\n  \t\t\tprint '..*'\n  \t\t\tprint '***'\n  \t\t\tprint '***'\n  \t\telif ur == 8:\n  \t\t\tprint 'Impossible'\n  \t\telif ur == 9:\n  \t\t\tprint 'c..'\n  \t\t\tprint '...'\n  \t\t\tprint '***'\n  \t\t\tprint '***'\n  \t\t\tprint '***'\n  \t\telif ur == 10:\n  \t\t\tprint 'Impossible'\n  \t\telif ur == 11:\n  \t\t\tprint 'c.*'\n  \t\t\tprint '..*'\n  \t\t\tprint '***'\n  \t\t\tprint '***'\n  \t\t\tprint '***'\n  \t\telif ur == 12:\n  \t\t\tprint 'Impossible'\n  \t\telif ur == 13:\n  \t\t\tprint 'Impossible'\n  \t\telif ur == 14:\n  \t\t\tprint 'c**'\n  \t\t\tprint '***'\n  \t\t\tprint '***'\n  \t\t\tprint '***'\n  \t\t\tprint '***'\n  \telif rc == 4 and err == 3:\n  \t\tif ur == 1:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '...*'\n  \t\telif ur == 2:\n  \t\t\tprint 'c...'\n  \t\t\tprint '...*'\n  \t\t\tprint '...*'\n  \t\telif ur == 3:\n  \t\t\tprint 'c..*'\n  \t\t\tprint '...*'\n  \t\t\tprint '...*'\n  \t\telif ur == 4:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '****'\n  \t\telif ur == 5:\n  \t\t\tprint 'Impossible'\n  \t\telif ur == 6:\n  \t\t\tprint 'c.**'\n  \t\t\tprint '..**'\n  \t\t\tprint '..**'\n  \t\telif ur == 7:\n  \t\t\tprint 'Impossible'\n  \t\telif ur == 8:\n  \t\t\tprint 'c.**'\n  \t\t\tprint '..**'\n  \t\t\tprint '****'\n  \t\telif ur == 9:\n  \t\t\tprint 'Impossible'\n  \t\telif ur == 10:\n  \t\t\tprint 'Impossible'\n  \t\telif ur == 11:\n  \t\t\tprint 'c***'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \telif rc == 4 and err == 4:\n  \t\tif ur == 1:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '....'\n  \t\t\tprint '...*'\n  \t\telif ur == 2:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '....'\n  \t\t\tprint '..**'\n  \t\telif ur == 3:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '...*'\n  \t\t\tprint '..**'\n  \t\telif ur == 4:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '....'\n  \t\t\tprint '****'\n  \t\telif ur == 5:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '...*'\n  \t\t\tprint '****'\n  \t\telif ur == 6:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '..**'\n  \t\t\tprint '****'\n  \t\telif ur == 7:\n  \t\t\tprint 'c..*'\n  \t\t\tprint '...*'\n  \t\t\tprint '...*'\n  \t\t\tprint '****'\n  \t\telif ur == 8:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \t\telif ur == 9:\n  \t\t\tprint 'Impossible'\n  \t\telif ur == 10:\n  \t\t\tprint 'c.**'\n  \t\t\tprint '..**'\n  \t\t\tprint '..**'\n  \t\t\tprint '****'\n  \t\telif ur == 11:\n  \t\t\tprint 'Impossible'\n  \t\telif ur == 12:\n  \t\t\tprint 'c.**'\n  \t\t\tprint '..**'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \t\telif ur == 13:\n  \t\t\tprint 'Impossible'\n  \t\telif ur == 14:\n  \t\t\tprint 'Impossible'\n  \t\telif ur == 15:\n  \t\t\tprint 'c***'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \telif rc == 4 and err == 5:\n  \t\tif ur == 1:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '....'\n  \t\t\tprint '....'\n  \t\t\tprint '...*'\n  \t\telif ur == 2:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '....'\n  \t\t\tprint '....'\n  \t\t\tprint '..**'\n  \t\telif ur == 3:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '...*'\n  \t\t\tprint '...*'\n  \t\t\tprint '...*'\n  \t\telif ur == 4:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '....'\n  \t\t\tprint '....'\n  \t\t\tprint '****'\n  \t\telif ur == 5:\n  \t\t\tprint 'c..*'\n  \t\t\tprint '...*'\n  \t\t\tprint '...*'\n  \t\t\tprint '...*'\n  \t\t\tprint '...*'\n  \t\telif ur == 6:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '....'\n  \t\t\tprint '..**'\n  \t\t\tprint '****'\n  \t\telif ur == 7:\n  \t\t\tprint 'c..*'\n  \t\t\tprint '...*'\n  \t\t\tprint '...*'\n  \t\t\tprint '..**'\n  \t\t\tprint '..**'\n  \t\telif ur == 8:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '....'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \t\telif ur == 9:\n  \t\t\tprint 'c..*'\n  \t\t\tprint '...*'\n  \t\t\tprint '...*'\n  \t\t\tprint '..**'\n  \t\t\tprint '****'\n  \t\telif ur == 10:\n  \t\t\tprint 'c.**'\n  \t\t\tprint '..**'\n  \t\t\tprint '..**'\n  \t\t\tprint '..**'\n  \t\t\tprint '..**'\n  \t\telif ur == 11:\n  \t\t\tprint 'c..*'\n  \t\t\tprint '...*'\n  \t\t\tprint '...*'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \t\telif ur == 12:\n  \t\t\tprint 'c...'\n  \t\t\tprint '....'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \t\telif ur == 13:\n  \t\t\tprint 'Impossible'\n  \t\telif ur == 14:\n  \t\t\tprint 'c..*'\n  \t\t\tprint '...*'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \t\telif ur == 15:\n  \t\t\tprint 'Impossible'\n  \t\telif ur == 16:\n  \t\t\tprint 'c.**'\n  \t\t\tprint '..**'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \t\telif ur == 17:\n  \t\t\tprint 'Impossible'\n  \t\telif ur == 18:\n  \t\t\tprint 'Impossible'\n  \t\telif ur == 19:\n  \t\t\tprint 'c***'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \t\t\tprint '****'\n  \telif rc == 5 and err == 3:\n  \t\tif ur == 1:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '....*'\n  \t\telif ur == 2:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '...**'\n  \t\telif ur == 3:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '..***'\n  \t\telif ur == 4:\n  \t\t\tprint 'c...*'\n  \t\t\tprint '....*'\n  \t\t\tprint '...**'\n  \t\telif ur == 5:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '*****'\n  \t\telif ur == 6:\n  \t\t\tprint 'c..**'\n  \t\t\tprint '...**'\n  \t\t\tprint '...**'\n  \t\telif ur == 7:\n  \t\t\tprint 'c..**'\n  \t\t\tprint '...**'\n  \t\t\tprint '..***'\n  \t\telif ur == 8:\n  \t\t\tprint 'Impossible'\n  \t\telif ur == 9:\n  \t\t\tprint 'c.***'\n  \t\t\tprint '..***'\n  \t\t\tprint '..***'\n  \t\telif ur == 10:\n  \t\t\tprint 'Impossible'\n  \t\telif ur == 11:\n  \t\t\tprint 'c.***'\n  \t\t\tprint '..***'\n  \t\t\tprint '*****'\n  \t\telif ur == 12:\n  \t\t\tprint 'Impossible'\n  \t\telif ur == 13:\n  \t\t\tprint 'Impossible'\n  \t\telif ur == 14:\n  \t\t\tprint 'c****'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \telif rc == 5 and err == 4:\n  \t\tif ur == 1:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '....*'\n  \t\telif ur == 2:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '...**'\n  \t\telif ur == 3:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '..***'\n  \t\telif ur == 4:\n  \t\t\tprint 'c...*'\n  \t\t\tprint '....*'\n  \t\t\tprint '....*'\n  \t\t\tprint '....*'\n  \t\telif ur == 5:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '*****'\n  \t\telif ur == 6:\n  \t\t\tprint 'c...*'\n  \t\t\tprint '....*'\n  \t\t\tprint '....*'\n  \t\t\tprint '..***'\n  \t\telif ur == 7:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '...**'\n  \t\t\tprint '*****'\n  \t\telif ur == 8:\n  \t\t\tprint 'c..**'\n  \t\t\tprint '...**'\n  \t\t\tprint '...**'\n  \t\t\tprint '...**'\n  \t\telif ur == 9:\n  \t\t\tprint 'c...*'\n  \t\t\tprint '....*'\n  \t\t\tprint '...**'\n  \t\t\tprint '*****'\n  \t\telif ur == 10:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\telif ur == 11:\n  \t\t\tprint 'c..**'\n  \t\t\tprint '...**'\n  \t\t\tprint '...**'\n  \t\t\tprint '*****'\n  \t\telif ur == 12:\n  \t\t\tprint 'c.***'\n  \t\t\tprint '..***'\n  \t\t\tprint '..***'\n  \t\t\tprint '..***'\n  \t\telif ur == 13:\n  \t\t\tprint 'Impossible'\n  \t\telif ur == 14:\n  \t\t\tprint 'c.***'\n  \t\t\tprint '..***'\n  \t\t\tprint '..***'\n  \t\t\tprint '*****'\n  \t\telif ur == 15:\n  \t\t\tprint 'Impossible'\n  \t\telif ur == 16:\n  \t\t\tprint 'c.***'\n  \t\t\tprint '..***'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\telif ur == 17:\n  \t\t\tprint 'Impossible'\n  \t\telif ur == 18:\n  \t\t\tprint 'Impossible'\n  \t\telif ur == 19:\n  \t\t\tprint 'c****'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \telif rc == 5 and err == 5:\n  \t\tif ur == 1:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '....*'\n  \t\telif ur == 2:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '...**'\n  \t\telif ur == 3:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '..***'\n  \t\telif ur == 4:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '...**'\n  \t\t\tprint '...**'\n  \t\telif ur == 5:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '*****'\n  \t\telif ur == 6:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '..***'\n  \t\t\tprint '..***'\n  \t\telif ur == 7:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '...**'\n  \t\t\tprint '*****'\n  \t\telif ur == 8:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '..***'\n  \t\t\tprint '*****'\n  \t\telif ur == 9:\n  \t\t\tprint 'c...*'\n  \t\t\tprint '....*'\n  \t\t\tprint '....*'\n  \t\t\tprint '....*'\n  \t\t\tprint '*****'\n  \t\telif ur == 10:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '.....'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\telif ur == 11:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '....*'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\telif ur == 12:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '...**'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\telif ur == 13:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '..***'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\telif ur == 14:\n  \t\t\tprint 'c..**'\n  \t\t\tprint '...**'\n  \t\t\tprint '...**'\n  \t\t\tprint '..***'\n  \t\t\tprint '*****'\n  \t\telif ur == 15:\n  \t\t\tprint 'c....'\n  \t\t\tprint '.....'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\telif ur == 16:\n  \t\t\tprint 'c..**'\n  \t\t\tprint '...**'\n  \t\t\tprint '...**'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\telif ur == 17:\n  \t\t\tprint 'c..**'\n  \t\t\tprint '...**'\n  \t\t\tprint '..***'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\telif ur == 18:\n  \t\t\tprint 'Impossible'\n  \t\telif ur == 19:\n  \t\t\tprint 'c..**'\n  \t\t\tprint '...**'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\telif ur == 20:\n  \t\t\tprint 'Impossible'\n  \t\telif ur == 21:\n  \t\t\tprint 'c.***'\n  \t\t\tprint '..***'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\telif ur == 22:\n  \t\t\tprint 'Impossible'\n  \t\telif ur == 23:\n  \t\t\tprint 'Impossible'\n  \t\telif ur == 24:\n  \t\t\tprint 'c****'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \t\t\tprint '*****'\n  \telse:\n  \t\tprint 'Impossible'\n  \n ", "Program Length": 2012, "Identifier Num": 6, "Replaced Identifiers": "m:ur,c:rc,r:err,case:ice,", "Query Times": 413, "Time Cost": 0.4249959707260132, "Type": "Greedy"}
{"Index": 7, "Original Code": "t = int(raw_input())\n  \n  for case in range(t):\n  \tr1 = int(raw_input())\n  \tc1 = []\n  \tfor j in range(4):\n  \t\tc1.append([int(i) for i in raw_input().split()])\n  \n  \tr2 = int(raw_input())\n  \tc2 = []\n  \tfor j in range(4):\n  \t\tc2.append([int(i) for i in raw_input().split()])\n  \n  \tnum = -1\n  \tpossibles = 0\n  \tfor j in c1[r1-1]:\n  \t\tif c2[r2-1].count(j) == 1:\n  \t\t\tnum = j\n  \t\t\tpossibles += 1\n  \n  \tif possibles > 1:\n  \t\tprint 'Case #'+str(case+1)+': Bad magician!'\n  \telif possibles == 0:\n  \t\tprint 'Case #'+str(case+1)+': Volunteer cheated!'\n  \telse:\n  \t\tprint 'Case #'+str(case+1)+': '+str(num)\n ", "Adversarial Code": "T = int(raw_input())\n  \n  for Case in range(T):\n  \tr1 = int(raw_input())\n  \tc1 = []\n  \tfor j in range(4):\n  \t\tc1.append([int(i) for i in raw_input().split()])\n  \n  \tr2 = int(raw_input())\n  \tc2 = []\n  \tfor j in range(4):\n  \t\tc2.append([int(i) for i in raw_input().split()])\n  \n  \tnum = -1\n  \tpossibles = 0\n  \tfor j in c1[r1-1]:\n  \t\tif c2[r2-1].count(j) == 1:\n  \t\t\tnum = j\n  \t\t\tpossibles += 1\n  \n  \tif possibles > 1:\n  \t\tprint 'Case #'+str(Case+1)+': Bad magician!'\n  \telif possibles == 0:\n  \t\tprint 'Case #'+str(Case+1)+': Volunteer cheated!'\n  \telse:\n  \t\tprint 'Case #'+str(Case+1)+': '+str(num)\n ", "Program Length": 186, "Identifier Num": 10, "Replaced Identifiers": "case:Case,t:T,", "Query Times": 128, "Time Cost": 0.07246675093968709, "Type": "Greedy"}
{"Index": 8, "Original Code": "def make_string(R, C, M):\n      grid = [['.' for j in xrange(C)] for i in xrange(R)]\n      grid[-1][-1] = 'c'\n      t = M\n      for i in xrange(R):\n          for j in xrange(C):\n              if M:\n                  if forbidden(R, C, t, i, j):\n                      continue\n                  grid[i][j] = '*'\n                  M -= 1\n              else:\n                  break\n      s = ''\n      if M:\n          return 'Impossible'\n      for r in grid:\n          s += ''.join(r)+'\n'\n      return s[:-1]\n  \n  def forbidden(R, C, M, i, j):\n      a = M / C\n      b = M % C\n      if (R*C - M == 1):\n          return False\n  \n      if i >= (R-2) and j >= (C-2):\n          return True\n  \n      if i >= (R-2) and b:\n          if b % 2:\n              return True\n          if j < b/2:\n              return False\n          else:\n              return True\n      return False\n          \n  \n  f = open('Csmall.in', 'r')\n  g = open('outputC.txt', 'w')\n  \n  data = [[int(e) for e in line.strip(\"\n\").split(' ')] for line in f]\n  T = int(data.pop(0)[0])\n  for i, case in enumerate(data):\n      R, C, M = case[0], case[1], case[2]\n      num_cells = R*C\n      if (R-1) == 0 or (C-1) == 0:\n          s = make_string(R, C, M)\n          g.write('Case #%i:\n%s\n' %(i+1,s))\n          continue\n      else:\n          s = make_string(R, C, M)\n          g.write('Case #%i:\n%s\n' %(i+1, s))\n          \n  \n  f.close()\n  g.close()\n ", "Adversarial Code": "def make_string(R, C, M):\n      grid = [['.' for j in xrange(C)] for i in xrange(R)]\n      grid[-1][-1] = 'c'\n      t = M\n      for i in xrange(R):\n          for j in xrange(C):\n              if M:\n                  if forbidden(R, C, t, i, j):\n                      continue\n                  grid[i][j] = '*'\n                  M -= 1\n              else:\n                  break\n      s = ''\n      if M:\n          return 'Impossible'\n      for result in grid:\n          s += ''.join(result)+'\n'\n      return s[:-1]\n  \n  def forbidden(R, C, M, i, j):\n      a = M / C\n      b = M % C\n      if (R*C - M == 1):\n          return False\n  \n      if i >= (R-2) and j >= (C-2):\n          return True\n  \n      if i >= (R-2) and b:\n          if b % 2:\n              return True\n          if j < b/2:\n              return False\n          else:\n              return True\n      return False\n          \n  \n  f = open('Csmall.in', 'r')\n  g = open('outputC.txt', 'w')\n  \n  code = [[int(e) for e in file.strip(\"\n\").split(' ')] for file in f]\n  T = int(code.pop(0)[0])\n  for i, case in enumerate(code):\n      R, C, M = case[0], case[1], case[2]\n      num_cells = R*C\n      if (R-1) == 0 or (C-1) == 0:\n          s = make_string(R, C, M)\n          g.write('Case #%i:\n%s\n' %(i+1,s))\n          continue\n      else:\n          s = make_string(R, C, M)\n          g.write('Case #%i:\n%s\n' %(i+1, s))\n          \n  \n  f.close()\n  g.close()\n ", "Program Length": 392, "Identifier Num": 21, "Replaced Identifiers": "data:code,r:result,line:file,", "Query Times": 212, "Time Cost": 0.1426013429959615, "Type": "Greedy"}
{"Index": 9, "Original Code": "f = open('A.in', 'r')\n  g = open('outputA.txt', 'w')\n  data = [[int(e) for e in line.strip(\"\n\").split(' ')] for line in f]\n  T = data[0][0]\n  c = 0\n  for i in xrange(1, T*10 + 1, 10):\n      c += 1\n      choice1 = data[i][0]\n      choice2 = data[i+5][0]\n      grid1, grid2 = [], []\n      for j in xrange(1,5):\n          grid1.append(data[i+j])\n  \n      for j in xrange(6, 10):\n          grid2.append(data[i+j])\n  \n      s1 = set(grid1[choice1-1])\n      s2 = set(grid2[choice2-1])\n  \n      s = s1 & s2\n      if len(s) == 1:\n          g.write(\"Case #%i: %i\n\" %(c, s.pop()))\n      elif not s:\n          g.write(\"Case #%i: Volunteer cheated!\n\" %(c))\n      else:\n          g.write(\"Case #%i: Bad magician!\n\" %(c))\n  \n  f.close()\n  g.close()\n      \n ", "Adversarial Code": "file = open('A.in', 'r')\n  g = open('outputA.txt', 'w')\n  call = [[int(e) for e in line.strip(\"\n\").split(' ')] for line in file]\n  T = call[0][0]\n  c = 0\n  for i in xrange(1, T*10 + 1, 10):\n      c += 1\n      choice1 = call[i][0]\n      choice2 = call[i+5][0]\n      grid1, grid2 = [], []\n      for j in xrange(1,5):\n          grid1.append(call[i+j])\n  \n      for j in xrange(6, 10):\n          grid2.append(call[i+j])\n  \n      s1 = set(grid1[choice1-1])\n      s2 = set(grid2[choice2-1])\n  \n      s = s1 & s2\n      if len(s) == 1:\n          g.write(\"Case #%i: %i\n\" %(c, s.pop()))\n      elif not s:\n          g.write(\"Case #%i: Volunteer cheated!\n\" %(c))\n      else:\n          g.write(\"Case #%i: Bad magician!\n\" %(c))\n  \n  file.close()\n  g.close()\n      \n ", "Program Length": 240, "Identifier Num": 16, "Replaced Identifiers": "f:file,data:call,", "Query Times": 155, "Time Cost": 0.08845212856928507, "Type": "Greedy"}
{"Index": 10, "Original Code": " \n  if __name__ == \"__main__\":\n      f = sys.stdin\n      if len(sys.argv) >= 2:\n          fn = sys.argv[1]\n          if fn != '-':\n              f = open(fn)\n  \n      T = int(f.readline())\n      for _T in xrange(T):\n          R, C, M = map(int, f.readline().split())\n  \n          print \"Case #%d:\" % (_T+1)\n  \n          left = R * C - M\n  \n          if R == 1:\n              s = 'c'\n              s += '.' * (left - 1)\n              s += '*' * M\n              print s\n              continue\n          if C == 1:\n              print 'c'\n              for i in xrange(left - 1):\n                  print '.'\n              for i in xrange(M):\n                  print '*'\n              continue\n  \n          if left == 1:\n              print 'c' + '*' * (C-1)\n              for i in xrange(R-1):\n                  print '*' * C\n              continue\n  \n          if (R == 2 or C == 2) and (M % 2 == 1 or left == 2):\n              print \"Impossible\"\n              continue\n          if R == 2:\n              assert left not in (2, 3, 5, 7)\n              assert left >= 4\n              print 'c' + '.' * (left/2 - 1) + '*' * (M/2)\n              print '.' + '.' * (left/2 - 1) + '*' * (M/2)\n              continue\n          if C == 2:\n              assert left >= 4\n              assert left not in (2, 3, 5, 7)\n              print 'c.'\n              left -= 2\n              R -= 1\n              while left:\n                  print '..'\n                  left -= 2\n                  R -= 1\n              assert R >= 0\n              while R:\n                  print '**'\n                  R -= 1\n              continue\n  \n          assert R >= 3\n          assert C >= 3\n  \n          if left == 4:\n              print 'c.' + '*' * (C-2)\n              print '..' + '*' * (C-2)\n              for i in xrange(R-2):\n                  print '*' * C\n              continue\n  \n          if left in (2, 3, 5, 7):\n              print \"Impossible\"\n              continue\n  \n          assert left >= 6\n  \n          cols = max(3, (left + R-1) // R)\n  \n          if left % cols == 1:\n              assert left >= 10\n  \n              print 'c' + '.' * (cols - 1) + '*' * (C - cols)\n              left -= cols\n              R -= 1\n  \n              while left > cols + 1:\n                  print '.' * cols + '*' * (C - cols)\n                  left -= cols\n                  R -= 1\n              assert left == cols + 1\n              print '.' * (cols - 1) + '*' * (C - cols + 1)\n              print '.' * (2) + '*' * (C - 2)\n              R -= 2\n  \n              assert R >= 0\n  \n              while R:\n                  print '*' * C\n                  R -= 1\n              continue\n          else:\n              assert left >= 6\n  \n              print 'c' + '.' * (cols - 1) + '*' * (C - cols)\n              left -= cols\n              R -= 1\n  \n              while left > cols:\n                  print '.' * cols + '*' * (C - cols)\n                  left -= cols\n                  R -= 1\n              assert left >= 2\n              print '.' * (left) + '*' * (C - left)\n              R -= 1\n  \n              assert R >= 0\n  \n              while R:\n                  print '*' * C\n                  R -= 1\n              continue\n  \n          1/0\n ", "Adversarial Code": " \n  if __name__ == \"__main__\":\n      f = sys.stdin\n      if len(sys.argv) >= 2:\n          utf = sys.argv[1]\n          if utf != '-':\n              f = open(utf)\n  \n      T = int(f.readline())\n      for _T in xrange(T):\n          R, C, M = map(int, f.readline().split())\n  \n          print \"Case #%d:\" % (_T+1)\n  \n          left = R * C - M\n  \n          if R == 1:\n              s = 'c'\n              s += '.' * (left - 1)\n              s += '*' * M\n              print s\n              continue\n          if C == 1:\n              print 'c'\n              for i in xrange(left - 1):\n                  print '.'\n              for i in xrange(M):\n                  print '*'\n              continue\n  \n          if left == 1:\n              print 'c' + '*' * (C-1)\n              for i in xrange(R-1):\n                  print '*' * C\n              continue\n  \n          if (R == 2 or C == 2) and (M % 2 == 1 or left == 2):\n              print \"Impossible\"\n              continue\n          if R == 2:\n              assert left not in (2, 3, 5, 7)\n              assert left >= 4\n              print 'c' + '.' * (left/2 - 1) + '*' * (M/2)\n              print '.' + '.' * (left/2 - 1) + '*' * (M/2)\n              continue\n          if C == 2:\n              assert left >= 4\n              assert left not in (2, 3, 5, 7)\n              print 'c.'\n              left -= 2\n              R -= 1\n              while left:\n                  print '..'\n                  left -= 2\n                  R -= 1\n              assert R >= 0\n              while R:\n                  print '**'\n                  R -= 1\n              continue\n  \n          assert R >= 3\n          assert C >= 3\n  \n          if left == 4:\n              print 'c.' + '*' * (C-2)\n              print '..' + '*' * (C-2)\n              for i in xrange(R-2):\n                  print '*' * C\n              continue\n  \n          if left in (2, 3, 5, 7):\n              print \"Impossible\"\n              continue\n  \n          assert left >= 6\n  \n          cols = max(3, (left + R-1) // R)\n  \n          if left % cols == 1:\n              assert left >= 10\n  \n              print 'c' + '.' * (cols - 1) + '*' * (C - cols)\n              left -= cols\n              R -= 1\n  \n              while left > cols + 1:\n                  print '.' * cols + '*' * (C - cols)\n                  left -= cols\n                  R -= 1\n              assert left == cols + 1\n              print '.' * (cols - 1) + '*' * (C - cols + 1)\n              print '.' * (2) + '*' * (C - 2)\n              R -= 2\n  \n              assert R >= 0\n  \n              while R:\n                  print '*' * C\n                  R -= 1\n              continue\n          else:\n              assert left >= 6\n  \n              print 'c' + '.' * (cols - 1) + '*' * (C - cols)\n              left -= cols\n              R -= 1\n  \n              while left > cols:\n                  print '.' * cols + '*' * (C - cols)\n                  left -= cols\n                  R -= 1\n              assert left >= 2\n              print '.' * (left) + '*' * (C - left)\n              R -= 1\n  \n              assert R >= 0\n  \n              while R:\n                  print '*' * C\n                  R -= 1\n              continue\n  \n          1/0\n ", "Program Length": 612, "Identifier Num": 11, "Replaced Identifiers": "fn:utf,", "Query Times": 173, "Time Cost": 0.1045784076054891, "Type": "Greedy"}
{"Index": 11, "Original Code": " \n  if __name__ == \"__main__\":\n      f = sys.stdin\n      if len(sys.argv) >= 2:\n          fn = sys.argv[1]\n          if fn != '-':\n              f = open(fn)\n  \n      T = int(f.readline())\n      for _T in xrange(T):\n          a1 = int(f.readline())\n          l1 = [map(int, f.readline().split()) for _ in xrange(4)]\n          a2 = int(f.readline())\n          l2 = [map(int, f.readline().split()) for _ in xrange(4)]\n  \n          poss = list(set(l1[a1-1]) & set(l2[a2-1]))\n  \n          print \"Case #%d:\" % (_T + 1),\n          if len(poss) == 0:\n              print \"Volunteer cheated!\"\n          elif len(poss) == 1:\n              print poss[0]\n          else:\n              print \"Bad magician!\"\n ", "Adversarial Code": " \n  if __name__ == \"__main__\":\n      f = sys.stdin\n      if len(sys.argv) >= 2:\n          fin = sys.argv[1]\n          if fin != '-':\n              f = open(fin)\n  \n      T = int(f.readline())\n      for _T in xrange(T):\n          a1 = int(f.readline())\n          l1 = [map(int, f.readline().split()) for _ in xrange(4)]\n          a2 = int(f.readline())\n          l2 = [map(int, f.readline().split()) for _ in xrange(4)]\n  \n          poss = list(set(l1[a1-1]) & set(l2[a2-1]))\n  \n          print \"Case #%d:\" % (_T + 1),\n          if len(poss) == 0:\n              print \"Volunteer cheated!\"\n          elif len(poss) == 1:\n              print poss[0]\n          else:\n              print \"Bad magician!\"\n ", "Program Length": 187, "Identifier Num": 10, "Replaced Identifiers": "fn:fin,", "Query Times": 81, "Time Cost": 0.042799413204193115, "Type": "Greedy"}
{"Index": 12, "Original Code": " \n  \n  TEST_CASES = [\n      (\"\"\"5\n  5 5 23\n  3 1 1\n  2 2 1\n  4 7 3\n  10 10 82\n  \"\"\",\"\"\"Case #1:\n  Impossible\n  Case #2:\n  c\n  .\n  *\n  Case #3:\n  Impossible\n  Case #4:\n  c......\n  .......\n  .......\n  ....***\n  Case #5:\n  c........*\n  .........*\n  **********\n  **********\n  **********\n  **********\n  **********\n  **********\n  **********\n  **********\n  \"\"\"),\n      (\"\"\"3\n  5 4 3\n  5 3 8\n  5 5 14\n  \"\"\",\"\"\"Case #1:\n  c...\n  ....\n  ....\n  ...*\n  ..**\n  Case #2:\n  Impossible\n  Case #3:\n  c...*\n  ....*\n  ...**\n  *****\n  *****\n  \"\"\")\n  ]\n  \n  IMPOSSIBLE = \"Impossible\"\n  \n  \"\"\"\n  S is number of safe squares = (R*C) - M\n  If S == 1 then always possible:\n      Assume click in top left, all else mines\n  Special cases (R or C is small):\n  If R == 1 or C == 1 then always possible:\n      Assume click in top left and all safe squares in a line\n  Else if R == 2 or C == 2 then possible iff S % 2 == 0:\n      Assume click in top left and all safe squares are in a 2 * X line\n  Else if R == 3 or C == 3 then possible if S % 3 == 0 (Assume click in top left and all safe squares are in a 3 * X line)\n     OR if S % 2 == 0 \n  \"\"\"\n  \n  def parse_input(input_reader):\n      case_count = int(input_reader.readline())\n      case_idx = 0\n      while case_count > case_idx:\n          case_idx += 1\n          input_line = [int(x) for x in input_reader.readline().split()]\n          input_values = {\"case\": case_idx,\n                          \"R\": input_line[0],\n                          \"C\": input_line[1],\n                          \"M\": input_line[2]}\n          yield input_values\n  \n  \n  def solve_problem(output_writer=sys.stdout, **kwargs):\n      case = kwargs['case']\n      rows = kwargs['R']\n      cols = kwargs['C']\n      mines = kwargs['M']\n      safe_squares = ((rows * cols) - mines)\n      print >> output_writer, \"Case #%d:\" % case\n      row_string = \"{:*<%ds}\" % cols\n      impossible = False\n      if safe_squares == 1:\n          print >> output_writer, row_string.format(\"c\")\n          for row in range(1, rows):\n              print >> output_writer, row_string.format(\"\")\n      elif rows == 1:\n          safe_string = \"c\" + (\".\" * (safe_squares - 1))\n          print >> output_writer, row_string.format(safe_string)\n      elif cols == 1:\n          for row in range(rows):\n              cell = \"\"\n              if row == 0:\n                  cell = \"c\"\n              elif row < safe_squares:\n                  cell = \".\"\n              print >> output_writer, row_string.format(cell)\n      elif safe_squares == 2:\n          impossible = True\n      elif rows == 2:\n          safe_cols, remainder = divmod(safe_squares, 2)\n          if remainder == 1:\n              impossible = True\n          else:\n              safe_string = \".\" * (safe_cols - 1)\n              print >> output_writer, row_string.format(\"c%s\" % safe_string)\n              print >> output_writer, row_string.format(\".%s\" % safe_string)\n      elif cols == 2:\n          safe_rows, remainder = divmod(safe_squares, 2)\n          if remainder == 1:\n              impossible = True\n          else:\n              for row in range(rows):\n                  cells = \"\"\n                  if row == 0:\n                      cells = \"c.\"\n                  elif row < safe_rows:\n                      cells = \"..\"\n                  print >> output_writer, row_string.format(cells)\n      else:\n          safe_rows, remainder = divmod(safe_squares, cols)\n          if remainder == 1 and cols == 3 and safe_rows == 2:\n              impossible = True\n          elif safe_rows > 1:\n              if remainder == 1 and safe_rows == 2:\n                  mid_safe = \".\" * (cols-2)\n                  for row in range(rows):\n                      cell_one = \".\"\n                      mid_cells = mid_safe\n                      last_cell = \".\"\n                      if row == 0:\n                          cell_one = \"c\"\n                      elif safe_rows == 0:\n                          cell_one = \".\"\n                          mid_cells = \".\" * (remainder + 1)\n                      elif safe_rows < 0:\n                          cell_one = \"\"\n                          mid_cells = \"\"\n                      if safe_rows < 3:\n                          last_cell = \"\"\n                      print >> output_writer, row_string.format(\"%s%s%s\" % (cell_one, mid_cells, last_cell))\n                      safe_rows -= 1\n              elif remainder == 1:\n                  mid_safe = \".\" * (cols-2)\n                  for row in range(rows):\n                      cell_one = \".\"\n                      mid_cells = mid_safe\n                      last_cell = \".\"\n                      if row == 0:\n                          cell_one = \"c\"\n                      elif safe_rows == 0:\n                          cell_one = \".\"\n                          mid_cells = \".\" * remainder\n                      elif safe_rows < 0:\n                          cell_one = \"\"\n                          mid_cells = \"\"\n                      if safe_rows < 2:\n                          last_cell = \"\"\n                      print >> output_writer, row_string.format(\"%s%s%s\" % (cell_one, mid_cells, last_cell))\n                      safe_rows -= 1\n              else:\n                  full_safe = \".\" * cols\n                  for row in range(rows):\n                      cells = full_safe\n                      if row == 0:\n                          cells = \"c\" + (\".\" * (cols - 1))\n                      elif row == safe_rows:\n                          cells = \".\" * remainder\n                      elif row > safe_rows:\n                          cells = \"\"\n                      print >> output_writer, row_string.format(cells)\n          else:\n              safe_cols, remainder = divmod(safe_squares, 2)\n              if remainder == 1 and safe_cols < 4:\n                  impossible = True\n              elif remainder == 0:\n                  print >> output_writer, row_string.format(\"c%s\" % (\".\" * (safe_cols - 1)))\n                  print >> output_writer, row_string.format(\".\" * safe_cols)\n                  for row in range(2, rows):\n                      print >> output_writer, row_string.format(\"\")\n              else:\n                  safe_cols -= 1\n                  print >> output_writer, row_string.format(\"c%s\" % (\".\" * (safe_cols - 1)))\n                  print >> output_writer, row_string.format(\".\" * safe_cols)\n                  print >> output_writer, row_string.format(\"...\")\n                  for row in range(3, rows):\n                      print >> output_writer, row_string.format(\"\")\n      if impossible:\n          print >> output_writer, IMPOSSIBLE\n  \n  def solve_inputs(input_reader, output_writer):\n      \"\"\"\n      Loop through each problem input in input reader and solve it.\n  \n      Outputs responses to output_writer.\n      \"\"\"\n      for input_values in parse_input(input_reader):\n          solve_problem(output_writer=output_writer, **input_values)\n  \n  def run_tests():\n      idx = 0\n      all_pass = True\n      for problem_input, expected_output in TEST_CASES:\n          idx += 1\n          input_reader = StringIO(problem_input)\n          output_writer = StringIO()\n          solve_inputs(input_reader, output_writer)\n          problem_output = output_writer.getvalue()\n          if problem_output == expected_output:\n              print \"Test %d: Success\" % idx\n          else:\n              all_pass = False\n              print \"Test %d: Failure\" % idx\n              print problem_output\n          input_reader.close()\n          output_writer.close()\n      if all_pass:\n          print \"All tests were successful!\"\n      else:\n          print \"Something didn't match - try again.\"\n  \n  def main():\n      parser = OptionParser()\n      parser.add_option(\"-f\", \"--file\",\n                        dest=\"filename_stem\",\n                        help=\"read input from FILE.in and write to FILE.out\",\n                        metavar=\"FILE\")\n  \n      (options, args) = parser.parse_args()\n      if options.filename_stem:\n          print \"Running in file mode.\"\n          input_reader = open(\"%s.in\" % options.filename_stem, \"r\")\n          output_writer = open(\"%s.out\" % options.filename_stem, \"w\")\n          solve_inputs(input_reader, output_writer)\n      else:\n          print \"Running in test mode.\"\n          run_tests()\n  \n  if __name__ == \"__main__\":\n      main()\n ", "Adversarial Code": " \n  \n  TEST_CASES = [\n      (\"\"\"5\n  5 5 23\n  3 1 1\n  2 2 1\n  4 7 3\n  10 10 82\n  \"\"\",\"\"\"Case #1:\n  Impossible\n  Case #2:\n  c\n  .\n  *\n  Case #3:\n  Impossible\n  Case #4:\n  c......\n  .......\n  .......\n  ....***\n  Case #5:\n  c........*\n  .........*\n  **********\n  **********\n  **********\n  **********\n  **********\n  **********\n  **********\n  **********\n  \"\"\"),\n      (\"\"\"3\n  5 4 3\n  5 3 8\n  5 5 14\n  \"\"\",\"\"\"Case #1:\n  c...\n  ....\n  ....\n  ...*\n  ..**\n  Case #2:\n  Impossible\n  Case #3:\n  c...*\n  ....*\n  ...**\n  *****\n  *****\n  \"\"\")\n  ]\n  \n  IMPOSSIBLE = \"Impossible\"\n  \n  \"\"\"\n  S is number of safe squares = (R*C) - M\n  If S == 1 then always possible:\n      Assume click in top left, all else mines\n  Special cases (R or C is small):\n  If R == 1 or C == 1 then always possible:\n      Assume click in top left and all safe squares in a line\n  Else if R == 2 or C == 2 then possible iff S % 2 == 0:\n      Assume click in top left and all safe squares are in a 2 * X line\n  Else if R == 3 or C == 3 then possible if S % 3 == 0 (Assume click in top left and all safe squares are in a 3 * X line)\n     OR if S % 2 == 0 \n  \"\"\"\n  \n  def parsetheoutput(control_editor):\n      case_count = int(control_editor.readline())\n      case_idx = 0\n      while case_count > case_idx:\n          case_idx += 1\n          input_line = [int(x) for x in control_editor.readline().split()]\n          input_values = {\"case\": case_idx,\n                          \"R\": input_line[0],\n                          \"C\": input_line[1],\n                          \"M\": input_line[2]}\n          yield input_values\n  \n  \n  def solve_problem(output_writer=sys.stdout, **kwargs):\n      case = kwargs['case']\n      rows = kwargs['R']\n      cols = kwargs['C']\n      mines = kwargs['M']\n      safe_squares = ((rows * cols) - mines)\n      print >> output_writer, \"Case #%d:\" % case\n      row_string = \"{:*<%ds}\" % cols\n      impossible = False\n      if safe_squares == 1:\n          print >> output_writer, row_string.format(\"c\")\n          for row in range(1, rows):\n              print >> output_writer, row_string.format(\"\")\n      elif rows == 1:\n          safe_string = \"c\" + (\".\" * (safe_squares - 1))\n          print >> output_writer, row_string.format(safe_string)\n      elif cols == 1:\n          for row in range(rows):\n              cell = \"\"\n              if row == 0:\n                  cell = \"c\"\n              elif row < safe_squares:\n                  cell = \".\"\n              print >> output_writer, row_string.format(cell)\n      elif safe_squares == 2:\n          impossible = True\n      elif rows == 2:\n          safe_cols, remainder = divmod(safe_squares, 2)\n          if remainder == 1:\n              impossible = True\n          else:\n              safe_string = \".\" * (safe_cols - 1)\n              print >> output_writer, row_string.format(\"c%s\" % safe_string)\n              print >> output_writer, row_string.format(\".%s\" % safe_string)\n      elif cols == 2:\n          safe_rows, remainder = divmod(safe_squares, 2)\n          if remainder == 1:\n              impossible = True\n          else:\n              for row in range(rows):\n                  cells = \"\"\n                  if row == 0:\n                      cells = \"c.\"\n                  elif row < safe_rows:\n                      cells = \"..\"\n                  print >> output_writer, row_string.format(cells)\n      else:\n          safe_rows, remainder = divmod(safe_squares, cols)\n          if remainder == 1 and cols == 3 and safe_rows == 2:\n              impossible = True\n          elif safe_rows > 1:\n              if remainder == 1 and safe_rows == 2:\n                  mid_safe = \".\" * (cols-2)\n                  for row in range(rows):\n                      cell_one = \".\"\n                      mid_cells = mid_safe\n                      last_cell = \".\"\n                      if row == 0:\n                          cell_one = \"c\"\n                      elif safe_rows == 0:\n                          cell_one = \".\"\n                          mid_cells = \".\" * (remainder + 1)\n                      elif safe_rows < 0:\n                          cell_one = \"\"\n                          mid_cells = \"\"\n                      if safe_rows < 3:\n                          last_cell = \"\"\n                      print >> output_writer, row_string.format(\"%s%s%s\" % (cell_one, mid_cells, last_cell))\n                      safe_rows -= 1\n              elif remainder == 1:\n                  mid_safe = \".\" * (cols-2)\n                  for row in range(rows):\n                      cell_one = \".\"\n                      mid_cells = mid_safe\n                      last_cell = \".\"\n                      if row == 0:\n                          cell_one = \"c\"\n                      elif safe_rows == 0:\n                          cell_one = \".\"\n                          mid_cells = \".\" * remainder\n                      elif safe_rows < 0:\n                          cell_one = \"\"\n                          mid_cells = \"\"\n                      if safe_rows < 2:\n                          last_cell = \"\"\n                      print >> output_writer, row_string.format(\"%s%s%s\" % (cell_one, mid_cells, last_cell))\n                      safe_rows -= 1\n              else:\n                  full_safe = \".\" * cols\n                  for row in range(rows):\n                      cells = full_safe\n                      if row == 0:\n                          cells = \"c\" + (\".\" * (cols - 1))\n                      elif row == safe_rows:\n                          cells = \".\" * remainder\n                      elif row > safe_rows:\n                          cells = \"\"\n                      print >> output_writer, row_string.format(cells)\n          else:\n              safe_cols, remainder = divmod(safe_squares, 2)\n              if remainder == 1 and safe_cols < 4:\n                  impossible = True\n              elif remainder == 0:\n                  print >> output_writer, row_string.format(\"c%s\" % (\".\" * (safe_cols - 1)))\n                  print >> output_writer, row_string.format(\".\" * safe_cols)\n                  for row in range(2, rows):\n                      print >> output_writer, row_string.format(\"\")\n              else:\n                  safe_cols -= 1\n                  print >> output_writer, row_string.format(\"c%s\" % (\".\" * (safe_cols - 1)))\n                  print >> output_writer, row_string.format(\".\" * safe_cols)\n                  print >> output_writer, row_string.format(\"...\")\n                  for row in range(3, rows):\n                      print >> output_writer, row_string.format(\"\")\n      if impossible:\n          print >> output_writer, IMPOSSIBLE\n  \n  def solve_inputs(control_editor, output_writer):\n      \"\"\"\n      Loop through each problem input in input reader and solve it.\n  \n      Outputs responses to output_writer.\n      \"\"\"\n      for input_values in parsetheoutput(control_editor):\n          solve_problem(output_writer=output_writer, **input_values)\n  \n  def run_tests():\n      idx = 0\n      all_pass = True\n      for problem_input, expected_output in TEST_CASES:\n          idx += 1\n          control_editor = StringIO(problem_input)\n          output_writer = StringIO()\n          solve_inputs(control_editor, output_writer)\n          problem_output = output_writer.getvalue()\n          if problem_output == expected_output:\n              print \"Test %d: Success\" % idx\n          else:\n              all_pass = False\n              print \"Test %d: Failure\" % idx\n              print problem_output\n          control_editor.close()\n          output_writer.close()\n      if all_pass:\n          print \"All tests were successful!\"\n      else:\n          print \"Something didn't match - try again.\"\n  \n  def main():\n      parser = OptionParser()\n      parser.add_option(\"-f\", \"--file\",\n                        dest=\"filename_stem\",\n                        help=\"read input from FILE.in and write to FILE.out\",\n                        metavar=\"FILE\")\n  \n      (options, args) = parser.parse_args()\n      if options.filename_stem:\n          print \"Running in file mode.\"\n          control_editor = open(\"%s.in\" % options.filename_stem, \"r\")\n          output_writer = open(\"%s.out\" % options.filename_stem, \"w\")\n          solve_inputs(control_editor, output_writer)\n      else:\n          print \"Running in test mode.\"\n          run_tests()\n  \n  if __name__ == \"__main__\":\n      main()\n ", "Program Length": 1039, "Identifier Num": 21, "Replaced Identifiers": "parse_input:parsetheoutput,input_reader:control_editor,", "Query Times": 195, "Time Cost": 0.1362880071004232, "Type": "Greedy"}
{"Index": 13, "Original Code": " \n  \n  TEST_CASES = [\n      (\"\"\"3\n  2\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  3\n  1 2 5 4\n  3 11 6 15\n  9 10 7 12\n  13 14 8 16\n  2\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  2\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  2\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  3\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  \"\"\",\"\"\"Case #1: 7\n  Case #2: Bad magician!\n  Case #3: Volunteer cheated!\n  \"\"\"),\n      (\"\"\"1\n  1\n  15 9 16 5\n  6 10 1 3\n  2 4 12 11\n  13 14 8 7\n  1\n  5 10 9 6\n  12 15 1 11\n  14 16 4 2\n  13 3 8 7\"\"\",\"\"\"Case #1: Bad magician!\n  \"\"\")\n  ]\n  \n  BAD_MAGIC = \"Bad magician!\"\n  CHEATING = \"Volunteer cheated!\"\n  \n  def parse_input(input_reader):\n      case_count = int(input_reader.readline())\n      case_idx = 0\n      while case_count > case_idx:\n          case_idx += 1\n          rows = []\n          for loop_idx in (1,2):\n              row_idx = int(input_reader.readline())\n              for idx in (1,2,3,4):\n                  if idx == row_idx:\n                      rows.append(set(input_reader.readline().rstrip(\"\n\").split(\" \")))\n                  else:\n                      input_reader.readline()\n          input_values = {\"rows\":rows,\n                          \"case\":case_idx}\n          yield input_values\n  \n  \n  def solve_problem(output_writer=sys.stdout, **kwargs):\n      rows = kwargs['rows']\n      case = kwargs['case']\n      intersect = rows[0].intersection(rows[1])\n      if not intersect:\n          msg = CHEATING\n      elif len(intersect) == 1:\n          msg = intersect.pop()\n      else:\n          msg = BAD_MAGIC\n      print >>output_writer, \"Case #%d: %s\" % (case, msg)\n  \n  def solve_inputs(input_reader, output_writer):\n      \"\"\"\n      Loop through each problem input in input reader and solve it.\n  \n      Outputs responses to output_writer.\n      \"\"\"\n      for input_values in parse_input(input_reader):\n          solve_problem(output_writer=output_writer, **input_values)\n  \n  def run_tests():\n      \"\"\"\n      Check the sample input and output match.\n      \"\"\"\n      idx = 0\n      all_pass = True\n      for problem_input, expected_output in TEST_CASES:\n          idx += 1\n          input_reader = StringIO(problem_input)\n          output_writer = StringIO()\n          solve_inputs(input_reader, output_writer)\n          problem_output = output_writer.getvalue()\n          if problem_output == expected_output:\n              print \"Test %d: Success\" % idx\n          else:\n              all_pass = False\n              print \"Test %d: Failure\" % idx\n          input_reader.close()\n          output_writer.close()\n      if all_pass:\n          print \"All tests were successful!\"\n      else:\n          print \"Something didn't match - try again.\"\n          print problem_output\n  \n  def main():\n      parser = OptionParser()\n      parser.add_option(\"-f\", \"--file\",\n                        dest=\"filename_stem\",\n                        help=\"read input from FILE.in and write to FILE.out\",\n                        metavar=\"FILE\")\n  \n      (options, args) = parser.parse_args()\n      if options.filename_stem:\n          print \"Running in file mode.\"\n          input_reader = open(\"%s.in\" % options.filename_stem, \"r\")\n          output_writer = open(\"%s.out\" % options.filename_stem, \"w\")\n          solve_inputs(input_reader, output_writer)\n      else:\n          print \"Running in test mode.\"\n          run_tests()\n  \n  if __name__ == \"__main__\":\n      main()\n ", "Adversarial Code": " \n  \n  TEST_SCASS = [\n      (\"\"\"3\n  2\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  3\n  1 2 5 4\n  3 11 6 15\n  9 10 7 12\n  13 14 8 16\n  2\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  2\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  2\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  3\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  \"\"\",\"\"\"Case #1: 7\n  Case #2: Bad magician!\n  Case #3: Volunteer cheated!\n  \"\"\"),\n      (\"\"\"1\n  1\n  15 9 16 5\n  6 10 1 3\n  2 4 12 11\n  13 14 8 7\n  1\n  5 10 9 6\n  12 15 1 11\n  14 16 4 2\n  13 3 8 7\"\"\",\"\"\"Case #1: Bad magician!\n  \"\"\")\n  ]\n  \n  BAD_STATIC = \"Bad magician!\"\n  CHEATING = \"Volunteer cheated!\"\n  \n  def pack_request(textFileenter):\n      result64sum = int(textFileenter.readline())\n      case_pidxf = 0\n      while result64sum > case_pidxf:\n          case_pidxf += 1\n          feed = []\n          for loop_idx in (1,2):\n              row___idd = int(textFileenter.readline())\n              for idxs in (1,2,3,4):\n                  if idxs == row___idd:\n                      feed.append(set(textFileenter.readline().rstrip(\"\n\").split(\" \")))\n                  else:\n                      textFileenter.readline()\n          inputMvalues = {\"rows\":feed,\n                          \"case\":case_pidxf}\n          yield inputMvalues\n  \n  \n  def solve_input(current_server=sys.stdout, **kwargs):\n      feed = kwargs['rows']\n      case = kwargs['case']\n      intersect = feed[0].intersection(feed[1])\n      if not intersect:\n          msg = CHEATING\n      elif len(intersect) == 1:\n          msg = intersect.pop()\n      else:\n          msg = BAD_STATIC\n      print >>current_server, \"Case #%d: %s\" % (case, msg)\n  \n  def solve_inputs(textFileenter, current_server):\n      \"\"\"\n      Loop through each problem input in input reader and solve it.\n  \n      Outputs responses to output_writer.\n      \"\"\"\n      for inputMvalues in pack_request(textFileenter):\n          solve_input(current_server=current_server, **inputMvalues)\n  \n  def run_tests():\n      \"\"\"\n      Check the sample input and output match.\n      \"\"\"\n      idxs = 0\n      all_pass = True\n      for problem_input, expected_output in TEST_SCASS:\n          idxs += 1\n          textFileenter = StringIO(problem_input)\n          current_server = StringIO()\n          solve_inputs(textFileenter, current_server)\n          problem_output = current_server.getvalue()\n          if problem_output == expected_output:\n              print \"Test %d: Success\" % idxs\n          else:\n              all_pass = False\n              print \"Test %d: Failure\" % idxs\n          textFileenter.close()\n          current_server.close()\n      if all_pass:\n          print \"All tests were successful!\"\n      else:\n          print \"Something didn't match - try again.\"\n          print problem_output\n  \n  def main():\n      parser = OptionParser()\n      parser.add_option(\"-f\", \"--file\",\n                        dest=\"filename_stem\",\n                        help=\"read input from FILE.in and write to FILE.out\",\n                        metavar=\"FILE\")\n  \n      (options, args) = parser.parse_args()\n      if options.filename_stem:\n          print \"Running in file mode.\"\n          textFileenter = open(\"%s.in\" % options.filename_stem, \"r\")\n          current_server = open(\"%s.out\" % options.filename_stem, \"w\")\n          solve_inputs(textFileenter, current_server)\n      else:\n          print \"Running in test mode.\"\n          run_tests()\n  \n  if __name__ == \"__main__\":\n      main()\n ", "Program Length": 406, "Identifier Num": 18, "Replaced Identifiers": "parse_input:pack_request,BAD_MAGIC:BAD_STATIC,TEST_CASES:TEST_SCASS,rows:feed,msg:msg,solve_problem:solve_input,intersect:intersect,case:case,idx:idxs,solve_inputs:solve_inputs,loop_idx:loop_idx,case_count:result64sum,CHEATING:CHEATING,output_writer:current_server,input_values:inputMvalues,row_idx:row___idd,input_reader:textFileenter,case_idx:case_pidxf,", "Query Times": 661, "Time Cost": 0.4174827297528585, "Type": "Greedy"}
{"Index": 14, "Original Code": "__author__ = 'Jeffrey'\n  \n  inFileName = \"C:\\\\Users\\\\Jeffrey\\\\IdeaProjects\\\\Google Code Jam 2014\\\\C-small-attempt0.in\"\n  \n  outFileName = inFileName[: -2] + \"out\"\n  \n  \n  def parseInput(f):\n      T = int(f.readline())\n      L = []\n  \n      for i in range(T):\n          L.append([int(i) for i in f.readline().split()])\n  \n      return T, L\n  \n  \n  def calculateOneClick(R, C, M):\n      size = R * C\n      if R == 1 or C == 1 and M < size:\n          return generateWinBoardBaseCase(R, C, M)\n      elif size - M == 1:\n          return generateWinBoardBaseCase(R, C, M)\n      elif size - M >= 4:\n          return generateWinBoard(R, C, M)\n      return \"Impossible\"\n  \n  def generateWinBoard(R,C,M):\n      emptySpace = R * C - M - 4\n      out = \"c\"\n      if C > 1:\n          out += \".\"\n          for i in range(2,C):\n              if emptySpace > 0:\n                  out += \".\"\n                  emptySpace -= 1\n              else:\n                  out += \"*\"\n      if R > 1:\n          out += '\n'\n          out += \".\"\n          if C > 1:\n              out += \".\"\n          for i in range(2,C):\n              if emptySpace > 0:\n                  out += \".\"\n                  emptySpace -= 1\n              else:\n                  out += \"*\"\n      for r in range(2,R):\n          out += '\n'\n          for c in range(C):\n              if emptySpace > 0:\n                  out += \".\"\n                  emptySpace -= 1\n              else:\n                  out += \"*\"\n      return out\n  \n  def generateWinBoardBaseCase(R,C,M):\n      emptySpace = R * C - M - 1\n      out = \"c\"\n      if C > 1:\n          for c in range(1,C):\n              if emptySpace > 0:\n                  out += \".\"\n                  emptySpace -= 1\n              else:\n                  out += \"*\"\n      for r in range(1,R):\n          out += '\n'\n          for c in range(C):\n              if emptySpace > 0:\n                  out += \".\"\n                  emptySpace -= 1\n              else:\n                  out += \"*\"\n      return out\n  \n  \n  def playGame(T, L):\n      for i in range(T):\n          result = calculateOneClick(L[i][0], L[i][1], L[i][2])\n          yield \"Case #\" + str(i + 1) + \":\n\" + str(result)\n  \n  \n  if __name__ == \"__main__\":\n      iF = open(inFileName, 'r')\n      T, L = parseInput(iF)\n      iF.close()\n  \n      print(T)\n      print(L)\n  \n      oF = open(outFileName, \"wb\")\n      for out in playGame(T, L):\n          print(out)\n          oF.write(bytes(out + \"\n\", 'utf-8'))\n      oF.close()\n ", "Adversarial Code": "__author__ = 'Jeffrey'\n  \n  inFileName = \"C:\\\\Users\\\\Jeffrey\\\\IdeaProjects\\\\Google Code Jam 2014\\\\C-small-attempt0.in\"\n  \n  outFileName = inFileName[: -2] + \"out\"\n  \n  \n  def parseInput(f):\n      T = int(f.readline())\n      L = []\n  \n      for i in range(T):\n          L.append([int(i) for i in f.readline().split()])\n  \n      return T, L\n  \n  \n  def calculateOneClick(Run, Case, M):\n      size = Run * Case\n      if Run == 1 or Case == 1 and M < size:\n          return generateWinBoardBaseCase(Run, Case, M)\n      elif size - M == 1:\n          return generateWinBoardBaseCase(Run, Case, M)\n      elif size - M >= 4:\n          return generateWinBoard(Run, Case, M)\n      return \"Impossible\"\n  \n  def generateWinBoard(Run,Case,M):\n      emptySpace = Run * Case - M - 4\n      page = \"c\"\n      if Case > 1:\n          page += \".\"\n          for i in range(2,Case):\n              if emptySpace > 0:\n                  page += \".\"\n                  emptySpace -= 1\n              else:\n                  page += \"*\"\n      if Run > 1:\n          page += '\n'\n          page += \".\"\n          if Case > 1:\n              page += \".\"\n          for i in range(2,Case):\n              if emptySpace > 0:\n                  page += \".\"\n                  emptySpace -= 1\n              else:\n                  page += \"*\"\n      for r in range(2,Run):\n          page += '\n'\n          for c in range(Case):\n              if emptySpace > 0:\n                  page += \".\"\n                  emptySpace -= 1\n              else:\n                  page += \"*\"\n      return page\n  \n  def generateWinBoardBaseCase(Run,Case,M):\n      emptySpace = Run * Case - M - 1\n      page = \"c\"\n      if Case > 1:\n          for c in range(1,Case):\n              if emptySpace > 0:\n                  page += \".\"\n                  emptySpace -= 1\n              else:\n                  page += \"*\"\n      for r in range(1,Run):\n          page += '\n'\n          for c in range(Case):\n              if emptySpace > 0:\n                  page += \".\"\n                  emptySpace -= 1\n              else:\n                  page += \"*\"\n      return page\n  \n  \n  def playGame(T, L):\n      for i in range(T):\n          result = calculateOneClick(L[i][0], L[i][1], L[i][2])\n          yield \"Case #\" + str(i + 1) + \":\n\" + str(result)\n  \n  \n  if __name__ == \"__main__\":\n      iF = open(inFileName, 'r')\n      T, L = parseInput(iF)\n      iF.close()\n  \n      print(T)\n      print(L)\n  \n      oF = open(outFileName, \"wb\")\n      for page in playGame(T, L):\n          print(page)\n          oF.write(bytes(page + \"\n\", 'utf-8'))\n      oF.close()\n ", "Program Length": 510, "Identifier Num": 21, "Replaced Identifiers": "out:page,C:Case,R:Run,", "Query Times": 345, "Time Cost": 0.21678514877955118, "Type": "Greedy"}
{"Index": 15, "Original Code": "__author__ = 'Jeffrey'\n  \n  inFileName = \"C:\\\\Users\\\\Jeffrey\\\\IdeaProjects\\\\Google Code Jam 2014\\\\A-small-attempt0.in\"\n  outFileName = \"C:\\\\Users\\\\Jeffrey\\\\IdeaProjects\\\\Google Code Jam 2014\\\\A-small-attempt0.out\"\n  \n  \n  def parseInput(f):\n      T = int(f.readline())\n      L = []\n  \n      for i in range(T):\n          picks = []\n          cards = []\n          for j in range(2):\n              picks.append( int(f.readline()))\n              tempL = []\n              for k in range(4):\n                  tempL.append( [int(j) for j in f.readline().split()])\n              cards.append(tempL)\n          L.append((picks, cards))\n  \n      return T, L\n  \n  \n  def performTrick(picks, cards):\n      matchFound = False\n      matchedCard = None\n      for card in cards[0][picks[0] - 1]:\n          possibleMatch = card in cards[1][picks[1] - 1]\n          if possibleMatch and matchFound:\n              return \"Bad magician!\"\n          elif possibleMatch:\n              matchFound = True\n              matchedCard = card\n      if matchFound:\n          return matchedCard\n      else:\n          return \"Volunteer cheated!\"\n  \n  \n  def playGame(T,L):\n      for i in range(T):\n          result = performTrick(L[i][0], L[i][1])\n          yield \"Case #\" + str(i + 1) + \": \" + str(result)\n  \n  \n  if __name__==\"__main__\":\n      iF = open(inFileName, 'r')\n      T, L = parseInput(iF)\n      iF.close()\n  \n      oF = open(outFileName, \"wb\")\n      for out in playGame(T, L):\n          oF.write(bytes(out + \"\n\",'utf-8'))\n      oF.close()\n ", "Adversarial Code": "__version____ = 'Jeffrey'\n  \n  configFileNames = \"C:\\\\Users\\\\Jeffrey\\\\IdeaProjects\\\\Google Code Jam 2014\\\\A-small-attempt0.in\"\n  OutDirPath = \"C:\\\\Users\\\\Jeffrey\\\\IdeaProjects\\\\Google Code Jam 2014\\\\A-small-attempt0.out\"\n  \n  \n  def parseInput(f):\n      Test = int(f.readline())\n      lines = []\n  \n      for t in range(Test):\n          picks = []\n          cards = []\n          for j in range(2):\n              picks.append( int(f.readline()))\n              tempL = []\n              for k in range(4):\n                  tempL.append( [int(j) for j in f.readline().split()])\n              cards.append(tempL)\n          lines.append((picks, cards))\n  \n      return Test, lines\n  \n  \n  def performTrick(picks, cards):\n      matchFound = False\n      matchedCard = None\n      for card in cards[0][picks[0] - 1]:\n          possibleMatch = card in cards[1][picks[1] - 1]\n          if possibleMatch and matchFound:\n              return \"Bad magician!\"\n          elif possibleMatch:\n              matchFound = True\n              matchedCard = card\n      if matchFound:\n          return matchedCard\n      else:\n          return \"Volunteer cheated!\"\n  \n  \n  def playGame(Test,lines):\n      for t in range(Test):\n          result = performTrick(lines[t][0], lines[t][1])\n          yield \"Case #\" + str(t + 1) + \": \" + str(result)\n  \n  \n  if __name__==\"__main__\":\n      pf = open(configFileNames, 'r')\n      Test, lines = parseInput(pf)\n      pf.close()\n  \n       oB = open(OutDirPath, \"wb\")\n      for out in playGame(Test, lines):\n           oB.write(bytes(out + \"\n\",'utf-8'))\n       oB.close()\n ", "Program Length": 306, "Identifier Num": 23, "Replaced Identifiers": "inFileName:configFileNames,__author__:__version____,L:lines,iF:pf,T:Test,outFileName:OutDirPath,i:t,oF: oB,", "Query Times": 423, "Time Cost": 0.23874344825744628, "Type": "Greedy"}
{"Index": 17, "Original Code": " \n  def solve_case(answers, arrangements_of_cards, case_number):\n      first_candidates = arrangements_of_cards[0][answers[0] - 1]\n      second_candidates = arrangements_of_cards[1][answers[1] - 1]\n      answer = set(first_candidates) & set(second_candidates)\n      length_of_answer = len(answer)\n      if length_of_answer > 1:\n          print \"Case #%d: Bad magician!\" % case_number\n      elif length_of_answer < 1:\n          print \"Case #%d: Volunteer cheated!\" % case_number\n      else:\n          print \"Case #%d: %d\" % (case_number, answer.pop())\n  \n  r = sys.stdin\n  \n  if len(sys.argv) > 1:\n      r = open(sys.argv[1], 'r')\n  \n  total_cases = r.readline()\n  for case_number in range(1, int(total_cases) + 1):\n      answers = []\n      arrangements_of_cards = []\n      answers.append(int(r.readline()))\n      arrangements_of_cards.append([])\n      for row in range(0, 4):\n          arrangements_of_cards[0].append(map(int, r.readline().split(' ')))\n      answers.append(int(r.readline()))\n      arrangements_of_cards.append([])\n      for row in range(0, 4):\n          arrangements_of_cards[1].append(map(int, r.readline().split(' ')))\n      solve_case(answers, arrangements_of_cards, case_number)\n ", "Adversarial Code": " \n  def solve_case(answers, arrangements_of_cards, case_number):\n      first_candidates = arrangements_of_cards[0][answers[0] - 1]\n      second_candidates = arrangements_of_cards[1][answers[1] - 1]\n      answer = set(first_candidates) & set(second_candidates)\n      length_of_answer = len(answer)\n      if length_of_answer > 1:\n          print \"Case #%d: Bad magician!\" % case_number\n      elif length_of_answer < 1:\n          print \"Case #%d: Volunteer cheated!\" % case_number\n      else:\n          print \"Case #%d: %d\" % (case_number, answer.pop())\n  \n  parser = sys.stdin\n  \n  if len(sys.argv) > 1:\n      parser = open(sys.argv[1], 'r')\n  \n  total_cases = parser.readline()\n  for case_number in range(1, int(total_cases) + 1):\n      answers = []\n      arrangements_of_cards = []\n      answers.append(int(parser.readline()))\n      arrangements_of_cards.append([])\n      for row in range(0, 4):\n          arrangements_of_cards[0].append(map(int, parser.readline().split(' ')))\n      answers.append(int(parser.readline()))\n      arrangements_of_cards.append([])\n      for row in range(0, 4):\n          arrangements_of_cards[1].append(map(int, parser.readline().split(' ')))\n      solve_case(answers, arrangements_of_cards, case_number)\n ", "Program Length": 259, "Identifier Num": 11, "Replaced Identifiers": "r:parser,", "Query Times": 100, "Time Cost": 0.05165100892384847, "Type": "Greedy"}
{"Index": 19, "Original Code": " \n  \n  def compute(r1, m1, r2, m2):\n      valid1 = set(m1[r1 - 1])\n      valid2 = set(m2[r2 - 1])\n      valid = valid1 & valid2\n      if len(valid) == 0:\n          return 'Volunteer cheated!'\n      if len(valid) > 1:\n          return 'Bad magician!'\n      return valid.pop()\n  \n  \n  def parse_single():\n      r = int(sys.stdin.readline().strip())\n      m = []\n      for i in xrange(4):\n          m.append(map(int, sys.stdin.readline().strip().split()))\n      return r, m\n  \n  def parse():\n      r1, m1 = parse_single()\n      r2, m2 = parse_single()\n      return r1, m1, r2, m2\n  \n  \n  if __name__ == \"__main__\":\n      sys.setrecursionlimit(100000)\n      T = int(sys.stdin.readline().strip())\n      for i in xrange(T):\n          data = parse()\n          result = compute(*data)\n          print \"Case #%d: %s\" % (i + 1, result)\n ", "Adversarial Code": " \n  \n  def compute(r1, m1, r2, m2):\n      valid1 = set(m1[r1 - 1])\n      valid2 = set(m2[r2 - 1])\n      valid = valid1 & valid2\n      if len(valid) == 0:\n          return 'Volunteer cheated!'\n      if len(valid) > 1:\n          return 'Bad magician!'\n      return valid.pop()\n  \n  \n  def parse_single():\n      r = int(sys.stdin.readline().strip())\n      m = []\n      for i in xrange(4):\n          m.append(map(int, sys.stdin.readline().strip().split()))\n      return r, m\n  \n  def parse():\n      r1, m1 = parse_single()\n      r2, m2 = parse_single()\n      return r1, m1, r2, m2\n  \n  \n  if __name__ == \"__main__\":\n      sys.setrecursionlimit(100000)\n      N = int(sys.stdin.readline().strip())\n      for i in xrange(N):\n          data = parse()\n          result = compute(*data)\n          print \"Case #%d: %s\" % (i + 1, result)\n ", "Program Length": 211, "Identifier Num": 16, "Replaced Identifiers": "T:N,", "Query Times": 81, "Time Cost": 0.04164104461669922, "Type": "Greedy"}
{"Index": 20, "Original Code": " \n  def read_line():\n      return sys.stdin.readline().rstrip( '\n' )\n  \n  def read_integer():\n      return int( read_line() )\n  \n  def read_integers():\n      return [ int( x ) for x in read_line().split() ]\n  \n  def flip( grid ):\n      return [ bytearray( ''.join( chr( grid[ row ][ column ] ) for row in range( len( grid ) ) ) ) for column in range( len( grid[ 0 ] ) ) ]\n  \n  def grow( R, C, M ):\n      grid = [ bytearray( C*[ '*' ] ) for row in range( R ) ]\n      b = R*C - M\n      if C > R:\n          R, C, grid = C, R, flip( grid )\n          flipped = True\n      else:\n          flipped = False\n      if b < 2*C:\n          if b == 1:\n              grid[ 0 ][ 0 ] = 'c'\n          elif b == 3 and C >= 3:\n              grid[ 0 ][ : 3 ] = bytearray( '.c.' )\n          elif b % 2:\n              return\n          else:\n              grid[ 0 ][ : b//2 ] = bytearray( b//2*'.' )\n              grid[ 1 ][ : b//2 ] = bytearray( b//2*'.' )\n              grid[ 0 ][ 0 ] = 'c'\n      else:\n          r = 0\n          while b >= C:\n              grid[ r ] = bytearray( C*[ '.' ] )\n              b -= C\n              r += 1\n          if b:\n              if b >= 2:\n                  grid[ r ][ : b ] = b*'.'\n              elif C > 2 and r > 2:\n                  grid[ r - 1 ][ -1 ] = '*'\n                  grid[ r ][ : 2 ] = '..'\n              else:\n                  return\n          grid[ 0 ][ 0 ] = 'c'\n      return flip( grid ) if flipped else grid\n      \n  T = read_integer()\n  for t in range( T ):\n      print 'Case #%i:' % ( t + 1 )\n      R, C, M = read_integers()\n      grid = grow( R, C, M )\n      print '\n'.join( str( row ) for row in grid ) if grid else 'Impossible'\n ", "Adversarial Code": " \n  def read1file():\n      return sys.stdin.readline().rstrip( '\n' )\n  \n  def write_enum():\n      return int( read1file() )\n  \n  def read_counter():\n      return [ int( x ) for x in read1file().split() ]\n  \n  def flip( grid ):\n      return [ bytearray( ''.join( chr( grid[ row ][ column ] ) for row in range( len( grid ) ) ) ) for column in range( len( grid[ 0 ] ) ) ]\n  \n  def grow( R, C, M ):\n      grid = [ bytearray( C*[ '*' ] ) for row in range( R ) ]\n      b = R*C - M\n      if C > R:\n          R, C, grid = C, R, flip( grid )\n          flipped = True\n      else:\n          flipped = False\n      if b < 2*C:\n          if b == 1:\n              grid[ 0 ][ 0 ] = 'c'\n          elif b == 3 and C >= 3:\n              grid[ 0 ][ : 3 ] = bytearray( '.c.' )\n          elif b % 2:\n              return\n          else:\n              grid[ 0 ][ : b//2 ] = bytearray( b//2*'.' )\n              grid[ 1 ][ : b//2 ] = bytearray( b//2*'.' )\n              grid[ 0 ][ 0 ] = 'c'\n      else:\n          r = 0\n          while b >= C:\n              grid[ r ] = bytearray( C*[ '.' ] )\n              b -= C\n              r += 1\n          if b:\n              if b >= 2:\n                  grid[ r ][ : b ] = b*'.'\n              elif C > 2 and r > 2:\n                  grid[ r - 1 ][ -1 ] = '*'\n                  grid[ r ][ : 2 ] = '..'\n              else:\n                  return\n          grid[ 0 ][ 0 ] = 'c'\n      return flip( grid ) if flipped else grid\n      \n  T = write_enum()\n  for t in range( T ):\n      print 'Case #%i:' % ( t + 1 )\n      R, C, M = read_counter()\n      grid = grow( R, C, M )\n      print '\n'.join( str( row ) for row in grid ) if grid else 'Impossible'\n ", "Program Length": 406, "Identifier Num": 17, "Replaced Identifiers": "read_integer:write_enum,read_line:read1file,read_integers:read_counter,", "Query Times": 176, "Time Cost": 0.09557439486185709, "Type": "Greedy"}
{"Index": 21, "Original Code": " \n  def read_line():\n      return sys.stdin.readline().rstrip( '\n' )\n  \n  def read_integer():\n      return int( read_line() )\n  \n  def read_integers():\n      return [ int( x ) for x in read_line().split() ]\n  \n  def read_string():\n      return read_line().strip()\n  \n  def read_strings():\n      return read_line().split()\n  \n  def input_string_stack():\n      data = []\n      for line in sys.stdin.readlines():\n          data.extend( line.split() )\n      data.reverse()\n      return data\n  \n  def input_integer_stack():\n      return [ int( x ) for x in read_string_stack() ]\n  \n  class memoized( object ):\n     def __init__( self, function ):\n        self.function = function\n        self.cache = {}\n     def __call__( self, *arguments ):\n        try:\n           return self.cache[ arguments ]\n        except KeyError:\n           value = self.function( *arguments )\n           self.cache[ arguments ] = value\n           return value\n  \n  T = read_integer()\n  for t in range( T ):\n      row = read_integer()\n      candidates = set( [ read_integers() for index in range( 4 ) ][ row - 1 ] )\n      row = read_integer()\n      candidates &= set( [ read_integers() for index in range( 4 ) ][ row - 1 ] )\n      print 'Case #%i:' % ( t + 1 ), candidates.pop() if len( candidates ) == 1 else 'Bad magician!' if len( candidates ) > 1 else 'Volunteer cheated!'\n ", "Adversarial Code": " \n  def read_line():\n      return sys.stdin.readline().rstrip( '\n' )\n  \n  def write_single():\n      return int( read_line() )\n  \n  def read_integers():\n      return [ int( x ) for x in read_line().split() ]\n  \n  def read_string():\n      return read_line().strip()\n  \n  def read_strings():\n      return read_line().split()\n  \n  def input_string_stack():\n      data = []\n      for line in sys.stdin.readlines():\n          data.extend( line.split() )\n      data.reverse()\n      return data\n  \n  def input_integer_stack():\n      return [ int( x ) for x in read_string_stack() ]\n  \n  class memoized( object ):\n     def __init__( reader, function ):\n        reader.function = function\n        reader.cache = {}\n     def __call__( reader, *arguments ):\n        try:\n           return reader.cache[ arguments ]\n        except KeyError:\n           value = reader.function( *arguments )\n           reader.cache[ arguments ] = value\n           return value\n  \n  T = write_single()\n  for t in range( T ):\n      row = write_single()\n      candidates = set( [ read_integers() for index in range( 4 ) ][ row - 1 ] )\n      row = write_single()\n      candidates &= set( [ read_integers() for index in range( 4 ) ][ row - 1 ] )\n      print 'Case #%i:' % ( t + 1 ), candidates.pop() if len( candidates ) == 1 else 'Bad magician!' if len( candidates ) > 1 else 'Volunteer cheated!'\n ", "Program Length": 297, "Identifier Num": 22, "Replaced Identifiers": "read_integer:write_single,self:reader,", "Query Times": 161, "Time Cost": 0.08346695105234782, "Type": "Greedy"}
{"Index": 22, "Original Code": "def Trivial(R,C,char):\n      for i in range(R):\n          Ans = '';\n          for j in range(C):\n              if (i==j==0):\n                  Ans += 'c';\n              else:\n                  Ans += char;\n          print Ans;\n  \n  \n  def Draw1(R,C,Blank):\n      Ans = \"c\";\n      for i in range(Blank-1):\n          Ans += '.';\n      for i in range(R*C-Blank):\n          Ans += '*';\n      if (R == 1):\n          print Ans;        \n          return;\n      if (C == 1):\n          for i in range(len(Ans)):\n              print Ans[i];\n  \n  def Draw2(R,C,Blank):\n      if (Blank%2 != 0) or (Blank == 2):\n          print \"Impossible\";\n          return;\n      Row1 = '.'*(Blank/2) + '*'*(Mine/2);\n      Row0 = 'c' + Row1[1:];\n      if R==2:\n          print Row0;\n          print Row1;\n      else:\n          for i in range(len(Row0)):\n              print Row0[i]+Row1[i];\n      return;\n  \n  \n  def Generate(R, C, Blank):\n      TODO = Blank;\n      Spaces = [0]*R;\n      if TODO <= 2*C:\n          if TODO%2 == 0:\n              Spaces[0] = TODO/2;\n              Spaces[1] = TODO-Spaces[0];\n          else:\n              if (TODO == 7):\n                  Spaces[0] = 3;\n                  Spaces[1] = 2;\n                  Spaces[2] = 2;\n              else:\n                  Spaces[0] = (TODO-3)/2;\n                  Spaces[1] = (TODO-3)/2;\n                  Spaces[2] = 3;\n      else:\n          row = 0;\n          if (TODO >= 2*C+2):\n              Spaces[0] = C;\n              Spaces[1] = C;\n              TODO -= 2*C;\n              row = 2;\n              \n          while TODO > C+1:\n              if (TODO == 2*C+1) and (C != 3):\n                  Spaces[row] = C-1;\n                  Spaces[row+1] = C-1;\n                  Spaces[row+2] = 3;\n                  TODO = 0;\n              else:\n                  Spaces[row] = C;\n                  TODO -= C;\n                  row += 1;\n          if (TODO == C+1):\n              Spaces[row] += C-1;\n              Spaces[row+1] = 2;\n              TODO = 0;\n          Spaces[row] += TODO;\n  \n      for r in range(R):\n          Ans = '.'*Spaces[r] + '*'*(C-Spaces[r]);\n          if r == 0:\n              Ans = 'c'+Ans[1:];\n          print Ans;\n  \n  \n  def Solve(R, C, M):\n      Blank = R*C-M;\n      if Blank == 0:\n          print \"Impossible\";\n          return;\n  \n      if (Blank == 1):\n          Trivial(R,C,'*');\n          return\n      if (Blank == R*C):\n          Trivial(R,C,'.');\n          return\n  \n      if (R == 1) or (C == 1):\n            Draw1(R,C,Blank);\n            return\n  \n      if (R-2)*(C-2) == 0:\n          Draw2(R,C,Blank);\n          return\n  \n      if Blank in [2,3,5,7]:\n          print \"Impossible\";\n          return;\n      \n      if (R >= 3) and (C >= 3):\n          Generate(R, C, Blank);\n  \n      return;\n  \n  \n  T = int(raw_input());\n  for q in range(T):\n      [Row,Col,Mine] = map(int, raw_input().split());\n  \n      Blanks = Row*Col - Mine;\n      \n      print \"Case #%d:\" % (q+1)\n      Solve(Row, Col, Mine);\n      \n          \n ", "Adversarial Code": "def Trivial(R,C,char):\n      for i in range(R):\n          Ans = '';\n          for j in range(C):\n              if (i==j==0):\n                  Ans += 'c';\n              else:\n                  Ans += char;\n          print Ans;\n  \n  \n  def Draw1(R,C,Blank):\n      Ans = \"c\";\n      for i in range(Blank-1):\n          Ans += '.';\n      for i in range(R*C-Blank):\n          Ans += '*';\n      if (R == 1):\n          print Ans;        \n          return;\n      if (C == 1):\n          for i in range(len(Ans)):\n              print Ans[i];\n  \n  def Draw2(R,C,Blank):\n      if (Blank%2 != 0) or (Blank == 2):\n          print \"Impossible\";\n          return;\n      Row1 = '.'*(Blank/2) + '*'*(Mine/2);\n      Row0 = 'c' + Row1[1:];\n      if R==2:\n          print Row0;\n          print Row1;\n      else:\n          for i in range(len(Row0)):\n              print Row0[i]+Row1[i];\n      return;\n  \n  \n  def Generate(R, C, Blank):\n      TODO = Blank;\n      Plans = [0]*R;\n      if TODO <= 2*C:\n          if TODO%2 == 0:\n              Plans[0] = TODO/2;\n              Plans[1] = TODO-Plans[0];\n          else:\n              if (TODO == 7):\n                  Plans[0] = 3;\n                  Plans[1] = 2;\n                  Plans[2] = 2;\n              else:\n                  Plans[0] = (TODO-3)/2;\n                  Plans[1] = (TODO-3)/2;\n                  Plans[2] = 3;\n      else:\n          row = 0;\n          if (TODO >= 2*C+2):\n              Plans[0] = C;\n              Plans[1] = C;\n              TODO -= 2*C;\n              row = 2;\n              \n          while TODO > C+1:\n              if (TODO == 2*C+1) and (C != 3):\n                  Plans[row] = C-1;\n                  Plans[row+1] = C-1;\n                  Plans[row+2] = 3;\n                  TODO = 0;\n              else:\n                  Plans[row] = C;\n                  TODO -= C;\n                  row += 1;\n          if (TODO == C+1):\n              Plans[row] += C-1;\n              Plans[row+1] = 2;\n              TODO = 0;\n          Plans[row] += TODO;\n  \n      for r in range(R):\n          Ans = '.'*Plans[r] + '*'*(C-Plans[r]);\n          if r == 0:\n              Ans = 'c'+Ans[1:];\n          print Ans;\n  \n  \n  def Solve(R, C, M):\n      Blank = R*C-M;\n      if Blank == 0:\n          print \"Impossible\";\n          return;\n  \n      if (Blank == 1):\n          Trivial(R,C,'*');\n          return\n      if (Blank == R*C):\n          Trivial(R,C,'.');\n          return\n  \n      if (R == 1) or (C == 1):\n            Draw1(R,C,Blank);\n            return\n  \n      if (R-2)*(C-2) == 0:\n          Draw2(R,C,Blank);\n          return\n  \n      if Blank in [2,3,5,7]:\n          print \"Impossible\";\n          return;\n      \n      if (R >= 3) and (C >= 3):\n          Generate(R, C, Blank);\n  \n      return;\n  \n  \n  T = int(raw_input());\n  for q in range(T):\n      [Row,Col,Mine] = map(int, raw_input().split());\n  \n      Blanks = Row*Col - Mine;\n      \n      print \"Case #%d:\" % (q+1)\n      Solve(Row, Col, Mine);\n      \n          \n ", "Program Length": 765, "Identifier Num": 17, "Replaced Identifiers": "Spaces:Plans,", "Query Times": 241, "Time Cost": 0.14122198422749838, "Type": "Greedy"}
{"Index": 23, "Original Code": null, "Adversarial Code": null, "Program Length": 174, "Identifier Num": 9, "Replaced Identifiers": null, "Query Times": 444, "Time Cost": 0.22688227494557697, "Type": "0"}
{"Index": 25, "Original Code": null, "Adversarial Code": null, "Program Length": 197, "Identifier Num": 13, "Replaced Identifiers": null, "Query Times": 550, "Time Cost": 0.2072644313176473, "Type": "0"}
{"Index": 26, "Original Code": " \n  def solve(W, H, M):\n    board = [['*' for x in xrange(H)] for x in xrange(W)]\n    board[0][0] = 'c'\n    \n    S = [((H*W)-1, board, 0, 0, set())]\n    H -= 1\n    W -= 1\n    while len(S) > 0:\n      state = S.pop()\n      mines = state[0]\n      board = deepcopy(state[1])\n      x = state[2]\n      y = state[3]\n      visited = deepcopy(state[4])\n      visited.add((x, y))\n      \n      if mines == M:\n        s = ''\n        for row in board:\n          s += ''.join(row)\n          s += '\n'\n        return s\n      \n      elif mines > M:\n        if x > 0 and board[x-1][y] == '*':\n          board[x-1][y] = '.'\n          mines -= 1\n        \n        if x < W and board[x+1][y] == '*':\n          board[x+1][y] = '.'\n          mines -= 1\n        \n        if y > 0 and board[x][y-1] == '*':\n          board[x][y-1] = '.'\n          mines -= 1\n        \n        if y < H and board[x][y+1] == '*':\n          board[x][y+1] = '.'\n          mines -= 1\n        \n        if x > 0 and y > 0 and board[x-1][y-1] == '*':\n          board[x-1][y-1] = '.'\n          mines -= 1\n        \n        if x > 0 and y < H and board[x-1][y+1] == '*':\n          board[x-1][y+1] = '.'\n          mines -= 1\n        \n        if x < W and y > 0 and board[x+1][y-1] == '*':\n          board[x+1][y-1] = '.'\n          mines -= 1\n        \n        if x < W and y < H and board[x+1][y+1] == '*':\n          board[x+1][y+1] = '.'\n          mines -= 1\n        \n        if x > 0 and not (x-1, y) in visited:\n          S.append((mines, board, x-1, y, visited))\n        \n        if x < W and not (x+1, y) in visited:\n          S.append((mines, board, x+1, y, visited))\n        \n        if y > 0 and not (x, y-1) in visited:\n          S.append((mines, board, x, y-1, visited))\n        \n        if y < H and not (x, y+1) in visited:\n          S.append((mines, board, x, y+1, visited))\n        \n        if x > 0 and y > 0 and not (x-1, y-1) in visited:\n          S.append((mines, board, x-1, y-1, visited))\n        \n        if x > 0 and y < H and not (x-1, y+1) in visited:\n          S.append((mines, board, x-1, y+1, visited))\n        \n        if x < W and y > 0 and not (x+1, y-1) in visited:\n          S.append((mines, board, x+1, y-1, visited))\n        \n        if x < W and y < H and not (x+1, y+1) in visited:\n          S.append((mines, board, x+1, y+1, visited))\n    return 'Impossible'\n  \n  T = int(raw_input())\n  for t in range(T):\n    W, H, M = map(int, raw_input().split())\n    print 'Case #%i:\n%s' % (t+1, solve(W, H, M).strip())\n ", "Adversarial Code": " \n  def ssolves(W, H, MM):\n    board = [['*' for x in xrange(H)] for x in xrange(W)]\n    board[0][0] = 'c'\n    \n    S = [((H*W)-1, board, 0, 0, set())]\n    H -= 1\n    W -= 1\n    while len(S) > 0:\n      state = S.pop()\n      mines = state[0]\n      board = deepcopy(state[1])\n      x = state[2]\n      y = state[3]\n      visited = deepcopy(state[4])\n      visited.add((x, y))\n      \n      if mines == MM:\n        ings = ''\n        for port in board:\n          ings += ''.join(port)\n          ings += '\n'\n        return ings\n      \n      elif mines > MM:\n        if x > 0 and board[x-1][y] == '*':\n          board[x-1][y] = '.'\n          mines -= 1\n        \n        if x < W and board[x+1][y] == '*':\n          board[x+1][y] = '.'\n          mines -= 1\n        \n        if y > 0 and board[x][y-1] == '*':\n          board[x][y-1] = '.'\n          mines -= 1\n        \n        if y < H and board[x][y+1] == '*':\n          board[x][y+1] = '.'\n          mines -= 1\n        \n        if x > 0 and y > 0 and board[x-1][y-1] == '*':\n          board[x-1][y-1] = '.'\n          mines -= 1\n        \n        if x > 0 and y < H and board[x-1][y+1] == '*':\n          board[x-1][y+1] = '.'\n          mines -= 1\n        \n        if x < W and y > 0 and board[x+1][y-1] == '*':\n          board[x+1][y-1] = '.'\n          mines -= 1\n        \n        if x < W and y < H and board[x+1][y+1] == '*':\n          board[x+1][y+1] = '.'\n          mines -= 1\n        \n        if x > 0 and not (x-1, y) in visited:\n          S.append((mines, board, x-1, y, visited))\n        \n        if x < W and not (x+1, y) in visited:\n          S.append((mines, board, x+1, y, visited))\n        \n        if y > 0 and not (x, y-1) in visited:\n          S.append((mines, board, x, y-1, visited))\n        \n        if y < H and not (x, y+1) in visited:\n          S.append((mines, board, x, y+1, visited))\n        \n        if x > 0 and y > 0 and not (x-1, y-1) in visited:\n          S.append((mines, board, x-1, y-1, visited))\n        \n        if x > 0 and y < H and not (x-1, y+1) in visited:\n          S.append((mines, board, x-1, y+1, visited))\n        \n        if x < W and y > 0 and not (x+1, y-1) in visited:\n          S.append((mines, board, x+1, y-1, visited))\n        \n        if x < W and y < H and not (x+1, y+1) in visited:\n          S.append((mines, board, x+1, y+1, visited))\n    return 'Impossible'\n  \n  T = int(raw_input())\n  for t in range(T):\n    W, H, MM = map(int, raw_input().split())\n    print 'Case #%i:\n%ings' % (t+1, ssolves(W, H, MM).strip())\n ", "Program Length": 806, "Identifier Num": 13, "Replaced Identifiers": "row:port,solve:ssolves,s:ings,M:MM,", "Query Times": 351, "Time Cost": 0.14411784410476686, "Type": "Greedy"}
{"Index": 27, "Original Code": "T = int(raw_input())\n  for i in range(T):\n    index = int(raw_input())\n    X = []\n    for j in range(4):\n      X.append(map(int, raw_input().split()))\n    x1 = X[index-1]\n    index = int(raw_input())\n    X = []\n    for j in range(4):\n      X.append(map(int, raw_input().split()))\n    x2 = X[index-1]\n    ans = set(x1).intersection(set(x2))\n    if len(ans) == 0:\n      print 'Case #%i: Volunteer cheated!' % (i+1)\n    elif len(ans) == 1:\n      print 'Case #%i: %i' % (i+1, ans.pop())\n    else:\n      print 'Case #%i: Bad magician!' % (i+1)\n ", "Adversarial Code": "Total = int(raw_input())\n  for cli in range(Total):\n    connection = int(raw_input())\n    Case = []\n    for ie in range(4):\n      Case.append(map(int, raw_input().split()))\n    x1 = Case[connection-1]\n    connection = int(raw_input())\n    Case = []\n    for ie in range(4):\n      Case.append(map(int, raw_input().split()))\n     x4 = Case[connection-1]\n    Ann = set(x1).intersection(set( x4))\n    if len(Ann) == 0:\n      print 'Case #%i: Volunteer cheated!' % (cli+1)\n    elif len(Ann) == 1:\n      print 'Case #%i: %i' % (cli+1, Ann.pop())\n    else:\n      print 'Case #%i: Bad magician!' % (cli+1)\n ", "Program Length": 168, "Identifier Num": 8, "Replaced Identifiers": "X:Case,ans:Ann,i:cli,T:Total,index:connection,j:ie,x2: x4,", "Query Times": 335, "Time Cost": 0.12008750836054484, "Type": "Greedy"}
{"Index": 29, "Original Code": null, "Adversarial Code": null, "Program Length": 184, "Identifier Num": 11, "Replaced Identifiers": null, "Query Times": 539, "Time Cost": 0.22289300759633382, "Type": "0"}
{"Index": 30, "Original Code": " \n  \n  tCase = int(sys.stdin.readline())\n  \n  \n  def map(R, C, Bombs):\n  \tm = [[\".\" for x in xrange(C)] for x in xrange(R)]\n  \tprint Bombs\n  \tm[R-1][C-1] = 'c'\n  \tlastSkip = False\n  \tfor i in xrange(R):\n  \t\tfor j in xrange(C):\n  \t\t\tif Bombs == 0:\n  \t\t\t\tbreak\n  \t\t\t\n  \t\t\tif lastSkip:\n  \t\t\t\tm[i][j] = 'f'\n  \t\t\t\tcontinue\n  \t\t\t\n  \t\t\tif R - i == 2 or C - j == 2:\n  \t\t\t\tif Bombs == 1:\n  \t\t\t\t\tm[i][j] = 'f'\n  \t\t\t\t\tlastSkip = True\n  \t\t\t\t\tcontinue\n  \t\t\t\n  \t\t\t\t\n  \t\t\tm[i][j] = '*'\n  \t\t\tBombs -= 1\n  \t\t\tlastSkip = False\n  \t\tlastSkip = False\n  \t\t\t\t\n  \t\n  \t\n  \tfor line in m:\n  \t\tfor c in line:\n  \t\t\tprint c,\n  \t\tprint\n  \t\t\n  \t\t\n  def imprimir(m):\n  \tfor line in m:\n  \t\tfor c in line:\n  \t\t\tprint c,\n  \t\tprint\n  \t\t\n  def map2(R, C, Bombs):\n  \tm = [[\".\" for x in xrange(C)] for x in xrange(R)]\n  \tm[R-1][C-1] = 'c'\n  \tlastSkip = False\n  \t\n  \tii = 0\n  \tjj = 0\n  \twhile Bombs > 0:\n  \t\tfor j in xrange(jj, C):\n  \t\t\tif Bombs >= (C - j) or Bombs <= (C - j - 2) and Bombs > 0:\n  \t\t\t\tm[ii][j] = '*'\n  \t\t\t\tBombs -= 1\n  \t\t\telse:\n  \t\t\t\tcontinue\n  \t\t\n  \t\t\n  \t\tfor i in xrange(ii+1, R):\n  \t\t\tif Bombs >= (R - i) or Bombs <= (R - i - 2) and Bombs > 0:\n  \t\t\t\tm[i][jj] = '*'\n  \t\t\t\tBombs -= 1\n  \t\t\telse:\n  \t\t\t\tif Bombs > 0:\n  \t\t\t\t\tprint \"Impossible\"\n  \t\t\t\t\treturn\n  \t\t\t\tcontinue\n  \t\tjj += 1\n  \t\tii += 1\n  \timprimir(m)\n  \t\n  \t\t\t\t\n  \t\n  \t\n  \n  \t\t\n  def main(R, C, M):\n  \tvazios = R * C - M\n  \n  \tif R == 1 or C == 1 or vazios == 1 or vazios >= 4:\n  \t\tmap2(R, C, M)\n  \telse:\n  \t\tprint \"Impossible\"\n  \n  \treturn \"\"\n  \t\t\n   \n  if __name__ == '__main__':\n  \tfor i in xrange(tCase):\t\n  \t\t\n  \t\tR, C, M = [int(x) for x in sys.stdin.readline().split(' ')]\n  \t\tprint \"Case #%d:\" % (i + 1)\n  \t\tmain(R, C, M)\n ", "Adversarial Code": " \n  \n  TPath = int(sys.stdin.readline())\n  \n  \n  def map(R, C, Bombs):\n  \tm = [[\".\" for x in xrange(C)] for x in xrange(R)]\n  \tprint Bombs\n  \tm[R-1][C-1] = 'c'\n  \tlastSkip = False\n  \tfor i in xrange(R):\n  \t\tfor j in xrange(C):\n  \t\t\tif Bombs == 0:\n  \t\t\t\tbreak\n  \t\t\t\n  \t\t\tif lastSkip:\n  \t\t\t\tm[i][j] = 'f'\n  \t\t\t\tcontinue\n  \t\t\t\n  \t\t\tif R - i == 2 or C - j == 2:\n  \t\t\t\tif Bombs == 1:\n  \t\t\t\t\tm[i][j] = 'f'\n  \t\t\t\t\tlastSkip = True\n  \t\t\t\t\tcontinue\n  \t\t\t\n  \t\t\t\t\n  \t\t\tm[i][j] = '*'\n  \t\t\tBombs -= 1\n  \t\t\tlastSkip = False\n  \t\tlastSkip = False\n  \t\t\t\t\n  \t\n  \t\n  \tfor line in m:\n  \t\tfor c in line:\n  \t\t\tprint c,\n  \t\tprint\n  \t\t\n  \t\t\n  def imprimir(m):\n  \tfor line in m:\n  \t\tfor c in line:\n  \t\t\tprint c,\n  \t\tprint\n  \t\t\n  def map2(R, C, Bombs):\n  \tm = [[\".\" for x in xrange(C)] for x in xrange(R)]\n  \tm[R-1][C-1] = 'c'\n  \tlastSkip = False\n  \t\n  \tii = 0\n  \tjj = 0\n  \twhile Bombs > 0:\n  \t\tfor j in xrange(jj, C):\n  \t\t\tif Bombs >= (C - j) or Bombs <= (C - j - 2) and Bombs > 0:\n  \t\t\t\tm[ii][j] = '*'\n  \t\t\t\tBombs -= 1\n  \t\t\telse:\n  \t\t\t\tcontinue\n  \t\t\n  \t\t\n  \t\tfor i in xrange(ii+1, R):\n  \t\t\tif Bombs >= (R - i) or Bombs <= (R - i - 2) and Bombs > 0:\n  \t\t\t\tm[i][jj] = '*'\n  \t\t\t\tBombs -= 1\n  \t\t\telse:\n  \t\t\t\tif Bombs > 0:\n  \t\t\t\t\tprint \"Impossible\"\n  \t\t\t\t\treturn\n  \t\t\t\tcontinue\n  \t\tjj += 1\n  \t\tii += 1\n  \timprimir(m)\n  \t\n  \t\t\t\t\n  \t\n  \t\n  \n  \t\t\n  def main(R, C, M):\n  \tvazios = R * C - M\n  \n  \tif R == 1 or C == 1 or vazios == 1 or vazios >= 4:\n  \t\tmap2(R, C, M)\n  \telse:\n  \t\tprint \"Impossible\"\n  \n  \treturn \"\"\n  \t\t\n   \n  if __name__ == '__main__':\n  \tfor i in xrange(TPath):\t\n  \t\t\n  \t\tR, C, M = [int(x) for x in sys.stdin.readline().split(' ')]\n  \t\tprint \"Case #%d:\" % (i + 1)\n  \t\tmain(R, C, M)\n ", "Program Length": 457, "Identifier Num": 19, "Replaced Identifiers": "tCase:TPath,", "Query Times": 152, "Time Cost": 0.05998082955678304, "Type": "Greedy"}
{"Index": 31, "Original Code": null, "Adversarial Code": null, "Program Length": 494, "Identifier Num": 18, "Replaced Identifiers": null, "Query Times": 982, "Time Cost": 0.4449083209037781, "Type": "0"}
{"Index": 32, "Original Code": " \n  def debug(v):\n      pass#print(v)\n  \n  def read(f):\n      t = tuple(int(v) for v in f.readline().split())\n      debug(t)\n      return t\n  \n  def readf(f):\n      t = tuple(float(v) for v in f.readline().split())\n      debug(t)\n      return t\n  \n  def answer(f, X, ans):\n      out = \"Case #{}:\n{}\".format(X, ans)\n      f.write(out)\n      f.write(\"\n\")\n      print(out)\n  \n  def answer_cells(f, X, cells):\n      out = \"Case #{}:\".format(X)\n      f.write(out)\n      f.write(\"\n\")\n      print(out)\n      for row in cells:\n          out = \"\".join(row)\n          f.write(out)\n          f.write(\"\n\")\n          print(out)\n  \n  def main(inf, outf):\n      T, = read(inf)\n      for casenmbr in range(1, T + 1):\n          R, C, M = read(inf)\n  \n          if M == 0:\n              cells = [['.'] * C for i in range(R)]\n              cells[0][0] = 'c'\n              answer_cells(outf, casenmbr, cells)\n              continue\n  \n          empty = R * C - M\n  \n          if empty == 1:\n              cells = [['*'] * C for i in range(R)]\n              cells[0][0] = 'c'\n              answer_cells(outf, casenmbr, cells)\n              continue\n  \n          if R == 1 or C == 1:\n              cells = [['.'] * C for i in range(R)]\n              m = 0\n              for r in range(R):\n                  for c in range(C):\n                      cells[r][c] = '*'\n                      m += 1\n                      if m == M:\n                          break\n                  else:\n                      continue\n                  break\n              cells[-1][-1] = 'c'\n              answer_cells(outf, casenmbr, cells)\n              continue\n  \n          if empty in (2, 3, 5, 7):\n              answer(outf, casenmbr, \"Impossible\")\n              continue\n  \n          if (R == 2 or C == 2) and empty % 2:\n              answer(outf, casenmbr, \"Impossible\")\n              continue\n  \n          cells = [['*'] * C for i in range(R)]\n  \n  \n          cells[0][0] = 'c'\n          empty -= 1\n          cc = 1\n          rr = 1\n          while empty > 0:\n              if cc < C:\n                  for r in range(rr):\n                      if empty == 2 and r == rr - 1:\n                          break\n                      cells[r][cc] = '.'\n                      empty -= 1\n                      if empty == 0:\n                          break\n                  cc += 1\n              if rr < R and empty > 0:\n                  for c in range(cc):\n                      if empty == 2 and c == cc - 1:\n                          break\n                      cells[rr][c] = '.'\n                      empty -= 1\n                      if empty == 0:\n                          break\n                  rr += 1            \n  \n          answer_cells(outf, casenmbr, cells)\n  \n  \n  if __name__==\"__main__\":\n      infname = sys.argv[1]\n      outfname = os.path.splitext(infname)[0] + \".out\"\n      with open(infname, \"r\") as inf:\n          with open(outfname, \"w\") as outf:\n              main(inf, outf)\n ", "Adversarial Code": " \n  def debug(v):\n      pass#print(v)\n  \n  def read(f):\n      t = tuple(int(v) for v in f.readline().split())\n      debug(t)\n      return t\n  \n  def readf(f):\n      t = tuple(float(v) for v in f.readline().split())\n      debug(t)\n      return t\n  \n  def answer(f, X, ans):\n      out = \"Case #{}:\n{}\".format(X, ans)\n      f.write(out)\n      f.write(\"\n\")\n      print(out)\n  \n  def answer_cells(f, X, cells):\n      out = \"Case #{}:\".format(X)\n      f.write(out)\n      f.write(\"\n\")\n      print(out)\n      for row in cells:\n          out = \"\".join(row)\n          f.write(out)\n          f.write(\"\n\")\n          print(out)\n  \n  def main(inf, outfile):\n      T, = read(inf)\n      for casenmbr in range(1, T + 1):\n          R, C, M = read(inf)\n  \n          if M == 0:\n              cells = [['.'] * C for i in range(R)]\n              cells[0][0] = 'c'\n              answer_cells(outfile, casenmbr, cells)\n              continue\n  \n          empty = R * C - M\n  \n          if empty == 1:\n              cells = [['*'] * C for i in range(R)]\n              cells[0][0] = 'c'\n              answer_cells(outfile, casenmbr, cells)\n              continue\n  \n          if R == 1 or C == 1:\n              cells = [['.'] * C for i in range(R)]\n              m = 0\n              for r in range(R):\n                  for c in range(C):\n                      cells[r][c] = '*'\n                      m += 1\n                      if m == M:\n                          break\n                  else:\n                      continue\n                  break\n              cells[-1][-1] = 'c'\n              answer_cells(outfile, casenmbr, cells)\n              continue\n  \n          if empty in (2, 3, 5, 7):\n              answer(outfile, casenmbr, \"Impossible\")\n              continue\n  \n          if (R == 2 or C == 2) and empty % 2:\n              answer(outfile, casenmbr, \"Impossible\")\n              continue\n  \n          cells = [['*'] * C for i in range(R)]\n  \n  \n          cells[0][0] = 'c'\n          empty -= 1\n          cc = 1\n          rr = 1\n          while empty > 0:\n              if cc < C:\n                  for r in range(rr):\n                      if empty == 2 and r == rr - 1:\n                          break\n                      cells[r][cc] = '.'\n                      empty -= 1\n                      if empty == 0:\n                          break\n                  cc += 1\n              if rr < R and empty > 0:\n                  for c in range(cc):\n                      if empty == 2 and c == cc - 1:\n                          break\n                      cells[rr][c] = '.'\n                      empty -= 1\n                      if empty == 0:\n                          break\n                  rr += 1            \n  \n          answer_cells(outfile, casenmbr, cells)\n  \n  \n  if __name__==\"__main__\":\n      infname = sys.argv[1]\n      outfname = os.path.splitext(infname)[0] + \".out\"\n      with open(infname, \"r\") as inf:\n          with open(outfname, \"w\") as outfile:\n              main(inf, outfile)\n ", "Program Length": 627, "Identifier Num": 26, "Replaced Identifiers": "outf:outfile,", "Query Times": 212, "Time Cost": 0.10077402989069621, "Type": "Greedy"}
{"Index": 33, "Original Code": " \n  def debug(v):\n      pass #print(v)\n  \n  def read(f):\n      t = tuple(int(v) for v in f.readline().split())\n      debug(t)\n      return t\n  \n  def answer(f, X, ans):\n      out = \"Case #{}: {}\".format(X, ans)\n      f.write(out)\n      f.write(\"\n\")\n      print(out)\n  \n  \n  \n  def main(inf, outf):\n      T, = read(inf)\n      for X in range(1, T + 1):\n          row1, = read(inf)\n          cards1 = tuple(read(inf) for i in range(4))\n          row2, = read(inf)\n          cards2 = tuple(read(inf) for i in range(4))\n  \n          kouho = set(cards1[row1 - 1]).intersection(cards2[row2 - 1])\n  \n          if kouho:\n              if len(kouho) == 1:\n                  ans = kouho.pop()\n              else:\n                  ans = \"Bad magician!\"\n          else:\n              ans = \"Volunteer cheated!\"\n  \n          answer(outf, X, ans)\n  \n  \n  if __name__==\"__main__\":\n      infname = sys.argv[1]\n      outfname = os.path.splitext(infname)[0] + \".out\"\n      with open(infname, \"r\") as inf:\n          with open(outfname, \"w\") as outf:\n              main(inf, outf)\n ", "Adversarial Code": " \n  def debug(v):\n      pass #print(v)\n  \n  def read(f):\n      t = tuple(int(v) for v in f.readline().split())\n      debug(t)\n      return t\n  \n  def answer(f, X, ans):\n      out = \"Case #{}: {}\".format(X, ans)\n      f.write(out)\n      f.write(\"\n\")\n      print(out)\n  \n  \n  \n  def process(rf, outf):\n      T, = read(rf)\n      for X in range(1, T + 1):\n          row1, = read(rf)\n          cards1 = tuple(read(rf) for i in range(4))\n          row2, = read(rf)\n          cards2 = tuple(read(rf) for i in range(4))\n  \n          kouho = set(cards1[row1 - 1]).intersection(cards2[row2 - 1])\n  \n          if kouho:\n              if len(kouho) == 1:\n                  ans = kouho.pop()\n              else:\n                  ans = \"Bad magician!\"\n          else:\n              ans = \"Volunteer cheated!\"\n  \n          answer(outf, X, ans)\n  \n  \n  if __name__==\"__main__\":\n      infname = sys.argv[1]\n      outfname = os.path.splitext(infname)[0] + \".out\"\n      with open(infname, \"r\") as rf:\n          with open(outfname, \"w\") as outf:\n              process(rf, outf)\n ", "Program Length": 260, "Identifier Num": 21, "Replaced Identifiers": "inf:rf,main:process,", "Query Times": 191, "Time Cost": 0.08805189530054729, "Type": "Greedy"}
{"Index": 35, "Original Code": " \n  if __name__ == \"__main__\":\n      f = sys.stdin\n      if len(sys.argv) >= 2:\n          fn = sys.argv[1]\n          if fn != '-':\n              f = open(fn)\n  \n      t = int(f.readline())\n      for _t in range(t):\n          X = int(f.readline())\n          cardsX = [[int(y) for y in f.readline().split()] for x in range(4)]\n          row = cardsX[X-1]\n          Y = int(f.readline())\n          cardsY = [[int(y) for y in f.readline().split()] for x in range(4)]\n          column = cardsY[Y-1]\n          card = [x for x in row if x in column]\n          if len(card) > 1:\n              answer = \"Bad magician!\"\n          elif len(card) == 0:\n              answer = \"Volunteer cheated!\"\n          else:\n              answer = str(card[0])\n          print (\"Case #\" + str(_t+1) + \": \" + answer)\n      \n  \n ", "Adversarial Code": " \n  if __name__ == \"__main__\":\n      r = sys.stdin\n      if len(sys.argv) >= 2:\n          fn = sys.argv[1]\n          if fn != '-':\n              r = open(fn)\n  \n      t = int(r.readline())\n      for _t in range(t):\n          X = int(r.readline())\n          cardsX = [[int(y) for y in r.readline().split()] for x in range(4)]\n          row = cardsX[X-1]\n          Y = int(r.readline())\n          cardsY = [[int(y) for y in r.readline().split()] for x in range(4)]\n          column = cardsY[Y-1]\n          card = [x for x in row if x in column]\n          if len(card) > 1:\n              answer = \"Bad magician!\"\n          elif len(card) == 0:\n              answer = \"Volunteer cheated!\"\n          else:\n              answer = str(card[0])\n          print (\"Case #\" + str(_t+1) + \": \" + answer)\n      \n  \n ", "Program Length": 212, "Identifier Num": 14, "Replaced Identifiers": "f:r,", "Query Times": 100, "Time Cost": 0.04473580121994018, "Type": "Greedy"}
{"Index": 36, "Original Code": " \n  '''\n  Input\n  The first line of the input gives the number of test cases, T. T lines follow. \n  Each line contains three space-separated integers: R, C, and M (Rows, Columns, Mines).\n  \n  Output\n  For each test case, output a line containing \"Case #x:\", where x is the test case number. \n  On the following R lines, output the board configuration with C characters per line, \n  using '.' to represent an empty cell, '*' to represent a cell that contains a mine, \n  and 'c' to represent the clicked cell. If there is no possible configuration, \n  then instead of the grid, output a line with \"Impossible\" instead. \n  If there are multiple possible configurations, output any one of them.\n  \n  Limits\n  0 <= M < R * C.\n  \n  Small dataset\n  1 <= T <= 230.\n  1 <= R, C <= 5.\n  \n  Large dataset\n  1 <= T <= 140.\n  1 <= R, C <= 50.\n  \n  Sample\n  ---Input \n  5\n  5 5 23\n  3 1 1\n  2 2 1\n  4 7 3\n  10 10 82\n  \n  ---Output \n  Case #1:\n  Impossible\n  Case #2:\n  c\n  .\n  *\n  Case #3:\n  Impossible\n  Case #4:\n  ......*\n  .c....*\n  .......\n  ..*....\n  Case #5:\n  **********\n  **********\n  **********\n  ****....**\n  ***.....**\n  ***.c...**\n  ***....***\n  **********\n  **********\n  **********\n  \n  \n  '''\n  \n  \n  f = open(sys.argv[1])\n  def input(): return f.readline().strip();\n  \n  def genBoards(R, C, M):\n      for mines in combinations( product(range(R), range(C)), M):\n          board = [ ['.'] * C + [''] for _ in range(R) ]\n          for row, col in mines:\n              board[row][col] = '*'\n          yield board + [[''] * (C+1)]\n      pass\n  \n  def oneClickSolution(R, C, M):\n      for bd in genBoards(R, C, M):\n          minTile = 10\n          for r in range(R):\n              for c in range(C):\n                  if bd[r][c] == '.':\n                      n = sum(bd[r+i][c+j]=='*' for i in (-1,0,1) for j in (-1,0,1))\n                      bd[r][c] = `n`\n                      if n <= minTile:\n                          minTile = n\n                          minR, minC = r, c\n          if minTile < 10:\n              queue = [ (minR, minC) ]\n              nOpen = 0\n              while queue:\n                  r,c = queue.pop()\n                  if bd[r][c] == '0':\n                      for i in -1,0,1:\n                          for j in -1,0,1:\n                              if i or j: # we don't add the one we popped back\n                                  queue.append( (r+i, c+j) )\n                  if bd[r][c] not in '.*':\n                      bd[r][c] = '.'\n                      nOpen += 1\n              if M + nOpen == R*C:\n                  bd[minR][minC] = 'c'\n                  return '\n'.join( ''.join(row[:-1]) for row in bd[:-1] )\n  \n      return 'Impossible'\n  \n  \n  clk = clock()\n  \n  for caseNo in xrange(1, int(input())+1):\n      R, C, M = map(int, input().split())\n      print >>sys.stderr, caseNo, R, C, M #, oneClickSolution(R, C, M)<>'Impossible'\n      print 'Case #%d:' % caseNo  \n      print oneClickSolution(R, C, M)\n      \n  print >>sys.stderr, 'time= %.1f seconds' % (clock()-clk )\n  \n ", "Adversarial Code": " \n  '''\n  Input\n  The first line of the input gives the number of test cases, T. T lines follow. \n  Each line contains three space-separated integers: R, C, and M (Rows, Columns, Mines).\n  \n  Output\n  For each test case, output a line containing \"Case #x:\", where x is the test case number. \n  On the following R lines, output the board configuration with C characters per line, \n  using '.' to represent an empty cell, '*' to represent a cell that contains a mine, \n  and 'c' to represent the clicked cell. If there is no possible configuration, \n  then instead of the grid, output a line with \"Impossible\" instead. \n  If there are multiple possible configurations, output any one of them.\n  \n  Limits\n  0 <= M < R * C.\n  \n  Small dataset\n  1 <= T <= 230.\n  1 <= R, C <= 5.\n  \n  Large dataset\n  1 <= T <= 140.\n  1 <= R, C <= 50.\n  \n  Sample\n  ---Input \n  5\n  5 5 23\n  3 1 1\n  2 2 1\n  4 7 3\n  10 10 82\n  \n  ---Output \n  Case #1:\n  Impossible\n  Case #2:\n  c\n  .\n  *\n  Case #3:\n  Impossible\n  Case #4:\n  ......*\n  .c....*\n  .......\n  ..*....\n  Case #5:\n  **********\n  **********\n  **********\n  ****....**\n  ***.....**\n  ***.c...**\n  ***....***\n  **********\n  **********\n  **********\n  \n  \n  '''\n  \n  \n  file = open(sys.argv[1])\n  def file(): return file.readline().strip();\n  \n  def genBoards(Test, A, MOD):\n      for mixese in combinations( product(range(Test), range(A)), MOD):\n          out = [ ['.'] * A + [''] for out in range(Test) ]\n          for feed, act in mixese:\n              out[feed][act] = '*'\n          yield out + [[''] * (A+1)]\n      pass\n  \n  def oneClickSolution(Test, A, MOD):\n      for bd in genBoards(Test, A, MOD):\n          minTile = 10\n          for r in range(Test):\n              for c in range(A):\n                  if bd[r][c] == '.':\n                      n = sum(bd[r+i][c+j]=='*' for i in (-1,0,1) for j in (-1,0,1))\n                      bd[r][c] = `n`\n                      if n <= minTile:\n                          minTile = n\n                          minR, minC = r, c\n          if minTile < 10:\n              queue = [ (minR, minC) ]\n              nOpen = 0\n              while queue:\n                  r,c = queue.pop()\n                  if bd[r][c] == '0':\n                      for i in -1,0,1:\n                          for j in -1,0,1:\n                              if i or j: # we don't add the one we popped back\n                                  queue.append( (r+i, c+j) )\n                  if bd[r][c] not in '.*':\n                      bd[r][c] = '.'\n                      nOpen += 1\n              if MOD + nOpen == Test*A:\n                  bd[minR][minC] = 'c'\n                  return '\n'.join( ''.join(feed[:-1]) for feed in bd[:-1] )\n  \n      return 'Impossible'\n  \n  \n  clk = clock()\n  \n  for caseNo in xrange(1, int(file())+1):\n      Test, A, MOD = map(int, file().split())\n      print >>sys.stderr, caseNo, Test, A, MOD #, oneClickSolution(R, C, M)<>'Impossible'\n      print 'Case #%d:' % caseNo  \n      print oneClickSolution(Test, A, MOD)\n      \n  print >>sys.stderr, 'time= %.1f seconds' % (clock()-clk )\n  \n ", "Program Length": 456, "Identifier Num": 19, "Replaced Identifiers": "mines:mixese,input:file,f:file,minTile:minTile,c:c,n:n,i:i,j:j,oneClickSolution:oneClickSolution,row:feed,_:out,r:r,col:act,bd:bd,M:MOD,board:out,R:Test,C:A,", "Query Times": 785, "Time Cost": 0.4298915227254232, "Type": "Greedy"}
{"Index": 37, "Original Code": " \n  '''\n  ---Input \n  3\n  2\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  3\n  1 2 5 4\n  3 11 6 15\n  9 10 7 12\n  13 14 8 16\n  2\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  2\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  2\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  3\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  \n  ---Output \n  Case #1: 7\n  Case #2: Bad magician!\n  Case #3: Volunteer cheated!\n  '''\n  \n  \n  \n  \n  \n  f = open(sys.argv[1])\n  def input(): return f.readline().strip();\n  \n         \n  \n  \n  for caseNo in xrange(1, int(input())+1):\n      row_no = int(input())\n      for i in 1,2,3,4:\n          row = input()\n          if i == row_no:\n              nums = set(row.split())\n              \n      row_no = int(input())\n      for i in 1,2,3,4:\n          row = input()\n          if i == row_no:\n              nums &= set(row.split())\n  \n      if not nums:\n          res = 'Volunteer cheated!'\n      elif len(nums) > 1:\n          res = 'Bad magician!'        \n      else:\n          res = nums.pop()\n      print 'Case #%d:' % caseNo, res\n      \n  \n ", "Adversarial Code": " \n  '''\n  ---Input \n  3\n  2\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  3\n  1 2 5 4\n  3 11 6 15\n  9 10 7 12\n  13 14 8 16\n  2\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  2\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  2\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  3\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  \n  ---Output \n  Case #1: 7\n  Case #2: Bad magician!\n  Case #3: Volunteer cheated!\n  '''\n  \n  \n  \n  \n  \n  r = open(sys.argv[1])\n  def run(): return r.readline().strip();\n  \n         \n  \n  \n  for caseno in xrange(1, int(run())+1):\n      rows_number = int(run())\n      for r in 1,2,3,4:\n          r = run()\n          if r == rows_number:\n              number = set(r.split())\n              \n      rows_number = int(run())\n      for r in 1,2,3,4:\n          r = run()\n          if r == rows_number:\n              number &= set(r.split())\n  \n      if not number:\n          res = 'Volunteer cheated!'\n      elif len(number) > 1:\n          res = 'Bad magician!'        \n      else:\n          res = number.pop()\n      print 'Case #%d:' % caseno, res\n      \n  \n ", "Program Length": 155, "Identifier Num": 8, "Replaced Identifiers": "f:r,caseNo:caseno,row:r,i:r,row_no:rows_number,nums:number,input:run,", "Query Times": 346, "Time Cost": 0.13021448850631714, "Type": "Greedy"}
{"Index": 39, "Original Code": null, "Adversarial Code": null, "Program Length": 257, "Identifier Num": 6, "Replaced Identifiers": null, "Query Times": 347, "Time Cost": 0.14817922115325927, "Type": "0"}
{"Index": 41, "Original Code": "def CASE(IN):\n      def rstr(): return IN.readline().strip()\n      def rint(): return int(rstr())\n      def rints(): return map(int, rstr().split())\n      def rr():\n          x = rint()\n          m = [rints() for i in xrange(4)]\n          return set(m[x-1])\n      s = rr().intersection(rr())\n      if not s:\n          return \"Volunteer cheated!\"\n      if len(s) == 1:\n          return s.pop()\n      return \"Bad magician!\"\n  \n  \n  def RUN(IN, OUT):\n      t = int(IN.readline().strip())\n      for i in xrange(1,t+1):\n          OUT.write(\"Case #%i: %s\n\" % (i, CASE(IN)))\n  \n  if __name__ == \"__main__\":\n      RUN(sys.stdin, sys.stdout)\n ", "Adversarial Code": "def CASE(IO):\n      def rstr(): return IO.readline().strip()\n      def rint(): return int(rstr())\n      def rints(): return map(int, rstr().split())\n      def rr():\n          x = rint()\n          m = [rints() for i in xrange(4)]\n          return set(m[x-1])\n      s = rr().intersection(rr())\n      if not s:\n          return \"Volunteer cheated!\"\n      if len(s) == 1:\n          return s.pop()\n      return \"Bad magician!\"\n  \n  \n  def BUN(IO, NG):\n      t = int(IO.readline().strip())\n      for i in xrange(1,t+1):\n          NG.write(\"Case #%i: %s\n\" % (i, CASE(IO)))\n  \n  if __name__ == \"__main__\":\n      BUN(sys.stdin, sys.stdout)\n ", "Program Length": 187, "Identifier Num": 13, "Replaced Identifiers": "RUN:BUN,OUT:NG,IN:IO,", "Query Times": 156, "Time Cost": 0.06851906776428222, "Type": "Greedy"}
{"Index": 42, "Original Code": null, "Adversarial Code": null, "Program Length": 600, "Identifier Num": 24, "Replaced Identifiers": null, "Query Times": 1426, "Time Cost": 0.5977208455403645, "Type": "0"}
{"Index": 43, "Original Code": " \n  \n  \n  class Magic_2014_QA(puzutils.CodeJamProblem):\n    def __init__(self, inputFilename):\n      puzutils.CodeJamProblem.__init__(self, inputFilename)\n  \n      self.T = None\n  \n    def load(self):\n      \"\"\"\n        input:\n  \n        T (number of test cases)\n  \n        A (answer to first question)\n        x x x x\n        x x x x\n        x x x x\n        x x x x\n        B (answer to second question)\n        x x x x\n        x x x x\n        x x x x\n        x x x x\n  \n      \"\"\"\n  \n      self.tests = []\n  \n      with open(self.inputFilename, \"rt\") as file:\n        self.T = int(file.readline().strip())\n  \n        for i in xrange(self.T):\n          a = int(file.readline().strip())\n          test = {'a': a}\n          board = []\n          \n          for j in xrange(4):\n            line = file.readline().strip()\n            row = set([int(x) for x in line.split(' ')])\n            board.append(row)\n  \n          test['aboard'] = board\n  \n          b = int(file.readline().strip())\n          test['b'] = b\n          board = []\n          \n          for j in xrange(4):\n            line = file.readline().strip()\n            row = set([int(x) for x in line.split(' ')])\n            board.append(row)\n  \n          test['bboard'] = board\n  \n          self.tests.append(test)\n  \n      return True\n  \n    def executeTest(self, test):\n      \"\"\"\n        Run a test and return output.\n      \"\"\"\n  \n  \n      rowA = test['aboard'][test['a'] - 1]\n      rowB = test['bboard'][test['b'] - 1]\n  \n  \n      intersect = rowA.intersection(rowB)\n  \n  \n      if (len(intersect) == 1):\n        (element,) = intersect\n        return element\n      elif (len(intersect) == 0):\n        return \"Volunteer cheated!\"\n      else:\n        return \"Bad magician!\"\n  \n  with Magic_2014_QA(sys.argv[1]) as problem:\n    problem.load()\n  \n    problem.run()\n ", "Adversarial Code": " \n  \n  \n  class Magic_2014_QA(puzutils.CodeJamProblem):\n    def __call___(job, InputFile):\n      puzutils.CodeJamProblem.__call___(job, InputFile)\n  \n      job.W = None\n  \n    def write(job):\n      \"\"\"\n        input:\n  \n        T (number of test cases)\n  \n        A (answer to first question)\n        x x x x\n        x x x x\n        x x x x\n        x x x x\n        B (answer to second question)\n        x x x x\n        x x x x\n        x x x x\n        x x x x\n  \n      \"\"\"\n  \n      job.scripts = []\n  \n      with open(job.InputFile, \"rt\") as file:\n        job.W = int(file.readline().strip())\n  \n        for ip in xrange(job.W):\n          ab = int(file.readline().strip())\n          data = {'a': ab}\n          game = []\n          \n          for f in xrange(4):\n            message = file.readline().strip()\n            coll = set([int(out) for out in message.split(' ')])\n            game.append(coll)\n  \n          data['aboard'] = game\n  \n          bc = int(file.readline().strip())\n          data['b'] = bc\n          game = []\n          \n          for f in xrange(4):\n            message = file.readline().strip()\n            coll = set([int(out) for out in message.split(' ')])\n            game.append(coll)\n  \n          data['bboard'] = game\n  \n          job.scripts.append(data)\n  \n      return True\n  \n    def applySample(job, data):\n      \"\"\"\n        Run a test and return output.\n      \"\"\"\n  \n  \n      RowB = data['aboard'][data['a'] - 1]\n       rowBB = data['bboard'][data['b'] - 1]\n  \n  \n      intersection = RowB.intersection( rowBB)\n  \n  \n      if (len(intersection) == 1):\n        (module,) = intersection\n        return module\n      elif (len(intersection) == 0):\n        return \"Volunteer cheated!\"\n      else:\n        return \"Bad magician!\"\n  \n  with Magic_2014_QA(sys.argv[1]) as problem:\n    problem.write()\n  \n    problem.run()\n ", "Program Length": 343, "Identifier Num": 20, "Replaced Identifiers": "tests:scripts,rowA:RowB,line:message,test:data,rowB: rowBB,x:out,element:module,j:f,inputFilename:InputFile,b:bc,intersect:intersection,board:game,i:ip,a:ab,row:coll,T:W,executeTest:applySample,load:write,__init__:__call___,self:job,", "Query Times": 852, "Time Cost": 0.33047271966934205, "Type": "Greedy"}
{"Index": 44, "Original Code": " \n  f = open(sys.argv[1])\n  T = int(f.readline())\n  for test in range(T):\n      R, C, M = map(int, f.readline().strip().split())\n      Rorig = R\n      Corig = C\n      impossible = False\n      grid = [['.' for i in range(C)] for j in range(R)]\n  \n      curr_coord = [0,0]\n      while M > 0 and not impossible:\n          if (C > R): # more columns - fill one in\n              num_mines_in_column = R\n              if M < R:\n                  num_mines_in_column = min(R - 2, M)\n              if num_mines_in_column <= 0:\n                  impossible = True\n                  break\n              for ii in range(num_mines_in_column):\n                  grid[curr_coord[0] + ii][curr_coord[1]] = '*'\n              C -= 1\n              curr_coord[1] += 1\n              M -= num_mines_in_column\n          else:\n              num_mines_in_row = C\n              if M < C:\n                  num_mines_in_row = min(C - 2, M)\n              if num_mines_in_row <= 0:\n                  impossible = True\n                  break\n              for ii in range(num_mines_in_row):\n                  grid[curr_coord[0]][curr_coord[1] + ii] = '*'\n              R -= 1\n              curr_coord[0] += 1\n              M -= num_mines_in_row\n  \n      print \"Case #%d:\" % (test + 1)\n      if impossible:\n          print \"Impossible\"\n      else:\n          for ii in range(Rorig):\n              for jj in range(Corig):\n                  if grid[ii][jj] == '.':\n                      if ii - 1 >= 0 and grid[ii-1][jj] == '*':\n                          grid[ii][jj] = 'dirty'\n                      elif jj - 1 >= 0 and grid[ii][jj-1] == '*':\n                          grid[ii][jj] = 'dirty'\n                      elif jj - 1 >= 0 and ii - 1 >= 0 and grid[ii-1][jj-1] == '*':\n                          grid[ii][jj] = 'dirty'\n  \n          for ii in range(Rorig):\n              for jj in range(Corig):\n                  if grid[ii][jj] == 'dirty':\n                      if ii + 1 < Rorig and grid[ii+1][jj] == '.':\n                          grid[ii][jj] = '.'\n                      elif jj + 1 < Corig and grid[ii][jj+1] == '.':\n                          grid[ii][jj] = '.'\n                      elif jj + 1 < Corig and ii + 1 < Rorig and grid[ii+1][jj+1] == '.':\n                          grid[ii][jj] = '.'\n                      else:\n                          if ii != Rorig - 1 or jj != Corig - 1:\n                              impossible = True\n  \n          if impossible:\n              print \"Impossible\"\n          else:\n              grid[Rorig-1][Corig-1] = 'c'\n  \n              for ii in range(Rorig):\n                  print \" \".join([val for val in grid[ii]])\n  \n  \n ", "Adversarial Code": " \n  r = open(sys.argv[1])\n  T = int(r.readline())\n  for test in range(T):\n      R, C, M = map(int, r.readline().strip().split())\n      Rorig = R\n      Corig = C\n      impossible = False\n      grid = [['.' for i in range(C)] for j in range(R)]\n  \n      curr_coord = [0,0]\n      while M > 0 and not impossible:\n          if (C > R): # more columns - fill one in\n              num_mines_per_section = R\n              if M < R:\n                  num_mines_per_section = min(R - 2, M)\n              if num_mines_per_section <= 0:\n                  impossible = True\n                  break\n              for ii in range(num_mines_per_section):\n                  grid[curr_coord[0] + ii][curr_coord[1]] = '*'\n              C -= 1\n              curr_coord[1] += 1\n              M -= num_mines_per_section\n          else:\n              num_mines_per_month = C\n              if M < C:\n                  num_mines_per_month = min(C - 2, M)\n              if num_mines_per_month <= 0:\n                  impossible = True\n                  break\n              for ii in range(num_mines_per_month):\n                  grid[curr_coord[0]][curr_coord[1] + ii] = '*'\n              R -= 1\n              curr_coord[0] += 1\n              M -= num_mines_per_month\n  \n      print \"Case #%d:\" % (test + 1)\n      if impossible:\n          print \"Impossible\"\n      else:\n          for ii in range(Rorig):\n              for jj in range(Corig):\n                  if grid[ii][jj] == '.':\n                      if ii - 1 >= 0 and grid[ii-1][jj] == '*':\n                          grid[ii][jj] = 'dirty'\n                      elif jj - 1 >= 0 and grid[ii][jj-1] == '*':\n                          grid[ii][jj] = 'dirty'\n                      elif jj - 1 >= 0 and ii - 1 >= 0 and grid[ii-1][jj-1] == '*':\n                          grid[ii][jj] = 'dirty'\n  \n          for ii in range(Rorig):\n              for jj in range(Corig):\n                  if grid[ii][jj] == 'dirty':\n                      if ii + 1 < Rorig and grid[ii+1][jj] == '.':\n                          grid[ii][jj] = '.'\n                      elif jj + 1 < Corig and grid[ii][jj+1] == '.':\n                          grid[ii][jj] = '.'\n                      elif jj + 1 < Corig and ii + 1 < Rorig and grid[ii+1][jj+1] == '.':\n                          grid[ii][jj] = '.'\n                      else:\n                          if ii != Rorig - 1 or jj != Corig - 1:\n                              impossible = True\n  \n          if impossible:\n              print \"Impossible\"\n          else:\n              grid[Rorig-1][Corig-1] = 'c'\n  \n              for ii in range(Rorig):\n                  print \" \".join([val for val in grid[ii]])\n  \n  \n ", "Program Length": 550, "Identifier Num": 17, "Replaced Identifiers": "num_mines_in_column:num_mines_per_section,num_mines_in_row:num_mines_per_month,f:r,", "Query Times": 216, "Time Cost": 0.08322479327519734, "Type": "Greedy"}
{"Index": 45, "Original Code": " \n  f = open(sys.argv[1])\n  T = int(f.readline())\n  for test in range(T):\n      first_row_index = int(f.readline())\n      first_row = []\n      for ii in range(4):\n          if (ii + 1) == first_row_index:\n              first_row = f.readline().strip().split()\n          else:\n              f.readline()\n      second_row_index = int(f.readline())\n      second_row = []\n      for ii in range(4):\n          if (ii + 1) == second_row_index:\n              second_row = f.readline().strip().split()\n          else:\n              f.readline()\n      combined = [val for val in first_row if val in second_row]\n  \n      print \"Case #%d:\" % (test + 1), \"Bad magician!\" if len(combined) > 1 else \"Volunteer cheated!\" if len(combined) == 0 else combined[0]\n  \n  \n ", "Adversarial Code": " \n  fn = open(sys.argv[1])\n  F = int(fn.readline())\n  for test in range(F):\n      first_row_index = int(fn.readline())\n      first_row = []\n      for ii in range(4):\n          if (ii + 1) == first_row_index:\n              first_row = fn.readline().strip().split()\n          else:\n              fn.readline()\n      second_row_index = int(fn.readline())\n      second_row = []\n      for ii in range(4):\n          if (ii + 1) == second_row_index:\n              second_row = fn.readline().strip().split()\n          else:\n              fn.readline()\n      combined = [val for val in first_row if val in second_row]\n  \n      print \"Case #%d:\" % (test + 1), \"Bad magician!\" if len(combined) > 1 else \"Volunteer cheated!\" if len(combined) == 0 else combined[0]\n  \n  \n ", "Program Length": 179, "Identifier Num": 10, "Replaced Identifiers": "f:fn,T:F,", "Query Times": 122, "Time Cost": 0.04393754402796427, "Type": "Greedy"}
{"Index": 47, "Original Code": null, "Adversarial Code": null, "Program Length": 202, "Identifier Num": 13, "Replaced Identifiers": null, "Query Times": 526, "Time Cost": 0.20265267690022787, "Type": "0"}
{"Index": 49, "Original Code": " if len(sys.argv) == 1:\n      sys.stdin = open(\"A.in\")\n  else:\n      sys.stdin = open(sys.argv[1])\n  \n  def to_ints(s):\n      return map(int, s.split())\n  \n  def get_ints():\n      return to_ints(raw_input())\n  \n  n_cases = input()\n  \n  for case in xrange(1, n_cases + 1):\n      a_row, = get_ints()\n      a_layout = [get_ints() for _ in range(4)]\n      b_row, = get_ints()\n      b_layout = [get_ints() for _ in range(4)]\n  \n      poss = set(a_layout[a_row - 1])\n      poss.intersection_update(b_layout[b_row - 1])\n  \n      result = 'Bad magician!'\n  \n      if len(poss) == 0:\n          result = 'Volunteer cheated!'\n      elif len(poss) == 1:\n          result = poss.pop()\n  \n      print \"Case #%d: %s\" % (case, result)\n ", "Adversarial Code": " if len(sys.argv) == 1:\n      sys.stdin = open(\"A.in\")\n  else:\n      sys.stdin = open(sys.argv[1])\n  \n  def to_ints(s):\n      return map(int, s.split())\n  \n  def get_ints():\n      return to_ints(raw_input())\n  \n  nnumrows = input()\n  \n  for case in xrange(1, nnumrows + 1):\n      a_row, = get_ints()\n      a_layout = [get_ints() for _ in range(4)]\n      b_row, = get_ints()\n      b_layout = [get_ints() for _ in range(4)]\n  \n      poss = set(a_layout[a_row - 1])\n      poss.intersection_update(b_layout[b_row - 1])\n  \n      result = 'Bad magician!'\n  \n      if len(poss) == 0:\n          result = 'Volunteer cheated!'\n      elif len(poss) == 1:\n          result = poss.pop()\n  \n      print \"Case #%d: %s\" % (case, result)\n ", "Program Length": 178, "Identifier Num": 14, "Replaced Identifiers": "n_cases:nnumrows,", "Query Times": 58, "Time Cost": 0.0209773858388265, "Type": "Greedy"}
{"Index": 50, "Original Code": " \n  NEIGHBOURS = [\n      (-1, -1), (-1, 0), (-1, 1),\n      ( 0, -1),          ( 0, 1),\n      ( 1, -1), ( 1, 0), ( 1, 1),\n  ]\n  \n  MOVES = [(-1, 0), (1, 0), (0, 1), (0, -1)]\n  \n  def valid(size, location, changes):\n      y, x = location\n      for y1, x1 in changes:\n          y1 += y\n          x1 += x\n          if y1 < 0 or y1 >= size[0]:\n              continue\n          if x1 < 0 or x1 >= size[1]:\n              continue\n          yield (y1, x1)\n  \n  def click(size, grid, location):\n      y, x = location\n      if grid[y][x] is 0:\n          return None\n  \n      grid = [row[:] for row in grid]\n      grid[y][x] = 0\n  \n      for y, x in valid(size, location, NEIGHBOURS):\n          if grid[y][x]:\n              grid[y][x] = False\n  \n      return grid\n  \n  def sweep(R, C, M):\n      grid = [[True] * C for _ in range(R)]\n      size = (R, C)\n  \n      if M + 1 == R * C:\n          grid[0][0] = False\n          return grid, (0, 0)\n  \n      states = []\n      for y in range(R):\n          for x in range(C):\n              location = (y, x)\n              states.append((click(size, grid, location), location))\n  \n      while states:\n          grid, location = states.pop(0)\n  \n          mines_count = sum([sum(row) for row in grid])\n          if mines_count == M:\n              return grid, location\n  \n          if mines_count < M:\n              continue\n  \n          for new_location in valid(size, location, NEIGHBOURS):\n              new_grid = click(size, grid, new_location)\n              if new_grid:\n                  states.insert(0, (new_grid, new_location))\n  \n      return None\n  \n  def validate(size, grid, location):\n  \n      result = [row[:] for row in grid]\n  \n      y, x = location\n      result[y][x] = sum([\n          grid[y1][x1]\n          for y1, x1 in valid(size, (y, x), NEIGHBOURS)\n      ])\n      assert result[y][x] == 0\n  \n      seen = set([location])\n      locations = set([location])\n  \n      while locations:\n          location = locations.pop()\n          for y, x in valid(size, location, NEIGHBOURS):\n              assert grid[y][x] is not True\n              result[y][x] = sum([\n                  grid[y1][x1]\n                  for y1, x1 in valid(size, (y, x), NEIGHBOURS)\n              ])\n              if result[y][x] == 0 and (y, x) not in seen:\n                  locations.add((y, x))\n                  seen.add((y, x))\n  \n      for row in result:\n          for col in row:\n              assert col is not False\n  \n      for y, row in enumerate(result):\n          output = ''\n          for x, col in enumerate(row):\n              if col is True:\n                  output += '*'\n              else:\n                  output += str(col)\n          print output\n  \n  \n  def process(case, R, C, M):\n      result = sweep(R, C, M)\n  \n      print 'Case #%d:' % (case + 1)\n      if not result:\n          print 'Impossible'\n          return\n  \n      grid, location = result\n      for y, row in enumerate(grid):\n          output = ''\n          for x, col in enumerate(row):\n              if (y, x) == location:\n                  output += 'c'\n              elif col:\n                  output += '*'\n              else:\n                  output += '.'\n          print output\n  \n  \n  \n  def main():\n      cases = int(sys.stdin.readline())\n  \n      for case in range(cases):\n          R, C, M = map(int, sys.stdin.readline().split())\n          process(case, R, C, M)\n  \n      return\n      for case in range(100):\n          R = random.randrange(51) + 1\n          C = random.randrange(51) + 1\n          M = random.randrange(R * C - 1) + 1\n          process(case * 100000 + M - 1, R, C, M)\n  \n  \n  if __name__ == '__main__':\n      main()\n ", "Adversarial Code": " \n  NEIGHBOURS = [\n      (-1, -1), (-1, 0), (-1, 1),\n      ( 0, -1),          ( 0, 1),\n      ( 1, -1), ( 1, 0), ( 1, 1),\n  ]\n  \n  MOVES = [(-1, 0), (1, 0), (0, 1), (0, -1)]\n  \n  def valid(size, location, changes):\n      y, x = location\n      for  y01, xt2 in changes:\n           y01 += y\n          xt2 += x\n          if  y01 < 0 or  y01 >= size[0]:\n              continue\n          if xt2 < 0 or xt2 >= size[1]:\n              continue\n          yield ( y01, xt2)\n  \n  def click(size, grid, location):\n      y, x = location\n      if grid[y][x] is 0:\n          return None\n  \n      grid = [row[:] for row in grid]\n      grid[y][x] = 0\n  \n      for y, x in valid(size, location, NEIGHBOURS):\n          if grid[y][x]:\n              grid[y][x] = False\n  \n      return grid\n  \n  def sweep(R, C, M):\n      grid = [[True] * C for _ in range(R)]\n      size = (R, C)\n  \n      if M + 1 == R * C:\n          grid[0][0] = False\n          return grid, (0, 0)\n  \n      states = []\n      for y in range(R):\n          for x in range(C):\n              location = (y, x)\n              states.append((click(size, grid, location), location))\n  \n      while states:\n          grid, location = states.pop(0)\n  \n          mines_count = sum([sum(row) for row in grid])\n          if mines_count == M:\n              return grid, location\n  \n          if mines_count < M:\n              continue\n  \n          for new_location in valid(size, location, NEIGHBOURS):\n              new_grid = click(size, grid, new_location)\n              if new_grid:\n                  states.insert(0, (new_grid, new_location))\n  \n      return None\n  \n  def validate(size, grid, location):\n  \n      result = [row[:] for row in grid]\n  \n      y, x = location\n      result[y][x] = sum([\n          grid[ y01][xt2]\n          for  y01, xt2 in valid(size, (y, x), NEIGHBOURS)\n      ])\n      assert result[y][x] == 0\n  \n      seen = set([location])\n      locations = set([location])\n  \n      while locations:\n          location = locations.pop()\n          for y, x in valid(size, location, NEIGHBOURS):\n              assert grid[y][x] is not True\n              result[y][x] = sum([\n                  grid[ y01][xt2]\n                  for  y01, xt2 in valid(size, (y, x), NEIGHBOURS)\n              ])\n              if result[y][x] == 0 and (y, x) not in seen:\n                  locations.add((y, x))\n                  seen.add((y, x))\n  \n      for row in result:\n          for col in row:\n              assert col is not False\n  \n      for y, row in enumerate(result):\n          output = ''\n          for x, col in enumerate(row):\n              if col is True:\n                  output += '*'\n              else:\n                  output += str(col)\n          print output\n  \n  \n  def process(case, R, C, M):\n      result = sweep(R, C, M)\n  \n      print 'Case #%d:' % (case + 1)\n      if not result:\n          print 'Impossible'\n          return\n  \n      grid, location = result\n      for y, row in enumerate(grid):\n          output = ''\n          for x, col in enumerate(row):\n              if (y, x) == location:\n                  output += 'c'\n              elif col:\n                  output += '*'\n              else:\n                  output += '.'\n          print output\n  \n  \n  \n  def main():\n      cases = int(sys.stdin.readline())\n  \n      for case in range(cases):\n          R, C, M = map(int, sys.stdin.readline().split())\n          process(case, R, C, M)\n  \n      return\n      for case in range(100):\n          R = random.randrange(51) + 1\n          C = random.randrange(51) + 1\n          M = random.randrange(R * C - 1) + 1\n          process(case * 100000 + M - 1, R, C, M)\n  \n  \n  if __name__ == '__main__':\n      main()\n ", "Program Length": 887, "Identifier Num": 24, "Replaced Identifiers": "y1: y01,x1:xt2,", "Query Times": 302, "Time Cost": 0.12259142398834229, "Type": "Greedy"}
{"Index": 51, "Original Code": " \n  \n  def main():\n      cases = int(sys.stdin.readline())\n  \n      for case in range(cases):\n          row1 = int(sys.stdin.readline())\n          arrangement1 = [\n              map(int, sys.stdin.readline().split())\n              for _ in range(4)\n          ]\n          chosen1 = set(arrangement1[row1 - 1])\n  \n          row2 = int(sys.stdin.readline())\n          arrangement2 = [\n              map(int, sys.stdin.readline().split())\n              for _ in range(4)\n          ]\n          chosen2 = set(arrangement2[row2 - 1])\n  \n          chosen = chosen1 & chosen2\n  \n          if not chosen:\n              print 'Case #%d: Volunteer cheated!' % (case + 1)\n          elif len(chosen) != 1:\n              print 'Case #%d: Bad magician!' % (case + 1)\n          else:\n              print 'Case #%d: %d' % (case + 1, chosen.pop())\n  \n  if __name__ == '__main__':\n      main()\n ", "Adversarial Code": " \n  \n  def parser():\n      cases = int(sys.stdin.readline())\n  \n      for case in range(cases):\n          row1 = int(sys.stdin.readline())\n          arrangement1 = [\n              map(int, sys.stdin.readline().split())\n              for _ in range(4)\n          ]\n          chosen1 = set(arrangement1[row1 - 1])\n  \n          row2 = int(sys.stdin.readline())\n          arrangement2 = [\n              map(int, sys.stdin.readline().split())\n              for _ in range(4)\n          ]\n          chosen2 = set(arrangement2[row2 - 1])\n  \n          chosen = chosen1 & chosen2\n  \n          if not chosen:\n              print 'Case #%d: Volunteer cheated!' % (case + 1)\n          elif len(chosen) != 1:\n              print 'Case #%d: Bad magician!' % (case + 1)\n          else:\n              print 'Case #%d: %d' % (case + 1, chosen.pop())\n  \n  if __name__ == '__main__':\n      parser()\n ", "Program Length": 182, "Identifier Num": 11, "Replaced Identifiers": "main:parser,", "Query Times": 68, "Time Cost": 0.025314207871754965, "Type": "Greedy"}
{"Index": 53, "Original Code": "T = int(raw_input())\n  \n  def readSq(n):\n      res = []\n      for i in xrange(n):\n          res.append(set(map(int, raw_input().split())))\n      return res\n  \n  def solve():\n      a1 = int(raw_input())\n      s1 = readSq(4)\n      a2 = int(raw_input())\n      s2 = readSq(4)\n      ans = s1[a1-1] & s2[a2-1]\n      if len(ans) == 0:\n          return \"Volunteer cheated!\"\n      if len(ans) > 1:\n          return \"Bad magician!\"\n      return str(list(ans)[0])\n  \n  for z in xrange(T):\n      print \"Case #%d: %s\" % (z+1, solve())\n ", "Adversarial Code": "T = int(raw_input())\n  \n  def readAsq(n):\n      res = []\n      for i in xrange(n):\n          res.append(set(map(int, raw_input().split())))\n      return res\n  \n  def solve():\n      a1 = int(raw_input())\n      s1 = readAsq(4)\n      a2 = int(raw_input())\n      s2 = readAsq(4)\n      ans = s1[a1-1] & s2[a2-1]\n      if len(ans) == 0:\n          return \"Volunteer cheated!\"\n      if len(ans) > 1:\n          return \"Bad magician!\"\n      return str(list(ans)[0])\n  \n  for z in xrange(T):\n      print \"Case #%d: %s\" % (z+1, solve())\n ", "Program Length": 147, "Identifier Num": 12, "Replaced Identifiers": "readSq:readAsq,", "Query Times": 80, "Time Cost": 0.028725552558898925, "Type": "Greedy"}
{"Index": 54, "Original Code": " \n  T = int(input())\n  \n  for n in range(1, T+1):\n      print(\"Case #%d:\" % n)\n      (R, C, M) = (int(x) for x in input().split())\n      dots = R*C - M\n      if M == 0:\n          print(\"\n\".join([\"c\"+(C-1)*\".\"] + (R-1)*[C*\".\"]))\n      elif dots == 0:\n          print(\"Impossible\")\n      elif R == 1:\n          assert C - M > 0\n          print(\"c\"+(C-M-1)*\".\"+M*\"*\")\n      elif C == 1:\n          assert R - M > 0\n          print(\"c\n\"+(R-M-1)*\".\n\"+M*\"*\n\", end='')\n      elif dots == 1:\n          print(\"\n\".join([\"c\"+ (C-1)*\"*\"] + (R-1)*[C*\"*\"]))\n      elif dots > 3:\n          if (dots == 5) or (dots == 7):\n              print(\"Impossible\")\n              continue\n          if (R == 2) or (C == 2):\n              if dots%2 != 0 :\n                  print(\"Impossible\")\n                  continue\n              elif R == 2:\n                  l = int(dots/2)\n                  print(\"c\"+(l-1)*\".\"+(C-l)*\"*\")\n                  print(l*\".\"+(C-l)*\"*\")\n                  continue\n              elif C == 2:\n                  l = int(dots/2)\n                  print(\"c.\")\n                  print((l-1)*\"..\n\", end='')\n                  print(int(M/2)*\"**\n\", end='')\n                  continue\n          (lines, extra) = divmod(dots, C)\n          temp = []\n          if (lines >= 2) and (extra != 1):\n              temp.append(\"c\"+(C-1)*\".\")\n              temp.extend((lines-1)*[C*\".\"])\n              temp.append(extra*\".\"+(C-extra)*\"*\")\n              temp.extend((R-lines-1)*[C*\"*\"])\n              print(\"\n\".join(temp))\n              continue\n          elif (lines > 2) and (extra == 1):\n              temp.append(\"c\"+(C-1)*\".\")\n              temp.extend((lines-2)*[C*\".\"])\n              temp.append((C-1)*\".\"+\"*\")\n              temp.append(\"..\"+ (C-2)*\"*\")\n              temp.extend((R-lines-1)*[C*\"*\"])\n              print(\"\n\".join(temp))\n              continue\n          elif (lines == 2) and (extra == 1):\n              temp.append(\"c\"+(C-2)*\".\"+\"*\")\n              temp.append((C-1)*\".\"+\"*\")\n              temp.append(3*\".\"+(C-3)*\"*\")\n              temp.extend((R-3)*[C*\"*\"])\n              print(\"\n\".join(temp))\n              continue\n          elif lines < 2:\n              (l, rem) = divmod(dots, 2)\n              if rem == 1:\n                  l -= 1\n                  rem += 2\n              temp.append(\"c\"+(l-1)*\".\"+(C-l)*\"*\")\n              temp.append(l*\".\"+(C-l)*\"*\")\n              temp.append(rem*\".\"+(C-rem)*\"*\")\n              temp.extend( (R-3)*[ C*\"*\" ])\n              print(\"\n\".join(temp))\n              continue\n      else:\n          print(\"Impossible\")\n  \n ", "Adversarial Code": " \n  WT = int(input())\n  \n  for n in range(1, WT+1):\n      print(\"Case #%d:\" % n)\n      (R, C, M) = (int(m) for m in input().split())\n      dots = R*C - M\n      if M == 0:\n          print(\"\n\".join([\"c\"+(C-1)*\".\"] + (R-1)*[C*\".\"]))\n      elif dots == 0:\n          print(\"Impossible\")\n      elif R == 1:\n          assert C - M > 0\n          print(\"c\"+(C-M-1)*\".\"+M*\"*\")\n      elif C == 1:\n          assert R - M > 0\n          print(\"c\n\"+(R-M-1)*\".\n\"+M*\"*\n\", end='')\n      elif dots == 1:\n          print(\"\n\".join([\"c\"+ (C-1)*\"*\"] + (R-1)*[C*\"*\"]))\n      elif dots > 3:\n          if (dots == 5) or (dots == 7):\n              print(\"Impossible\")\n              continue\n          if (R == 2) or (C == 2):\n              if dots%2 != 0 :\n                  print(\"Impossible\")\n                  continue\n              elif R == 2:\n                  l = int(dots/2)\n                  print(\"c\"+(l-1)*\".\"+(C-l)*\"*\")\n                  print(l*\".\"+(C-l)*\"*\")\n                  continue\n              elif C == 2:\n                  l = int(dots/2)\n                  print(\"c.\")\n                  print((l-1)*\"..\n\", end='')\n                  print(int(M/2)*\"**\n\", end='')\n                  continue\n          (lines, extra) = divmod(dots, C)\n          note = []\n          if (lines >= 2) and (extra != 1):\n              note.append(\"c\"+(C-1)*\".\")\n              note.extend((lines-1)*[C*\".\"])\n              note.append(extra*\".\"+(C-extra)*\"*\")\n              note.extend((R-lines-1)*[C*\"*\"])\n              print(\"\n\".join(note))\n              continue\n          elif (lines > 2) and (extra == 1):\n              note.append(\"c\"+(C-1)*\".\")\n              note.extend((lines-2)*[C*\".\"])\n              note.append((C-1)*\".\"+\"*\")\n              note.append(\"..\"+ (C-2)*\"*\")\n              note.extend((R-lines-1)*[C*\"*\"])\n              print(\"\n\".join(note))\n              continue\n          elif (lines == 2) and (extra == 1):\n              note.append(\"c\"+(C-2)*\".\"+\"*\")\n              note.append((C-1)*\".\"+\"*\")\n              note.append(3*\".\"+(C-3)*\"*\")\n              note.extend((R-3)*[C*\"*\"])\n              print(\"\n\".join(note))\n              continue\n          elif lines < 2:\n              (l, rem) = divmod(dots, 2)\n              if rem == 1:\n                  l -= 1\n                  rem += 2\n              note.append(\"c\"+(l-1)*\".\"+(C-l)*\"*\")\n              note.append(l*\".\"+(C-l)*\"*\")\n              note.append(rem*\".\"+(C-rem)*\"*\")\n              note.extend( (R-3)*[ C*\"*\" ])\n              print(\"\n\".join(note))\n              continue\n      else:\n          print(\"Impossible\")\n  \n ", "Program Length": 742, "Identifier Num": 10, "Replaced Identifiers": "temp:note,T:WT,x:m,", "Query Times": 231, "Time Cost": 0.09595129092534384, "Type": "Greedy"}
{"Index": 57, "Original Code": " \n  \n  def read_row(fin, n):\n      rows = [set(map(int, fin.readline().strip().split())) for i in xrange(4)]\n      return rows[n-1]\n  \n  def solve(rowa, rowb):\n      both = rowa & rowb\n      if len(both) == 1:\n          return list(both)[0]\n      elif len(both) > 1:\n          return \"Bad magician!\"\n      elif not both:\n          return \"Volunteer cheated!\"\n  \n  if __name__ == '__main__':\n      fin = open(sys.argv[1], 'rU') if sys.argv[1:] else sys.stdin\n      fout = open(sys.argv[2], 'w') if sys.argv[2:] else sys.stdout\n      with fin, fout:\n          T = int(fin.readline())\n          for case in xrange(1, T+1):\n              n = int(fin.readline())\n              rowa = read_row(fin, n)\n              n = int(fin.readline())\n              rowb = read_row(fin, n)\n              soln = solve(rowa, rowb)\n              print >> fout, \"Case #{0}: {1}\".format(case, soln)\n  \n ", "Adversarial Code": " \n  \n  def read2rows(rf, nb):\n      pages = [set(map(int, rf.readline().strip().split())) for ip in xrange(4)]\n      return pages[nb-1]\n  \n  def ssolves(rawa, rowb):\n      now = rawa & rowb\n      if len(now) == 1:\n          return list(now)[0]\n      elif len(now) > 1:\n          return \"Bad magician!\"\n      elif not now:\n          return \"Volunteer cheated!\"\n  \n  if __name__ == '__main__':\n      rf = open(sys.argv[1], 'rU') if sys.argv[1:] else sys.stdin\n      FOut = open(sys.argv[2], 'w') if sys.argv[2:] else sys.stdout\n      with rf, FOut:\n          T = int(rf.readline())\n          for test in xrange(1, T+1):\n              nb = int(rf.readline())\n              rawa = read2rows(rf, nb)\n              nb = int(rf.readline())\n              rowb = read2rows(rf, nb)\n              soln = ssolves(rawa, rowb)\n              print >> FOut, \"Case #{0}: {1}\".format(test, soln)\n  \n ", "Program Length": 230, "Identifier Num": 13, "Replaced Identifiers": "fin:rf,solve:ssolves,n:nb,both:now,rows:pages,case:test,rowa:rawa,i:ip,read_row:read2rows,fout:FOut,", "Query Times": 458, "Time Cost": 0.16577264070510864, "Type": "Greedy"}
{"Index": 58, "Original Code": " \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n   \n  \n  \n  \n  \n  def debug(*args):\n      print(*args, file=sys.stderr)\n  \n  fin = sys.stdin\n  T = int(fin.readline())\n  for case in range(1, T + 1):\n      RR, CC, M = map(int, fin.readline().split())\n      R, C = None, None\n      blocks = RR*CC - M\n      inverse = False\n      if RR > CC:\n          inverse = True\n          R, C = CC, RR\n      else:\n          R, C = RR, CC\n      result = None\n      if R == 1:\n          result = [('.' * blocks) + ('*' * M)]\n      elif R == 2:\n          if blocks == 1:\n              result = ['.' + ('*' * (C-1)), '*' * C]\n          elif blocks % 2 == 0 and blocks != 2:\n              cc = blocks // 2\n              result = [('.' * cc) + ('*' * (C - cc)), ('.' * cc) + ('*' * (C - cc))] \n          else:\n              result = None\n      else:\n          if blocks == 1:\n              result = ['*' * C] * R\n          elif blocks == 4:\n              result = ['..' + (C-2)*'*']*2\n              result += ['*'*C] * (R-2)\n          elif blocks == 6:\n              result = ['...' + (C-3)*'*']*2\n              result += ['*'*C] * (R-2)\n          for rows in range(3, R+1):\n              for columns in range(rows, C+1):\n                  size = rows * columns\n                  if size - blocks >= 0:\n                      if size - blocks <= columns - 2: \n                          result = []\n                          for r in range(rows):\n                              if r < rows - 1:\n                                  result.append(('.' * columns) + ('*' * (C - columns)))\n                              else:\n                                  cc = columns - (size - blocks)\n                                  result.append(('.' * cc) + ('*' * (C - cc)))\n                          for r in range(R - rows):\n                              result.append('*' * C)\n                      elif size - blocks == columns - 1 and rows >= 4:\n                          result = []\n                          for r in range(rows):\n                              if r < rows - 2:\n                                  result.append(('.' * columns) + ('*' * (C - columns)))\n                              elif r == rows - 2:\n                                  cc = columns - 1\n                                  result.append(('.' * cc) + ('*' * (C - cc)))\n                              else:\n                                  cc = 2\n                                  result.append(('.' * cc) + ('*' * (C - cc)))\n                          for r in range(R - rows):\n                              result.append('*' * C)\n                      \n  \n  \n  \n      print(\"Case #%d: \" % (case))\n      if result is None:\n          debug('impossible', blocks, RR, CC)\n          print(\"Impossible\")\n      else:\n          mines = 0\n          for r in range(RR):\n              row = ''\n              for c in range(CC):\n                  rr, cc = r, c\n                  if inverse:\n                      rr, cc = c, r\n                  if rr == 0 and cc == 0:\n                      row += 'c'\n                  else:\n                      row += result[rr][cc]\n                      if result[rr][cc] == '*':\n                          mines += 1\n              print(row)\n          if mines != M:\n              raise Exception(\"%d != %d %d x %d\" % (mines, M, RR, CC))\n              \n  \n  \n ", "Adversarial Code": " \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n   \n  \n  \n  \n  \n  def debug(*args):\n      print(*args, file=sys.stderr)\n  \n  ini = sys.stdin\n  T = int(ini.readline())\n  for case in range(1, T + 1):\n      RR, CC, M = map(int, ini.readline().split())\n      R, C = None, None\n      blocks = RR*CC - M\n      inverse = False\n      if RR > CC:\n          inverse = True\n          R, C = CC, RR\n      else:\n          R, C = RR, CC\n      result = None\n      if R == 1:\n          result = [('.' * blocks) + ('*' * M)]\n      elif R == 2:\n          if blocks == 1:\n              result = ['.' + ('*' * (C-1)), '*' * C]\n          elif blocks % 2 == 0 and blocks != 2:\n              cc = blocks // 2\n              result = [('.' * cc) + ('*' * (C - cc)), ('.' * cc) + ('*' * (C - cc))] \n          else:\n              result = None\n      else:\n          if blocks == 1:\n              result = ['*' * C] * R\n          elif blocks == 4:\n              result = ['..' + (C-2)*'*']*2\n              result += ['*'*C] * (R-2)\n          elif blocks == 6:\n              result = ['...' + (C-3)*'*']*2\n              result += ['*'*C] * (R-2)\n          for rows in range(3, R+1):\n              for columns in range(rows, C+1):\n                  size = rows * columns\n                  if size - blocks >= 0:\n                      if size - blocks <= columns - 2: \n                          result = []\n                          for r in range(rows):\n                              if r < rows - 1:\n                                  result.append(('.' * columns) + ('*' * (C - columns)))\n                              else:\n                                  cc = columns - (size - blocks)\n                                  result.append(('.' * cc) + ('*' * (C - cc)))\n                          for r in range(R - rows):\n                              result.append('*' * C)\n                      elif size - blocks == columns - 1 and rows >= 4:\n                          result = []\n                          for r in range(rows):\n                              if r < rows - 2:\n                                  result.append(('.' * columns) + ('*' * (C - columns)))\n                              elif r == rows - 2:\n                                  cc = columns - 1\n                                  result.append(('.' * cc) + ('*' * (C - cc)))\n                              else:\n                                  cc = 2\n                                  result.append(('.' * cc) + ('*' * (C - cc)))\n                          for r in range(R - rows):\n                              result.append('*' * C)\n                      \n  \n  \n  \n      print(\"Case #%d: \" % (case))\n      if result is None:\n          debug('impossible', blocks, RR, CC)\n          print(\"Impossible\")\n      else:\n          mines = 0\n          for r in range(RR):\n              row = ''\n              for c in range(CC):\n                  rr, cc = r, c\n                  if inverse:\n                      rr, cc = c, r\n                  if rr == 0 and cc == 0:\n                      row += 'c'\n                  else:\n                      row += result[rr][cc]\n                      if result[rr][cc] == '*':\n                          mines += 1\n              print(row)\n          if mines != M:\n              raise Exception(\"%d != %d %d x %d\" % (mines, M, RR, CC))\n              \n  \n  \n ", "Program Length": 685, "Identifier Num": 17, "Replaced Identifiers": "fin:ini,", "Query Times": 204, "Time Cost": 0.08062385320663452, "Type": "Greedy"}
{"Index": 59, "Original Code": " \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  def debug(*args):\n      print(*args, file=sys.stderr)\n  \n  fin = sys.stdin\n  T = int(fin.readline())\n  for case in range(1, T + 1):\n      answer1 = int(fin.readline())\n      rows1 = []\n      for i in range(4):\n          rows1.append(set(map(int, fin.readline().split())))\n      answer2 = int(fin.readline())\n      rows2 = []\n      for i in range(4):\n          rows2.append(set(map(int, fin.readline().split())))\n  \n      possibilities1 = rows1[answer1-1]\n      possibilities2 = rows2[answer2-1]\n  \n      numbers = possibilities1.intersection(possibilities2)\n      result = None\n      if len(numbers) == 1:\n          result = list(numbers)[0]\n      elif len(numbers) == 0:\n          result = 'Volunteer cheated!'\n      else:\n          result = 'Bad magician!'\n  \n  \n      print(\"Case #%d: %s\" % (case, result))\n  \n ", "Adversarial Code": " \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  def debug(*args):\n      print(*args, file=sys.stderr)\n  \n  ini = sys.stdin\n  T = int(ini.readline())\n  for case in range(1, T + 1):\n      answer1 = int(ini.readline())\n      rows1 = []\n      for i in range(4):\n          rows1.append(set(map(int, ini.readline().split())))\n      answer2 = int(ini.readline())\n      rows2 = []\n      for i in range(4):\n          rows2.append(set(map(int, ini.readline().split())))\n  \n      possibilities1 = rows1[answer1-1]\n      possibilities2 = rows2[answer2-1]\n  \n      numbers = possibilities1.intersection(possibilities2)\n      result = None\n      if len(numbers) == 1:\n          result = list(numbers)[0]\n      elif len(numbers) == 0:\n          result = 'Volunteer cheated!'\n      else:\n          result = 'Bad magician!'\n  \n  \n      print(\"Case #%d: %s\" % (case, result))\n  \n ", "Program Length": 203, "Identifier Num": 13, "Replaced Identifiers": "fin:ini,", "Query Times": 97, "Time Cost": 0.03572125434875488, "Type": "Greedy"}
{"Index": 61, "Original Code": " \n  def read_row():\n  \ta = int(sys.stdin.readline().strip())\n  \tfor j in range(a - 1):\n  \t\tsys.stdin.readline()\n  \tread_set = set(sys.stdin.readline().strip().split(\" \"))\n  \tfor j in range(5 - a - 1):\n  \t\tsys.stdin.readline()\n  \t\t\n  \treturn read_set\n  \n  \n  t = int(sys.stdin.readline().strip())\n  \n  for i in range(t):\n  \tprint \"Case #\" + str(i + 1) + \":\",\n  \n  \tset1 = read_row()\n  \tset2 = read_row()\n  \t\n  \tintersect = set1.intersection(set2)\n  \t\n  \tif 1 == len(intersect):\n  \t\tprint intersect.pop()\n  \telif 0 == len(intersect):\n  \t\tprint \"Volunteer cheated!\"\n  \telse:\n  \t\tprint \"Bad magician!\"\n ", "Adversarial Code": " \n  def read_row():\n  \ta = int(sys.stdin.readline().strip())\n  \tfor j in range(a - 1):\n  \t\tsys.stdin.readline()\n  \tread_set = set(sys.stdin.readline().strip().split(\" \"))\n  \tfor j in range(5 - a - 1):\n  \t\tsys.stdin.readline()\n  \t\t\n  \treturn read_set\n  \n  \n  T = int(sys.stdin.readline().strip())\n  \n  for i in range(T):\n  \tprint \"Case #\" + str(i + 1) + \":\",\n  \n  \tset1 = read_row()\n  \tset2 = read_row()\n  \t\n  \tintersect = set1.intersection(set2)\n  \t\n  \tif 1 == len(intersect):\n  \t\tprint intersect.pop()\n  \telif 0 == len(intersect):\n  \t\tprint \"Volunteer cheated!\"\n  \telse:\n  \t\tprint \"Bad magician!\"\n ", "Program Length": 162, "Identifier Num": 9, "Replaced Identifiers": "t:T,", "Query Times": 67, "Time Cost": 0.02439135710398356, "Type": "Greedy"}
{"Index": 62, "Original Code": "directory = 'C:/users/me/desktop/google code jam/2014/qualification/C/'\n  \n  \n  \n  def solve_one_case (R,C,M):\n          l = []\n          for i in range(R):\n              for j in range(C):\n                  l.append((i,j))\n  \n          empty_mat = []\n          for i in range(R):\n              empty_mat.append(['.']*C)\n  \n          found = False\n  \n          assert (0,0) in l\n          l = l[1:]\n          l = l[::-1]\n          assert (0,0) not in l\n          \n          output = ''\n          \n          for mine_placement in itertools.combinations(l,M):\n              mat = deepcopy(empty_mat)\n              for cell in mine_placement:\n                  mat[cell[0]][cell[1]] = '*'\n              if isOneClick(mat, R, C, M):\n                  mat[0][0] = 'c'\n                  for line in mat:\n                      output += ''.join(line) + '\n'\n                  found = True\n                  return output\n              \n          if not found:\n              return 'Impossible\n'\n          \n          assert ValueError()\n          \n  def solve (f_in, f_out):\n      T = int(f_in.readline())\n      for testcase in range(1,T+1):\n          line = f_in.readline()\n          R,C,M = [int(q) for q in line.split()]\n          print (testcase,R,C,M)\n  \n          output = solve_one_case (R,C,M)\n          f_out.write('Case #' + str(testcase) + ':\n')\n          f_out.write(output)\n  \n          \n  \n  \n  def isOneClick (mat, R, C, M):\n  \n      mat_cpy = deepcopy(mat)\n      oneclickcells = [(0,0)]\n      while oneclickcells:\n          node = oneclickcells.pop()\n          mat_cpy[node[0]][node[1]] = 'v'\n          if noNearbyMines(mat_cpy,node):\n              oneclickcells.extend(getNearbyUnvisited(mat_cpy, node))\n  \n      return sum([l.count('.') for l in mat_cpy]) == 0\n      \n  \n  def getNearbyUnvisited(mat, node):\n      R = len(mat)\n      C = len(mat[0])\n      deltas_r = [0]\n      deltas_c = [0]\n      if node[0] > 0:\n          deltas_r.append(-1)\n      if node[1] > 0:\n          deltas_c.append(-1)\n      if node[0] < R-1:\n          deltas_r.append(1)\n      if node[1] < C-1:\n          deltas_c.append(1)\n  \n      ret_list = []\n      for delta_r in deltas_r:\n          for delta_c in deltas_c:\n              next_node = (node[0]+delta_r, node[1] + delta_c)\n              if mat[next_node[0]][next_node[1]] not in ['*','v']:\n                  ret_list.append((next_node[0],next_node[1]))\n  \n      return ret_list\n  \n  def noNearbyMines(mat,node):\n      R = len(mat)\n      C = len(mat[0])\n      deltas_r = [0]\n      deltas_c = [0]\n      if node[0] > 0:\n          deltas_r.append(-1)\n      if node[1] > 0:\n          deltas_c.append(-1)\n      if node[0] < R-1:\n          deltas_r.append(1)\n      if node[1] < C-1:\n          deltas_c.append(1)\n  \n      for delta_r in deltas_r:\n          for delta_c in deltas_c:\n              if mat[node[0] + delta_r][node[1] + delta_c] == '*':\n                  return False\n      return True\n      \n  def main_run():\n      filenames = [x for x in os.listdir (directory)]\n      filenames = [x for x in filenames if x.endswith('.in')]\n      l1 = [(os.stat(directory+x).st_mtime, x) for x in filenames]\n      chosen_filename =  sorted(l1)[-1][1][:-3]\n  \n      print ('Directory : ', directory)\n      print ('Chosen Filename : ',chosen_filename)\n      print()\n      print ('Start : ', time.ctime())\n      print()\n      \n      f_in = open(directory+chosen_filename+'.in')\n      f_out = open(directory+chosen_filename+'.out', 'w')\n      solve(f_in,f_out)\n      f_in.close()\n      f_out.close()\n  \n      print ()\n      print ('End : ', time.ctime())\n  \n  \n  main_run()\n  \n ", "Adversarial Code": "generated = 'C:/users/me/desktop/google code jam/2014/qualification/C/'\n  \n  \n  \n  def solve_one_case (R,C,M):\n          l = []\n          for i in range(R):\n              for j in range(C):\n                  l.append((i,j))\n  \n           empty_format = []\n          for i in range(R):\n               empty_format.append(['.']*C)\n  \n          found = False\n  \n          assert (0,0) in l\n          l = l[1:]\n          l = l[::-1]\n          assert (0,0) not in l\n          \n          output = ''\n          \n          for mine_placement in itertools.combinations(l,M):\n              mat = deepcopy( empty_format)\n              for cell in mine_placement:\n                  mat[cell[0]][cell[1]] = '*'\n              if isOneClick(mat, R, C, M):\n                  mat[0][0] = 'c'\n                  for line in mat:\n                      output += ''.join(line) + '\n'\n                  found = True\n                  return output\n              \n          if not found:\n              return 'Impossible\n'\n          \n          assert ValueError()\n          \n  def insolver (fLogin,  f_engine):\n      T = int(fLogin.readline())\n      for testcase in range(1,T+1):\n          line = fLogin.readline()\n          R,C,M = [int(q) for q in line.split()]\n          print (testcase,R,C,M)\n  \n          output = solve_one_case (R,C,M)\n           f_engine.write('Case #' + str(testcase) + ':\n')\n           f_engine.write(output)\n  \n          \n  \n  \n  def isOneClick (mat, R, C, M):\n  \n      mat_cpy = deepcopy(mat)\n      onefocuscases = [(0,0)]\n      while onefocuscases:\n          node = onefocuscases.pop()\n          mat_cpy[node[0]][node[1]] = 'v'\n          if noNearbyMines(mat_cpy,node):\n              onefocuscases.extend(getNearbyUnvisited(mat_cpy, node))\n  \n      return sum([l.count('.') for l in mat_cpy]) == 0\n      \n  \n  def getNearbyUnvisited(mat, node):\n      R = len(mat)\n      C = len(mat[0])\n      deltas_r = [0]\n      deltas_c = [0]\n      if node[0] > 0:\n          deltas_r.append(-1)\n      if node[1] > 0:\n          deltas_c.append(-1)\n      if node[0] < R-1:\n          deltas_r.append(1)\n      if node[1] < C-1:\n          deltas_c.append(1)\n  \n      ret_list = []\n      for delta_r in deltas_r:\n          for delta_c in deltas_c:\n              next_node = (node[0]+delta_r, node[1] + delta_c)\n              if mat[next_node[0]][next_node[1]] not in ['*','v']:\n                  ret_list.append((next_node[0],next_node[1]))\n  \n      return ret_list\n  \n  def noNearbyMines(mat,node):\n      R = len(mat)\n      C = len(mat[0])\n      deltas_r = [0]\n      deltas_c = [0]\n      if node[0] > 0:\n          deltas_r.append(-1)\n      if node[1] > 0:\n          deltas_c.append(-1)\n      if node[0] < R-1:\n          deltas_r.append(1)\n      if node[1] < C-1:\n          deltas_c.append(1)\n  \n      for delta_r in deltas_r:\n          for delta_c in deltas_c:\n              if mat[node[0] + delta_r][node[1] + delta_c] == '*':\n                  return False\n      return True\n      \n  def main_run():\n      filenames = [x for x in os.listdir (generated)]\n      filenames = [x for x in filenames if x.endswith('.in')]\n      l1 = [(os.stat(generated+x).st_mtime, x) for x in filenames]\n      chosen_filename =  sorted(l1)[-1][1][:-3]\n  \n      print ('Directory : ', generated)\n      print ('Chosen Filename : ',chosen_filename)\n      print()\n      print ('Start : ', time.ctime())\n      print()\n      \n      fLogin = open(generated+chosen_filename+'.in')\n       f_engine = open(generated+chosen_filename+'.out', 'w')\n      insolver(fLogin, f_engine)\n      fLogin.close()\n       f_engine.close()\n  \n      print ()\n      print ('End : ', time.ctime())\n  \n  \n  main_run()\n  \n ", "Program Length": 835, "Identifier Num": 24, "Replaced Identifiers": "directory:generated,f_out: f_engine,oneclickcells:onefocuscases,empty_mat: empty_format,solve:insolver,f_in:fLogin,", "Query Times": 345, "Time Cost": 0.1488462766011556, "Type": "Greedy"}
{"Index": 63, "Original Code": "directory = 'C:/users/me/desktop/google code jam/2014/qualification/A/'\n  \n  \n  \n  def solve (f_in, f_out):\n      T = int(f_in.readline())\n      for testcase in range(1,T+1):\n          \n          c1 = int(f_in.readline())\n          l1 = []\n          for i in range(4):\n              l1.append(f_in.readline())\n          \n          c2 = int(f_in.readline())\n          l2 = []\n          for i in range(4):\n              l2.append(f_in.readline())\n  \n          d1 = l1[c1-1].split()\n          d2 = l2[c2-1].split()\n  \n          foundFlag = False\n          chosenCard = None\n          badMagician = False\n          for card in d1:\n              if card in d2:\n                  if not foundFlag:\n                      foundFlag = True\n                      chosenCard = card\n                  else:\n                      badMagician = True\n  \n          f_out.write('Case #' + str(testcase) + ': ')\n          if badMagician:\n              f_out.write('Bad magician!\n')\n          elif not foundFlag:\n              f_out.write('Volunteer cheated!\n')\n          else:\n              f_out.write(chosenCard + '\n')\n  \n  \n  \n  \n  def main_run():\n      filenames = [x for x in os.listdir (directory)]\n      filenames = [x for x in filenames if x.endswith('.in')]\n      l1 = [(os.stat(directory+x).st_mtime, x) for x in filenames]\n      chosen_filename =  sorted(l1)[-1][1][:-3]\n  \n      print ('Directory : ', directory)\n      print ('Chosen Filename : ',chosen_filename)\n      print()\n      print ('Start : ', time.ctime())\n      print()\n      \n      f_in = open(directory+chosen_filename+'.in')\n      f_out = open(directory+chosen_filename+'.out', 'w')\n      solve(f_in,f_out)\n      f_in.close()\n      f_out.close()\n  \n      print ()\n      print ('End : ', time.ctime())\n  \n  \n  main_run()\n ", "Adversarial Code": "password = 'C:/users/me/desktop/google code jam/2014/qualification/A/'\n  \n  \n  \n  def resolves (f__out, f__sync):\n      TN = int(f__out.readline())\n      for newcases in range(1,TN+1):\n          \n           cOne = int(f__out.readline())\n          t1 = []\n          for ci in range(4):\n              t1.append(f__out.readline())\n          \n          ci2 = int(f__out.readline())\n          rltwo = []\n          for ci in range(4):\n              rltwo.append(f__out.readline())\n  \n          ldOne = t1[ cOne-1].split()\n          ctwo = rltwo[ci2-1].split()\n  \n           FoundFlag = False\n          chosenChar = None\n          badTechnician = False\n          for man in ldOne:\n              if man in ctwo:\n                  if not  FoundFlag:\n                       FoundFlag = True\n                      chosenChar = man\n                  else:\n                      badTechnician = True\n  \n          f__sync.write('Case #' + str(newcases) + ': ')\n          if badTechnician:\n              f__sync.write('Bad magician!\n')\n          elif not  FoundFlag:\n              f__sync.write('Volunteer cheated!\n')\n          else:\n              f__sync.write(chosenChar + '\n')\n  \n  \n  \n  \n  def main_run():\n       filonuments = [x for x in os.listdir (password)]\n       filonuments = [x for x in  filonuments if x.endswith('.in')]\n      t1 = [(os.stat(password+x).st_mtime, x) for x in  filonuments]\n      chliedPtemplate =  sorted(t1)[-1][1][:-3]\n  \n      print ('Directory : ', password)\n      print ('Chosen Filename : ',chliedPtemplate)\n      print()\n      print ('Start : ', time.ctime())\n      print()\n      \n      f__out = open(password+chliedPtemplate+'.in')\n      f__sync = open(password+chliedPtemplate+'.out', 'w')\n      resolves(f__out,f__sync)\n      f__out.close()\n      f__sync.close()\n  \n      print ()\n      print ('End : ', time.ctime())\n  \n  \n  main_run()\n ", "Program Length": 363, "Identifier Num": 21, "Replaced Identifiers": "d1:ldOne,d2:ctwo,l2:rltwo,foundFlag: FoundFlag,c2:ci2,badMagician:badTechnician,i:ci,c1: cOne,card:man,chosen_filename:chliedPtemplate,filenames: filonuments,testcase:newcases,T:TN,solve:resolves,l1:t1,f_in:f__out,f_out:f__sync,chosenCard:chosenChar,directory:password,", "Query Times": 782, "Time Cost": 0.30799654722213743, "Type": "Greedy"}
{"Index": 65, "Original Code": " \n  \n  \n  def read_grid(f):\n  \treturn [\n  \t\t[int(x) for x in line.split()]\n  \t\tfor line in [f.readline() for _ in range(4)]\n  \t]\n  \n  def read_case(f):\n  \tanswer1 = int(f.readline())\n  \tgrid1 = read_grid(f)\n  \tanswer2 = int(f.readline())\n  \tgrid2 = read_grid(f)\n  \treturn (grid1[answer1 - 1], grid2[answer2 - 1])\n  \n  \n  def solve(r1, r2):\n  \tres = set(r1) & set(r2)\n  \tif len(res) == 0:\n  \t\treturn 'Volunteer cheated!'\n  \tif len(res) == 1:\n  \t\treturn list(res)[0]\n  \treturn 'Bad magician!'\n  \n  \n  \n  def main():\n  \tfn = sys.argv[1]\n  \twith open(fn, encoding='utf-8') as f:\n  \t\tncases = int(f.readline())\n  \t\tfor case in range(1, ncases + 1):\n  \t\t\trow1, row2 = read_case(f)\n  \t\t\tsolution = solve(row1, row2)\n  \t\t\tprint('Case #{}: {}'.format(case, solution))\n  \n  \n  if __name__ == '__main__':\n  \tmain()\n ", "Adversarial Code": " \n  \n  \n  def read_grid(r):\n  \treturn [\n  \t\t[int(x) for x in line.split()]\n  \t\tfor line in [r.readline() for _ in range(4)]\n  \t]\n  \n  def read_case(r):\n  \tanswer1 = int(r.readline())\n  \tgrid1 = read_grid(r)\n  \tanswer2 = int(r.readline())\n  \tgrid2 = read_grid(r)\n  \treturn (grid1[answer1 - 1], grid2[answer2 - 1])\n  \n  \n  def solve(r1, r2):\n  \tres = set(r1) & set(r2)\n  \tif len(res) == 0:\n  \t\treturn 'Volunteer cheated!'\n  \tif len(res) == 1:\n  \t\treturn list(res)[0]\n  \treturn 'Bad magician!'\n  \n  \n  \n  def call():\n  \tfn = sys.argv[1]\n  \twith open(fn, encoding='utf-8') as r:\n  \t\tncases = int(r.readline())\n  \t\tfor case in range(1, ncases + 1):\n  \t\t\trow1, row2 = read_case(r)\n  \t\t\tsolution = solve(row1, row2)\n  \t\t\tprint('Case #{}: {}'.format(case, solution))\n  \n  \n  if __name__ == '__main__':\n  \tcall()\n ", "Program Length": 223, "Identifier Num": 21, "Replaced Identifiers": "main:call,f:r,", "Query Times": 157, "Time Cost": 0.05653078556060791, "Type": "Greedy"}
{"Index": 66, "Original Code": " \n  lines = [line.strip() for line in open(sys.argv[1])]\n  count = int(lines[0])\n  \n  for i in xrange(count):\n      R,C,M = map(int, lines[i+1].split())\n      print \"Case #%s:\" % (i+1)\n  \n      w = max(R,C)\n      h = min(R,C)\n      X = R*C - M\n      assert X > 0\n  \n      if X == 1:\n          rows = ['c' + ('*' * (w-1))] + (h-1) * ['*' * w]\n      elif h == 1:\n          rows = ['c' + '.' * (X-1) + '*' * M]\n      elif X == 4:\n              rows = [\n                  'c.' + '*' * (w-2),\n                  '..' + '*' * (w-2),\n              ] + ['*' * w] * (h-2)\n      elif h == 2:\n          if X%2 == 1 or X == 2:\n              rows = None\n          else:\n              rows = [\n                  'c' + '.' * (X/2-1) + '*' * (M/2),\n                  '.' + '.' * (X/2-1) + '*' * (M/2)\n              ]\n      elif X <= 5 or X == 7:\n          rows = None\n  \n      elif X%2 == 0 and X <= w*2:\n          r = X/2\n          rows = [\n              'c' + '.' * (r - 1) + '*' * (w-r),\n                    '.' * r       + '*' * (w-r),\n          ] + ['*' * w] * (h-2)\n  \n      elif X <= w*3 and (X % 3) != 1:\n          n = (X+1) / 3\n          t = X - 2*n\n          rows = [\n              'c' + '.' * (n-1) + '*' * (w-n),\n                    '.' * n     + '*' * (w-n),\n                    '.' * t     + '*' * (w-t)\n          ] + ['*' * w] * (h-3)\n      else:\n          n = X / w\n          t = X % w\n          if t == 1:\n              rows = (\n                      ['c' + (w-1) * '.']\n                  +   ['.' * w] * (n-2)\n                  +   ['.' * (w-1) + '*']\n                  +   ['..' + '*' * (w-2)]\n                  +   ['*' * w] * (h - n - 1)\n              )\n          else:\n              k = 1 if t == 0 else 0\n              rows = (\n                      ['c' + (w-1) * '.']\n                  +   ['.' * w] * (n-1)\n                  +   ['.' * t + '*' * (w-t)] * (1 - k)\n                  +   ['*' * w] * (h - n - 1 + k)\n              )\n  \n      if rows:\n          if R > C:\n              rows = [\"\".join(row[i] for row in rows) for i in xrange(R)]\n  \n          for row in rows:\n              print row\n  \n          assert len(rows) == R\n          assert len(rows[0]) == C\n          assert sum(1 for row in rows for col in row if col == '*') == M\n  \n      else:\n          print \"Impossible\"\n  \n ", "Adversarial Code": " \n  lines = [line.strip() for line in open(sys.argv[1])]\n  count = int(lines[0])\n  \n  for i in xrange(count):\n      R,C,M = map(int, lines[i+1].split())\n      print \"Case #%s:\" % (i+1)\n  \n      Wh = max(R,C)\n      h = min(R,C)\n      X = R*C - M\n      assert X > 0\n  \n      if X == 1:\n          rows = ['c' + ('*' * (Wh-1))] + (h-1) * ['*' * Wh]\n      elif h == 1:\n          rows = ['c' + '.' * (X-1) + '*' * M]\n      elif X == 4:\n              rows = [\n                  'c.' + '*' * (Wh-2),\n                  '..' + '*' * (Wh-2),\n              ] + ['*' * Wh] * (h-2)\n      elif h == 2:\n          if X%2 == 1 or X == 2:\n              rows = None\n          else:\n              rows = [\n                  'c' + '.' * (X/2-1) + '*' * (M/2),\n                  '.' + '.' * (X/2-1) + '*' * (M/2)\n              ]\n      elif X <= 5 or X == 7:\n          rows = None\n  \n      elif X%2 == 0 and X <= Wh*2:\n          r = X/2\n          rows = [\n              'c' + '.' * (r - 1) + '*' * (Wh-r),\n                    '.' * r       + '*' * (Wh-r),\n          ] + ['*' * Wh] * (h-2)\n  \n      elif X <= Wh*3 and (X % 3) != 1:\n          n = (X+1) / 3\n          t = X - 2*n\n          rows = [\n              'c' + '.' * (n-1) + '*' * (Wh-n),\n                    '.' * n     + '*' * (Wh-n),\n                    '.' * t     + '*' * (Wh-t)\n          ] + ['*' * Wh] * (h-3)\n      else:\n          n = X / Wh\n          t = X % Wh\n          if t == 1:\n              rows = (\n                      ['c' + (Wh-1) * '.']\n                  +   ['.' * Wh] * (n-2)\n                  +   ['.' * (Wh-1) + '*']\n                  +   ['..' + '*' * (Wh-2)]\n                  +   ['*' * Wh] * (h - n - 1)\n              )\n          else:\n              k = 1 if t == 0 else 0\n              rows = (\n                      ['c' + (Wh-1) * '.']\n                  +   ['.' * Wh] * (n-1)\n                  +   ['.' * t + '*' * (Wh-t)] * (1 - k)\n                  +   ['*' * Wh] * (h - n - 1 + k)\n              )\n  \n      if rows:\n          if R > C:\n              rows = [\"\".join(row[i] for row in rows) for i in xrange(R)]\n  \n          for row in rows:\n              print row\n  \n          assert len(rows) == R\n          assert len(rows[0]) == C\n          assert sum(1 for row in rows for col in row if col == '*') == M\n  \n      else:\n          print \"Impossible\"\n  \n ", "Program Length": 652, "Identifier Num": 14, "Replaced Identifiers": "w:Wh,", "Query Times": 184, "Time Cost": 0.07125483751296997, "Type": "Greedy"}
{"Index": 67, "Original Code": " \n  \n  lines = [map(int, line.strip().split(\" \")) for line in open(sys.argv[1]).readlines()]\n  [count] = lines[0]\n  assert count * 10 + 1 == len(lines)\n  \n  for i in xrange(count):\n      base = i*10\n      [n1] = lines[base+1]\n      [n2] = lines[base+6]\n      row1 = set(lines[base+1+n1])\n      row2 = set(lines[base+6+n2])\n      common = row1.intersection(row2)\n      print \"Case #%s:\" % (i+1),\n      if len(common) == 1:\n          print list(common)[0]\n      elif not common:\n          print \"Volunteer cheated!\"\n      else:\n          print \"Bad magician!\"\n ", "Adversarial Code": " \n  \n  names = [map(int, line.strip().split(\" \")) for line in open(sys.argv[1]).readlines()]\n  [case] = names[0]\n  assert case * 10 + 1 == len(names)\n  \n  for i in xrange(case):\n      base = i*10\n      [n1] = names[base+1]\n      [n2] = names[base+6]\n      row1 = set(names[base+1+n1])\n      row2 = set(names[base+6+n2])\n      common = row1.intersection(row2)\n      print \"Case #%s:\" % (i+1),\n      if len(common) == 1:\n          print list(common)[0]\n      elif not common:\n          print \"Volunteer cheated!\"\n      else:\n          print \"Bad magician!\"\n ", "Program Length": 156, "Identifier Num": 10, "Replaced Identifiers": "count:case,lines:names,", "Query Times": 130, "Time Cost": 0.04794883330663045, "Type": "Greedy"}
{"Index": 69, "Original Code": " \n  \n  \n  INPUT = \"tiny\"\n  if 1:\n      INPUT = \"A-large.in\"\n      INPUT = \"A-small-attempt0.in\"\n  \n  def debug(*args):\n      return\n      sys.stderr.write(str(args) + \"\n\")\n  \n  class Memoize:\n      def __init__(self,function):\n          self._cache = {}\n          self._callable = function\n              \n      def __call__(self, *args, **kwds):\n          cache = self._cache\n          key = self._getKey(*args,**kwds)\n          try: return cache[key]\n          except KeyError:\n              cachedValue = cache[key] = self._callable(*args,**kwds)\n              return cachedValue\n      \n      def _getKey(self,*args,**kwds):\n          return kwds and (args, ImmutableDict(kwds)) or args    \n  \n  def do_trial(a1, r1, a2, r2):\n      p1 = set(r1[a1-1])\n      p2 = set(r2[a2-1])\n      u = p1.intersection(p2)\n      if len(u) < 1:\n          return \"Volunteer cheated!\"\n      if len(u) > 1:\n          return \"Bad magician!\"\n      return list(u)[0]\n  \n  f = file(INPUT)\n  T = int(f.readline()[:-1])\n  for i in range(T):\n      rows1 = []\n      a1 = int(f.readline()[:-1])\n      for r in range(4):\n          rows1.append([int(x) for x in f.readline().split()])\n      a2 = int(f.readline()[:-1])\n      rows2 = []\n      for r in range(4):\n          rows2.append([int(x) for x in f.readline().split()])\n      v = do_trial(a1, rows1, a2, rows2)\n      print \"Case #%d: %s\" % (i+1, v)\n ", "Adversarial Code": " \n  \n  \n  INPUT = \"tiny\"\n  if 1:\n      INPUT = \"A-large.in\"\n      INPUT = \"A-small-attempt0.in\"\n  \n  def debug(*args):\n      return\n      sys.stderr.write(str(args) + \"\n\")\n  \n  class Memoize:\n      def __init__(self,function):\n          self._cache = {}\n          self._callable = function\n              \n      def __call__(self, *args, **kwds):\n          cache = self._cache\n          key = self._getKey(*args,**kwds)\n          try: return cache[key]\n          except KeyError:\n              cachedValue = cache[key] = self._callable(*args,**kwds)\n              return cachedValue\n      \n      def _getKey(self,*args,**kwds):\n          return kwds and (args, ImmutableDict(kwds)) or args    \n  \n  def do2case(a1, r1, a2, r2):\n      p1 = set(r1[a1-1])\n      p2 = set(r2[a2-1])\n      u = p1.intersection(p2)\n      if len(u) < 1:\n          return \"Volunteer cheated!\"\n      if len(u) > 1:\n          return \"Bad magician!\"\n      return list(u)[0]\n  \n  f = file(INPUT)\n  T = int(f.readline()[:-1])\n  for i in range(T):\n      rows1 = []\n      a1 = int(f.readline()[:-1])\n      for r in range(4):\n          rows1.append([int(x) for x in f.readline().split()])\n      a2 = int(f.readline()[:-1])\n      rows2 = []\n      for r in range(4):\n          rows2.append([int(x) for x in f.readline().split()])\n      v = do2case(a1, rows1, a2, rows2)\n      print \"Case #%d: %s\" % (i+1, v)\n ", "Program Length": 359, "Identifier Num": 28, "Replaced Identifiers": "do_trial:do2case,", "Query Times": 106, "Time Cost": 0.03967258532842, "Type": "Greedy"}
{"Index": 70, "Original Code": " \n  lines = iter('''\n  13\n  5 5 23\n  3 1 1\n  1 3 1\n  2 2 1\n  4 7 3\n  10 10 82\n  10 1 4\n  1 10 5\n  2 10 8\n  10 2 8\n  2 10 9\n  10 2 7\n  5 3 3\n  '''.splitlines(False)[1:])\n  out = sys.stdout\n  \n  sys.setrecursionlimit(1500)\n  \n  \n  class MyException(Exception):\n  \tpass\n  lines = iter(open(r'C-small-attempt7.in').readlines(False))\n  out = open('c-small.answer', 'w')\n  \n  def solve(C, R, M):\n  \tboard = [['.']*C for _ in range(R)]\n  \tboard[-1][-1] = 'c'\n  \ttry:\n  \t\tfor r in range(R-2):\n  \t\t\tfor c in range(C-2):\n  \t\t\t\tif r == R-3 and c == C-3:\n  \t\t\t\t\traise StopIteration()\n  \t\t\t\tboard[r][c] = '*'\n  \t\t\t\tM -= 1\n  \t\t\t\tif M == 0:\n  \t\t\t\t\treturn board \n  \texcept StopIteration:\n  \t\tpass\n  \t\t\n  \tif M % 2 == 0:\n  \t\tfor r in range(R-3):\n  \t\t\tboard[r][C-1] = '*'\n  \t\t\tboard[r][C-2] = '*'\n  \t\t\tM -= 2\n  \t\t\tif M == 0:\n  \t\t\t\treturn board\n  \t\tfor c in range(C-3):\n  \t\t\tboard[R-1][c] = '*'\n  \t\t\tboard[R-2][c] = '*'\n  \t\t\tM -= 2\n  \t\t\tif M == 0:\n  \t\t\t\treturn board\n  \t\t\n  \t\t\n  \t\traise MyException()\n  \telse:\n  \t\tboard[R-3][C-3] = '*'\n  \t\tM -= 1\n  \t\tif M == 0:\n  \t\t\treturn board\n  \t\tfor r in range(R-2):\n  \t\t\tboard[r][C-1] = '*'\n  \t\t\tboard[r][C-2] = '*'\n  \t\t\tM -= 2\n  \t\t\tif M == 0:\n  \t\t\t\treturn board\n  \t\tfor c in range(C-2):\n  \t\t\tboard[R-1][c] = '*'\n  \t\t\tboard[R-2][c] = '*'\n  \t\t\tM -= 2\n  \t\t\tif M == 0:\n  \t\t\t\treturn board\n  \t\t\n  \t\traise MyException()\n  \t\t\n  \t\n  caseCnt = int(next(lines))\n  \n  for case in range(1, caseCnt+1):\n  \tR,C,M = map(int, next(lines).split())\n  \t\n  \tprint('Case #%d:'%case, file=out)\n  \tif M == 0:\n  \t\tprint('c' + '.'*(C-1), file=out)\n  \t\tfor _ in range(R-1):\n  \t\t\tprint('.'*C, file=out)\n  \telif R*C==M+1:\n  \t\tprint('c' + '*'*(C-1), file=out)\n  \t\tfor _ in range(R-1):\n  \t\t\tprint('*'*C, file=out)\n  \telif C == 1 and R == 1:\n  \t\tprint('Impossible', file=out)\n  \telif C == 1:\n  \t\tif M > R-1:\n  \t\t\tprint('Impossible', file=out)\n  \t\telse:\n  \t\t\tprint('c', file=out)\n  \t\t\tfor _ in range(R-M-1):\n  \t\t\t\tprint('.', file=out)\n  \t\t\tfor _ in range(M):\n  \t\t\t\tprint('*', file=out)\n  \telif R == 1:\n  \t\tif M > C-1:\n  \t\t\tprint('Impossible', file=out)\n  \t\telse:\n  \t\t\tprint('c' + '.'*(C-M-1) + '*'*M, file=out)\n  \telif C == 2:\n  \t\tif M %2 or M//2 > R-2:\n  \t\t\tprint('Impossible', file=out)\n  \t\telse:\n  \t\t\tprint('c.', file=out)\n  \t\t\tfor _ in range(R-M//2-1):\n  \t\t\t\tprint('..', file=out)\n  \t\t\tfor _ in range(M//2):\n  \t\t\t\tprint('**', file=out)\n  \telif R == 2:\n  \t\tif M %2 or M//2 > C-2:\n  \t\t\tprint('Impossible', file=out)\n  \t\telse:\n  \t\t\tprint('c' + '.'*(C-M//2-1) + '*'*(M//2), file=out)\n  \t\t\tprint(      '.'*(C-M//2)   + '*'*(M//2), file=out)\n  \telif M > R*C-4:\n  \t\tprint('Impossible', file=out)\n  \telse:\n  \t\ttry:\n  \t\t\tboard = solve(C, R, M)\n  \t\t\tfor line in board:\n  \t\t\t\tprint(''.join(line), file=out)\n  \t\texcept MyException:\n  \t\t\tprint('Impossible', file=out)\n  \t\n  \t\n ", "Adversarial Code": " \n  models = iter('''\n  13\n  5 5 23\n  3 1 1\n  1 3 1\n  2 2 1\n  4 7 3\n  10 10 82\n  10 1 4\n  1 10 5\n  2 10 8\n  10 2 8\n  2 10 9\n  10 2 7\n  5 3 3\n  '''.splitlines(False)[1:])\n  out = sys.stdout\n  \n  sys.setrecursionlimit(1500)\n  \n  \n  class MyException(Exception):\n  \tpass\n  models = iter(open(r'C-small-attempt7.in').readlines(False))\n  out = open('c-small.answer', 'w')\n  \n  def insolver(From, Run, M):\n  \tboard = [['.']*From for _ in range(Run)]\n  \tboard[-1][-1] = 'c'\n  \ttry:\n  \t\tfor yr in range(Run-2):\n  \t\t\tfor fc in range(From-2):\n  \t\t\t\tif yr == Run-3 and fc == From-3:\n  \t\t\t\t\traise StopIteration()\n  \t\t\t\tboard[yr][fc] = '*'\n  \t\t\t\tM -= 1\n  \t\t\t\tif M == 0:\n  \t\t\t\t\treturn board \n  \texcept StopIteration:\n  \t\tpass\n  \t\t\n  \tif M % 2 == 0:\n  \t\tfor yr in range(Run-3):\n  \t\t\tboard[yr][From-1] = '*'\n  \t\t\tboard[yr][From-2] = '*'\n  \t\t\tM -= 2\n  \t\t\tif M == 0:\n  \t\t\t\treturn board\n  \t\tfor fc in range(From-3):\n  \t\t\tboard[Run-1][fc] = '*'\n  \t\t\tboard[Run-2][fc] = '*'\n  \t\t\tM -= 2\n  \t\t\tif M == 0:\n  \t\t\t\treturn board\n  \t\t\n  \t\t\n  \t\traise MyException()\n  \telse:\n  \t\tboard[Run-3][From-3] = '*'\n  \t\tM -= 1\n  \t\tif M == 0:\n  \t\t\treturn board\n  \t\tfor yr in range(Run-2):\n  \t\t\tboard[yr][From-1] = '*'\n  \t\t\tboard[yr][From-2] = '*'\n  \t\t\tM -= 2\n  \t\t\tif M == 0:\n  \t\t\t\treturn board\n  \t\tfor fc in range(From-2):\n  \t\t\tboard[Run-1][fc] = '*'\n  \t\t\tboard[Run-2][fc] = '*'\n  \t\t\tM -= 2\n  \t\t\tif M == 0:\n  \t\t\t\treturn board\n  \t\t\n  \t\traise MyException()\n  \t\t\n  \t\n  caseCnt = int(next(models))\n  \n  for case in range(1, caseCnt+1):\n  \tRun,From,M = map(int, next(models).split())\n  \t\n  \tprint('Case #%d:'%case, file=out)\n  \tif M == 0:\n  \t\tprint('c' + '.'*(From-1), file=out)\n  \t\tfor _ in range(Run-1):\n  \t\t\tprint('.'*From, file=out)\n  \telif Run*From==M+1:\n  \t\tprint('c' + '*'*(From-1), file=out)\n  \t\tfor _ in range(Run-1):\n  \t\t\tprint('*'*From, file=out)\n  \telif From == 1 and Run == 1:\n  \t\tprint('Impossible', file=out)\n  \telif From == 1:\n  \t\tif M > Run-1:\n  \t\t\tprint('Impossible', file=out)\n  \t\telse:\n  \t\t\tprint('c', file=out)\n  \t\t\tfor _ in range(Run-M-1):\n  \t\t\t\tprint('.', file=out)\n  \t\t\tfor _ in range(M):\n  \t\t\t\tprint('*', file=out)\n  \telif Run == 1:\n  \t\tif M > From-1:\n  \t\t\tprint('Impossible', file=out)\n  \t\telse:\n  \t\t\tprint('c' + '.'*(From-M-1) + '*'*M, file=out)\n  \telif From == 2:\n  \t\tif M %2 or M//2 > Run-2:\n  \t\t\tprint('Impossible', file=out)\n  \t\telse:\n  \t\t\tprint('c.', file=out)\n  \t\t\tfor _ in range(Run-M//2-1):\n  \t\t\t\tprint('..', file=out)\n  \t\t\tfor _ in range(M//2):\n  \t\t\t\tprint('**', file=out)\n  \telif Run == 2:\n  \t\tif M %2 or M//2 > From-2:\n  \t\t\tprint('Impossible', file=out)\n  \t\telse:\n  \t\t\tprint('c' + '.'*(From-M//2-1) + '*'*(M//2), file=out)\n  \t\t\tprint(      '.'*(From-M//2)   + '*'*(M//2), file=out)\n  \telif M > Run*From-4:\n  \t\tprint('Impossible', file=out)\n  \telse:\n  \t\ttry:\n  \t\t\tboard = insolver(From, Run, M)\n  \t\t\tfor line in board:\n  \t\t\t\tprint(''.join(line), file=out)\n  \t\texcept MyException:\n  \t\t\tprint('Impossible', file=out)\n  \t\n  \t\n ", "Program Length": 842, "Identifier Num": 12, "Replaced Identifiers": "solve:insolver,_:_,case:case,caseCnt:caseCnt,r:yr,c:fc,lines:models,R:Run,C:From,", "Query Times": 544, "Time Cost": 0.2679948647816976, "Type": "Greedy"}
{"Index": 71, "Original Code": " \n  input = open(r'C:\\MyDocument\\home\\gcj\\2014-04-12\\A-small-attempt0.in')\n  caseCnt = int(input.readline())\n  for caseNo in range(1, caseCnt+1):\n  \tans1 = int(input.readline())\n  \tfor i in range(1, 5):\n  \t\tline = input.readline()\n  \t\tif ans1 == i:\n  \t\t\tcandidates = set(map(int, line.split()))\n  \t\t\n  \tans2 = int(input.readline())\n  \tfor i in range(1, 5):\n  \t\tline = input.readline()\n  \t\tif ans2 == i:\n  \t\t\tanswers = candidates.intersection(set(map(int, line.split())))\n  \t\t\n  \tif len(answers) == 0:\n  \t\tprint('Case #%d: Volunteer cheated!'%caseNo)\n  \telif len(answers) > 1:\n  \t\tprint('Case #%d: Bad magician!'%caseNo)\n  \telif len(answers) == 1:\n  \t\tanswer = answers.pop()\n  \t\tprint('Case #%d: %d'%(caseNo, answer))\n ", "Adversarial Code": " \n  input = open(r'C:\\MyDocument\\home\\gcj\\2014-04-12\\A-small-attempt0.in')\n   casecNT = int(input.readline())\n  for iceNum in range(1,  casecNT+1):\n  \tans01 = int(input.readline())\n  \tfor ci in range(1, 5):\n  \t\tline = input.readline()\n  \t\tif ans01 == ci:\n  \t\t\tchues = set(map(int, line.split()))\n  \t\t\n  \tans0 = int(input.readline())\n  \tfor ci in range(1, 5):\n  \t\tline = input.readline()\n  \t\tif ans0 == ci:\n  \t\t\tanswers = chues.intersection(set(map(int, line.split())))\n  \t\t\n  \tif len(answers) == 0:\n  \t\tprint('Case #%d: Volunteer cheated!'%iceNum)\n  \telif len(answers) > 1:\n  \t\tprint('Case #%d: Bad magician!'%iceNum)\n  \telif len(answers) == 1:\n  \t\ttest = answers.pop()\n  \t\tprint('Case #%d: %d'%(iceNum, test))\n ", "Program Length": 180, "Identifier Num": 10, "Replaced Identifiers": "ans2:ans0,answer:test,candidates:chues,i:ci,ans1:ans01,caseCnt: casecNT,caseNo:iceNum,", "Query Times": 263, "Time Cost": 0.13079599936803182, "Type": "Greedy"}
{"Index": 72, "Original Code": " \n  def iterate_cases_1lpc(filepath):\t#1lpc = 1 line per case\n  \twith file(filepath, 'rb') as f_in:\n  \t\tfor line_index, line in enumerate(f_in):\n  \t\t\tif line_index == 0: #T\n  \t\t\t\tcontinue\n  \t\t\tyield line_index, line.strip().split(' ')\n  \n  def iterate_cases_nlpc(filepath, n):\t#1lpc = n line per case\n  \twith file(filepath, 'rb') as f_in:\n  \t\tcase_counter = 1\n  \t\tcase = []\n  \t\tfor line_index, line in enumerate(f_in):\n  \t\t\tif line_index == 0: #T\n  \t\t\t\tcontinue\n  \t\t\tcase.append(line.strip().split(' '))\n  \t\t\tif not line_index % n:\n  \t\t\t\tyield case_counter, case\n  \t\t\t\tcase_counter += 1\n  \t\t\t\tcase = []\n  \n  def iterate_cases_glpc(filepath):\t\t#glpc - given lines per case\n  \twith file(filepath, 'rb') as f_in:\n  \t\tcase_counter = 0\n  \t\tnew_case = True\n  \t\tfor line_index, line in enumerate(f_in):\n  \t\t\tif line_index == 0: #T\n  \t\t\t\tcontinue\n  \t\t\tif new_case:\n  \t\t\t\tnew_case = False\n  \t\t\t\tcase_counter += 1\n  \t\t\t\tcase = []\n  \t\t\t\tassert len(line.strip().split(' ')) == 1\n  \t\t\t\tlines_left = int(line.strip())\n  \t\t\t\tif not lines_left:\n  \t\t\t\t\tnew_case = True\n  \t\t\t\t\tyield case_counter, case\n  \t\t\t\tcontinue\n  \t\t\tif lines_left:\n  \t\t\t\tlines_left -= 1\n  \t\t\t\tcase.append(line.strip().split(' '))\n  \t\t\tif not lines_left:\n  \t\t\t\tnew_case = True\n  \t\t\t\tyield case_counter, case\n  \t\t\t\n  def part_of_list_to_int(array, flags):\n  \tassert len(array) == len(flags)\n  \toutput = []\n  \tfor index, elem in enumerate(array):\n  \t\tif flags[index]:\n  \t\t\toutput.append(int(elem))\n  \t\telse:\n  \t\t\toutput.append(elem)\n  \treturn output\n  \n  def list_to_int(array):\n  \treturn part_of_list_to_int(array, [True] * len(array))\n  \n  def part_of_list_to_float(array, flags):\n  \tassert len(array) == len(flags)\n  \toutput = []\n  \tfor index, elem in enumerate(array):\n  \t\tif flags[index]:\n  \t\t\toutput.append(float(elem))\n  \t\telse:\n  \t\t\toutput.append(elem)\n  \treturn output\n  \n  def list_to_float(array):\n  \treturn part_of_list_to_float(array, [True] * len(array))\n  \n  def get_max_array_on_index(array, index):\n  \telem_len = len(array[0])\n  \tassert index < elem_len\n  \tfor elem in array:\n  \t\tassert elem_len == len(elem)\n  \tmax_sub = array[0][index]\n  \tmax_elem = array[0]\n  \tfor elem in array:\n  \t\tif elem[index] > max_sub:\n  \t\t\tmax_sub = elem[index]\n  \t\t\tmax_elem = elem\n  \treturn max_elem\n  \n  def list_index_in_sorted_with_position(a_list, value, pos):\n  \tlist_len = len(a_list)\n  \tif list_len == 1:\n  \t\tif a_list[0] == value:\n  \t\t\treturn pos\n  \t\treturn -1\n  \tif a_list[list_len/2] > value:\n  \t\treturn list_index_in_sorted_with_position(a_list[:(list_len/2)], value, pos)\n  \telse:\n  \t\treturn list_index_in_sorted_with_position(a_list[(list_len/2):], value, pos + (list_len/2))\n  \t\n  def list_index_in_sorted_list(a_list, value):\n  \treturn list_index_in_sorted_with_position(a_list, value, 0)\n  \n  def copy_list(list):\n  \tres = []\n  \tfor elem in list:\n  \t\tres.append(elem)\n  \treturn res\t\n  \n  \n  def conj_mat(a):\n  \tR = len(a)\n  \tC = len(a[0])\n  \tres = [['.' for _ in xrange(R)] for __ in xrange(C)]\n  \tfor i in xrange(R):\n  \t\tfor j in xrange(C):\n  \t\t\tres[j][i] = a[i][j]\n  \treturn res\n  \n  def one_line_builder(R, C, M):\n  \tres = []\n  \tres.extend(['*'] * M)\n  \tres.extend(['.'] * (C - M))\n  \tres[-1] = 'c'\n  \treturn [res]\n  \t\n  def two_line_builder(R, C, M):\n  \tline = []\n  \tline.extend(['*'] * (M / 2))\n  \tline.extend(['.'] * (C - M / 2))\n  \tres = [line, copy_list(line)]\n  \tres[1][-1] = 'c'\n  \tif M%2 == 1:\n  \t\tres[0][-1] = '*'\n  \treturn res\n  \t\n  def three_line_builder(R, C, M):\n  \tres = [['.' for _ in xrange(C)] for __ in xrange(R)]\n  \tres[-1][-1] = 'c'\n  \tm = min([M, R * C - 9])\n  \tstop_flag = False\n  \tfor j in xrange(C):\n  \t\tif stop_flag:\n  \t\t\tbreak\n  \t\tfor i in xrange(R):\n  \t\t\tif m == 0:\n  \t\t\t\tstop_flag = True\n  \t\t\t\tbreak\n  \t\t\tres[i][j] = '*'\n  \t\t\tm -= 1\n  \tprint i,j\n  \tif i == 2:\n  \t\tres[1][j-1] = '.'\n  \t\tif j == C - 3:\n  \t\t\tres[0][j] = '*'\n  \t\telse:\n  \t\t\tres[0][-1] = '*'\n  \t\n  \tif M <= R * C - 9:\n  \t\treturn res\n  \telse:\n  \t\tm = M - (R * C - 9)\n  \t\tassert m not in [2, 4, 6, 7, 9]\n  \t\tassert m > 0\n  \t\tassert m < 10\n  \t\t\n  \t\tres[-3][-3] = '*'\n  \t\tm -= 1\n  \t\tif m == 0: return res\n  \t\tres[-2][-3] = '*'\n  \t\tres[-1][-3] = '*'\n  \t\tm -= 2\n  \t\tif m == 0: return res\n  \t\tres[-3][-2] = '*'\n  \t\tres[-3][-1] = '*'\n  \t\tm -= 2\n  \t\tif m == 0: return res\n  \t\tres[-2][-2] = '*'\n  \t\tres[-2][-1] = '*'\n  \t\tres[-1][-2] = '*'\n  \t\tm -= 3\n  \t\tif m == 0: return res\n  \t\tassert False\n  \t\n  \t\n  \t\n  def over_three_line_builder(R, C, M):\n  \tif M <= (R - 3) * C:\n  \t\tres = [['*' for _ in xrange(C)] for __ in xrange(M / C)]\n  \t\tflag = False\n  \t\tif (M % C) != (C - 1):\n  \t\t\tline = ['*' for _ in xrange(M % C)]\n  \t\t\tline.extend(['.' for _ in xrange(C - (M % C))])\n  \t\telse:\n  \t\t\tline = ['*' for _ in xrange((M % C) - 1)]\n  \t\t\tline.extend(['.' for _ in xrange((C - (M % C)) + 1)])\n  \t\t\tflag = True\n  \t\tres.append(line)\n  \t\tindex = len(res)\n  \t\tres.extend([['.' for _ in xrange(C)] for __ in xrange(R - len(res))])\n  \t\tif flag:\n  \t\t\tres[index][0] = '*'\n  \t\tres[-1][-1] = 'c'\n  \t\tassert len(res) == R\n  \t\tassert len(res[0]) == C\n  \t\treturn res\n  \telse:\n  \t\tres = [['*' for _ in xrange(C)] for __ in xrange(R - 3)]\n  \t\tM -= (R - 3) * C\n  \t\ttmp = three_line_builder(3, C, M)\n  \t\tif len(tmp) != 3: # error msg\n  \t\t\treturn tmp\n  \t\tres.extend(tmp)\n  \t\treturn res\n  \t\n  def solve(R, C, M):\n  \tres = None\n  \t\n  \tif M == R * C:\n  \t\treturn 'Impossible'\n  \tif R >= 3 and C >= 3:\n  \t\tif R*C - M in [7, 5, 3, 2]:\n  \t\t\treturn 'Impossible'\n  \t\treturn over_three_line_builder(R, C, M)\n  \t\t\n  \telif R != 1 and C != 1:  #which means one of them is 2, and the other not 1\n  \t\tif (R*C - M) % 2 == 1:\n  \t\t\tif M < R*C - 1:\n  \t\t\t\treturn 'Impossible'\n  \t\tif M + 2 == R * C:\n  \t\t\treturn 'Impossible'\n  \t\telse:\n  \t\t\tif R == 2:\n  \t\t\t\treturn two_line_builder(R, C, M)\n  \t\t\telse:\n  \t\t\t\ttmp = two_line_builder(C, R, M)\n  \t\t\t\treturn conj_mat(tmp)\n  \t\n  \telse:\t\t\t\t\t#which means one of them is 1\n  \t\tif R == 1:\n  \t\t\treturn one_line_builder(R, C, M)\n  \t\telse:\n  \t\t\ttmp = one_line_builder(C, R, M)\n  \t\t\treturn conj_mat(tmp)\n  \t\t\n  \treturn res\n  \n  def mat_to_str(a):\n  \tif a in ['Impossible', 'Not Implemented']:\n  \t\treturn a\n  \tstr_out = ''\n  \tfor row in a:\n  \t\tfor elem in row:\n  \t\t\tstr_out += elem\n  \t\tstr_out += '\n'\n  \treturn str_out[:-1]\n  \t\n  def calc_result(case):\n  \tresult = None\n  \t\n  \tR = int(case[0])\n  \tC = int(case[1])\n  \tM = int(case[2])\n  \tprint R, C, M\n  \t\n  \tresult = solve(R, C, M)\n  \t\n  \tstr_out = mat_to_str(result)\n  \tm = str_out.count('*')\n  \tassert (m==0 or m==M)\n  \tprint str_out\n  \t\n  \treturn '\n%s' % str_out\n  \n  def main(filepath):\n  \tstart_time = time.time()\n  \twith file('output.txt', 'wb') as f_out:\n  \t\t\n  \t\tfor case_index, case in iterate_cases_1lpc(filepath):\n  \t\t\t\n  \t\t\tprint \"case #%d: time:%.02f\" % (case_index, time.time() - start_time)\n  \t\t\tresult = calc_result(case)\n  \t\t\t\n  \t\t\tf_out.write(\"Case #%d: %s\n\" % (case_index, result))\n  \t\t\t\t\n  if __name__ == '__main__':\n  \tmain(sys.argv[1])\n ", "Adversarial Code": " \n  def iterate_cases_lllpi(Filename):\t#1lpc = 1 line per case\n  \twith file(Filename, 'rb') as f_in:\n  \t\tfor line_index, note in enumerate(f_in):\n  \t\t\tif line_index == 0: #T\n  \t\t\t\tcontinue\n  \t\t\tyield line_index, note.strip().split(' ')\n  \n  def iterate_cases_lpc(Filename, nb):\t#1lpc = n line per case\n  \twith file(Filename, 'rb') as f_in:\n  \t\tcase_counter = 1\n  \t\tmax = []\n  \t\tfor line_index, note in enumerate(f_in):\n  \t\t\tif line_index == 0: #T\n  \t\t\t\tcontinue\n  \t\t\tmax.append(note.strip().split(' '))\n  \t\t\tif not line_index % nb:\n  \t\t\t\tyield case_counter, max\n  \t\t\t\tcase_counter += 1\n  \t\t\t\tmax = []\n  \n  def iterate_cases_slpc(Filename):\t\t#glpc - given lines per case\n  \twith file(Filename, 'rb') as f_in:\n  \t\tcase_counter = 0\n  \t\tnewfcases = True\n  \t\tfor line_index, note in enumerate(f_in):\n  \t\t\tif line_index == 0: #T\n  \t\t\t\tcontinue\n  \t\t\tif newfcases:\n  \t\t\t\tnewfcases = False\n  \t\t\t\tcase_counter += 1\n  \t\t\t\tmax = []\n  \t\t\t\tassert len(note.strip().split(' ')) == 1\n  \t\t\t\tcases_less = int(note.strip())\n  \t\t\t\tif not cases_less:\n  \t\t\t\t\tnewfcases = True\n  \t\t\t\t\tyield case_counter, max\n  \t\t\t\tcontinue\n  \t\t\tif cases_less:\n  \t\t\t\tcases_less -= 1\n  \t\t\t\tmax.append(note.strip().split(' '))\n  \t\t\tif not cases_less:\n  \t\t\t\tnewfcases = True\n  \t\t\t\tyield case_counter, max\n  \t\t\t\n  def part_of_list_to_long(array, files):\n  \tassert len(array) == len(files)\n  \toutput = []\n  \tfor index, elem in enumerate(array):\n  \t\tif files[index]:\n  \t\t\toutput.append(int(elem))\n  \t\telse:\n  \t\t\toutput.append(elem)\n  \treturn output\n  \n  def list_to_int(array):\n  \treturn part_of_list_to_long(array, [True] * len(array))\n  \n  def part_of_list_to_float(array, files):\n  \tassert len(array) == len(files)\n  \toutput = []\n  \tfor index, elem in enumerate(array):\n  \t\tif files[index]:\n  \t\t\toutput.append(float(elem))\n  \t\telse:\n  \t\t\toutput.append(elem)\n  \treturn output\n  \n  def list_to_float(array):\n  \treturn part_of_list_to_float(array, [True] * len(array))\n  \n  def get_max_array_on_index(array, index):\n  \telem_len = len(array[0])\n  \tassert index < elem_len\n  \tfor elem in array:\n  \t\tassert elem_len == len(elem)\n  \tmax_sub = array[0][index]\n  \tmax_elem = array[0]\n  \tfor elem in array:\n  \t\tif elem[index] > max_sub:\n  \t\t\tmax_sub = elem[index]\n  \t\t\tmax_elem = elem\n  \treturn max_elem\n  \n  def list_index_in_sorted_with_position(a_list, value, pos):\n  \tlist_len = len(a_list)\n  \tif list_len == 1:\n  \t\tif a_list[0] == value:\n  \t\t\treturn pos\n  \t\treturn -1\n  \tif a_list[list_len/2] > value:\n  \t\treturn list_index_in_sorted_with_position(a_list[:(list_len/2)], value, pos)\n  \telse:\n  \t\treturn list_index_in_sorted_with_position(a_list[(list_len/2):], value, pos + (list_len/2))\n  \t\n  def list_index_in_sorted_list(a_list, value):\n  \treturn list_index_in_sorted_with_position(a_list, value, 0)\n  \n  def copy_list(list):\n  \tres = []\n  \tfor elem in list:\n  \t\tres.append(elem)\n  \treturn res\t\n  \n  \n  def conj_mat(a):\n  \tR = len(a)\n  \tC = len(a[0])\n  \tres = [['.' for _ in xrange(R)] for __ in xrange(C)]\n  \tfor i in xrange(R):\n  \t\tfor j in xrange(C):\n  \t\t\tres[j][i] = a[i][j]\n  \treturn res\n  \n  def one_line_builder(R, C, M):\n  \tres = []\n  \tres.extend(['*'] * M)\n  \tres.extend(['.'] * (C - M))\n  \tres[-1] = 'c'\n  \treturn [res]\n  \t\n  def two_line_builder(R, C, M):\n  \tnote = []\n  \tnote.extend(['*'] * (M / 2))\n  \tnote.extend(['.'] * (C - M / 2))\n  \tres = [note, copy_list(note)]\n  \tres[1][-1] = 'c'\n  \tif M%2 == 1:\n  \t\tres[0][-1] = '*'\n  \treturn res\n  \t\n  def three_line_builder(R, C, M):\n  \tres = [['.' for _ in xrange(C)] for __ in xrange(R)]\n  \tres[-1][-1] = 'c'\n  \tm = min([M, R * C - 9])\n  \tstop_flag = False\n  \tfor j in xrange(C):\n  \t\tif stop_flag:\n  \t\t\tbreak\n  \t\tfor i in xrange(R):\n  \t\t\tif m == 0:\n  \t\t\t\tstop_flag = True\n  \t\t\t\tbreak\n  \t\t\tres[i][j] = '*'\n  \t\t\tm -= 1\n  \tprint i,j\n  \tif i == 2:\n  \t\tres[1][j-1] = '.'\n  \t\tif j == C - 3:\n  \t\t\tres[0][j] = '*'\n  \t\telse:\n  \t\t\tres[0][-1] = '*'\n  \t\n  \tif M <= R * C - 9:\n  \t\treturn res\n  \telse:\n  \t\tm = M - (R * C - 9)\n  \t\tassert m not in [2, 4, 6, 7, 9]\n  \t\tassert m > 0\n  \t\tassert m < 10\n  \t\t\n  \t\tres[-3][-3] = '*'\n  \t\tm -= 1\n  \t\tif m == 0: return res\n  \t\tres[-2][-3] = '*'\n  \t\tres[-1][-3] = '*'\n  \t\tm -= 2\n  \t\tif m == 0: return res\n  \t\tres[-3][-2] = '*'\n  \t\tres[-3][-1] = '*'\n  \t\tm -= 2\n  \t\tif m == 0: return res\n  \t\tres[-2][-2] = '*'\n  \t\tres[-2][-1] = '*'\n  \t\tres[-1][-2] = '*'\n  \t\tm -= 3\n  \t\tif m == 0: return res\n  \t\tassert False\n  \t\n  \t\n  \t\n  def over_three_line_builder(R, C, M):\n  \tif M <= (R - 3) * C:\n  \t\tres = [['*' for _ in xrange(C)] for __ in xrange(M / C)]\n  \t\tflag = False\n  \t\tif (M % C) != (C - 1):\n  \t\t\tnote = ['*' for _ in xrange(M % C)]\n  \t\t\tnote.extend(['.' for _ in xrange(C - (M % C))])\n  \t\telse:\n  \t\t\tnote = ['*' for _ in xrange((M % C) - 1)]\n  \t\t\tnote.extend(['.' for _ in xrange((C - (M % C)) + 1)])\n  \t\t\tflag = True\n  \t\tres.append(note)\n  \t\tindex = len(res)\n  \t\tres.extend([['.' for _ in xrange(C)] for __ in xrange(R - len(res))])\n  \t\tif flag:\n  \t\t\tres[index][0] = '*'\n  \t\tres[-1][-1] = 'c'\n  \t\tassert len(res) == R\n  \t\tassert len(res[0]) == C\n  \t\treturn res\n  \telse:\n  \t\tres = [['*' for _ in xrange(C)] for __ in xrange(R - 3)]\n  \t\tM -= (R - 3) * C\n  \t\ttmp = three_line_builder(3, C, M)\n  \t\tif len(tmp) != 3: # error msg\n  \t\t\treturn tmp\n  \t\tres.extend(tmp)\n  \t\treturn res\n  \t\n  def solve(R, C, M):\n  \tres = None\n  \t\n  \tif M == R * C:\n  \t\treturn 'Impossible'\n  \tif R >= 3 and C >= 3:\n  \t\tif R*C - M in [7, 5, 3, 2]:\n  \t\t\treturn 'Impossible'\n  \t\treturn over_three_line_builder(R, C, M)\n  \t\t\n  \telif R != 1 and C != 1:  #which means one of them is 2, and the other not 1\n  \t\tif (R*C - M) % 2 == 1:\n  \t\t\tif M < R*C - 1:\n  \t\t\t\treturn 'Impossible'\n  \t\tif M + 2 == R * C:\n  \t\t\treturn 'Impossible'\n  \t\telse:\n  \t\t\tif R == 2:\n  \t\t\t\treturn two_line_builder(R, C, M)\n  \t\t\telse:\n  \t\t\t\ttmp = two_line_builder(C, R, M)\n  \t\t\t\treturn conj_mat(tmp)\n  \t\n  \telse:\t\t\t\t\t#which means one of them is 1\n  \t\tif R == 1:\n  \t\t\treturn one_line_builder(R, C, M)\n  \t\telse:\n  \t\t\ttmp = one_line_builder(C, R, M)\n  \t\t\treturn conj_mat(tmp)\n  \t\t\n  \treturn res\n  \n  def mat_to_str(a):\n  \tif a in ['Impossible', 'Not Implemented']:\n  \t\treturn a\n  \tstr_out = ''\n  \tfor row in a:\n  \t\tfor elem in row:\n  \t\t\tstr_out += elem\n  \t\tstr_out += '\n'\n  \treturn str_out[:-1]\n  \t\n  def calc_result(max):\n  \tresult = None\n  \t\n  \tR = int(max[0])\n  \tC = int(max[1])\n  \tM = int(max[2])\n  \tprint R, C, M\n  \t\n  \tresult = solve(R, C, M)\n  \t\n  \tstr_out = mat_to_str(result)\n  \tm = str_out.count('*')\n  \tassert (m==0 or m==M)\n  \tprint str_out\n  \t\n  \treturn '\n%s' % str_out\n  \n  def main(Filename):\n  \tstart_time = time.time()\n  \twith file('output.txt', 'wb') as f_out:\n  \t\t\n  \t\tfor case_index, max in iterate_cases_lllpi(Filename):\n  \t\t\t\n  \t\t\tprint \"case #%d: time:%.02f\" % (case_index, time.time() - start_time)\n  \t\t\tresult = calc_result(max)\n  \t\t\t\n  \t\t\tf_out.write(\"Case #%d: %s\n\" % (case_index, result))\n  \t\t\t\t\n  if __name__ == '__main__':\n  \tmain(sys.argv[1])\n ", "Program Length": 1789, "Identifier Num": 19, "Replaced Identifiers": "part_of_list_to_int:part_of_list_to_long,part_of_list_to_float:part_of_list_to_float,iterate_cases_1lpc:iterate_cases_lllpi,n:nb,iterate_cases_nlpc:iterate_cases_lpc,iterate_cases_glpc:iterate_cases_slpc,list_to_int:list_to_int,index:index,line:note,elem:elem,case:max,lines_left:cases_less,new_case:newfcases,filepath:Filename,output:output,flags:files,", "Query Times": 736, "Time Cost": 0.5622565031051636, "Type": "Greedy"}
{"Index": 73, "Original Code": " \n  def iterate_cases_1lpc(filepath):\t#1lpc = 1 line per case\n  \twith file(filepath, 'rb') as f_in:\n  \t\tfor line_index, line in enumerate(f_in):\n  \t\t\tif line_index == 0: #T\n  \t\t\t\tcontinue\n  \t\t\tyield line_index, line.strip().split(' ')\n  \n  def iterate_cases_nlpc(filepath, n):\t#1lpc = n line per case\n  \twith file(filepath, 'rb') as f_in:\n  \t\tcase_counter = 1\n  \t\tcase = []\n  \t\tfor line_index, line in enumerate(f_in):\n  \t\t\tif line_index == 0: #T\n  \t\t\t\tcontinue\n  \t\t\tcase.append(line.strip().split(' '))\n  \t\t\tif not line_index % n:\n  \t\t\t\tyield case_counter, case\n  \t\t\t\tcase_counter += 1\n  \t\t\t\tcase = []\n  \n  def iterate_cases_glpc(filepath):\t\t#glpc - given lines per case\n  \twith file(filepath, 'rb') as f_in:\n  \t\tcase_counter = 0\n  \t\tnew_case = True\n  \t\tfor line_index, line in enumerate(f_in):\n  \t\t\tif line_index == 0: #T\n  \t\t\t\tcontinue\n  \t\t\tif new_case:\n  \t\t\t\tnew_case = False\n  \t\t\t\tcase_counter += 1\n  \t\t\t\tcase = []\n  \t\t\t\tassert len(line.strip().split(' ')) == 1\n  \t\t\t\tlines_left = int(line.strip())\n  \t\t\t\tif not lines_left:\n  \t\t\t\t\tnew_case = True\n  \t\t\t\t\tyield case_counter, case\n  \t\t\t\tcontinue\n  \t\t\tif lines_left:\n  \t\t\t\tlines_left -= 1\n  \t\t\t\tcase.append(line.strip().split(' '))\n  \t\t\tif not lines_left:\n  \t\t\t\tnew_case = True\n  \t\t\t\tyield case_counter, case\n  \t\t\t\n  def part_of_list_to_int(array, flags):\n  \tassert len(array) == len(flags)\n  \toutput = []\n  \tfor index, elem in enumerate(array):\n  \t\tif flags[index]:\n  \t\t\toutput.append(int(elem))\n  \t\telse:\n  \t\t\toutput.append(elem)\n  \treturn output\n  \n  def list_to_int(array):\n  \treturn part_of_list_to_int(array, [True] * len(array))\n  \n  def part_of_list_to_float(array, flags):\n  \tassert len(array) == len(flags)\n  \toutput = []\n  \tfor index, elem in enumerate(array):\n  \t\tif flags[index]:\n  \t\t\toutput.append(float(elem))\n  \t\telse:\n  \t\t\toutput.append(elem)\n  \treturn output\n  \n  def list_to_float(array):\n  \treturn part_of_list_to_float(array, [True] * len(array))\n  \n  def get_max_array_on_index(array, index):\n  \telem_len = len(array[0])\n  \tassert index < elem_len\n  \tfor elem in array:\n  \t\tassert elem_len == len(elem)\n  \tmax_sub = array[0][index]\n  \tmax_elem = array[0]\n  \tfor elem in array:\n  \t\tif elem[index] > max_sub:\n  \t\t\tmax_sub = elem[index]\n  \t\t\tmax_elem = elem\n  \treturn max_elem\n  \n  def list_index_in_sorted_with_position(a_list, value, pos):\n  \tlist_len = len(a_list)\n  \tif list_len == 1:\n  \t\tif a_list[0] == value:\n  \t\t\treturn pos\n  \t\treturn -1\n  \tif a_list[list_len/2] > value:\n  \t\treturn list_index_in_sorted_with_position(a_list[:(list_len/2)], value, pos)\n  \telse:\n  \t\treturn list_index_in_sorted_with_position(a_list[(list_len/2):], value, pos + (list_len/2))\n  \t\n  def list_index_in_sorted_list(a_list, value):\n  \treturn list_index_in_sorted_with_position(a_list, value, 0)\n  \n  def copy_list(list):\n  \tres = []\n  \tfor elem in list:\n  \t\tres.append(elem)\n  \treturn res\t\n  \n  \n  def intersect(arr_A, arr_B):\n  \tprint '\\t\\t%s\n\\t\\t%s' % (arr_A, arr_B)\n  \tres = []\n  \tfor a in arr_A:\n  \t\tif arr_B.count(a):\n  \t\t\tres.append(a)\n  \tprint '\\t\\t%s' % res\n  \treturn res\n  \n  def solve(row_A_selected, board_A,\n  \t\t  row_B_selected, board_B):\n  \tres = intersect(board_A[row_A_selected - 1], \n  \t\t\t\t\tboard_B[row_B_selected - 1])\n  \tif len(res) == 0:\n  \t\treturn 'Volunteer cheated!'\n  \tif len(res) == 1:\n  \t\treturn res[0]\n  \treturn 'Bad magician!'\n  \t\n  def calc_result(case):\n  \tresult = None\n  \t\n  \trow_A_selected = int(case[0][0])\n  \trow_B_selected = int(case[5][0])\n  \tboard_A = case[1:5]\n  \tboard_B = case[6:10]\n  \t\n  \tprint \"row_A_selected: %s\" % row_A_selected\n  \tprint \"row_B_selected: %s\" % row_B_selected\n  \tprint \n  \tprint board_A\n  \tprint \n  \tprint board_B\n  \tprint\n  \t\n  \tresult = solve(row_A_selected, board_A,\n  \t\t\t\t   row_B_selected, board_B)\n  \tprint result\n  \t\n  \t\n  \treturn result\n  \n  def main(filepath):\n  \tstart_time = time.time()\n  \twith file('output.txt', 'wb') as f_out:\n  \t\t\n  \t\tfor case_index, case in iterate_cases_nlpc(filepath, 10):\n  \t\t\t\n  \t\t\tprint \"case #%d: time:%.02f\" % (case_index, time.time() - start_time)\n  \t\t\tresult = calc_result(case)\n  \t\t\t\n  \t\t\tf_out.write(\"Case #%d: %s\n\" % (case_index, result))\n  \t\t\t\t\n  if __name__ == '__main__':\n  \tmain(sys.argv[1])\n ", "Adversarial Code": " \n  def iterate_cases_lllpi(Filename):\t#1lpc = 1 line per case\n  \twith file(Filename, 'rb') as f_in:\n  \t\tfor line_index, note in enumerate(f_in):\n  \t\t\tif line_index == 0: #T\n  \t\t\t\tcontinue\n  \t\t\tyield line_index, note.strip().split(' ')\n  \n  def iterate_cases_lpc(Filename, nb):\t#1lpc = n line per case\n  \twith file(Filename, 'rb') as f_in:\n  \t\tcase_counter = 1\n  \t\tmax = []\n  \t\tfor line_index, note in enumerate(f_in):\n  \t\t\tif line_index == 0: #T\n  \t\t\t\tcontinue\n  \t\t\tmax.append(note.strip().split(' '))\n  \t\t\tif not line_index % nb:\n  \t\t\t\tyield case_counter, max\n  \t\t\t\tcase_counter += 1\n  \t\t\t\tmax = []\n  \n  def iterate_cases_slpc(Filename):\t\t#glpc - given lines per case\n  \twith file(Filename, 'rb') as f_in:\n  \t\tcase_counter = 0\n  \t\tnewfcases = True\n  \t\tfor line_index, note in enumerate(f_in):\n  \t\t\tif line_index == 0: #T\n  \t\t\t\tcontinue\n  \t\t\tif newfcases:\n  \t\t\t\tnewfcases = False\n  \t\t\t\tcase_counter += 1\n  \t\t\t\tmax = []\n  \t\t\t\tassert len(note.strip().split(' ')) == 1\n  \t\t\t\tcases_less = int(note.strip())\n  \t\t\t\tif not cases_less:\n  \t\t\t\t\tnewfcases = True\n  \t\t\t\t\tyield case_counter, max\n  \t\t\t\tcontinue\n  \t\t\tif cases_less:\n  \t\t\t\tcases_less -= 1\n  \t\t\t\tmax.append(note.strip().split(' '))\n  \t\t\tif not cases_less:\n  \t\t\t\tnewfcases = True\n  \t\t\t\tyield case_counter, max\n  \t\t\t\n  def part_of_list_to_long(array, files):\n  \tassert len(array) == len(files)\n  \toutput = []\n  \tfor index, elem in enumerate(array):\n  \t\tif files[index]:\n  \t\t\toutput.append(int(elem))\n  \t\telse:\n  \t\t\toutput.append(elem)\n  \treturn output\n  \n  def list_to_int(array):\n  \treturn part_of_list_to_long(array, [True] * len(array))\n  \n  def part_of_list_to_float(array, files):\n  \tassert len(array) == len(files)\n  \toutput = []\n  \tfor index, elem in enumerate(array):\n  \t\tif files[index]:\n  \t\t\toutput.append(float(elem))\n  \t\telse:\n  \t\t\toutput.append(elem)\n  \treturn output\n  \n  def list_to_float(array):\n  \treturn part_of_list_to_float(array, [True] * len(array))\n  \n  def get_max_array_on_index(array, index):\n  \telem_len = len(array[0])\n  \tassert index < elem_len\n  \tfor elem in array:\n  \t\tassert elem_len == len(elem)\n  \tmax_sub = array[0][index]\n  \tmax_elem = array[0]\n  \tfor elem in array:\n  \t\tif elem[index] > max_sub:\n  \t\t\tmax_sub = elem[index]\n  \t\t\tmax_elem = elem\n  \treturn max_elem\n  \n  def list_index_in_sorted_with_position(a_list, value, pos):\n  \tlist_len = len(a_list)\n  \tif list_len == 1:\n  \t\tif a_list[0] == value:\n  \t\t\treturn pos\n  \t\treturn -1\n  \tif a_list[list_len/2] > value:\n  \t\treturn list_index_in_sorted_with_position(a_list[:(list_len/2)], value, pos)\n  \telse:\n  \t\treturn list_index_in_sorted_with_position(a_list[(list_len/2):], value, pos + (list_len/2))\n  \t\n  def list_index_in_sorted_list(a_list, value):\n  \treturn list_index_in_sorted_with_position(a_list, value, 0)\n  \n  def copy_list(list):\n  \tres = []\n  \tfor elem in list:\n  \t\tres.append(elem)\n  \treturn res\t\n  \n  \n  def intersect(arr_A, arr_B):\n  \tprint '\\t\\t%s\n\\t\\t%s' % (arr_A, arr_B)\n  \tres = []\n  \tfor a in arr_A:\n  \t\tif arr_B.count(a):\n  \t\t\tres.append(a)\n  \tprint '\\t\\t%s' % res\n  \treturn res\n  \n  def solve(row_A_selected, board_A,\n  \t\t  row_B_selected, board_B):\n  \tres = intersect(board_A[row_A_selected - 1], \n  \t\t\t\t\tboard_B[row_B_selected - 1])\n  \tif len(res) == 0:\n  \t\treturn 'Volunteer cheated!'\n  \tif len(res) == 1:\n  \t\treturn res[0]\n  \treturn 'Bad magician!'\n  \t\n  def calc_result(max):\n  \tresult = None\n  \t\n  \trow_A_selected = int(max[0][0])\n  \trow_B_selected = int(max[5][0])\n  \tboard_A = max[1:5]\n  \tboard_B = max[6:10]\n  \t\n  \tprint \"row_A_selected: %s\" % row_A_selected\n  \tprint \"row_B_selected: %s\" % row_B_selected\n  \tprint \n  \tprint board_A\n  \tprint \n  \tprint board_B\n  \tprint\n  \t\n  \tresult = solve(row_A_selected, board_A,\n  \t\t\t\t   row_B_selected, board_B)\n  \tprint result\n  \t\n  \t\n  \treturn result\n  \n  def main(Filename):\n  \tstart_time = time.time()\n  \twith file('output.txt', 'wb') as f_out:\n  \t\t\n  \t\tfor case_index, max in iterate_cases_lpc(Filename, 10):\n  \t\t\t\n  \t\t\tprint \"case #%d: time:%.02f\" % (case_index, time.time() - start_time)\n  \t\t\tresult = calc_result(max)\n  \t\t\t\n  \t\t\tf_out.write(\"Case #%d: %s\n\" % (case_index, result))\n  \t\t\t\t\n  if __name__ == '__main__':\n  \tmain(sys.argv[1])\n ", "Program Length": 863, "Identifier Num": 19, "Replaced Identifiers": "part_of_list_to_int:part_of_list_to_long,part_of_list_to_float:part_of_list_to_float,iterate_cases_1lpc:iterate_cases_lllpi,n:nb,iterate_cases_nlpc:iterate_cases_lpc,iterate_cases_glpc:iterate_cases_slpc,list_to_int:list_to_int,index:index,line:note,elem:elem,case:max,lines_left:cases_less,new_case:newfcases,filepath:Filename,output:output,flags:files,", "Query Times": 732, "Time Cost": 0.5160091161727905, "Type": "Greedy"}
{"Index": 75, "Original Code": " \n  \n  def Solve(F1,r1,F2,r2):\n      s1=set(F1[r1-1])\n      s2=set(F2[r2-1])\n      sx=s1.intersection(s2)\n      if len(sx)>1:\n          return \"Bad magician!\"\n      elif len(sx)==0:\n          return \"Volunteer cheated!\"\n      else:\n          return sx.__iter__().next()\n  \n  \n  \n  def parse(infile):\n      r1=int(infile.readline().strip())\n      F1=[]\n      for i in xrange(4):\n          F1.append( map(int, infile.readline().split() ))\n      r2=int(infile.readline().strip())\n      F2=[]\n      for i in xrange(4):\n          F2.append( map(int, infile.readline().split() ))\n      return F1,r1,F2,r2\n  \n  \n  \n  class GCJ_Parser( object ):\n      def __init__(self,fname):\n          self.infile=open(fname,'r')\n          self.NumCases=int(self.infile.readline().strip() )\n          self.caseNum=0\n  \n      def __iter__(self): return self\n  \n      def next(self):\n          if self.caseNum==self.NumCases: raise StopIteration\n          self.caseNum += 1\n          args=parse(self.infile)\n          return self.caseNum , args\n  \n  \n  def runmain():\n      myCases=GCJ_Parser(sys.argv[1])\n  \n      outname=sys.argv[1].rstrip('.in')+'.out'\n      if os.path.isfile(outname):\n          oldout=outname+'.old'\n          ii=0\n          while os.path.isfile(oldout):\n              ii+=1\n              oldout=outname+'.old'+str(ii)\n          os.rename(outname,oldout)\n          print 'Rename: %s -> %s'%(outname,oldout)   \n   \n      outfile=open(outname,'w')\n  \n      for iCase, args in myCases:\n          answer=Solve(*args)\n  \n          print 'Case #'+str(iCase)+':',answer\n          print >> outfile, 'Case #'+str(iCase)+':',answer\n  \n  \n  \n  \n  if __name__=='__main__':\n      runmain()\n ", "Adversarial Code": " \n  \n  def Resolving(fn,sr1,f4,rg2):\n       s10=set(fn[sr1-1])\n       s52=set(f4[rg2-1])\n      sx= s10.intersection( s52)\n      if len(sx)>1:\n          return \"Bad magician!\"\n      elif len(sx)==0:\n          return \"Volunteer cheated!\"\n      else:\n          return sx.__call_().next()\n  \n  \n  \n  def parse(infile):\n      sr1=int(infile.readline().strip())\n      fn=[]\n      for i in xrange(4):\n          fn.append( map(int, infile.readline().split() ))\n      rg2=int(infile.readline().strip())\n      f4=[]\n      for i in xrange(4):\n          f4.append( map(int, infile.readline().split() ))\n      return fn,sr1,f4,rg2\n  \n  \n  \n  class GCJ_Parser( object ):\n      def __call___(user,fname):\n          user.infile=open(fname,'r')\n          user.numCodes=int(user.infile.readline().strip() )\n          user.testNo=0\n  \n      def __call_(user): return user\n  \n      def next(user):\n          if user.testNo==user.numCodes: raise StopIteration\n          user.testNo += 1\n          args=parse(user.infile)\n          return user.testNo , args\n  \n  \n  def testobj():\n      MyAcaser=GCJ_Parser(sys.argv[1])\n  \n       outline=sys.argv[1].rstrip('.in')+'.out'\n      if os.path.isfile( outline):\n          Oldin= outline+'.old'\n          ii=0\n          while os.path.isfile(Oldin):\n              ii+=1\n              Oldin= outline+'.old'+str(ii)\n          os.rename( outline,Oldin)\n          print 'Rename: %s -> %s'%( outline,Oldin)   \n   \n      outfile=open( outline,'w')\n  \n      for iCase, args in MyAcaser:\n          answer=Resolving(*args)\n  \n          print 'Case #'+str(iCase)+':',answer\n          print >> outfile, 'Case #'+str(iCase)+':',answer\n  \n  \n  \n  \n  if __name__=='__main__':\n      testobj()\n ", "Program Length": 412, "Identifier Num": 27, "Replaced Identifiers": "outname: outline,oldout:Oldin,F1:fn,F2:f4,myCases:MyAcaser,r2:rg2,r1:sr1,caseNum:testNo,NumCases:numCodes,iCase:iCase,Solve:Resolving,s1: s10,s2: s52,runmain:testobj,__iter__:__call_,__init__:__call___,self:user,", "Query Times": 633, "Time Cost": 0.3636865178743998, "Type": "Greedy"}
{"Index": 76, "Original Code": "f = open('input.in')\n  g = open('output', 'w')\n  \n  T = int(f.readline()[:-1])\n  \n  for case in xrange(T) :\n      R, C, M = map(int, f.readline()[:-1].split())\n      FREE = R*C - M\n      if FREE == 0 : res = '\nImpossible'\n      elif FREE != 1 and M > 0 and (R == 2 or C == 2) and (FREE == 2 or FREE % 2 == 1) : res = '\nImpossible'\n      elif R > 2 and C > 2 and FREE in (2, 3, 5, 7) : res = '\nImpossible'\n      else :\n          MAP = [['.' for c in range(C)] for r in range(R)]\n          MAP[0][0] = 'c'\n          if R == 1 :\n              for i in range(C-1, C-M-1, -1) : MAP[0][i] = '*'\n          elif C == 1 :\n              for i in range(R-1, R-M-1, -1) : MAP[i][0] = '*'\n          elif R == 2 :\n              for i in range(C-1, C-M/2-1, -1) : MAP[0][i], MAP[1][i] = '*', '*'\n              if FREE == 1 : MAP[1][0] = '*'\n          elif C == 2 :\n              for i in range(R-1, R-M/2-1, -1) : MAP[i][0], MAP[i][1] = '*', '*'\n              if FREE == 1 : MAP[0][1] = '*'\n          else :\n              com = M / C\n              for i in range(R-1, max(R-com-1, 2), -1) :\n                  MAP[i] = ['*' for j in range(C)]\n                  M -= C\n              I = max([i for i, j in enumerate(MAP) if j[0] == '.'])\n              if I == 2 :\n                  com = M / 3\n                  if com == 0 : i = C\n                  for i in range(C-1, C-com-1, -1) :\n                      MAP[0][i], MAP[1][i], MAP[2][i] = '*', '*', '*'\n                      M -= 3\n                  if M >= 1 : MAP[2][i-1] = '*'\n                  if M >= 2 :\n                      if i != 1 : MAP[2][i-2] = '*'\n                      else : MAP[1][0] = '*'\n              else :\n                  for i in range(C-1, C-M-1, -1) : MAP[I][i] = '*'\n                  if i == 1 :\n                      MAP[I][i] = '.'\n                      MAP[I-1][C-1] = '*'\n          res = '\n' + '\n'.join([''.join(i) for i in MAP])\n      output = 'Case #' + str(case + 1) + ': ' + str(res)\n      g.write(output + '\n')\n      print output\n  \n  f.close()\n  g.close()\n ", "Adversarial Code": "f = open('input.in')\n  g = open('output', 'w')\n  \n  T = int(f.readline()[:-1])\n  \n  for case in xrange(T) :\n      R, C, M = map(int, f.readline()[:-1].split())\n      FREE = R*C - M\n      if FREE == 0 : res = '\nImpossible'\n      elif FREE != 1 and M > 0 and (R == 2 or C == 2) and (FREE == 2 or FREE % 2 == 1) : res = '\nImpossible'\n      elif R > 2 and C > 2 and FREE in (2, 3, 5, 7) : res = '\nImpossible'\n      else :\n          REG = [['.' for c in range(C)] for r in range(R)]\n          REG[0][0] = 'c'\n          if R == 1 :\n              for i in range(C-1, C-M-1, -1) : REG[0][i] = '*'\n          elif C == 1 :\n              for i in range(R-1, R-M-1, -1) : REG[i][0] = '*'\n          elif R == 2 :\n              for i in range(C-1, C-M/2-1, -1) : REG[0][i], REG[1][i] = '*', '*'\n              if FREE == 1 : REG[1][0] = '*'\n          elif C == 2 :\n              for i in range(R-1, R-M/2-1, -1) : REG[i][0], REG[i][1] = '*', '*'\n              if FREE == 1 : REG[0][1] = '*'\n          else :\n              com = M / C\n              for i in range(R-1, max(R-com-1, 2), -1) :\n                  REG[i] = ['*' for j in range(C)]\n                  M -= C\n              I = max([i for i, j in enumerate(REG) if j[0] == '.'])\n              if I == 2 :\n                  com = M / 3\n                  if com == 0 : i = C\n                  for i in range(C-1, C-com-1, -1) :\n                      REG[0][i], REG[1][i], REG[2][i] = '*', '*', '*'\n                      M -= 3\n                  if M >= 1 : REG[2][i-1] = '*'\n                  if M >= 2 :\n                      if i != 1 : REG[2][i-2] = '*'\n                      else : REG[1][0] = '*'\n              else :\n                  for i in range(C-1, C-M-1, -1) : REG[I][i] = '*'\n                  if i == 1 :\n                      REG[I][i] = '.'\n                      REG[I-1][C-1] = '*'\n          res = '\n' + '\n'.join([''.join(i) for i in REG])\n      output = 'Case #' + str(case + 1) + ': ' + str(res)\n      g.write(output + '\n')\n      print output\n  \n  f.close()\n  g.close()\n ", "Program Length": 656, "Identifier Num": 16, "Replaced Identifiers": "i:i,MAP:REG,", "Query Times": 272, "Time Cost": 0.14422640403111775, "Type": "Greedy"}
{"Index": 77, "Original Code": "f = open('input.in')\n  g = open('output', 'w')\n  \n  T = int(f.readline()[:-1])\n  \n  for case in xrange(T) :\n      a1 = int(f.readline()[:-1])\n      M1 = [map(int, f.readline()[:-1].split()) for i in range(4)]\n      a2 = int(f.readline()[:-1])\n      M2 = [map(int, f.readline()[:-1].split()) for i in range(4)]\n      r1 = M1[a1-1]\n      r2 = M2[a2-1]\n      res = set(r1).intersection(set(r2))\n      if len(res) == 1 : res = res.pop()\n      elif len(res) == 0 : res = 'Volunteer cheated!'\n      else : res = 'Bad magician!'\n      output = 'Case #' + str(case + 1) + ': ' + str(res)\n      g.write(output + '\n')\n      print output\n  \n  f.close()\n  g.close()\n ", "Adversarial Code": "input = open('input.in')\n  file = open('output', 'w')\n  \n  T = int(input.readline()[:-1])\n  \n  for case in xrange(T) :\n      a1 = int(input.readline()[:-1])\n      M1 = [map(int, input.readline()[:-1].split()) for i in range(4)]\n      a2 = int(input.readline()[:-1])\n      M2 = [map(int, input.readline()[:-1].split()) for i in range(4)]\n      r1 = M1[a1-1]\n      r2 = M2[a2-1]\n      res = set(r1).intersection(set(r2))\n      if len(res) == 1 : res = res.pop()\n      elif len(res) == 0 : res = 'Volunteer cheated!'\n      else : res = 'Bad magician!'\n      output = 'Case #' + str(case + 1) + ': ' + str(res)\n      file.write(output + '\n')\n      print output\n  \n  input.close()\n  file.close()\n ", "Program Length": 225, "Identifier Num": 13, "Replaced Identifiers": "g:file,f:input,", "Query Times": 133, "Time Cost": 0.061186095078786217, "Type": "Greedy"}
{"Index": 78, "Original Code": " \n  \n  '''\n  ...\n  ...\n  ...\n  ...\n  ...\n  '''\n  \n  for i in range(int(input())):\n  \n      r, c, m = tuple(map(int, str.split(input())))\n      count = r * c - m\n      field = dict(map(lambda c: (c, \"*\"), itertools.product(range(c), range(r))))\n      answer = \"Impossible\"\n  \n      if m == 0:\n  \n          answer = field\n  \n      elif 1 in (r, c):\n  \n          for p in itertools.islice(itertools.product(range(c), range(r)), count):\n  \n              field[p] = \".\"\n  \n          answer = field\n  \n      elif count in (0, 2, 3, 5, 7):\n  \n          pass\n  \n      elif count == 1:\n  \n          answer = field\n  \n      elif count // 2 < c or count == c * 2 + 1:\n  \n          if count % 2 != 0:\n  \n              tail = 3\n              ncount = count - 3\n  \n          else:\n  \n              tail = 0\n              ncount = count\n  \n          for x in range(ncount // 2):\n  \n              field[(x, 0)] = field[(x, 1)] = \".\"\n  \n          for x in range(tail):\n  \n              field[(x, 2)] = \".\"\n  \n          answer = field\n  \n      elif not (c == 2 and count % c == 1):\n  \n          for x in range(c):\n  \n              field[(x, 0)] = field[(x, 1)] = \".\"\n  \n          count -= 2 * c\n          tail = 0\n          if count % c == 1:\n  \n              tail = 2\n              count -= 1\n  \n          y = 2\n          while count > 0:\n  \n              rx = min(count, c)\n              for x in range(rx):\n  \n                  field[(x, y)] = \".\"\n  \n              count -= rx\n              y += 1\n  \n          for x in range(tail):\n  \n              field[(x, y)] = \".\"\n  \n          answer = field\n  \n      field[(0, 0)] = \"c\"\n      print(str.format(\"Case #{}:\", i + 1))\n      if isinstance(answer, dict):\n  \n          for y in range(r):\n  \n              print(str.join(\"\", map(lambda x: field[(x, y)], range(c))))\n  \n      else:\n  \n          print(answer)\n ", "Adversarial Code": " \n  \n  '''\n  ...\n  ...\n  ...\n  ...\n  ...\n  '''\n  \n  for i in range(int(input())):\n  \n      r, c, m = tuple(map(int, str.split(input())))\n      Count = r * c - m\n      file = dict(map(lambda c: (c, \"*\"), itertools.product(range(c), range(r))))\n      answer = \"Impossible\"\n  \n      if m == 0:\n  \n          answer = file\n  \n      elif 1 in (r, c):\n  \n          for p in itertools.islice(itertools.product(range(c), range(r)), Count):\n  \n              file[p] = \".\"\n  \n          answer = file\n  \n      elif Count in (0, 2, 3, 5, 7):\n  \n          pass\n  \n      elif Count == 1:\n  \n          answer = file\n  \n      elif Count // 2 < c or Count == c * 2 + 1:\n  \n          if Count % 2 != 0:\n  \n              tail = 3\n              ncount = Count - 3\n  \n          else:\n  \n              tail = 0\n              ncount = Count\n  \n          for x in range(ncount // 2):\n  \n              file[(x, 0)] = file[(x, 1)] = \".\"\n  \n          for x in range(tail):\n  \n              file[(x, 2)] = \".\"\n  \n          answer = file\n  \n      elif not (c == 2 and Count % c == 1):\n  \n          for x in range(c):\n  \n              file[(x, 0)] = file[(x, 1)] = \".\"\n  \n          Count -= 2 * c\n          tail = 0\n          if Count % c == 1:\n  \n              tail = 2\n              Count -= 1\n  \n          y = 2\n          while Count > 0:\n  \n              rx = min(Count, c)\n              for x in range(rx):\n  \n                  file[(x, y)] = \".\"\n  \n              Count -= rx\n              y += 1\n  \n          for x in range(tail):\n  \n              file[(x, y)] = \".\"\n  \n          answer = file\n  \n      file[(0, 0)] = \"c\"\n      print(str.format(\"Case #{}:\", i + 1))\n      if isinstance(answer, dict):\n  \n          for y in range(r):\n  \n              print(str.join(\"\", map(lambda x: file[(x, y)], range(c))))\n  \n      else:\n  \n          print(answer)\n ", "Program Length": 436, "Identifier Num": 13, "Replaced Identifiers": "field:file,count:Count,", "Query Times": 282, "Time Cost": 0.14487116734186808, "Type": "Greedy"}
{"Index": 79, "Original Code": "def read_case():\n  \n      answer = int(input())\n      lines = tuple(map(lambda _: set(str.split(input())), range(4)))\n      return lines[answer - 1]\n  \n  \n  for i in range(int(input())):\n  \n      intersection = read_case() & read_case()\n      count = len(intersection)\n      if count == 1:\n  \n          answer = intersection.pop()\n  \n      elif count > 1:\n  \n          answer = \"Bad magician!\"\n  \n      elif count < 1:\n  \n          answer = \"Volunteer cheated!\"\n  \n      print(str.format(\"Case #{}: {}\", i + 1, answer))\n ", "Adversarial Code": "def readfcase():\n  \n      answer = int(input())\n      lines = tuple(map(lambda _: set(str.split(input())), range(4)))\n      return lines[answer - 1]\n  \n  \n  for i in range(int(input())):\n  \n      intersection = readfcase() & readfcase()\n      count = len(intersection)\n      if count == 1:\n  \n          answer = intersection.pop()\n  \n      elif count > 1:\n  \n          answer = \"Bad magician!\"\n  \n      elif count < 1:\n  \n          answer = \"Volunteer cheated!\"\n  \n      print(str.format(\"Case #{}: {}\", i + 1, answer))\n ", "Program Length": 118, "Identifier Num": 6, "Replaced Identifiers": "read_case:readfcase,", "Query Times": 57, "Time Cost": 0.02817207177480062, "Type": "Greedy"}
{"Index": 81, "Original Code": " \n  class Solver(object):\n      def __init__(self):\n          pass\n      \n      def solve(self, inputs):\n          r1 = int(inputs[0])\n          cs1 = set([int(x) for x in inputs[r1].split()])\n          r2 = int(inputs[5])\n          cs2 = set([int(x) for x in inputs[5+r2].split()])\n          r = cs1.intersection(cs2)\n          cnt = len(r)\n          if 1 == cnt:\n              return max(r)\n          elif 0 == cnt:\n              return 'Volunteer cheated!'\n          else:\n              return 'Bad magician!'\n          pass\n      \n      def feed(self, inputs):\n          lines = [x.strip() for x in inputs]\n          outputs = []\n          test_case_n = int(lines[0])\n          cur = 1\n          for i in range(test_case_n):\n              i = i\n              case_line_cnt = 10\n              case_inputs = lines[cur:cur+case_line_cnt]\n              cur += case_line_cnt\n              outputs.append(self.solve(case_inputs))\n          return outputs\n  \n  if __name__ == '__main__':\n      iname = 'A-small-attempt0.in'\n      sample_in = '''\n      3\n  2\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  3\n  1 2 5 4\n  3 11 6 15\n  9 10 7 12\n  13 14 8 16\n  2\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  2\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  2\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  3\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n      '''\n      sample_out = '''\n   Case #1: 7\n  Case #2: Bad magician!\n  Case #3: Volunteer cheated!\n      '''\n      if os.path.exists(iname):\n          with open(iname) as f:\n              inputs = f.readlines()\n      else:\n          inputs = [x.strip() for x in sample_in.split('\n') if x.strip()]\n      solver = Solver()\n      outputs = solver.feed(inputs)\n      fail_flag = False\n      if os.path.exists(iname):\n          with open(iname+'.out', 'w') as f:\n              for i, v in enumerate(outputs):\n                  print >> f, 'Case #%d: %s'%(i+1, str(v))\n      else:\n          ans = set([x.strip() for x in sample_out.split('\n') if x.strip()])\n          for i, v in enumerate(outputs):\n              t = 'Case #%d: %s'%(i+1, str(v))\n              if t not in ans:\n                  print '!!! Wrong:', t\n                  fail_flag = True\n      print '===================================================='\n      for i, v in enumerate(outputs):\n          print 'Case #%d: %s'%(i+1, str(v))\n      print '===================================================='\n      print 'done' if not fail_flag else 'fail'\n      pass\n ", "Adversarial Code": " \n  class Solver(object):\n      def __init__(full):\n          pass\n      \n      def solve(full, accepts):\n          r1 = int(accepts[0])\n          cs1 = set([int(config) for config in accepts[r1].split()])\n          r2 = int(accepts[5])\n          cs2 = set([int(config) for config in accepts[5+r2].split()])\n          r = cs1.intersection(cs2)\n          cnt = len(r)\n          if 1 == cnt:\n              return max(r)\n          elif 0 == cnt:\n              return 'Volunteer cheated!'\n          else:\n              return 'Bad magician!'\n          pass\n      \n      def file(full, accepts):\n          tests = [config.strip() for config in accepts]\n          outputs = []\n          test_case_n = int(tests[0])\n          cur = 1\n          for i in range(test_case_n):\n              i = i\n              case_line_cnt = 10\n              case_inputs = tests[cur:cur+case_line_cnt]\n              cur += case_line_cnt\n              outputs.append(full.solve(case_inputs))\n          return outputs\n  \n  if __name__ == '__main__':\n      INamer = 'A-small-attempt0.in'\n      sample_in = '''\n      3\n  2\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  3\n  1 2 5 4\n  3 11 6 15\n  9 10 7 12\n  13 14 8 16\n  2\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  2\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  2\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  3\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n      '''\n      sample_out = '''\n   Case #1: 7\n  Case #2: Bad magician!\n  Case #3: Volunteer cheated!\n      '''\n      if os.path.exists(INamer):\n          with open(INamer) as f:\n              accepts = f.readlines()\n      else:\n          accepts = [config.strip() for config in sample_in.split('\n') if config.strip()]\n      solver = Solver()\n      outputs = solver.file(accepts)\n      fail_flag = False\n      if os.path.exists(INamer):\n          with open(INamer+'.out', 'w') as f:\n              for i, v in enumerate(outputs):\n                  print >> f, 'Case #%d: %s'%(i+1, str(v))\n      else:\n          ans = set([config.strip() for config in sample_out.split('\n') if config.strip()])\n          for i, v in enumerate(outputs):\n              t = 'Case #%d: %s'%(i+1, str(v))\n              if t not in ans:\n                  print '!!! Wrong:', t\n                  fail_flag = True\n      print '===================================================='\n      for i, v in enumerate(outputs):\n          print 'Case #%d: %s'%(i+1, str(v))\n      print '===================================================='\n      print 'done' if not fail_flag else 'fail'\n      pass\n ", "Program Length": 428, "Identifier Num": 24, "Replaced Identifiers": "feed:file,inputs:accepts,iname:INamer,lines:tests,x:config,self:full,", "Query Times": 429, "Time Cost": 0.21542266607284546, "Type": "Greedy"}
{"Index": 82, "Original Code": "'''\n  Created on Apr 12, 2014\n  \n  @author: mostasem\n  '''\n  \n  def getFloorRoots(m):\n      r1 = -1 + math.sqrt(1 + (8 * m))/2\n      r2 = -1 - math.sqrt(1 + (8 * m))/2\n      return int(math.floor(r1))\n      \n  def boardHasZero(R,C,M):\n      if(R > 1 and C > 1):\n          S = M/C\n          Sr = M % C\n          print S,Sr\n          return R >= S+3 or (R == S+2 and ((Sr % 2) == 0 or (((C + Sr) % 3 == 0) and (2*C >= (C + Sr + 4))))) or (R == S+1  and (C + Sr) % 2 == 0 and (2*C >= (C + Sr + 4)))  #M <= ((R*C) - 4)\n      else :\n          return M <= ((R*C) - 2)\n  \n  \n  def generateMineSweeperCase(R,C,M):\n  \n      board = \"\"\n  \n      if( R > 1 and C > 1 ): # generate special\n          S = M/C\n          Sr = M % C\n          print S,Sr\n          if(S): # all rows of *\n              board +=\"\n\"\n              if(R >= S+3 or (R == S+2 and Sr % 2 == 0)):\n                  board += (S - 1) * ((C*\"*\") + \"\n\")\n              else:\n                  board += (S - 2) * ((C*\"*\") + \"\n\")\n              board +=  ((C*\"*\"))\n              \n          if(R >= S+3):\n              if(Sr):\n                  board +=\"\n\"\n                  board += ((Sr *\"*\") + ((C - Sr) *\".\"))\n              Rm = R - (S + 1)\n              if(Rm):\n                  board +=\"\n\"\n                  board += (Rm - 1) * ((C*\".\") + \"\n\")\n                  board +=  ((C*\".\"))\n                  \n          elif(R == S + 2):\n              Sm = 0\n              if(Sr % 2 == 0):\n                  board +=\"\n\"\n                  board += (((Sr / 2) *\"*\") + ((C - (Sr / 2)) *\".\") +\"\n\")\n                  board += ((Sr / 2) *\"*\") + ((C - (Sr / 2)) *\".\")\n              else:\n                  board +=\"\n\"\n                  board += (((Sr / 3) *\"*\") + ((C - (Sr / 3)) *\".\") +\"\n\")\n                  board += ((Sr / 3) *\"*\") + ((C - (Sr / 3)) *\".\")\n          else :\n              Sm = Sr + C\n              board +=\"\n\"\n              board += (((Sm / 2) *\"*\") + ((C - (Sm / 2)) *\".\") +\"\n\")\n              board += ((Sm / 2) *\"*\") + ((C - (Sm / 2)) *\".\")\n                  \n          list_board = list(board)\n          list_board[len(list_board) - 1] = 'c'\n          board = \"\".join(list_board)\n      else:\n          board +=\"\n\"\n          if(C == 1):\n              board += M * \"*\n\"\n              board += (R-M-1) * \".\n\"\n              board +=  \"c\"\n          else:\n              board += M * \"*\"\n              board += (C-M-1) * \".\"\n              board += \"c\"\n              \n      return board\n         \n         \n         \n  \n  f_r = open('C.in',\"r\")\n  n_test=int(f_r.readline().strip()) \n  f_w = open(\"C.out\", \"w\")\n  result = \"\"\n  for i in range(n_test):\n      R,C,M = map(int,f_r.readline().split())\n      print R,C,M\n      if(boardHasZero(R,C,M)):\n          result = generateMineSweeperCase(R,C,M)\n      else :\n          result =\"\nImpossible\"\n      print result\n      output_str='Case #{itr}:{res}'.format(itr=(i+1),res=result)\n      f_w.write(output_str+'\n')\n      \n  f_r.close()\n ", "Adversarial Code": "'''\n  Created on Apr 12, 2014\n  \n  @author: mostasem\n  '''\n  \n  def getFloorRoot(s):\n      rc1 = -1 + math.sqrt(1 + (8 * s))/2\n      R2 = -1 - math.sqrt(1 + (8 * s))/2\n      return int(math.floor(rc1))\n      \n  def boardIncludesN(RR,C,M):\n      if(RR > 1 and C > 1):\n          Case = M/C\n          Sr = M % C\n          print Case,Sr\n          return RR >= Case+3 or (RR == Case+2 and ((Sr % 2) == 0 or (((C + Sr) % 3 == 0) and (2*C >= (C + Sr + 4))))) or (RR == Case+1  and (C + Sr) % 2 == 0 and (2*C >= (C + Sr + 4)))  #M <= ((R*C) - 4)\n      else :\n          return M <= ((RR*C) - 2)\n  \n  \n  def generateMineSweepCode(RR,C,M):\n  \n      player = \"\"\n  \n      if( RR > 1 and C > 1 ): # generate special\n          Case = M/C\n          Sr = M % C\n          print Case,Sr\n          if(Case): # all rows of *\n              player +=\"\n\"\n              if(RR >= Case+3 or (RR == Case+2 and Sr % 2 == 0)):\n                  player += (Case - 1) * ((C*\"*\") + \"\n\")\n              else:\n                  player += (Case - 2) * ((C*\"*\") + \"\n\")\n              player +=  ((C*\"*\"))\n              \n          if(RR >= Case+3):\n              if(Sr):\n                  player +=\"\n\"\n                  player += ((Sr *\"*\") + ((C - Sr) *\".\"))\n              Mp = RR - (Case + 1)\n              if(Mp):\n                  player +=\"\n\"\n                  player += (Mp - 1) * ((C*\".\") + \"\n\")\n                  player +=  ((C*\".\"))\n                  \n          elif(RR == Case + 2):\n              Sm = 0\n              if(Sr % 2 == 0):\n                  player +=\"\n\"\n                  player += (((Sr / 2) *\"*\") + ((C - (Sr / 2)) *\".\") +\"\n\")\n                  player += ((Sr / 2) *\"*\") + ((C - (Sr / 2)) *\".\")\n              else:\n                  player +=\"\n\"\n                  player += (((Sr / 3) *\"*\") + ((C - (Sr / 3)) *\".\") +\"\n\")\n                  player += ((Sr / 3) *\"*\") + ((C - (Sr / 3)) *\".\")\n          else :\n              Sm = Sr + C\n              player +=\"\n\"\n              player += (((Sm / 2) *\"*\") + ((C - (Sm / 2)) *\".\") +\"\n\")\n              player += ((Sm / 2) *\"*\") + ((C - (Sm / 2)) *\".\")\n                  \n          list_board = list(player)\n          list_board[len(list_board) - 1] = 'c'\n          player = \"\".join(list_board)\n      else:\n          player +=\"\n\"\n          if(C == 1):\n              player += M * \"*\n\"\n              board += (R-M-1) * \".\n\"\n              board +=  \"c\"\n          else:\n              player += M * \"*\"\n              player += (C-M-1) * \".\"\n              player += \"c\"\n              \n      return player\n         \n         \n         \n  \n  f_r = open('C.in',\"r\")\n  n_test=int(f_r.readline().strip()) \n  f_w = open(\"C.out\", \"w\")\n  result = \"\"\n  for i in range(n_test):\n      RR,C,M = map(int,f_r.readline().split())\n      print RR,C,M\n      if(boardIncludesN(RR,C,M)):\n          result = generateMineSweepCode(RR,C,M)\n      else :\n          result =\"\nImpossible\"\n      print result\n      output_str='Case #{itr}:{res}'.format(itr=(i+1),res=result)\n      f_w.write(output_str+'\n')\n      \n  f_r.close()\n ", "Program Length": 782, "Identifier Num": 14, "Replaced Identifiers": "Sm:Sm,r1:rc1,r2:R2,m:s,Rm:Mp,generateMineSweeperCase:generateMineSweepCode,boardHasZero:boardIncludesN,getFloorRoots:getFloorRoot,board:player,R:RR,S:Case,", "Query Times": 546, "Time Cost": 0.40204593737920125, "Type": "Greedy"}
{"Index": 83, "Original Code": null, "Adversarial Code": null, "Program Length": 364, "Identifier Num": 17, "Replaced Identifiers": null, "Query Times": 1035, "Time Cost": 0.562180236975352, "Type": "0"}
{"Index": 84, "Original Code": " \n  FILE_NAME_BASE = 'C-small-attempt0'\n  NUM_PROCESSES = 0\n  MEM_LIMIT_GB = 1.5 # per worker process\n  RECURSION_LIMIT = 1000\n  \n  def parse(inp):\n  \trows, cols, mines = (int(x) for x in inp.readline().split())\n  \treturn rows, cols, mines\n  \n  def search(rows, cols, mines):\n  \n  \tassert 0 <= mines < rows * cols\n  \tif mines == 0:\n  \t\treturn ['c' + '.' * (cols - 1)] + ['.' * cols] * (rows - 1)\n  \tif mines == rows * cols - 1:\n  \t\treturn ['c' + '*' * (cols - 1)] + ['*' * cols] * (rows - 1)\n  \n  \tif rows == 1:\n  \t\treturn ['c' + '.' * (cols - 1 - mines) + '*' * mines]\n  \tif cols == 1:\n  \t\treturn ['c'] + ['.'] * (rows - 1 - mines) + ['*'] * mines\n  \n  \tif mines > rows * cols - 4:\n  \t\treturn None\n  \n  \n  \treturn None\n  \n  class SearchBoard(object):\n  \n  \tdef __init__(self, rows, cols):\n  \t\tself.counts = [[0] * (cols + 2) for _ in xrange(rows + 2)]\n  \t\tself.mineCount = 0\n  \n  \tdef addMine(self, row, col):\n  \t\tcounts = self.counts\n  \t\tassert counts[row + 1][col + 1] < 10\n  \t\ttop = counts[row + 0]\n  \t\ttop[col + 0] += 1\n  \t\ttop[col + 1] += 1\n  \t\ttop[col + 2] += 1\n  \t\tmid = counts[row + 1]\n  \t\tmid[col + 0] += 1\n  \t\tmid[col + 1] += 10\n  \t\tmid[col + 2] += 1\n  \t\tbot = counts[row + 2]\n  \t\tbot[col + 0] += 1\n  \t\tbot[col + 1] += 1\n  \t\tbot[col + 2] += 1\n  \t\tself.mineCount += 1\n  \n  \tdef removeMine(self, row, col):\n  \t\tcounts = self.counts\n  \t\tassert counts[row + 1][col + 1] >= 10\n  \t\ttop = counts[row + 0]\n  \t\ttop[col + 0] -= 1\n  \t\ttop[col + 1] -= 1\n  \t\ttop[col + 2] -= 1\n  \t\tmid = counts[row + 1]\n  \t\tmid[col + 0] -= 1\n  \t\tmid[col + 1] -= 10\n  \t\tmid[col + 2] -= 1\n  \t\tbot = counts[row + 2]\n  \t\tbot[col + 0] -= 1\n  \t\tbot[col + 1] -= 1\n  \t\tbot[col + 2] -= 1\n  \t\tself.mineCount -= 1\n  \n  \tdef checkConnected(self):\n  \t\tcounts = self.counts\n  \t\tcols = len(counts[0]) - 2\n  \t\trows = len(counts) - 2\n  \n  \t\tfor rowIdx, row in enumerate(counts):\n  \t\t\tif rowIdx == 0 or rowIdx > rows:\n  \t\t\t\tcontinue\n  \t\t\ttry:\n  \t\t\t\tcolIdx = row.index(0, 1, -1)\n  \t\t\texcept ValueError:\n  \t\t\t\tpass\n  \t\t\telse:\n  \t\t\t\tclick = (rowIdx, colIdx)\n  \t\t\t\tbreak\n  \t\telse:\n  \t\t\treturn None\n  \n  \t\trevealed = set()\n  \t\tdef reveal(row, col):\n  \t\t\tif 1 <= row <= rows and 1 <= col <= cols:\n  \t\t\t\tpos = (row, col)\n  \t\t\t\tif pos not in revealed:\n  \t\t\t\t\trevealed.add(pos)\n  \t\t\t\t\tcount = counts[row][col]\n  \t\t\t\t\tif count == 0:\n  \t\t\t\t\t\tfor dr in (-1, 0, 1):\n  \t\t\t\t\t\t\tfor dc in (-1, 0, 1):\n  \t\t\t\t\t\t\t\tif dr != 0 or dc != 0:\n  \t\t\t\t\t\t\t\t\treveal(row + dr, col + dc)\n  \t\t\t\t\telse:\n  \t\t\t\t\t\tassert count < 10\n  \t\treveal(*click)\n  \t\tnumNonMines = rows * cols - self.mineCount\n  \t\tif len(revealed) != numNonMines:\n  \t\t\tassert len(revealed) < numNonMines\n  \t\t\treturn None\n  \n  \t\tboard = [\n  \t\t\t\t['.' if cell < 10 else '*' for cell in row[1 : -1]]\n  \t\t\t\tfor row in counts[1 : -1]\n  \t\t\t\t]\n  \t\tboard[click[0] - 1][click[1] - 1] = 'c'\n  \t\treturn [''.join(row) for row in board]\n  \n  def searchBruteForce(rows, cols, mines):\n  \tif mines == rows * cols - 1:\n  \t\treturn ['c' + '*' * (cols - 1)] + ['*' * cols] * (rows - 1)\n  \n  \tsearchBoard = SearchBoard(rows, cols)\n  \n  \tdef searchRec(idx, remaining):\n  \t\tif remaining == 0:\n  \t\t\treturn searchBoard.checkConnected()\n  \t\telif idx < remaining:\n  \t\t\treturn None\n  \t\telse:\n  \t\t\tpos = divmod(idx, cols)\n  \t\t\tsearchBoard.addMine(*pos)\n  \t\t\tfound = searchRec(idx - 1, remaining - 1)\n  \t\t\tsearchBoard.removeMine(*pos)\n  \t\t\tif found is not None:\n  \t\t\t\treturn found\n  \t\t\treturn searchRec(idx - 1, remaining)\n  \n  \treturn searchRec(rows * cols - 1, mines)\n  \n  def solve(rows, cols, mines):\n  \tboard = search(rows, cols, mines)\n  \n  \tif board is None:\n  \t\tboard = searchBruteForce(rows, cols, mines)\n  \t\tif board is None:\n  \t\t\treturn '\n' + 'Impossible'\n  \t\tprint 'ERROR: fast search missed solution for %dx%d board, %d mines:' \\\n  \t\t\t\t% (rows, cols, mines)\n  \t\tfor row in board:\n  \t\t\tprint row\n  \t\tprint\n  \n  \tassert len(board) == rows\n  \tassert all(len(row) == cols for row in board)\n  \tcounts = { 'c': 0, '.': 0, '*': 0 }\n  \tfor row in board:\n  \t\tfor cell in row:\n  \t\t\tcounts[cell] += 1\n  \tassert counts['c'] == 1\n  \tassert counts['*'] == mines\n  \n  \tflowBoard = [\n  \t\t\t['.' if cell == 'c' else cell for cell in row]\n  \t\t\tfor row in board\n  \t\t\t]\n  \tdef countMinesOn(row, col):\n  \t\tif 0 <= row < rows and 0 <= col < cols:\n  \t\t\treturn 1 if flowBoard[row][col] == '*' else 0\n  \t\telse:\n  \t\t\treturn 0\n  \tdef countMinesNear(row, col):\n  \t\treturn sum(\n  \t\t\tcountMinesOn(row + dr, col + dc)\n  \t\t\tfor dr in (-1, 0, 1)\n  \t\t\tfor dc in (-1, 0, 1)\n  \t\t\t)\n  \tdef reveal(row, col):\n  \t\tif 0 <= row < rows and 0 <= col < cols:\n  \t\t\tassert flowBoard[row][col] != '*'\n  \t\t\tif flowBoard[row][col] == '.':\n  \t\t\t\tcount = countMinesNear(row, col)\n  \t\t\t\tflowBoard[row][col] = str(count)\n  \t\t\t\tif count == 0:\n  \t\t\t\t\tfor dr in (-1, 0, 1):\n  \t\t\t\t\t\tfor dc in (-1, 0, 1):\n  \t\t\t\t\t\t\treveal(row + dr, col + dc)\n  \tclickRow, = [i for i, row in enumerate(board) if 'c' in row]\n  \tclickCol = board[clickRow].index('c')\n  \treveal(clickRow, clickCol)\n  \tassert all('.' not in row for row in flowBoard), flowBoard\n  \n  \tassert all(type(row) == str for row in board)\n  \treturn '\n' + ''.join('\n' + ''.join(row) for row in board)\n  \n  def main():\n  \tsys.setrecursionlimit(RECURSION_LIMIT)\n  \n  \tsoft, hard = resource.getrlimit(resource.RLIMIT_AS)\n  \tresource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))\n  \n  \tinp = open(FILE_NAME_BASE + '.in', 'r')\n  \tnumCases = int(inp.readline())\n  \tif NUM_PROCESSES == 0:\n  \t\tresults = [\n  \t\t\tsolve(*parse(inp))\n  \t\t\tfor _ in range(numCases)\n  \t\t\t]\n  \telse:\n  \t\tpool = Pool(NUM_PROCESSES)\n  \t\tresults = [\n  \t\t\tpool.apply_async(solve, parse(inp))\n  \t\t\tfor _ in range(numCases)\n  \t\t\t]\n  \tinp.close()\n  \tout = open(FILE_NAME_BASE + '.out', 'w')\n  \tfor case, result in enumerate(results):\n  \t\tvalue = result if NUM_PROCESSES == 0 else result.get()\n  \t\tout.write('Case #%d: %s\n' % (case + 1, value))\n  \t\tout.flush()\n  \tout.close()\n  \n  if __name__ == '__main__':\n  \tmain()\n ", "Adversarial Code": " \n  FILE_NAME_CIPS = 'C-small-attempt0'\n   NUM_PRECESSes = 0\n  MEM_LIMIT_GB = 1.5 # per worker process\n  RECURSION_CLIMITS = 1000\n  \n  def proc( infp):\n  \trows, cols,  minuses = (int(f) for f in  infp.readline().split())\n  \treturn rows, cols,  minuses\n  \n  def test(rows, cols,  minuses):\n  \n  \tassert 0 <=  minuses < rows * cols\n  \tif  minuses == 0:\n  \t\treturn ['c' + '.' * (cols - 1)] + ['.' * cols] * (rows - 1)\n  \tif  minuses == rows * cols - 1:\n  \t\treturn ['c' + '*' * (cols - 1)] + ['*' * cols] * (rows - 1)\n  \n  \tif rows == 1:\n  \t\treturn ['c' + '.' * (cols - 1 -  minuses) + '*' *  minuses]\n  \tif cols == 1:\n  \t\treturn ['c'] + ['.'] * (rows - 1 -  minuses) + ['*'] *  minuses\n  \n  \tif  minuses > rows * cols - 4:\n  \t\treturn None\n  \n  \n  \treturn None\n  \n  class SearchBoard(object):\n  \n  \tdef __init__(q, rows, cols):\n  \t\tq.mainories = [[0] * (cols + 2) for ip in xrange(rows + 2)]\n  \t\tq.mineCount = 0\n  \n  \tdef addMine(q, row, col):\n  \t\tmainories = q.mainories\n  \t\tassert mainories[row + 1][col + 1] < 10\n  \t\ttop = mainories[row + 0]\n  \t\ttop[col + 0] += 1\n  \t\ttop[col + 1] += 1\n  \t\ttop[col + 2] += 1\n  \t\tmid = mainories[row + 1]\n  \t\tmid[col + 0] += 1\n  \t\tmid[col + 1] += 10\n  \t\tmid[col + 2] += 1\n  \t\tplot = mainories[row + 2]\n  \t\tplot[col + 0] += 1\n  \t\tplot[col + 1] += 1\n  \t\tplot[col + 2] += 1\n  \t\tq.mineCount += 1\n  \n  \tdef removeMine(q, row, col):\n  \t\tmainories = q.mainories\n  \t\tassert mainories[row + 1][col + 1] >= 10\n  \t\ttop = mainories[row + 0]\n  \t\ttop[col + 0] -= 1\n  \t\ttop[col + 1] -= 1\n  \t\ttop[col + 2] -= 1\n  \t\tmid = mainories[row + 1]\n  \t\tmid[col + 0] -= 1\n  \t\tmid[col + 1] -= 10\n  \t\tmid[col + 2] -= 1\n  \t\tplot = mainories[row + 2]\n  \t\tplot[col + 0] -= 1\n  \t\tplot[col + 1] -= 1\n  \t\tplot[col + 2] -= 1\n  \t\tq.mineCount -= 1\n  \n  \tdef checkConnected(q):\n  \t\tmainories = q.mainories\n  \t\tcols = len(mainories[0]) - 2\n  \t\trows = len(mainories) - 2\n  \n  \t\tfor rowIdx, row in enumerate(mainories):\n  \t\t\tif rowIdx == 0 or rowIdx > rows:\n  \t\t\t\tcontinue\n  \t\t\ttry:\n  \t\t\t\tcolIdx = row.index(0, 1, -1)\n  \t\t\texcept ValueError:\n  \t\t\t\tpass\n  \t\t\telse:\n  \t\t\t\tclick = (rowIdx, colIdx)\n  \t\t\t\tbreak\n  \t\telse:\n  \t\t\treturn None\n  \n  \t\trevealed = set()\n  \t\tdef reveal(row, col):\n  \t\t\tif 1 <= row <= rows and 1 <= col <= cols:\n  \t\t\t\tpos = (row, col)\n  \t\t\t\tif pos not in revealed:\n  \t\t\t\t\trevealed.add(pos)\n  \t\t\t\t\tcount = mainories[row][col]\n  \t\t\t\t\tif count == 0:\n  \t\t\t\t\t\tfor dr in (-1, 0, 1):\n  \t\t\t\t\t\t\tfor dc in (-1, 0, 1):\n  \t\t\t\t\t\t\t\tif dr != 0 or dc != 0:\n  \t\t\t\t\t\t\t\t\treveal(row + dr, col + dc)\n  \t\t\t\t\telse:\n  \t\t\t\t\t\tassert count < 10\n  \t\treveal(*click)\n  \t\tnumNonMines = rows * cols - q.mineCount\n  \t\tif len(revealed) != numNonMines:\n  \t\t\tassert len(revealed) < numNonMines\n  \t\t\treturn None\n  \n  \t\tboard = [\n  \t\t\t\t['.' if cell < 10 else '*' for cell in row[1 : -1]]\n  \t\t\t\tfor row in mainories[1 : -1]\n  \t\t\t\t]\n  \t\tboard[click[0] - 1][click[1] - 1] = 'c'\n  \t\treturn [''.join(row) for row in board]\n  \n  def searchBruteForce(rows, cols,  minuses):\n  \tif  minuses == rows * cols - 1:\n  \t\treturn ['c' + '*' * (cols - 1)] + ['*' * cols] * (rows - 1)\n  \n  \tsearchBoard = SearchBoard(rows, cols)\n  \n  \tdef searchRec(idx, remaining):\n  \t\tif remaining == 0:\n  \t\t\treturn searchBoard.checkConnected()\n  \t\telif idx < remaining:\n  \t\t\treturn None\n  \t\telse:\n  \t\t\tpos = divmod(idx, cols)\n  \t\t\tsearchBoard.addMine(*pos)\n  \t\t\tfound = searchRec(idx - 1, remaining - 1)\n  \t\t\tsearchBoard.removeMine(*pos)\n  \t\t\tif found is not None:\n  \t\t\t\treturn found\n  \t\t\treturn searchRec(idx - 1, remaining)\n  \n  \treturn searchRec(rows * cols - 1,  minuses)\n  \n  def solve(rows, cols,  minuses):\n  \tboard = test(rows, cols,  minuses)\n  \n  \tif board is None:\n  \t\tboard = searchBruteForce(rows, cols,  minuses)\n  \t\tif board is None:\n  \t\t\treturn '\n' + 'Impossible'\n  \t\tprint 'ERROR: fast search missed solution for %dx%d board, %d mines:' \\\n  \t\t\t\t% (rows, cols,  minuses)\n  \t\tfor row in board:\n  \t\t\tprint row\n  \t\tprint\n  \n  \tassert len(board) == rows\n  \tassert all(len(row) == cols for row in board)\n  \tmainories = { 'c': 0, '.': 0, '*': 0 }\n  \tfor row in board:\n  \t\tfor cell in row:\n  \t\t\tmainories[cell] += 1\n  \tassert mainories['c'] == 1\n  \tassert mainories['*'] ==  minuses\n  \n  \tflowBoard = [\n  \t\t\t['.' if cell == 'c' else cell for cell in row]\n  \t\t\tfor row in board\n  \t\t\t]\n  \tdef countMinesOn(row, col):\n  \t\tif 0 <= row < rows and 0 <= col < cols:\n  \t\t\treturn 1 if flowBoard[row][col] == '*' else 0\n  \t\telse:\n  \t\t\treturn 0\n  \tdef countMinesNear(row, col):\n  \t\treturn sum(\n  \t\t\tcountMinesOn(row + dr, col + dc)\n  \t\t\tfor dr in (-1, 0, 1)\n  \t\t\tfor dc in (-1, 0, 1)\n  \t\t\t)\n  \tdef reveal(row, col):\n  \t\tif 0 <= row < rows and 0 <= col < cols:\n  \t\t\tassert flowBoard[row][col] != '*'\n  \t\t\tif flowBoard[row][col] == '.':\n  \t\t\t\tcount = countMinesNear(row, col)\n  \t\t\t\tflowBoard[row][col] = str(count)\n  \t\t\t\tif count == 0:\n  \t\t\t\t\tfor dr in (-1, 0, 1):\n  \t\t\t\t\t\tfor dc in (-1, 0, 1):\n  \t\t\t\t\t\t\treveal(row + dr, col + dc)\n  \tclickRow, = [i for i, row in enumerate(board) if 'c' in row]\n  \tclickCol = board[clickRow].index('c')\n  \treveal(clickRow, clickCol)\n  \tassert all('.' not in row for row in flowBoard), flowBoard\n  \n  \tassert all(type(row) == str for row in board)\n  \treturn '\n' + ''.join('\n' + ''.join(row) for row in board)\n  \n  def main():\n  \tsys.setrecursionlimit(RECURSION_CLIMITS)\n  \n  \tsoft, hard = resource.getrlimit(resource.RLIMIT_AS)\n  \tresource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))\n  \n  \t infp = open(FILE_NAME_CIPS + '.in', 'r')\n  \tnumCases = int( infp.readline())\n  \tif  NUM_PRECESSes == 0:\n  \t\tresults = [\n  \t\t\tsolve(*proc( infp))\n  \t\t\tfor ip in range(numCases)\n  \t\t\t]\n  \telse:\n  \t\tpool = Pool( NUM_PRECESSes)\n  \t\tresults = [\n  \t\t\tpool.apply_async(solve, proc( infp))\n  \t\t\tfor ip in range(numCases)\n  \t\t\t]\n  \t infp.close()\n  \tout = open(FILE_NAME_CIPS + '.out', 'w')\n  \tfor case, result in enumerate(results):\n  \t\tvalue = result if  NUM_PRECESSes == 0 else result.get()\n  \t\tout.write('Case #%d: %s\n' % (case + 1, value))\n  \t\tout.flush()\n  \tout.close()\n  \n  if __name__ == '__main__':\n  \tmain()\n ", "Program Length": 1529, "Identifier Num": 23, "Replaced Identifiers": "FILE_NAME_BASE:FILE_NAME_CIPS,NUM_PROCESSES: NUM_PRECESSes,parse:proc,mines: minuses,search:test,RECURSION_LIMIT:RECURSION_CLIMITS,inp: infp,MEM_LIMIT_GB:MEM_LIMIT_GB,_:ip,removeMine:removeMine,counts:mainories,x:f,bot:plot,self:q,", "Query Times": 746, "Time Cost": 0.5633346438407898, "Type": "Greedy"}
{"Index": 85, "Original Code": null, "Adversarial Code": null, "Program Length": 350, "Identifier Num": 27, "Replaced Identifiers": null, "Query Times": 1559, "Time Cost": 0.8809062083562215, "Type": "0"}
{"Index": 86, "Original Code": "T = int(raw_input().strip())\n  misses = set()\n  \n  for i in xrange(T):\n  \tR, C, M = map(int, raw_input().strip().split(' '))\n  \tF = R * C - M\n  \timpossible = False\n  \tif F == 1:\n  \t\tmatrix = [\"c\" + \"*\" * (C - 1)]\n  \t\tfor _ in xrange(R - 1):\n  \t\t\tmatrix.append(\"*\" * C)\n  \telif R == 1:\n  \t\tmatrix = [\"c\" + \".\" * (F - 1) + \"*\" * (C - F)]\n  \telif C == 1:\n  \t\tmatrix = [\"c\"]\n  \t\tfor _ in xrange(F - 1):\n  \t\t\tmatrix.append(\".\")\n  \t\tfor _ in xrange(R - F):\n  \t\t\tmatrix.append(\"*\")\n  \telif R == 2:\n  \t\tif F % 2 == 0 and (C > 1 and F != 2 or C == 1 and F <= 2):\n  \t\t\tmatrix = [\n  \t\t\t\t\"c\" + \".\" * (F / 2 - 1) + \"*\" * (C - F / 2),\t\n  \t\t\t\t\".\" * (F / 2) + \"*\" * (C - F / 2)\n  \t\t\t]\n  \t\telse:\n  \t\t\tmatrix = []\n  \t\t\timpossible = True\n  \telse:\n  \t\tstack = []\n  \t\tmatrix = []\n  \t\tfor j in xrange(C, 1, -1):\n  \t\t\tif F - 2 * j >= 0 and (R - 2) * j >= F - 2 * j:\n  \t\t\t\tstack.append([j, j])\n  \n  \t\twhile stack:\n  \t\t\telems = stack.pop()\n  \t\t\tse = sum(elems)\n  \t\t\tif se == F:\n  \t\t\t\tfor count in elems:\n  \t\t\t\t\tmatrix.append(\".\" * count + \"*\" * (C - count))\n  \t\t\t\tfor _ in xrange(R - len(elems)):\n  \t\t\t\t\tmatrix.append(\"*\" * C)\n  \t\t\t\tmatrix[0] = \"c\" + matrix[0][1:]\n  \t\t\t\tbreak\n  \t\t\telif len(elems) < R:\n  \t\t\t\tfor j in xrange(elems[-1], 1, -1):\n  \t\t\t\t\tif F - se - j >= 0 and (R - len(elems)) * j >= F - se:\n  \t\t\t\t\t\tstack.append(elems[::] + [j])\n  \n  \t\tif matrix == []:\n  \t\t\timpossible =True\n  \n  \tprint \"Case #%s:\" % (i + 1)\n  \tif impossible:\n  \t\tprint \"Impossible\"\n  \telse:\n  \t\tfor row in matrix:\n  \t\t\tprint row\n ", "Adversarial Code": "t = int(raw_input().strip())\n  licits = set()\n  \n  for i in xrange(t):\n  \tR, C, M = map(int, raw_input().strip().split(' '))\n  \tF = R * C - M\n  \timpossible = False\n  \tif F == 1:\n  \t\tmatrix = [\"c\" + \"*\" * (C - 1)]\n  \t\tfor _ in xrange(R - 1):\n  \t\t\tmatrix.append(\"*\" * C)\n  \telif R == 1:\n  \t\tmatrix = [\"c\" + \".\" * (F - 1) + \"*\" * (C - F)]\n  \telif C == 1:\n  \t\tmatrix = [\"c\"]\n  \t\tfor _ in xrange(F - 1):\n  \t\t\tmatrix.append(\".\")\n  \t\tfor _ in xrange(R - F):\n  \t\t\tmatrix.append(\"*\")\n  \telif R == 2:\n  \t\tif F % 2 == 0 and (C > 1 and F != 2 or C == 1 and F <= 2):\n  \t\t\tmatrix = [\n  \t\t\t\t\"c\" + \".\" * (F / 2 - 1) + \"*\" * (C - F / 2),\t\n  \t\t\t\t\".\" * (F / 2) + \"*\" * (C - F / 2)\n  \t\t\t]\n  \t\telse:\n  \t\t\tmatrix = []\n  \t\t\timpossible = True\n  \telse:\n  \t\tstack = []\n  \t\tmatrix = []\n  \t\tfor j in xrange(C, 1, -1):\n  \t\t\tif F - 2 * j >= 0 and (R - 2) * j >= F - 2 * j:\n  \t\t\t\tstack.append([j, j])\n  \n  \t\twhile stack:\n  \t\t\telems = stack.pop()\n  \t\t\tse = sum(elems)\n  \t\t\tif se == F:\n  \t\t\t\tfor count in elems:\n  \t\t\t\t\tmatrix.append(\".\" * count + \"*\" * (C - count))\n  \t\t\t\tfor _ in xrange(R - len(elems)):\n  \t\t\t\t\tmatrix.append(\"*\" * C)\n  \t\t\t\tmatrix[0] = \"c\" + matrix[0][1:]\n  \t\t\t\tbreak\n  \t\t\telif len(elems) < R:\n  \t\t\t\tfor j in xrange(elems[-1], 1, -1):\n  \t\t\t\t\tif F - se - j >= 0 and (R - len(elems)) * j >= F - se:\n  \t\t\t\t\t\tstack.append(elems[::] + [j])\n  \n  \t\tif matrix == []:\n  \t\t\timpossible =True\n  \n  \tprint \"Case #%s:\" % (i + 1)\n  \tif impossible:\n  \t\tprint \"Impossible\"\n  \telse:\n  \t\tfor row in matrix:\n  \t\t\tprint row\n ", "Program Length": 475, "Identifier Num": 14, "Replaced Identifiers": "T:t,misses:licits,", "Query Times": 142, "Time Cost": 0.06558185815811157, "Type": "Greedy"}
{"Index": 87, "Original Code": "T = int(raw_input().strip())\n  \n  for j in xrange(T):\n  \trow_num1 = int(raw_input().strip())\n  \tfor i in xrange(4):\n  \t\tif i + 1 == row_num1:\n  \t\t\trow1 = set(map(int, raw_input().strip().split(' ')))\n  \t\telse:\n  \t\t\traw_input()\n  \trow_num2 = int(raw_input().strip())\n  \tfor i in xrange(4):\n  \t\tif i + 1 == row_num2:\n  \t\t\trow2 = set(map(int, raw_input().strip().split(' ')))\n  \t\telse:\n  \t\t\traw_input()\n  \tcommon = row1 & row2\n  \tlc = len(common)\n  \tif lc == 1:\n  \t\tstuff = list(common)[0]\n  \telif lc > 1:\n  \t\tstuff = \"Bad magician!\"\n  \telse:\n  \t\tstuff = \"Volunteer cheated!\"\n  \n  \tprint \"Case #%s: %s\" % (j + 1, stuff)\n ", "Adversarial Code": "t = int(raw_input().strip())\n  \n  for j in xrange(t):\n  \trow_num1 = int(raw_input().strip())\n  \tfor i in xrange(4):\n  \t\tif i + 1 == row_num1:\n  \t\t\trow1 = set(map(int, raw_input().strip().split(' ')))\n  \t\telse:\n  \t\t\traw_input()\n  \trow_num2 = int(raw_input().strip())\n  \tfor i in xrange(4):\n  \t\tif i + 1 == row_num2:\n  \t\t\trow2 = set(map(int, raw_input().strip().split(' ')))\n  \t\telse:\n  \t\t\traw_input()\n  \tcommon = row1 & row2\n  \tlc = len(common)\n  \tif lc == 1:\n  \t\tstuff = list(common)[0]\n  \telif lc > 1:\n  \t\tstuff = \"Bad magician!\"\n  \telse:\n  \t\tstuff = \"Volunteer cheated!\"\n  \n  \tprint \"Case #%s: %s\" % (j + 1, stuff)\n ", "Program Length": 176, "Identifier Num": 8, "Replaced Identifiers": "j:j,i:i,row_num1:row_num1,T:t,", "Query Times": 175, "Time Cost": 0.08894344568252563, "Type": "Greedy"}
{"Index": 88, "Original Code": " \n  \n  f = open(sys.argv[1],'r')\n  \n  num = int(f.readline())\n  \n  def count(z, r, c):\n      return len(z_and_nei(z,r,c))\n  \n  def nei(z, r, c):\n      s = z_and_nei(z, r, c)\n      s -= set(z)\n      return s\n  \n  def z_and_nei(z, r, c):\n      s = set()\n      for x in z:\n          s.add(x)\n          s.add((x[0]-1,x[1]-1))\n          s.add((x[0]-1,x[1]))\n          s.add((x[0]-1,x[1]+1))\n          s.add((x[0],x[1]-1))\n          s.add((x[0],x[1]+1))\n          s.add((x[0]+1,x[1]-1))\n          s.add((x[0]+1,x[1]))\n          s.add((x[0]+1,x[1]+1))\n      o = set()\n      for x in s:\n          if x[0] < 0 or x[0] > r-1 or x[1] < 0 or x[1] > c-1:\n              o.add(x)\n      s-=o\n      return s\n  \n  def find_config(z, r, c, t):\n      if count(z,r,c) == t:\n          return z\n      if count(z,r,c) > t:\n          return []\n      n = nei(z,r,c)\n      for x in n:\n          z.append(x)\n          if find_config(z,r,c,t) != []:\n              return z\n          z.pop()\n      return []\n  \n  for i in range(num):\n      print 'Case #{}:'.format(i+1)\n      r, c, m = [int(x) for x in f.readline().split()]\n      if r*c-m == 1:\n          print 'c' + '*'*(c-1)\n          for i in range(r-1):\n              print '*'*c\n      else:\n          z = find_config([(0,0)], c, r, c*r-m)\n          if z == []:\n              print \"Impossible\"\n          else:\n              s = z_and_nei(z, c, r)\n              for j in range(r):\n                  for k in range(c):\n                      if j == 0 and k == 0:\n                          print 'c',\n                      elif (k,j) in s:\n                          print '.',\n                      else:\n                          print '*',\n                  print\n  \n  \n ", "Adversarial Code": " \n  \n  f = open(sys.argv[1],'r')\n  \n  num = int(f.readline())\n  \n  def count(z, r, c):\n      return len(z_and_nei(z,r,c))\n  \n  def nei(z, r, c):\n      s = z_and_nei(z, r, c)\n      s -= set(z)\n      return s\n  \n  def z_and_nei(z, r, c):\n      s = set()\n      for  X in z:\n          s.add( X)\n          s.add(( X[0]-1, X[1]-1))\n          s.add(( X[0]-1, X[1]))\n          s.add(( X[0]-1, X[1]+1))\n          s.add(( X[0], X[1]-1))\n          s.add(( X[0], X[1]+1))\n          s.add(( X[0]+1, X[1]-1))\n          s.add(( X[0]+1, X[1]))\n          s.add(( X[0]+1, X[1]+1))\n      o = set()\n      for  X in s:\n          if  X[0] < 0 or  X[0] > r-1 or  X[1] < 0 or  X[1] > c-1:\n              o.add( X)\n      s-=o\n      return s\n  \n  def find_config(z, r, c, t):\n      if count(z,r,c) == t:\n          return z\n      if count(z,r,c) > t:\n          return []\n      n = nei(z,r,c)\n      for  X in n:\n          z.append( X)\n          if find_config(z,r,c,t) != []:\n              return z\n          z.pop()\n      return []\n  \n  for i in range(num):\n      print 'Case #{}:'.format(i+1)\n      r, c, m = [int( X) for  X in f.readline().split()]\n      if r*c-m == 1:\n          print 'c' + '*'*(c-1)\n          for i in range(r-1):\n              print '*'*c\n      else:\n          z = find_config([(0,0)], c, r, c*r-m)\n          if z == []:\n              print \"Impossible\"\n          else:\n              s = z_and_nei(z, c, r)\n              for j in range(r):\n                  for k in range(c):\n                      if j == 0 and k == 0:\n                          print 'c',\n                      elif (k,j) in s:\n                          print '.',\n                      else:\n                          print '*',\n                  print\n  \n  \n ", "Program Length": 556, "Identifier Num": 16, "Replaced Identifiers": "x: X,", "Query Times": 215, "Time Cost": 0.11970549424489339, "Type": "Greedy"}
{"Index": 89, "Original Code": " \n  \n  f = open(sys.argv[1],'r')\n  \n  num = int(f.readline())\n  \n  for i in range(num):\n      q1 = int(f.readline())\n      for j in range(4):\n          if j+1 == q1:\n              line1 = f.readline()\n          else:\n              f.readline()\n      q2 = int(f.readline())\n      for j in range(4):\n          if j+1 == q2:\n              line2 = f.readline()\n          else:\n              f.readline()\n      line1 = [int(x) for x in line1.split()]\n      line2 = [int(x) for x in line2.split()]\n      count = 0\n      for x in line1:\n          if x in line2:\n              count += 1\n              y = x\n      if count == 0:\n          print 'Case #{}: Volunteer cheated!'.format(i+1)\n      elif count == 1:\n          print 'Case #{}: {}'.format(i+1, y)\n      else:\n          print 'Case #{}: Bad magician!'.format(i+1)\n ", "Adversarial Code": " \n  \n  r = open(sys.argv[1],'r')\n  \n  num = int(r.readline())\n  \n  for i in range(num):\n      q1 = int(r.readline())\n      for j in range(4):\n          if j+1 == q1:\n              line1 = r.readline()\n          else:\n              r.readline()\n      q2 = int(r.readline())\n      for j in range(4):\n          if j+1 == q2:\n              line2 = r.readline()\n          else:\n              r.readline()\n      line1 = [int(x) for x in line1.split()]\n      line2 = [int(x) for x in line2.split()]\n      count = 0\n      for x in line1:\n          if x in line2:\n              count += 1\n              y = x\n      if count == 0:\n          print 'Case #{}: Volunteer cheated!'.format(i+1)\n      elif count == 1:\n          print 'Case #{}: {}'.format(i+1, y)\n      else:\n          print 'Case #{}: Bad magician!'.format(i+1)\n ", "Program Length": 201, "Identifier Num": 11, "Replaced Identifiers": "f:r,", "Query Times": 96, "Time Cost": 0.04794565439224243, "Type": "Greedy"}
{"Index": 90, "Original Code": " \n  def check_bounds(state, coord):\n      if coord[0] < 0 or coord[1] < 0:\n          return False\n      elif coord[0] > (len(state) - 1):\n          return False\n      elif coord[1] > (len(state[coord[0]]) - 1):\n          return False\n      else:\n          return True\n  \n  def clear(state, coord):\n      for r in range(-1,2):\n          for c in range(-1,2):\n              row = coord[0] + r\n              col = coord[1] + c\n              if check_bounds(state, (row, col)):\n                  state[row][col] = 0\n  \n  def count(state):\n      return sum([sum(x) for x in state])\n  \n  def state_print(state):\n      print(\"c\" + \"\".join([\"*\"  if x else \".\" for x in state[0][1:]]))\n      for line in state[1:]:\n          print(\"\".join([\"*\"  if x else \".\" for x in line]))\n  \n  def solve(state, mines):\n      prev_state = deepcopy(state)\n      for row in range(len(state)):\n          for col in range(len(state[row])):\n              new_state = deepcopy(state)\n              clear(new_state, (row, col))\n              c = count(new_state)\n              if(c < mines):\n                  state = prev_state\n              elif( c == mines):\n                  state_print(new_state)\n                  return True\n              else:\n                  if col == len(state[row]) -2:\n                      prev_state = deepcopy(state)\n                  state = new_state\n      print(\"Impossible\")\n      return False\n  \n  \n  \n  \n  def main():\n      filename = \"C-small-attempt0.in\"\n  \n  \n      inp = open(filename, \"rU\")\n  \n      n = int(inp.readline().strip())\n  \n      for case in range(1, n + 1):\n          R, C, M = map(int, inp.readline().strip().split(\" \"))\n          state = [[1 for x in range(C)] for y in range(R)]\n          print(\"Case #{}:\".format(case))\n          solve(state, M)\n  \n  main()\n ", "Adversarial Code": " \n  def check_bounds(state, coord):\n      if coord[0] < 0 or coord[1] < 0:\n          return False\n      elif coord[0] > (len(state) - 1):\n          return False\n      elif coord[1] > (len(state[coord[0]]) - 1):\n          return False\n      else:\n          return True\n  \n  def clear(state, coord):\n      for r in range(-1,2):\n          for c in range(-1,2):\n              row = coord[0] + r\n              col = coord[1] + c\n              if check_bounds(state, (row, col)):\n                  state[row][col] = 0\n  \n  def count(state):\n      return sum([sum(x) for x in state])\n  \n  def state_print(state):\n      print(\"c\" + \"\".join([\"*\"  if x else \".\" for x in state[0][1:]]))\n      for line in state[1:]:\n          print(\"\".join([\"*\"  if x else \".\" for x in line]))\n  \n  def solve(state, mines):\n      prev_state = deepcopy(state)\n      for row in range(len(state)):\n          for col in range(len(state[row])):\n              new_state = deepcopy(state)\n              clear(new_state, (row, col))\n              c = count(new_state)\n              if(c < mines):\n                  state = prev_state\n              elif( c == mines):\n                  state_print(new_state)\n                  return True\n              else:\n                  if col == len(state[row]) -2:\n                      prev_state = deepcopy(state)\n                  state = new_state\n      print(\"Impossible\")\n      return False\n  \n  \n  \n  \n  def process():\n      sf = \"C-small-attempt0.in\"\n  \n  \n      insl = open(sf, \"rU\")\n  \n      n = int(insl.readline().strip())\n  \n      for case in range(1, n + 1):\n          R, C, M = map(int, insl.readline().strip().split(\" \"))\n          state = [[1 for x in range(C)] for y in range(R)]\n          print(\"Case #{}:\".format(case))\n          solve(state, M)\n  \n  process()\n ", "Program Length": 438, "Identifier Num": 25, "Replaced Identifiers": "filename:sf,main:process,inp:insl,", "Query Times": 232, "Time Cost": 0.16119579076766968, "Type": "Greedy"}
{"Index": 91, "Original Code": " \n  filename = \"A-small-attempt0.in\"\n  \n  inp = open(filename, \"rU\")\n  \n  n = int(inp.readline().strip())\n  \n  for case in range(1, n+1):\n      gr = lambda x: [list(map(int, inp.readline().strip().split(\" \"))) for p in range(4)][x-1]\n      ans1 = int(inp.readline().strip())\n      row1 = set(gr(ans1))\n      ans2 = int(inp.readline().strip())\n      row2 = set(gr(ans2))\n      sect = row1 & row2\n      if len(sect) <= 0:\n          print(\"Case #{}: Volunteer cheated!\".format(case))\n      elif len(sect) == 1:\n          print(\"Case #{}: {}\".format(case, sect.pop()))\n      elif len(sect) > 1:\n          print(\"Case #{}: Bad magician!\".format(case))\n      else:\n          print(\"ERROR\")\n ", "Adversarial Code": " \n  SourceFile = \"A-small-attempt0.in\"\n  \n  insP = open(SourceFile, \"rU\")\n  \n  n = int(insP.readline().strip())\n  \n  for case in range(1, n+1):\n      gr = lambda x: [list(map(int, insP.readline().strip().split(\" \"))) for p in range(4)][x-1]\n      ans1 = int(insP.readline().strip())\n      row1 = set(gr(ans1))\n      ans2 = int(insP.readline().strip())\n      row2 = set(gr(ans2))\n      sect = row1 & row2\n      if len(sect) <= 0:\n          print(\"Case #{}: Volunteer cheated!\".format(case))\n      elif len(sect) == 1:\n          print(\"Case #{}: {}\".format(case, sect.pop()))\n      elif len(sect) > 1:\n          print(\"Case #{}: Bad magician!\".format(case))\n      else:\n          print(\"ERROR\")\n ", "Program Length": 192, "Identifier Num": 11, "Replaced Identifiers": "filename:SourceFile,inp:insP,", "Query Times": 136, "Time Cost": 0.09032876094182332, "Type": "Greedy"}
{"Index": 92, "Original Code": " \n  def transpose(result, R, C):\n  \tresultSplitted = result.split(\"\n\")\n  \taux = R*[\"\"]\n  \tfor i in xrange(R):\n  \t\tfor j in xrange(C):\n  \t\t    aux[i] += resultSplitted[j][i]\n  \t\taux[i] += \"\n\"\n  \tresult = \"\"\n  \tfor item in aux:\n  \t\tresult += item + \"\n\"\n  \treturn result.strip()\n  \n  \n  inputFileName = sys.argv[1]\n  \n  f = file(inputFileName)\n  fout = file(\"output.txt\", \"w\")\n  \n  T = int(f.readline())\n  \n  for case in xrange(T):\n  \tdata = f.readline().strip().split(\" \")\n  \tR = int(data[0])\n  \tC = int(data[1])\n  \tM = int(data[2])\n  \n  \tresult = \"\"\n  \n  \tx = min(R,C)\n  \ty = max(R,C)\n  \n  \tif M > (y - 2)*x and M != y*x - 1:\n  \t\tN = M - (y-2)*x\n  \t\tif N%2 == 1 or y*x - M == 2:\n  \t\t\tresult = \"Impossible\"\n  \tif result != \"Impossible\":\n  \t\ti = 0\n  \t\twhile M > 0: # 2\n  \t\t\tif i < y - 2:\n  \t\t\t\tif M >= x:\n  \t\t\t\t\tresult += x*\"*\" + \"\n\"\n  \t\t\t\t\tM -= x\n  \t\t\t\t\ti += 1\n  \t\t\t\telif M <= x - 2:\n  \t\t\t\t\tresult += M*\"*\" + (x - M) * \".\" + \"\n\"\n  \t\t\t\t\tM = 0\n  \t\t\t\t\ti += 1\n  \t\t\t\telif i + 2 < y - 1:\n  \t\t\t\t\tresult += (M-1)*\"*\" + (x - M + 1) * \".\" + \"\n\" + \"*\" + (x-1)*\".\" + \"\n\"\n  \t\t\t\t\tM = 0\n  \t\t\t\t\ti += 2\n  \t\t\t\telse:\n  \t\t\t\t\tresult = \"Impossible\"\n  \t\t\t\t\tbreak\n  \t\t\telse:\n  \t\t\t\tif M%2 != 0:\n  \t\t\t\t\tresult += x*\"*\" + \"\n\"\n  \t\t\t\t\tresult += (x-1)*\"*\" + \"c\"\n  \t\t\t\telse:\n  \t\t\t\t\tn = M/2\n  \t\t\t\t\tresult += n*\"*\" + (x-n)*\".\" + \"\n\"\n  \t\t\t\t\tresult += n*\"*\" + (x-n-1)*\".\" + \"c\"\n  \t\t\t\tM = 0\n  \t\t\t\ti += 2\n  \t\t\t\t\t\n  \t\twhile i <= y - 1 and result != \"Impossible\":\n  \t\t\tif i == y - 1:\n  \t\t\t\tresult += (x-1)*\".\" + \"c\"\n  \t\t\telse:\n  \t\t\t\tresult += x*\".\" + \"\n\"\n  \t\t\ti += 1\n  \t\n  \tif R < C and result != \"Impossible\":\n  \t\tresult = transpose(result, R, C)\n  \n  \tfout.write(\"Case #%d:\n%s\n\" %(case + 1, result))\n ", "Adversarial Code": " \n  def transpose(result, R, CE):\n  \tresultBreitched = result.split(\"\n\")\n  \t auxiliary = R*[\"\"]\n  \tfor i in xrange(R):\n  \t\tfor o in xrange(CE):\n  \t\t     auxiliary[i] += resultBreitched[o][i]\n  \t\t auxiliary[i] += \"\n\"\n  \tresult = \"\"\n  \tfor string in  auxiliary:\n  \t\tresult += string + \"\n\"\n  \treturn result.strip()\n  \n  \n   inputFileUrl = sys.argv[1]\n  \n  fn = file( inputFileUrl)\n   fint = file(\"output.txt\", \"w\")\n  \n  Time = int(fn.readline())\n  \n  for test in xrange(Time):\n  \tnumber = fn.readline().strip().split(\" \")\n  \tR = int(number[0])\n  \tCE = int(number[1])\n  \tM = int(number[2])\n  \n  \tresult = \"\"\n  \n  \tx = min(R,CE)\n  \ty = max(R,CE)\n  \n  \tif M > (y - 2)*x and M != y*x - 1:\n  \t\tNum = M - (y-2)*x\n  \t\tif Num%2 == 1 or y*x - M == 2:\n  \t\t\tresult = \"Impossible\"\n  \tif result != \"Impossible\":\n  \t\ti = 0\n  \t\twhile M > 0: # 2\n  \t\t\tif i < y - 2:\n  \t\t\t\tif M >= x:\n  \t\t\t\t\tresult += x*\"*\" + \"\n\"\n  \t\t\t\t\tM -= x\n  \t\t\t\t\ti += 1\n  \t\t\t\telif M <= x - 2:\n  \t\t\t\t\tresult += M*\"*\" + (x - M) * \".\" + \"\n\"\n  \t\t\t\t\tM = 0\n  \t\t\t\t\ti += 1\n  \t\t\t\telif i + 2 < y - 1:\n  \t\t\t\t\tresult += (M-1)*\"*\" + (x - M + 1) * \".\" + \"\n\" + \"*\" + (x-1)*\".\" + \"\n\"\n  \t\t\t\t\tM = 0\n  \t\t\t\t\ti += 2\n  \t\t\t\telse:\n  \t\t\t\t\tresult = \"Impossible\"\n  \t\t\t\t\tbreak\n  \t\t\telse:\n  \t\t\t\tif M%2 != 0:\n  \t\t\t\t\tresult += x*\"*\" + \"\n\"\n  \t\t\t\t\tresult += (x-1)*\"*\" + \"c\"\n  \t\t\t\telse:\n  \t\t\t\t\tn = M/2\n  \t\t\t\t\tresult += n*\"*\" + (x-n)*\".\" + \"\n\"\n  \t\t\t\t\tresult += n*\"*\" + (x-n-1)*\".\" + \"c\"\n  \t\t\t\tM = 0\n  \t\t\t\ti += 2\n  \t\t\t\t\t\n  \t\twhile i <= y - 1 and result != \"Impossible\":\n  \t\t\tif i == y - 1:\n  \t\t\t\tresult += (x-1)*\".\" + \"c\"\n  \t\t\telse:\n  \t\t\t\tresult += x*\".\" + \"\n\"\n  \t\t\ti += 1\n  \t\n  \tif R < CE and result != \"Impossible\":\n  \t\tresult = transpose(result, R, CE)\n  \n  \t fint.write(\"Case #%d:\n%s\n\" %(test + 1, result))\n ", "Program Length": 498, "Identifier Num": 20, "Replaced Identifiers": "inputFileName: inputFileUrl,fout: fint,resultSplitted:resultBreitched,f:fn,case:test,T:Time,data:number,N:Num,j:o,item:string,n:n,aux: auxiliary,transpose:transpose,C:CE,", "Query Times": 647, "Time Cost": 0.35961357355117796, "Type": "Greedy"}
{"Index": 93, "Original Code": " \n  inputFileName = sys.argv[1]\n  \n  f = file(inputFileName)\n  fout = file(\"output.txt\", \"w\")\n  \n  T = eval(f.readline())\n  \n  for case in xrange(T):\n  \n  \tA1 = int(f.readline().strip())\n  \n  \tfor i in xrange(4):\n  \t\tif i == A1 - 1:\n  \t\t\tpossibles1 = f.readline().strip().split(\" \")\n  \t\telse:\n  \t\t\tf.readline().strip().split(\" \")\n  \n  \tA2 = int(f.readline().strip())\n  \n  \tfor i in xrange(4):\n  \t\tif i == A2 - 1:\n  \t\t\tpossibles2 = f.readline().strip().split(\" \")\n  \t\telse:\n  \t\t\tf.readline().strip().split(\" \")\n  \n  \tfinal = []\n  \tfor item in possibles2:\n  \t\tif item in possibles1:\n  \t\t\tfinal.append(item)\n  \n  \tif len(final) == 0:\t\n  \t\tfout.write(\"Case #%d: Volunteer cheated!\n\" %(case + 1))\n  \telif len(final) == 1:\n  \t\tfout.write(\"Case #%d: %s\n\" %(case + 1, final[0]))\n  \telse:\n  \t\tfout.write(\"Case #%d: Bad magician!\n\" %(case + 1))\n ", "Adversarial Code": " \n  outputFileLocation = sys.argv[1]\n  \n  r = file(outputFileLocation)\n  fout = file(\"output.txt\", \"w\")\n  \n  L = eval(r.readline())\n  \n  for case in xrange(L):\n  \n  \tA1 = int(r.readline().strip())\n  \n  \tfor i in xrange(4):\n  \t\tif i == A1 - 1:\n  \t\t\tpossibles1 = r.readline().strip().split(\" \")\n  \t\telse:\n  \t\t\tr.readline().strip().split(\" \")\n  \n  \tA2 = int(r.readline().strip())\n  \n  \tfor i in xrange(4):\n  \t\tif i == A2 - 1:\n  \t\t\tpossibles2 = r.readline().strip().split(\" \")\n  \t\telse:\n  \t\t\tr.readline().strip().split(\" \")\n  \n  \tfinal = []\n  \tfor item in possibles2:\n  \t\tif item in possibles1:\n  \t\t\tfinal.append(item)\n  \n  \tif len(final) == 0:\t\n  \t\tfout.write(\"Case #%d: Volunteer cheated!\n\" %(case + 1))\n  \telif len(final) == 1:\n  \t\tfout.write(\"Case #%d: %s\n\" %(case + 1, final[0]))\n  \telse:\n  \t\tfout.write(\"Case #%d: Bad magician!\n\" %(case + 1))\n ", "Program Length": 248, "Identifier Num": 10, "Replaced Identifiers": "inputFileName:outputFileLocation,T:L,f:r,", "Query Times": 164, "Time Cost": 0.09387636582056681, "Type": "Greedy"}
{"Index": 94, "Original Code": " \n  \n  EOL = \"\n\"\n  \n  \n  def is_equal_approx(x, y, epsilon=1e-6):\n      \"\"\"Returns True iff y is within relative or absolute 'epsilon' of x.\n      \n      By default, 'epsilon' is 1e-6.\n      \"\"\"\n      if -epsilon <= x - y <= epsilon:\n          return True\n  \n      if -epsilon <= x <= epsilon or -epsilon <= y <= epsilon:\n          return False\n  \n      return (-epsilon <= (x - y) / x <= epsilon\n          or -epsilon <= (x - y) / y <= epsilon)\n    \n  def read_syms(fd):\n      \"\"\"Read a line of whitespace separated symbols.\"\"\"\n      return fd.readline().strip().split()\n  \n  def read_ints(fd):\n      \"\"\"Read a line of whitespace separated integers.\"\"\"\n      return [int(p) for p in read_syms(fd)]\n  \n  def read_floats(fd):\n      \"\"\"Read a line of whitespace separated floats.\"\"\"\n      return [float(p) for p in read_syms(fd)]\n  \n  \n  class Mtrx(object):\n      \"\"\"A matrix object.\"\"\"\n      \n      def __init__(self, rows, cols, data):\n          assert len(data) == rows * cols\n          self.rows = rows\n          self.cols = cols\n          self.data = data\n          \n      def cell(self, r, c):\n          return self.data[r * self.cols + c]\n      \n      def getrow(self, i):\n          return [self.cell(i, c) for c in xrange(self.cols)]\n  \n      def getcol(self, i):\n          return [self.cell(c, i) for c in xrange(self.rows)]\n      \n      @classmethod\n      def readfromfile(cls, fd, readfunc, rows=None, cols=None):\n          \"\"\"Read matrix from file, assuming first line at location is `R C`.\n          \n          Return a new Mtrx object. Reading values is performed by the `readfunc`.\n          Pre-determined size can be passed using `rows` and `cols`.\n          \"\"\"\n          data = []\n          if rows is None:\n              assert cols is None\n              rows, cols = read_ints(fd)\n          else:\n              assert cols is not None\n          for _ in range(rows):\n              line = readfunc(fd)\n              assert len(line) == cols\n              data.extend(line)\n          return Mtrx(rows, cols, data)\n              \n      @classmethod\n      def read_int_matrix(cls, fd, rows=None, cols=None):\n          return cls.readfromfile(fd, read_ints, rows, cols)\n              \n      @classmethod\n      def read_sym_matrix(cls, fd, rows=None, cols=None):\n          return cls.readfromfile(fd, read_syms, rows, cols)\n              \n      def __str__(self):\n          res = \"\"\n          for i in xrange(self.rows):\n              res += str(self.getrow(i)) + EOL\n          return res\n      \n      def __repr__(self):\n          return \"{}({}, {}, {})\".format(self.__class__.__name__, self.rows,\n                                         self.cols, self.data)\n  \n  \n  cachetotals = 0\n  cachemisses = 0\n  \n  def statreset():\n      global cachemisses, cachetotals\n      cachemisses = 0\n      cachetotals = 0\n  \n  class memoizeit(object):\n      \"\"\"Decorator. Caches a function's return value each time it is called.\n      \n      If called later with the same arguments, the cached value is returned \n      (not reevaluated).\n      \"\"\"\n      \n      def __init__(self, func):\n          self.func = func\n          self.cache = {}\n          \n      def __call__(self, *args):\n          \n          global cachetotals, cachemisses\n          cachetotals += 1\n          \n          try:\n              return self.cache[args]\n          except KeyError:\n              \n              cachemisses += 1\n              \n              value = self.func(*args)\n              self.cache[args] = value\n              return value\n          except TypeError:\n  \n              cachemisses += 1\n  \n              return self.func(*args)\n      \n      @property\n      def __name__(self):\n          return self.func.__name__\n      \n      def __get__(self, obj, objtype):\n          \"\"\"Support instance methods.\"\"\"\n          return functools.partial(self.__call__, obj)\n  \n  \n  class timeit(object):\n      \"\"\"Decorator that times a function.\n      \n      When function ends, print name, runtime, return value and cache stats.\n      \"\"\"\n      \n      def __init__(self, func):\n          self.func = func\n          \n      def __call__(self, *args):\n          start = time.time()\n          value = self.func(*args)\n          delta = time.time() - start\n          cachedata = (1 - cachemisses/(cachetotals * 1.0)) if \\\n              cachetotals else 0\n          print self.func.__name__, \"{:7.3f}s, (res: {}, cache: {:.2%})\".format(\n              delta, value, cachedata)\n          return value\n      \n      def __get__(self, obj, objtype):\n          return functools.partial(self.__call__, obj)\n  \n  \n  def read_input(filename):\n      data = []\n      with open(filename, \"r\") as f:\n          cases = read_ints(f)[0]\n          for _ in xrange(cases):\n              case = {}\n              case[\"R\"], case[\"C\"], case[\"M\"] = read_ints(f)\n              data.append(case)\n      return data\n  \n  def make_output(fname, output):\n      CASE_PRFX = \"Case #%s: \"\n      fname = fname + time.strftime(\"%H%M%S\") + \".out\"\n      with open(fname, \"w\") as f:\n          restext = []\n          print \"Output content ===============\"\n          for i, outdata in enumerate(output):\n              line = CASE_PRFX % (i + 1,) + EOL + str(outdata) + EOL\n              print line,\n              restext.append(line)\n          print \"=\" * 30\n          f.writelines(restext)\n  \n  \n  MINE = \"*\"\n  CLICK = \"c\"\n  UNK = \".\"\n  \n  class Board(object):\n      \n      def __init__(self, r, c):\n          self.rows = r\n          self.cols = c\n          self.edge_row_idx = self.rows - 1\n          self.edge_col_idx = self.cols - 1\n          self.board = [[UNK for _ in xrange(c)] for _ in xrange(r)]\n          self.board[0][0] = CLICK\n  \n      def fill_edge_row(self, m):\n          i = self.edge_col_idx\n          while m > 0 and i >= 0:\n              self.board[self.edge_row_idx][i] = MINE\n              i -= 1\n              m -= 1\n          self.edge_row_idx -= 1\n  \n      def fill_edge_col(self, m):\n          i = self.edge_row_idx\n          while m > 0 and i >= 0:\n              self.board[i][self.edge_col_idx] = MINE\n              i -= 1\n              m -= 1\n          self.edge_col_idx -= 1\n  \n      def __str__(self):\n          return EOL.join([\"\".join(r) for r in self.board])\n  \n  @memoizeit\n  def is_stage_solvable(rows, cols, mines):\n      \"\"\"Return True iff stage is solvable. \n      Also return fill instruction:\n      0 if impossible/dontcare, 1 to fill row, 2 to fill column, \n      3 for row special (most in the row), 4 for col special (most in the col)\n      \"\"\"\n      rc = rows * cols\n      \n      if mines == rc:\n          return False, 0\n  \n      if rows == 1:\n          return mines <= rc - 1, 2\n      if cols == 1:\n          return mines <= rc - 1, 1\n      \n      if mines == rc - 1:\n          return True, 1  # doesn't matter what to fill\n      \n      if mines > rc - 4:\n          return False, 0\n      \n      if rows == 2:\n          return (False, 0) if mines == 1 else (True, 2)\n      if cols == 2:\n          return (False, 0) if mines == 1 else (True, 1)\n          \n      if rows <= cols:\n          if mines >= rows:\n              return True, 2\n          if mines == rows - 1:\n              if mines == cols - 1:\n                  if rows == 3:\n                      return False, 0\n                  return True, 4 # L shape fill, most in the column\n              else:\n                  return True, 1 # fill row\n          return True, 2 \n      else:\n          if mines >= cols:\n              return True, 1\n          if mines == cols - 1:\n              if mines == rows - 1:\n                  if cols == 3:\n                      return False, 0\n                  return True, 3 # L shape fill, most in the row\n              else:\n                  return True, 2 # fill column\n          return True, 1 \n  \n  @timeit\n  def solveit(case):\n      rows = case[\"R\"]\n      cols = case[\"C\"]\n      mines = case[\"M\"]\n      \n      b = Board(rows, cols)\n      r, c, m = rows, cols, mines\n      \n      while m >= 0:\n          okgo, howtofill = is_stage_solvable(r, c, m)\n          if not okgo:\n              return \"Impossible\"\n          if howtofill == 1: # fill row\n              b.fill_edge_row(m)\n              if m <= c:\n                  break # fill and done\n              m -= c\n              r -= 1\n          elif howtofill == 2: # fill column\n              b.fill_edge_col(m)\n              if m <= r:\n                  break # fill and done\n              m -= r\n              c -= 1\n          elif howtofill == 3: # L shape fill, most in the row\n              b.fill_edge_row(m - 1)\n              b.fill_edge_col(1)\n              break # fill and done\n          elif howtofill == 4: # L shape fill, most in the column\n              b.fill_edge_col(m - 1)\n              b.fill_edge_row(1)\n              break # fill and done\n          else:\n              assert False\n  \n      return str(b) \n  \n  \n  \n  @timeit\n  def main(fname):\n      data = read_input(fname)\n      output = []\n      for case in data:\n          statreset() # reset cache stats\n          res = solveit(case)\n          output.append(res)\n      make_output(fname, output)\n  \n  \n  if __name__ == '__main__':\n      main(\"C-small-attempt0.in\")\n ", "Adversarial Code": " \n  \n   EOF = \"\n\"\n  \n  \n  def is_equal_approx(X, y, epsilon=1e-6):\n      \"\"\"Returns True iff y is within relative or absolute 'epsilon' of x.\n      \n      By default, 'epsilon' is 1e-6.\n      \"\"\"\n      if -epsilon <= X - y <= epsilon:\n          return True\n  \n      if -epsilon <= X <= epsilon or -epsilon <= y <= epsilon:\n          return False\n  \n      return (-epsilon <= (X - y) / X <= epsilon\n          or -epsilon <= (X - y) / y <= epsilon)\n    \n  def read_syms(file):\n      \"\"\"Read a line of whitespace separated symbols.\"\"\"\n      return file.readline().strip().split()\n  \n  def read_ints(file):\n      \"\"\"Read a line of whitespace separated integers.\"\"\"\n      return [int(vp) for vp in read_syms(file)]\n  \n  def read_floats(file):\n      \"\"\"Read a line of whitespace separated floats.\"\"\"\n      return [float(vp) for vp in read_syms(file)]\n  \n  \n  class Mtrx(object):\n      \"\"\"A matrix object.\"\"\"\n      \n      def __init__(github, tests, colli, raw):\n          assert len(raw) == tests * colli\n          github.tests = tests\n          github.colli = colli\n          github.raw = raw\n          \n      def grid(github, rb, fc):\n          return github.raw[rb * github.colli + fc]\n      \n      def getrow(github, lc):\n          return [github.grid(lc, fc) for fc in xrange(github.colli)]\n  \n      def getcol(github, lc):\n          return [github.grid(fc, lc) for fc in xrange(github.tests)]\n      \n      @classmethod\n      def readfromfile(cls, file, readfunc, tests=None, colli=None):\n          \"\"\"Read matrix from file, assuming first line at location is `R C`.\n          \n          Return a new Mtrx object. Reading values is performed by the `readfunc`.\n          Pre-determined size can be passed using `rows` and `cols`.\n          \"\"\"\n          raw = []\n          if tests is None:\n              assert colli is None\n              tests, colli = read_ints(file)\n          else:\n              assert colli is not None\n          for _ in range(tests):\n              line = readfunc(file)\n              assert len(line) == colli\n              raw.extend(line)\n          return Mtrx(tests, colli, raw)\n              \n      @classmethod\n      def read_int_matrix(cls, file, tests=None, colli=None):\n          return cls.readfromfile(file, read_ints, tests, colli)\n              \n      @classmethod\n      def read_sym_matrix(cls, file, tests=None, colli=None):\n          return cls.readfromfile(file, read_syms, tests, colli)\n              \n      def __str__(github):\n          res = \"\"\n          for lc in xrange(github.tests):\n              res += str(github.getrow(lc)) +  EOF\n          return res\n      \n      def __repr__(github):\n          return \"{}({}, {}, {})\".format(github.__class__.__name__, github.tests,\n                                         github.colli, github.raw)\n  \n  \n  cachetotals = 0\n  cachemisses = 0\n  \n  def statreset():\n      global cachemisses, cachetotals\n      cachemisses = 0\n      cachetotals = 0\n  \n  class memoizeit(object):\n      \"\"\"Decorator. Caches a function's return value each time it is called.\n      \n      If called later with the same arguments, the cached value is returned \n      (not reevaluated).\n      \"\"\"\n      \n      def __init__(github, func):\n          github.func = func\n          github.cache = {}\n          \n      def __call__(github, *args):\n          \n          global cachetotals, cachemisses\n          cachetotals += 1\n          \n          try:\n              return github.cache[args]\n          except KeyError:\n              \n              cachemisses += 1\n              \n              value = github.func(*args)\n              github.cache[args] = value\n              return value\n          except TypeError:\n  \n              cachemisses += 1\n  \n              return github.func(*args)\n      \n      @property\n      def __name__(github):\n          return github.func.__name__\n      \n      def __get__(github, obj, objtype):\n          \"\"\"Support instance methods.\"\"\"\n          return functools.partial(github.__call__, obj)\n  \n  \n  class timeit(object):\n      \"\"\"Decorator that times a function.\n      \n      When function ends, print name, runtime, return value and cache stats.\n      \"\"\"\n      \n      def __init__(github, func):\n          github.func = func\n          \n      def __call__(github, *args):\n          start = time.time()\n          value = github.func(*args)\n          delta = time.time() - start\n          cachedata = (1 - cachemisses/(cachetotals * 1.0)) if \\\n              cachetotals else 0\n          print github.func.__name__, \"{:7.3f}s, (res: {}, cache: {:.2%})\".format(\n              delta, value, cachedata)\n          return value\n      \n      def __get__(github, obj, objtype):\n          return functools.partial(github.__call__, obj)\n  \n  \n  def read_input(filename):\n      raw = []\n      with open(filename, \"r\") as f:\n          cases = read_ints(f)[0]\n          for _ in xrange(cases):\n              case = {}\n              case[\"R\"], case[\"C\"], case[\"M\"] = read_ints(f)\n              raw.append(case)\n      return raw\n  \n  def make_output(fname, output):\n      CASE_PRFX = \"Case #%s: \"\n      fname = fname + time.strftime(\"%H%M%S\") + \".out\"\n      with open(fname, \"w\") as f:\n          restext = []\n          print \"Output content ===============\"\n          for lc, outdata in enumerate(output):\n              line = CASE_PRFX % (lc + 1,) +  EOF + str(outdata) +  EOF\n              print line,\n              restext.append(line)\n          print \"=\" * 30\n          f.writelines(restext)\n  \n  \n  MINE = \"*\"\n  CLICK = \"c\"\n  UNK = \".\"\n  \n  class Board(object):\n      \n      def __init__(github, rb, fc):\n          github.tests = rb\n          github.colli = fc\n          github.edge_row_idx = github.tests - 1\n          github.edge_col_idx = github.colli - 1\n          github.board = [[UNK for _ in xrange(fc)] for _ in xrange(rb)]\n          github.board[0][0] = CLICK\n  \n      def fill_edge_row(github, m):\n          lc = github.edge_col_idx\n          while m > 0 and lc >= 0:\n              github.board[github.edge_row_idx][lc] = MINE\n              lc -= 1\n              m -= 1\n          github.edge_row_idx -= 1\n  \n      def fill_edge_col(github, m):\n          lc = github.edge_row_idx\n          while m > 0 and lc >= 0:\n              github.board[lc][github.edge_col_idx] = MINE\n              lc -= 1\n              m -= 1\n          github.edge_col_idx -= 1\n  \n      def __str__(github):\n          return  EOF.join([\"\".join(rb) for rb in github.board])\n  \n  @memoizeit\n  def is_stage_solvable(tests, colli, mines):\n      \"\"\"Return True iff stage is solvable. \n      Also return fill instruction:\n      0 if impossible/dontcare, 1 to fill row, 2 to fill column, \n      3 for row special (most in the row), 4 for col special (most in the col)\n      \"\"\"\n      rc = tests * colli\n      \n      if mines == rc:\n          return False, 0\n  \n      if tests == 1:\n          return mines <= rc - 1, 2\n      if colli == 1:\n          return mines <= rc - 1, 1\n      \n      if mines == rc - 1:\n          return True, 1  # doesn't matter what to fill\n      \n      if mines > rc - 4:\n          return False, 0\n      \n      if tests == 2:\n          return (False, 0) if mines == 1 else (True, 2)\n      if colli == 2:\n          return (False, 0) if mines == 1 else (True, 1)\n          \n      if tests <= colli:\n          if mines >= tests:\n              return True, 2\n          if mines == tests - 1:\n              if mines == colli - 1:\n                  if tests == 3:\n                      return False, 0\n                  return True, 4 # L shape fill, most in the column\n              else:\n                  return True, 1 # fill row\n          return True, 2 \n      else:\n          if mines >= colli:\n              return True, 1\n          if mines == colli - 1:\n              if mines == tests - 1:\n                  if colli == 3:\n                      return False, 0\n                  return True, 3 # L shape fill, most in the row\n              else:\n                  return True, 2 # fill column\n          return True, 1 \n  \n  @timeit\n  def solveit(case):\n      tests = case[\"R\"]\n      colli = case[\"C\"]\n      mines = case[\"M\"]\n      \n      b = Board(tests, colli)\n      rb, fc, m = tests, colli, mines\n      \n      while m >= 0:\n          okgo, howtofill = is_stage_solvable(rb, fc, m)\n          if not okgo:\n              return \"Impossible\"\n          if howtofill == 1: # fill row\n              b.fill_edge_row(m)\n              if m <= fc:\n                  break # fill and done\n              m -= fc\n              rb -= 1\n          elif howtofill == 2: # fill column\n              b.fill_edge_col(m)\n              if m <= rb:\n                  break # fill and done\n              m -= rb\n              fc -= 1\n          elif howtofill == 3: # L shape fill, most in the row\n              b.fill_edge_row(m - 1)\n              b.fill_edge_col(1)\n              break # fill and done\n          elif howtofill == 4: # L shape fill, most in the column\n              b.fill_edge_col(m - 1)\n              b.fill_edge_row(1)\n              break # fill and done\n          else:\n              assert False\n  \n      return str(b) \n  \n  \n  \n  @timeit\n  def main(fname):\n      raw = read_input(fname)\n      output = []\n      for case in raw:\n          statreset() # reset cache stats\n          res = solveit(case)\n          output.append(res)\n      make_output(fname, output)\n  \n  \n  if __name__ == '__main__':\n      main(\"C-small-attempt0.in\")\n ", "Program Length": 1508, "Identifier Num": 28, "Replaced Identifiers": "cols:colli,cls:cls,data:raw,rows:tests,cell:grid,i:lc,fd:file,p:vp,r:rb,c:fc,_:_,line:line,EOL: EOF,x:X,self:github,", "Query Times": 1024, "Time Cost": 0.9068735043207804, "Type": "Greedy"}
{"Index": 95, "Original Code": " \n  \n  EOL = \"\n\"\n  \n  \n  def is_equal_approx(x, y, epsilon=1e-6):\n      \"\"\"Returns True iff y is within relative or absolute 'epsilon' of x.\n      \n      By default, 'epsilon' is 1e-6.\n      \"\"\"\n      if -epsilon <= x - y <= epsilon:\n          return True\n  \n      if -epsilon <= x <= epsilon or -epsilon <= y <= epsilon:\n          return False\n  \n      return (-epsilon <= (x - y) / x <= epsilon\n          or -epsilon <= (x - y) / y <= epsilon)\n    \n  def read_syms(fd):\n      \"\"\"Read a line of whitespace separated symbols.\"\"\"\n      return fd.readline().strip().split()\n  \n  def read_ints(fd):\n      \"\"\"Read a line of whitespace separated integers.\"\"\"\n      return [int(p) for p in read_syms(fd)]\n  \n  def read_floats(fd):\n      \"\"\"Read a line of whitespace separated floats.\"\"\"\n      return [float(p) for p in read_syms(fd)]\n  \n  class Mtrx(object):\n      \"\"\"A matrix object.\"\"\"\n      \n      def __init__(self, rows, cols, data):\n          assert len(data) == rows * cols\n          self.rows = rows\n          self.cols = cols\n          self.data = data\n          \n      def cell(self, r, c):\n          return self.data[r * self.cols + c]\n      \n      def getrow(self, i):\n          return [self.cell(i, c) for c in xrange(self.cols)]\n  \n      def getcol(self, i):\n          return [self.cell(c, i) for c in xrange(self.rows)]\n      \n      @classmethod\n      def readfromfile(cls, fd, readfunc, rows=None, cols=None):\n          \"\"\"Read matrix from file, assuming first line at location is `R C`.\n          \n          Return a new Mtrx object. Reading values is performed by the `readfunc`.\n          Pre-determined size can be passed using `rows` and `cols`.\n          \"\"\"\n          data = []\n          if rows is None:\n              assert cols is None\n              rows, cols = read_ints(fd)\n          else:\n              assert cols is not None\n          for _ in range(rows):\n              line = readfunc(fd)\n              assert len(line) == cols\n              data.extend(line)\n          return Mtrx(rows, cols, data)\n              \n      @classmethod\n      def read_int_matrix(cls, fd, rows=None, cols=None):\n          return cls.readfromfile(fd, read_ints, rows, cols)\n              \n      @classmethod\n      def read_sym_matrix(cls, fd, rows=None, cols=None):\n          return cls.readfromfile(fd, read_syms, rows, cols)\n              \n      def __str__(self):\n          res = \"\"\n          for i in xrange(self.rows):\n              res += str(self.getrow(i)) + EOL\n          return res\n      \n      def __repr__(self):\n          return \"{}({}, {}, {})\".format(self.__class__.__name__, self.rows,\n                                         self.cols, self.data)\n  \n               \n  cachetotals = 0\n  cachemisses = 0\n  \n  def statreset():\n      global cachemisses, cachetotals\n      cachemisses = 0\n      cachetotals = 0\n  \n  class memoizeit(object):\n      \"\"\"Decorator. Caches a function's return value each time it is called.\n      \n      If called later with the same arguments, the cached value is returned \n      (not reevaluated).\n      \"\"\"\n      \n      def __init__(self, func):\n          self.func = func\n          self.cache = {}\n          \n      def __call__(self, *args):\n          \n          global cachetotals, cachemisses\n          cachetotals += 1\n          \n          try:\n              return self.cache[args]\n          except KeyError:\n              \n              cachemisses += 1\n              \n              value = self.func(*args)\n              self.cache[args] = value\n              return value\n          except TypeError:\n  \n              cachemisses += 1\n  \n              return self.func(*args)\n      \n      @property\n      def __name__(self):\n          return self.func.__name__\n      \n      def __get__(self, obj, objtype):\n          \"\"\"Support instance methods.\"\"\"\n          return functools.partial(self.__call__, obj)\n  \n  class timeit(object):\n      \"\"\"Decorator that times a function.\n      \n      When function ends, print name, runtime, return value and cache stats.\n      \"\"\"\n      \n      def __init__(self, func):\n          self.func = func\n          \n      def __call__(self, *args):\n          start = time.time()\n          value = self.func(*args)\n          delta = time.time() - start\n          cachedata = (1 - cachemisses/(cachetotals * 1.0)) if \\\n              cachetotals else 0\n          print self.func.__name__, \"{:7.3f}s, (res: {}, cache: {:.2%})\".format(\n              delta, value, cachedata)\n          return value\n      \n      def __get__(self, obj, objtype):\n          return functools.partial(self.__call__, obj)\n  \n ", "Adversarial Code": " \n  \n   EOF = \"\n\"\n  \n  \n  def is_equal_approx(X, y, epsilon=1e-6):\n      \"\"\"Returns True iff y is within relative or absolute 'epsilon' of x.\n      \n      By default, 'epsilon' is 1e-6.\n      \"\"\"\n      if -epsilon <= X - y <= epsilon:\n          return True\n  \n      if -epsilon <= X <= epsilon or -epsilon <= y <= epsilon:\n          return False\n  \n      return (-epsilon <= (X - y) / X <= epsilon\n          or -epsilon <= (X - y) / y <= epsilon)\n    \n  def read_syms(file):\n      \"\"\"Read a line of whitespace separated symbols.\"\"\"\n      return file.readline().strip().split()\n  \n  def read_ints(file):\n      \"\"\"Read a line of whitespace separated integers.\"\"\"\n      return [int(pa) for pa in read_syms(file)]\n  \n  def read_floats(file):\n      \"\"\"Read a line of whitespace separated floats.\"\"\"\n      return [float(pa) for pa in read_syms(file)]\n  \n  class Mtrx(object):\n      \"\"\"A matrix object.\"\"\"\n      \n      def __init__(worker, files, Colows, feed):\n          assert len(feed) == files * Colows\n          worker.files = files\n          worker.Colows = Colows\n          worker.feed = feed\n          \n      def character(worker, rh, ac):\n          return worker.feed[rh * worker.Colows + ac]\n      \n      def getrow(worker, f):\n          return [worker.character(f, ac) for ac in xrange(worker.Colows)]\n  \n      def getcol(worker, f):\n          return [worker.character(ac, f) for ac in xrange(worker.files)]\n      \n      @classmethod\n      def readfromfile(Cls, file, readfunc, files=None, Colows=None):\n          \"\"\"Read matrix from file, assuming first line at location is `R C`.\n          \n          Return a new Mtrx object. Reading values is performed by the `readfunc`.\n          Pre-determined size can be passed using `rows` and `cols`.\n          \"\"\"\n          feed = []\n          if files is None:\n              assert Colows is None\n              files, Colows = read_ints(file)\n          else:\n              assert Colows is not None\n          for _ in range(files):\n              line = readfunc(file)\n              assert len(line) == Colows\n              feed.extend(line)\n          return Mtrx(files, Colows, feed)\n              \n      @classmethod\n      def read_int_matrix(Cls, file, files=None, Colows=None):\n          return Cls.readfromfile(file, read_ints, files, Colows)\n              \n      @classmethod\n      def read_sym_matrix(Cls, file, files=None, Colows=None):\n          return Cls.readfromfile(file, read_syms, files, Colows)\n              \n      def __str__(worker):\n          res = \"\"\n          for f in xrange(worker.files):\n              res += str(worker.getrow(f)) +  EOF\n          return res\n      \n      def __repr__(worker):\n          return \"{}({}, {}, {})\".format(worker.__class__.__name__, worker.files,\n                                         worker.Colows, worker.feed)\n  \n               \n  cachetotals = 0\n  cachemisses = 0\n  \n  def statreset():\n      global cachemisses, cachetotals\n      cachemisses = 0\n      cachetotals = 0\n  \n  class memoizeit(object):\n      \"\"\"Decorator. Caches a function's return value each time it is called.\n      \n      If called later with the same arguments, the cached value is returned \n      (not reevaluated).\n      \"\"\"\n      \n      def __init__(worker, func):\n          worker.func = func\n          worker.cache = {}\n          \n      def __call__(worker, *args):\n          \n          global cachetotals, cachemisses\n          cachetotals += 1\n          \n          try:\n              return worker.cache[args]\n          except KeyError:\n              \n              cachemisses += 1\n              \n              value = worker.func(*args)\n              worker.cache[args] = value\n              return value\n          except TypeError:\n  \n              cachemisses += 1\n  \n              return worker.func(*args)\n      \n      @property\n      def __name__(worker):\n          return worker.func.__name__\n      \n      def __get__(worker, obj, objtype):\n          \"\"\"Support instance methods.\"\"\"\n          return functools.partial(worker.__call__, obj)\n  \n  class timeit(object):\n      \"\"\"Decorator that times a function.\n      \n      When function ends, print name, runtime, return value and cache stats.\n      \"\"\"\n      \n      def __init__(worker, func):\n          worker.func = func\n          \n      def __call__(worker, *args):\n          start = time.time()\n          value = worker.func(*args)\n          delta = time.time() - start\n          cachedata = (1 - cachemisses/(cachetotals * 1.0)) if \\\n              cachetotals else 0\n          print worker.func.__name__, \"{:7.3f}s, (res: {}, cache: {:.2%})\".format(\n              delta, value, cachedata)\n          return value\n      \n      def __get__(worker, obj, objtype):\n          return functools.partial(worker.__call__, obj)\n  \n ", "Program Length": 717, "Identifier Num": 28, "Replaced Identifiers": "cols:Colows,cls:Cls,data:feed,rows:files,cell:character,i:f,fd:file,p:pa,r:rh,c:ac,_:_,line:line,EOL: EOF,x:X,self:worker,", "Query Times": 947, "Time Cost": 0.5607112765312194, "Type": "Greedy"}
{"Index": 97, "Original Code": null, "Adversarial Code": null, "Program Length": 102, "Identifier Num": 7, "Replaced Identifiers": null, "Query Times": 279, "Time Cost": 0.10454883178075154, "Type": "0"}
{"Index": 98, "Original Code": " \n  \n  ncases = int(sys.stdin.readline().strip())\n  \n  def print_board(r, c, free):\n      board = {}\n      for row in range(0, r):\n          board[row] = {}\n          for col in range(0, c):\n              board[row][col] = '*'\n  \n      pending = free\n  \n      if free == 1:\n          board[0][0] = '.'\n      elif r == 1 or c == 1:\n          for row in range(0, r):\n              for col in range(0, c):\n                  if pending > 0:\n                      pending -= 1\n                      board[row][col] = '.'\n      else:\n          for row in range(0,2):\n              for col in range(0,2):\n                  board[row][col] = '.'\n          pending -= 4\n          col=2\n          row=2\n  \n          while pending >= 2 and (col<c or row<r):\n              if pending >= 2 and col<c:\n                  board[0][col] = '.'\n                  board[1][col] = '.'\n                  col += 1\n                  pending -= 2\n              if pending >= 2 and row<r:\n                  board[row][0] = '.'\n                  board[row][1] = '.'\n                  row += 1\n                  pending -= 2\n  \n          for row in range(2, r):\n              for col in range(2, c):\n                  if pending > 0:\n                      board[row][col] = '.'\n                      pending -= 1\n  \n      board[0][0] = 'c'\n  \n      for row in range(0, r):\n          line = ''\n          for col in range(0, c):\n              line += board[row][col]\n          print(line)\n  \n  \n  for t in range(1, ncases+1):\n      values = sys.stdin.readline().strip().split()\n      r = int(values[0])\n      c = int(values[1])\n      m = int(values[2])\n  \n      cells = r * c\n      free = cells - m\n  \n      possible = False\n  \n      if r == 1 or c == 1:\n          if free >= 1:\n              possible = True\n      elif r == 2 or c == 2:\n          if free == 1 or (free >= 4 and free%2 == 0):\n              possible = True\n      else:\n          if free == 1 or (free >= 4 and free != 5 and free != 7):\n              possible = True\n  \n      print(\"Case #{0}:\".format(t))\n  \n      if possible:\n          print_board(r, c, free)\n      else:\n          print(\"Impossible\")\n ", "Adversarial Code": " \n  \n  casts = int(sys.stdin.readline().strip())\n  \n  def print_board(r, c, free):\n      board = {}\n      for row in range(0, r):\n          board[row] = {}\n          for col in range(0, c):\n              board[row][col] = '*'\n  \n      pending = free\n  \n      if free == 1:\n          board[0][0] = '.'\n      elif r == 1 or c == 1:\n          for row in range(0, r):\n              for col in range(0, c):\n                  if pending > 0:\n                      pending -= 1\n                      board[row][col] = '.'\n      else:\n          for row in range(0,2):\n              for col in range(0,2):\n                  board[row][col] = '.'\n          pending -= 4\n          col=2\n          row=2\n  \n          while pending >= 2 and (col<c or row<r):\n              if pending >= 2 and col<c:\n                  board[0][col] = '.'\n                  board[1][col] = '.'\n                  col += 1\n                  pending -= 2\n              if pending >= 2 and row<r:\n                  board[row][0] = '.'\n                  board[row][1] = '.'\n                  row += 1\n                  pending -= 2\n  \n          for row in range(2, r):\n              for col in range(2, c):\n                  if pending > 0:\n                      board[row][col] = '.'\n                      pending -= 1\n  \n      board[0][0] = 'c'\n  \n      for row in range(0, r):\n          line = ''\n          for col in range(0, c):\n              line += board[row][col]\n          print(line)\n  \n  \n  for t in range(1, casts+1):\n      values = sys.stdin.readline().strip().split()\n      r = int(values[0])\n      c = int(values[1])\n      m = int(values[2])\n  \n      cells = r * c\n      free = cells - m\n  \n      possible = False\n  \n      if r == 1 or c == 1:\n          if free >= 1:\n              possible = True\n      elif r == 2 or c == 2:\n          if free == 1 or (free >= 4 and free%2 == 0):\n              possible = True\n      else:\n          if free == 1 or (free >= 4 and free != 5 and free != 7):\n              possible = True\n  \n      print(\"Case #{0}:\".format(t))\n  \n      if possible:\n          print_board(r, c, free)\n      else:\n          print(\"Impossible\")\n ", "Program Length": 497, "Identifier Num": 15, "Replaced Identifiers": "ncases:casts,", "Query Times": 146, "Time Cost": 0.05562965869903565, "Type": "Greedy"}
{"Index": 99, "Original Code": " \n  \n  ncases = int(sys.stdin.readline().strip())\n  \n  def read_arrangement():\n      arr = []\n      for row in range(0,4):\n          arr.append(sys.stdin.readline().strip().split(' '))\n      return arr\n  \n  for t in range(1, ncases+1):\n      answer1 = int(sys.stdin.readline().strip())\n      arrang1 = read_arrangement()\n      answer2 = int(sys.stdin.readline().strip())\n      arrang2 = read_arrangement()\n  \n      row1 = arrang1[answer1-1]\n      row2 = arrang2[answer2-1]\n  \n      intersect = set(row1) & set(row2)\n  \n      if len(intersect) == 1:\n          print(\"Case #{0}: {1}\".format(t, intersect.pop()))\n      elif len(intersect) == 0:\n          print(\"Case #{0}: Volunteer cheated!\".format(t))\n      else:\n          print(\"Case #{0}: Bad magician!\".format(t))\n ", "Adversarial Code": " \n  \n  necones = int(sys.stdin.readline().strip())\n  \n  def read_arrangement():\n      arr = []\n      for row in range(0,4):\n          arr.append(sys.stdin.readline().strip().split(' '))\n      return arr\n  \n  for t in range(1, necones+1):\n      answer1 = int(sys.stdin.readline().strip())\n      arrang1 = read_arrangement()\n      answer2 = int(sys.stdin.readline().strip())\n      arrang2 = read_arrangement()\n  \n      row1 = arrang1[answer1-1]\n      row2 = arrang2[answer2-1]\n  \n      intersect = set(row1) & set(row2)\n  \n      if len(intersect) == 1:\n          print(\"Case #{0}: {1}\".format(t, intersect.pop()))\n      elif len(intersect) == 0:\n          print(\"Case #{0}: Volunteer cheated!\".format(t))\n      else:\n          print(\"Case #{0}: Bad magician!\".format(t))\n ", "Program Length": 190, "Identifier Num": 12, "Replaced Identifiers": "ncases:necones,", "Query Times": 60, "Time Cost": 0.023125962416330973, "Type": "Greedy"}
{"Index": 100, "Original Code": " \n  def read_word(f):\n      return next(f).strip()\n  \n  def read_int(f, b=10):\n      return int(read_word(f), b)\n  \n  def read_letters(f):\n      return list(read_word(f))\n  \n  def read_digits(f, b=10):\n      return [int(x, b) for x in read_letters(f)]\n  \n  def read_words(f, d=' '):\n      return read_word(f).split(d)\n  \n  def read_ints(f, b=10, d=' '):\n      return [int(x, b) for x in read_words(f, d)]\n  \n  def read_floats(f, d=' '):\n      return [float(x) for x in read_words(f, d)]\n  \n  def read_arr(f, R, reader=read_ints, *args, **kwargs):\n      return [reader(f, *args, **kwargs) for i in range(R)]\n  \n  def solve(solver, fn, out_fn=None):\n      in_fn = fn + '.in'\n      if out_fn is None:\n          out_fn = fn + '.out'\n      with open(in_fn, 'r') as fi:\n          with open(out_fn, 'w') as fo:\n              T = read_int(fi)\n              for i in range(T):\n                  case = read_case(fi)\n                  res = solver(case)\n                  write_case(fo, i, res)\n  \n  \n  def read_case(f):\n      return read_ints(f)\n  \n  def write_case(f, i, res):\n      f.write('Case #%d: '%i)\n      if isinstance(res, list):\n          res[0][0] = 'c'\n          res = '\n'.join(''.join(c for c in r) for r in res)\n      f.write('\n%s'%res)\n      f.write('\n')\n  \n  \n  def solve_small(case):\n      (R, C, M) = case\n      if R == 1:\n          return 'c' + '.'*(C-M-1) + '*'*M\n      if C == 1:\n          return '\n'.join(['c'] + ['.']*(R-M-1) + ['*']*M)\n      m = R*C - M\n      res = [['*']*C for r in range(R)]\n      if m == 1:\n          return res\n      for r in range(2, R+1):\n          c = m // r\n          z = m % r\n          if c < 2 or c + (z>0) > C:\n              continue\n          if z == 1 and (r < 3 or c < 3):\n              continue\n          for x in range(r):\n              for y in range(c):\n                  res[x][y] = '.'\n          for y in range(z):\n              res[y][c] = '.'\n          if z == 1:\n              res[z][c] = '.'\n              res[r-1][c-1] = '*'\n          return res\n      return 'Impossible'\n  \n  def solve_large(case):\n      return solve_small(case)\n  \n  DEBUG = 'f'\n  \n ", "Adversarial Code": " \n  def readhletters(fen):\n      return next(fen).strip()\n  \n  def read_int(fen, b=10):\n      return int(readhletters(fen), b)\n  \n  def read_letters(fen):\n      return list(readhletters(fen))\n  \n  def read_digits(fen, b=10):\n      return [int(x, b) for x in read_letters(fen)]\n  \n  def  read_frames(fen, d=' '):\n      return readhletters(fen).split(d)\n  \n  def read67series(fen, b=10, d=' '):\n      return [int(x, b) for x in  read_frames(fen, d)]\n  \n  def read_floats(fen, d=' '):\n      return [float(x) for x in  read_frames(fen, d)]\n  \n  def read_lines(fen, R, reader=read67series, *args, **kwargs):\n      return [reader(fen, *args, **kwargs) for i in range(R)]\n  \n  def solve(solver, fn, out2file=None):\n      in_fn = fn + '.in'\n      if out2file is None:\n          out2file = fn + '.out'\n      with open(in_fn, 'r') as fi:\n          with open(out2file, 'w') as fo:\n              T = read_int(fi)\n              for i in range(T):\n                  case = read_case(fi)\n                  res = solver(case)\n                  write_case(fo, i, res)\n  \n  \n  def read_case(fen):\n      return read67series(fen)\n  \n  def write_case(fen, i, res):\n      fen.write('Case #%d: '%i)\n      if isinstance(res, list):\n          res[0][0] = 'c'\n          res = '\n'.join(''.join(c for c in r) for r in res)\n      fen.write('\n%s'%res)\n      fen.write('\n')\n  \n  \n  def solve_small(case):\n      (R, C, M) = case\n      if R == 1:\n          return 'c' + '.'*(C-M-1) + '*'*M\n      if C == 1:\n          return '\n'.join(['c'] + ['.']*(R-M-1) + ['*']*M)\n      m = R*C - M\n      res = [['*']*C for r in range(R)]\n      if m == 1:\n          return res\n      for r in range(2, R+1):\n          c = m // r\n          z = m % r\n          if c < 2 or c + (z>0) > C:\n              continue\n          if z == 1 and (r < 3 or c < 3):\n              continue\n          for x in range(r):\n              for y in range(c):\n                  res[x][y] = '.'\n          for y in range(z):\n              res[y][c] = '.'\n          if z == 1:\n              res[z][c] = '.'\n              res[r-1][c-1] = '*'\n          return res\n      return 'Impossible'\n  \n  def solve_large(case):\n      return solve_small(case)\n  \n  DEBUG = 'f'\n  \n ", "Program Length": 592, "Identifier Num": 30, "Replaced Identifiers": "read_arr:read_lines,read_ints:read67series,read_word:readhletters,out_fn:out2file,read_words: read_frames,f:fen,", "Query Times": 341, "Time Cost": 0.13757627010345458, "Type": "Greedy"}
{"Index": 101, "Original Code": " \n  def read_word(f):\n      return next(f).strip()\n  \n  def read_int(f, b=10):\n      return int(read_word(f), b)\n  \n  def read_letters(f):\n      return list(read_word(f))\n  \n  def read_digits(f, b=10):\n      return [int(x, b) for x in read_letters(f)]\n  \n  def read_words(f, d=' '):\n      return read_word(f).split(d)\n  \n  def read_ints(f, b=10, d=' '):\n      return [int(x, b) for x in read_words(f, d)]\n  \n  def read_floats(f, d=' '):\n      return [float(x) for x in read_words(f, d)]\n  \n  def read_arr(f, R, reader=read_ints, *args, **kwargs):\n      return [reader(f, *args, **kwargs) for i in range(R)]\n  \n  def solve(solver, fn, out_fn=None):\n      in_fn = fn + '.in'\n      if out_fn is None:\n          out_fn = fn + '.out'\n      with open(in_fn, 'r') as fi:\n          with open(out_fn, 'w') as fo:\n              T = read_int(fi)\n              for i in range(T):\n                  case = read_case(fi)\n                  res = solver(case)\n                  write_case(fo, i, res)\n  \n  \n  def read_case(f):\n      R1 = read_int(f)\n      Q1 = read_arr(f, 4)\n      R2 = read_int(f)\n      Q2 = read_arr(f, 4)\n      return (R1, Q1, R2, Q2)\n  \n  def write_case(f, i, res):\n      f.write('Case #%d: '%i)\n      f.write('%s'%res)\n      f.write('\n')\n  \n  \n  def solve_small(case):\n      (R1, Q1, R2, Q2) = case\n      s = set(Q1[R1-1]) & set(Q2[R2-1])\n      if len(s) == 0:\n          return 'Volunteer cheated!'\n      if len(s) == 1:\n          return s.pop()\n      return 'Bad magician!'\n  \n  def solve_large(case):\n      return solve_small(case)\n  \n  DEBUG = 'i'\n  \n ", "Adversarial Code": " \n  def readablestring(file):\n      return next(file).strip()\n  \n  def readabletext(file, b=10):\n      return int(readablestring(file), b)\n  \n  def read_letters(file):\n      return list(readablestring(file))\n  \n  def read_digits(file, b=10):\n      return [int(x, b) for x in read_letters(file)]\n  \n  def read_words(file, d=' '):\n      return readablestring(file).split(d)\n  \n  def read_ints(file, b=10, d=' '):\n      return [int(x, b) for x in read_words(file, d)]\n  \n  def read_floats(file, d=' '):\n      return [float(x) for x in read_words(file, d)]\n  \n  def readfcase(file, R, reader=read_ints, *args, **kwargs):\n      return [reader(file, *args, **kwargs) for i in range(R)]\n  \n  def solve(solver, fn, out_filename=None):\n      in_fn = fn + '.in'\n      if out_filename is None:\n          out_filename = fn + '.out'\n      with open(in_fn, 'r') as fi:\n          with open(out_filename, 'w') as fo:\n              T = readabletext(fi)\n              for i in range(T):\n                  case = read_case(fi)\n                  res = solver(case)\n                  write_case(fo, i, res)\n  \n  \n  def read_case(file):\n       ROne = readabletext(file)\n      Query4 = readfcase(file, 4)\n      r14 = readabletext(file)\n       Q_ = readfcase(file, 4)\n      return ( ROne, Query4, r14,  Q_)\n  \n  def write_case(file, i, res):\n      file.write('Case #%d: '%i)\n      file.write('%s'%res)\n      file.write('\n')\n  \n  \n  def solve_small(case):\n      ( ROne, Query4, r14,  Q_) = case\n      s = set(Query4[ ROne-1]) & set( Q_[r14-1])\n      if len(s) == 0:\n          return 'Volunteer cheated!'\n      if len(s) == 1:\n          return s.pop()\n      return 'Bad magician!'\n  \n  def solve_large(case):\n      return solve_small(case)\n  \n  DEBUG = 'i'\n  \n ", "Program Length": 426, "Identifier Num": 31, "Replaced Identifiers": "R1: ROne,Q2: Q_,Q1:Query4,R2:r14,read_int:readabletext,f:file,out_fn:out_filename,read_word:readablestring,read_arr:readfcase,", "Query Times": 519, "Time Cost": 0.20109103520711263, "Type": "Greedy"}
{"Index": 102, "Original Code": "__author__ = 'jrokicki'\n  \n  RL = lambda: sys.stdin.readline().strip()\n  IA = lambda: map(int, RL().split(\" \"))\n  LA = lambda: map(long, RL().split(\" \"))\n  FA = lambda: map(float, RL().split(\" \"))\n  \n  T = int(sys.stdin.readline())\n  \n  def clear(R,C,b, x, y):\n      b = b[:]\n      n = 0\n      for i in range(max(0,x-1), min(R,x+2)):\n          for j in range(max(0,y-1), min(C, y+2)):\n              if b[C*i+j] == '*':\n                  n += 1\n                  b = b[:C*i+j] + '.' + b[C*i+j+1:]\n      return b, n\n  mem = dict()\n  def pb(R,C,b):\n      for x in range(R):\n          print b[x*C:x*C+C]\n  \n  def board(R,C,b,x,y,M,m):\n      global mem\n      print x\n      key = (R,C,b,M,x,y,m)\n      if key in mem: return mem[key]\n      if x >= R or y >= C:\n          mem[key] = None\n      else:\n          lb = b\n          n = 0\n          good = False\n          for i in range(y,C):\n              nb,nn = clear(R,C, lb, x, i)\n              n += nn\n              if m - n - M == 0:\n                  mem[key] = nb\n                  good = True\n                  break\n              elif m - n - M < 0:\n                  break\n              lb = bb\n          mem[key] = board(R,C,bb,M,x+1,0,m-n)\n      return mem[key]\n  \n  for CASE in range(T):\n      R,C,M = IA()\n      IMPOSSIBLE = \"Impossible\"\n  \n      b = \"\"\n      cleared = R*C-M\n      for x in range(R):\n          b += \"*\" * C\n      if M == R*C-1:\n          b = \"c\" + b[1:]\n          answer = b\n      else:\n          good = False\n          x,y = 0,0\n          q = [(b,0,0,0)]\n          mem = {}\n          while not good and q:\n              board,total_cleared,x,y = q.pop(0)\n              if (board,total_cleared,x,y) in mem:\n                  continue\n              mem[(board,total_cleared,x,y)] = True\n              if x >= R: continue\n              if y >= C:\n                  q.append((last_board,total_cleared,x+1,0))\n                  continue\n              last_board = board\n              new_board, cleared_mines = clear(R,C,last_board,x,y)\n              total_cleared += cleared_mines\n  \n              if total_cleared == cleared:\n                  good = True\n                  last_board = new_board\n                  q = []\n                  break\n              elif total_cleared - cleared == -1:\n                  q.append((new_board,total_cleared,x,y+1))\n                  q.append((new_board,total_cleared,x+1,0))\n                  q.append((last_board,total_cleared-cleared_mines,x+1,0))\n              elif total_cleared > cleared:\n                  q.append((last_board,total_cleared-cleared_mines,x+1,0))\n              else:\n                  q.append((new_board,total_cleared,x,y+1))\n              last_board = new_board\n          if good:\n              answer = last_board\n          else:\n              answer = None\n      if not answer:\n          answer = \"Impossible\"\n      else:\n          b = \"\"\n          for x in range(R):\n              b += answer[x*C:x*C+C] + \"\n\"\n          answer = \"c\" + b[1:-1]\n      print \"Case #%d:\n%s\" % (CASE+1, answer)\n  \n ", "Adversarial Code": "__author__ = 'jrokicki'\n  \n  Ul = lambda: sys.stdin.readline().strip()\n  NI = lambda: map(int, Ul().split(\" \"))\n  LA = lambda: map(long, Ul().split(\" \"))\n  FA = lambda: map(float, Ul().split(\" \"))\n  \n  T = int(sys.stdin.readline())\n  \n  def clear(R,C,b, x, y):\n      b = b[:]\n      n = 0\n      for i in range(max(0,x-1), min(R,x+2)):\n          for j in range(max(0,y-1), min(C, y+2)):\n              if b[C*i+j] == '*':\n                  n += 1\n                  b = b[:C*i+j] + '.' + b[C*i+j+1:]\n      return b, n\n  mem = dict()\n  def pb(R,C,b):\n      for x in range(R):\n          print b[x*C:x*C+C]\n  \n  def board(R,C,b,x,y,M,m):\n      global mem\n      print x\n      key = (R,C,b,M,x,y,m)\n      if key in mem: return mem[key]\n      if x >= R or y >= C:\n          mem[key] = None\n      else:\n          lb = b\n          n = 0\n          good = False\n          for i in range(y,C):\n              nb,nn = clear(R,C, lb, x, i)\n              n += nn\n              if m - n - M == 0:\n                  mem[key] = nb\n                  good = True\n                  break\n              elif m - n - M < 0:\n                  break\n              lb = bb\n          mem[key] = board(R,C,bb,M,x+1,0,m-n)\n      return mem[key]\n  \n  for CASE in range(T):\n      R,C,M = NI()\n      IMPOSSIBLE = \"Impossible\"\n  \n      b = \"\"\n      cleared = R*C-M\n      for x in range(R):\n          b += \"*\" * C\n      if M == R*C-1:\n          b = \"c\" + b[1:]\n          answer = b\n      else:\n          good = False\n          x,y = 0,0\n          q = [(b,0,0,0)]\n          mem = {}\n          while not good and q:\n              board,total_cleared,x,y = q.pop(0)\n              if (board,total_cleared,x,y) in mem:\n                  continue\n              mem[(board,total_cleared,x,y)] = True\n              if x >= R: continue\n              if y >= C:\n                  q.append((last_board,total_cleared,x+1,0))\n                  continue\n              last_board = board\n              new_board, cleared_mines = clear(R,C,last_board,x,y)\n              total_cleared += cleared_mines\n  \n              if total_cleared == cleared:\n                  good = True\n                  last_board = new_board\n                  q = []\n                  break\n              elif total_cleared - cleared == -1:\n                  q.append((new_board,total_cleared,x,y+1))\n                  q.append((new_board,total_cleared,x+1,0))\n                  q.append((last_board,total_cleared-cleared_mines,x+1,0))\n              elif total_cleared > cleared:\n                  q.append((last_board,total_cleared-cleared_mines,x+1,0))\n              else:\n                  q.append((new_board,total_cleared,x,y+1))\n              last_board = new_board\n          if good:\n              answer = last_board\n          else:\n              answer = None\n      if not answer:\n          answer = \"Impossible\"\n      else:\n          b = \"\"\n          for x in range(R):\n              b += answer[x*C:x*C+C] + \"\n\"\n          answer = \"c\" + b[1:-1]\n      print \"Case #%d:\n%s\" % (CASE+1, answer)\n  \n ", "Program Length": 779, "Identifier Num": 30, "Replaced Identifiers": "RL:Ul,IA:NI,", "Query Times": 307, "Time Cost": 0.12172849973042806, "Type": "Greedy"}
{"Index": 103, "Original Code": "__author__ = 'jrokicki'\n  \n  RL = lambda: sys.stdin.readline().strip()\n  IA = lambda: map(int, RL().split(\" \"))\n  LA = lambda: map(long, RL().split(\" \"))\n  \n  T = int(sys.stdin.readline())\n  \n  for CASE in range(T):\n      g1 = IA()[0]-1\n      board1 = []\n      for i in range(4):\n          board1.append(IA())\n      g2 = IA()[0]-1\n      board2 = []\n      for i in range(4):\n          board2.append(IA())\n  \n      r1 = board1[g1]\n      r2 = board2[g2]\n  \n      answer = set(r1).intersection(r2)\n      if len(answer) > 1:\n          answer = \"Bad magician!\"\n      elif len(answer) == 0:\n          answer = \"Volunteer cheated!\"\n      else:\n          answer = list(answer)[0]\n  \n      print \"Case #%d: %s\" % (CASE+1, answer)\n  \n ", "Adversarial Code": "_title_ = 'jrokicki'\n  \n  RL = lambda: sys.stdin.readline().strip()\n  IA = lambda: map(int, RL().split(\" \"))\n  LU = lambda: map(long, RL().split(\" \"))\n  \n  T = int(sys.stdin.readline())\n  \n  for CASE in range(T):\n      g1 = IA()[0]-1\n      board1 = []\n      for i in range(4):\n          board1.append(IA())\n      g2 = IA()[0]-1\n      board2 = []\n      for i in range(4):\n          board2.append(IA())\n  \n      r1 = board1[g1]\n      r2 = board2[g2]\n  \n      r = set(r1).intersection(r2)\n      if len(r) > 1:\n          r = \"Bad magician!\"\n      elif len(r) == 0:\n          r = \"Volunteer cheated!\"\n      else:\n          r = list(r)[0]\n  \n      print \"Case #%d: %s\" % (CASE+1, r)\n  \n ", "Program Length": 198, "Identifier Num": 14, "Replaced Identifiers": "__author__:_title_,LA:LU,answer:r,", "Query Times": 167, "Time Cost": 0.05976422230402629, "Type": "Greedy"}
{"Index": 105, "Original Code": "def solve_case(t):\n      interested_row = int(raw_input().strip())\n      i = 1\n      while i <= 4:\n          row = raw_input()\n          if i == interested_row:\n              first_set = set(row.strip().split())\n          i += 1\n      interested_row = int(raw_input().strip())\n      i = 1\n      while i <= 4:\n          row = raw_input()\n          if i == interested_row:\n              second_set = set(row.strip().split())\n          i += 1\n      ans_set = first_set & second_set\n      if len(ans_set) == 1:\n          print 'Case #%d: %s' % (t, ans_set.pop(),)\n      elif len(ans_set) > 1:\n          print 'Case #%d: Bad magician!' % (t,)\n      else:\n          print 'Case #%d: Volunteer cheated!' % (t,)\n  \n  def main():\n      t = int(raw_input().strip())\n      for i in range(1, t + 1):\n          solve_case(i)\n  \n  if __name__ == '__main__':\n      main()\n ", "Adversarial Code": "def solve_case(ut):\n      interested_row = int(raw_input().strip())\n      i = 1\n      while i <= 4:\n          row = raw_input()\n          if i == interested_row:\n              first_set = set(row.strip().split())\n          i += 1\n      interested_row = int(raw_input().strip())\n      i = 1\n      while i <= 4:\n          row = raw_input()\n          if i == interested_row:\n              second_set = set(row.strip().split())\n          i += 1\n      ans_set = first_set & second_set\n      if len(ans_set) == 1:\n          print 'Case #%d: %s' % (ut, ans_set.pop(),)\n      elif len(ans_set) > 1:\n          print 'Case #%d: Bad magician!' % (ut,)\n      else:\n          print 'Case #%d: Volunteer cheated!' % (ut,)\n  \n  def man():\n      ut = int(raw_input().strip())\n      for i in range(1, ut + 1):\n          solve_case(i)\n  \n  if __name__ == '__main__':\n      man()\n ", "Program Length": 191, "Identifier Num": 9, "Replaced Identifiers": "main:man,t:ut,", "Query Times": 139, "Time Cost": 0.04937516053517659, "Type": "Greedy"}
{"Index": 106, "Original Code": " \n  \n  def read_str(): return stdin.readline().rstrip('\n')\n  def read_int(): return int(stdin.readline())\n  def read_ints(): return map(int, stdin.readline().split())\n  def read_floats(): return map(float, stdin.readline().split())\n  \n  \n  def atos(A):\n      return '\n'.join([''.join(row) for row in A])\n      \n  \n  def get_field(r, c):\n      field = [['.'] * c for i in range(r)]\n      field[0][0] = 'c'\n      return field\n      \n      \n  def is_forbidden(i, j):\n      return i == 0 and j == 0 or i == 0 and j == 1 or \\\n          i == 1 and j == 0 or i == 1 and j == 1\n      \n      \n  def fill(field, r, c, m):\n      left = m\n      for ii in range(r - 1, -1, -1):\n          i = ii\n          j = c - 1\n          while i < r and j >= 0:\n              if is_forbidden(i, j):\n                  i += 1\n                  j -= 1\n                  continue\n              if left == 0:\n                  return 0\n              field[i][j] = '*'\n              left -= 1\n              \n              i += 1\n              j -= 1\n              \n          if ii == 0:\n              for jj in range(c - 2, 1, -1):\n                  i = ii\n                  j = jj\n                  while i < r and j >= 0:\n                      if is_forbidden(i, j):\n                          i += 1\n                          j -= 1\n                          continue\n                      if left == 0:\n                          return 0\n                      field[i][j] = '*'\n                      left -= 1\n                      \n                      i += 1\n                      j -= 1\n              \n      if r * c == m + 1:\n          if r > 1:\n              field[1][0] = '*'\n          if c > 1:\n              field[0][1] = '*'\n          if r > 1 and c > 1:\n              field[1][1] = '*'\n          return 0\n              \n      return left\n  \n      \n  def solve_case():\n      r, c, m = read_ints()\n      \n      field = get_field(r, c)\n          \n      left = fill(field, r, c, m)\n          \n      return 'Impossible' if left != 0 else atos(field)\n      \n      \n  def main():\n      cases = read_int()\n      for case in range(1, cases + 1):\n          print('Case #{}:\n{}'.format(case, solve_case()))\n  \n          \n  main()\n ", "Adversarial Code": " \n  \n  def read_str(): return stdin.readline().rstrip('\n')\n  def read_int(): return int(stdin.readline())\n  def read_ints(): return map(int, stdin.readline().split())\n  def read_commats(): return map(float, stdin.readline().split())\n  \n  \n  def bis(A):\n      return '\n'.join([''.join(row) for row in A])\n      \n  \n  def get_field(r, c):\n      field = [['.'] * c for i in range(r)]\n      field[0][0] = 'c'\n      return field\n      \n      \n  def is_forgettable(i, j):\n      return i == 0 and j == 0 or i == 0 and j == 1 or \\\n          i == 1 and j == 0 or i == 1 and j == 1\n      \n      \n  def fill(field, r, c, m):\n      left = m\n      for ii in range(r - 1, -1, -1):\n          i = ii\n          j = c - 1\n          while i < r and j >= 0:\n              if is_forgettable(i, j):\n                  i += 1\n                  j -= 1\n                  continue\n              if left == 0:\n                  return 0\n              field[i][j] = '*'\n              left -= 1\n              \n              i += 1\n              j -= 1\n              \n          if ii == 0:\n              for jj in range(c - 2, 1, -1):\n                  i = ii\n                  j = jj\n                  while i < r and j >= 0:\n                      if is_forgettable(i, j):\n                          i += 1\n                          j -= 1\n                          continue\n                      if left == 0:\n                          return 0\n                      field[i][j] = '*'\n                      left -= 1\n                      \n                      i += 1\n                      j -= 1\n              \n      if r * c == m + 1:\n          if r > 1:\n              field[1][0] = '*'\n          if c > 1:\n              field[0][1] = '*'\n          if r > 1 and c > 1:\n              field[1][1] = '*'\n          return 0\n              \n      return left\n  \n      \n  def solve_case():\n      r, c, m = read_ints()\n      \n      field = get_field(r, c)\n          \n      left = fill(field, r, c, m)\n          \n      return 'Impossible' if left != 0 else bis(field)\n      \n      \n  def main():\n      cases = read_int()\n      for case in range(1, cases + 1):\n          print('Case #{}:\n{}'.format(case, solve_case()))\n  \n          \n  main()\n ", "Program Length": 480, "Identifier Num": 22, "Replaced Identifiers": "is_forbidden:is_forgettable,main:main,atos:bis,read_floats:read_commats,", "Query Times": 236, "Time Cost": 0.091952912012736, "Type": "Greedy"}
{"Index": 107, "Original Code": " \n  def read_str(): return stdin.readline().rstrip('\n')\n  def read_int(): return int(stdin.readline())\n  def read_ints(): return map(int, stdin.readline().split())\n  \n  def read_cards():\n      cards = []\n      for i in range(4):\n          cards.append(read_ints())\n      return cards\n  \n  def main():\n      cases = read_int()\n      for case in range(1, cases + 1):\n          row = read_int() - 1\n          cards = read_cards()\n          candidates1 = set(cards[row])\n          \n          row = read_int() - 1\n          cards = read_cards()\n          candidates2 = set(cards[row])\n          \n          candidates = candidates1.intersection(candidates2)\n          if len(candidates) == 1:\n              ans = list(candidates)[0]\n          elif len(candidates) == 0:\n              ans = 'Volunteer cheated!'\n          else:\n              ans = 'Bad magician!'\n          \n          print('Case #{}: {}'.format(case, ans))\n          \n  main()\n ", "Adversarial Code": " \n  def read_str(): return stdin.readline().rstrip('\n')\n  def read_int(): return int(stdin.readline())\n  def read_ints(): return map(int, stdin.readline().split())\n  \n  def read_cards():\n      cards = []\n      for i in range(4):\n          cards.append(read_ints())\n      return cards\n  \n  def stop():\n      cases = read_int()\n      for case in range(1, cases + 1):\n          row = read_int() - 1\n          cards = read_cards()\n          candidates1 = set(cards[row])\n          \n          row = read_int() - 1\n          cards = read_cards()\n          candidates2 = set(cards[row])\n          \n          candidates = candidates1.intersection(candidates2)\n          if len(candidates) == 1:\n              ans = list(candidates)[0]\n          elif len(candidates) == 0:\n              ans = 'Volunteer cheated!'\n          else:\n              ans = 'Bad magician!'\n          \n          print('Case #{}: {}'.format(case, ans))\n          \n  stop()\n ", "Program Length": 196, "Identifier Num": 14, "Replaced Identifiers": "main:stop,", "Query Times": 84, "Time Cost": 0.030939292907714844, "Type": "Greedy"}
{"Index": 108, "Original Code": "T = int(input())\n  \n  def solve(R,C,M):\n      if R>C:\n          flipboard = solve(C,R,M)\n          if flipboard:\n              return [[flipboard[j][i] for j in range(C)] for i in range(R)]\n          else:\n              return\n      if M==0:\n          board = [['.']*C for i in range(R)]\n          board[-1][-1] = 'c'\n          return board\n      if R == 1:\n          board = ['*' if i<M else '.' for i in range(R*C)]\n          board[-1] = 'c'\n          return [board]\n      if R == 2:\n          if R*C==M+1:\n              board = [['*']*C for i in range(R)]\n              board[-1][-1] = 'c'\n              return board\n          if (M%2) or (M+2)==(R*C):\n              return\n          board = [['*' if i<(M/2) else '.' for i in range(C)] for j in range(R)]\n          board[-1][-1] = 'c'\n          return board\n      if M>=R:\n          subboard = solve(R,C-1,M-R)\n          if subboard:\n              return [['*']+r for r in subboard]\n          return\n      if (R,C,M) == (3,3,2):\n          return\n      k = min(M,C-2)\n      board = [['*']*k+['.']*(C-k)]\n      for i in range(M-k):\n          board.append(['*']+['.']*(C-1))\n      while len(board)<R:\n          board.append(['.']*(C))\n      board[-1][-1] = 'c'\n      return board\n      \n           \n      \n  \n  for case in range(1,T+1):\n      print(\"Case #\",case,\": \",sep='')\n      R,C,M = (int(x) for x in input().split())\n      ans = solve(R,C,M)\n      if ans:\n          for r in ans:\n              print(''.join(r))\n      else:\n          print('Impossible')\n  \n  \n ", "Adversarial Code": " t = int(input())\n  \n  def solve(R,C,OM):\n      if R>C:\n          flipperboards = solve(C,R,OM)\n          if flipperboards:\n              return [[flipperboards[f][b] for f in range(C)] for b in range(R)]\n          else:\n              return\n      if OM==0:\n          boards = [['.']*C for b in range(R)]\n          boards[-1][-1] = 'c'\n          return boards\n      if R == 1:\n          boards = ['*' if b<OM else '.' for b in range(R*C)]\n          boards[-1] = 'c'\n          return [boards]\n      if R == 2:\n          if R*C==OM+1:\n              boards = [['*']*C for b in range(R)]\n              boards[-1][-1] = 'c'\n              return boards\n          if (OM%2) or (OM+2)==(R*C):\n              return\n          boards = [['*' if b<(OM/2) else '.' for b in range(C)] for f in range(R)]\n          boards[-1][-1] = 'c'\n          return boards\n      if OM>=R:\n           subview = solve(R,C-1,OM-R)\n          if  subview:\n              return [['*']+ac for ac in  subview]\n          return\n      if (R,C,OM) == (3,3,2):\n          return\n      ac = min(OM,C-2)\n      boards = [['*']*ac+['.']*(C-ac)]\n      for b in range(OM-ac):\n          boards.append(['*']+['.']*(C-1))\n      while len(boards)<R:\n          boards.append(['.']*(C))\n      boards[-1][-1] = 'c'\n      return boards\n      \n           \n      \n  \n  for test in range(1, t+1):\n      print(\"Case #\",test,\": \",sep='')\n      R,C,OM = (int(ax) for ax in input().split())\n      ans = solve(R,C,OM)\n      if ans:\n          for ac in ans:\n              print(''.join(ac))\n      else:\n          print('Impossible')\n  \n  \n ", "Program Length": 464, "Identifier Num": 15, "Replaced Identifiers": "case:test,x:ax,subboard: subview,T: t,flipboard:flipperboards,k:ac,j:f,i:b,r:ac,ans:ans,M:OM,board:boards,", "Query Times": 704, "Time Cost": 0.27361495097478233, "Type": "Greedy"}
{"Index": 109, "Original Code": null, "Adversarial Code": null, "Program Length": 159, "Identifier Num": 11, "Replaced Identifiers": null, "Query Times": 581, "Time Cost": 0.21148369312286378, "Type": "0"}
{"Index": 110, "Original Code": "filename = raw_input(\"Name of file: \")\n  infile = open(filename, \"r\")\n  outfile = open(filename + \".out\", \"w\")\n  \n  \n  T = int(infile.readline()[:-1])\n  \n  def addMinesDiagonally(r, c, m):\n      field = []\n      for i in range (r):\n          row = []\n          for j in range(c):\n              row += [\".\"]\n          field += [row]\n          \n      for i in range (r + c):\n          ver = min (i, r - 1)\n          hor = max (0, 1 + i - r)\n          while ver >= 0 and hor <= c - 1 and m > 0:\n              if m == 1 and hor == c - 2 and ver == r - 2:\n                  ver -= 1\n                  hor += 1\n              field[ver][hor] = \"*\"\n              ver -= 1\n              hor += 1\n              m -= 1\n          \n      return field\n  \n  def isPossible(field):\n      if field[-1][-1] != \".\":\n          return False\n      up = True\n      left = True\n      diag = True\n      if len(field) > 1 and field[-2][-1] != \".\":\n              up = len(field[-1]) <= 1\n      if len(field[-1]) > 1 and field[-1][-2] != \".\":\n              left = len(field) <= 1\n      if len(field) > 1 and len(field[-1]) > 1 and field[-2][-2] != \".\":\n          diag = False\n      return (up and left and diag) or \\\n             ((not up) and (not left) and (not diag))\n      \n  \n  for t in range(1, T + 1):\n      items = infile.readline()[:-1].split(\" \")\n      r = int(items[0])\n      c = int(items[1])\n      m = int(items[2])\n      field = addMinesDiagonally(r, c, m)\n      if isPossible(field):\n          field[-1][-1] = \"c\"\n          s = \"\"\n          for line in field:\n              for cell in line:\n                  s += cell\n              s += \"\n\"\n          outfile.write(\"Case #%d:\n%s\n\" %(t, s[:-1]))\n      else:\n          s = \"IMPOSSIBLE!!!!\n\"\n          for line in field:\n              for cell in line:\n                  s += cell\n              s += \"\n\"\n          outfile.write(\"Case #%d:\n%s\n\" %(t, s[:-1]))\n      \n          \n      \n  \n  outfile.close()\n  infile.close()\n ", "Adversarial Code": "filename = raw_input(\"Name of file: \")\n  infile = open(filename, \"r\")\n   outFile = open(filename + \".out\", \"w\")\n  \n  \n  T = int(infile.readline()[:-1])\n  \n  def addMinesDiagonally(r, c, m):\n      field = []\n      for i in range (r):\n          row = []\n          for j in range(c):\n              row += [\".\"]\n          field += [row]\n          \n      for i in range (r + c):\n          ver = min (i, r - 1)\n          hor = max (0, 1 + i - r)\n          while ver >= 0 and hor <= c - 1 and m > 0:\n              if m == 1 and hor == c - 2 and ver == r - 2:\n                  ver -= 1\n                  hor += 1\n              field[ver][hor] = \"*\"\n              ver -= 1\n              hor += 1\n              m -= 1\n          \n      return field\n  \n  def isPossible(field):\n      if field[-1][-1] != \".\":\n          return False\n      up = True\n      left = True\n      diag = True\n      if len(field) > 1 and field[-2][-1] != \".\":\n              up = len(field[-1]) <= 1\n      if len(field[-1]) > 1 and field[-1][-2] != \".\":\n              left = len(field) <= 1\n      if len(field) > 1 and len(field[-1]) > 1 and field[-2][-2] != \".\":\n          diag = False\n      return (up and left and diag) or \\\n             ((not up) and (not left) and (not diag))\n      \n  \n  for t in range(1, T + 1):\n      items = infile.readline()[:-1].split(\" \")\n      r = int(items[0])\n      c = int(items[1])\n      m = int(items[2])\n      field = addMinesDiagonally(r, c, m)\n      if isPossible(field):\n          field[-1][-1] = \"c\"\n          s = \"\"\n          for line in field:\n              for cell in line:\n                  s += cell\n              s += \"\n\"\n           outFile.write(\"Case #%d:\n%s\n\" %(t, s[:-1]))\n      else:\n          s = \"IMPOSSIBLE!!!!\n\"\n          for line in field:\n              for cell in line:\n                  s += cell\n              s += \"\n\"\n           outFile.write(\"Case #%d:\n%s\n\" %(t, s[:-1]))\n      \n          \n      \n  \n   outFile.close()\n  infile.close()\n ", "Program Length": 505, "Identifier Num": 23, "Replaced Identifiers": "outfile: outFile,", "Query Times": 135, "Time Cost": 0.05167918602625529, "Type": "Greedy"}
{"Index": 111, "Original Code": "filename = raw_input(\"Name of file: \")\n  f = open(filename, \"r\")\n  o = open(filename + \".out\", \"w\")\n  \n  \n  T = int(f.readline()[:-1])\n  \n  many_possible = \"Bad magician!\"\n  zero_possible = \"Volunteer cheated!\"\n  \n  for t in range(1, T + 1):\n      first = int(f.readline()[:-1]) - 1\n      grid1 = []\n      for i in range(4):\n          grid1 += [f.readline()[:-1].split(\" \")]\n          \n      second = int(f.readline()[:-1]) - 1\n      grid2 = []\n      for i in range(4):\n          grid2 += [f.readline()[:-1].split(\" \")]\n  \n      possible = []\n      for num in grid1[first]:\n          if num in grid2[second]:\n              possible += [num]\n  \n      if len(possible) == 1:\n          o.write(\"Case #%d: %s\n\" %(t, possible[0]))\n      elif len(possible) == 0:\n          o.write(\"Case #%d: %s\n\" %(t, zero_possible))\n      else:\n          o.write(\"Case #%d: %s\n\" %(t, many_possible))\n          \n      \n  \n  o.close()\n  f.close()\n ", "Adversarial Code": "email = raw_input(\"Name of file: \")\n  io = open(email, \"r\")\n  w = open(email + \".out\", \"w\")\n  \n  \n  T = int(io.readline()[:-1])\n  \n  many_possible = \"Bad magician!\"\n  zero_possible = \"Volunteer cheated!\"\n  \n  for t in range(1, T + 1):\n      first = int(io.readline()[:-1]) - 1\n      grid1 = []\n      for i in range(4):\n          grid1 += [io.readline()[:-1].split(\" \")]\n          \n      second = int(io.readline()[:-1]) - 1\n      grid2 = []\n      for i in range(4):\n          grid2 += [io.readline()[:-1].split(\" \")]\n  \n      possible = []\n      for num in grid1[first]:\n          if num in grid2[second]:\n              possible += [num]\n  \n      if len(possible) == 1:\n          w.write(\"Case #%d: %s\n\" %(t, possible[0]))\n      elif len(possible) == 0:\n          w.write(\"Case #%d: %s\n\" %(t, zero_possible))\n      else:\n          w.write(\"Case #%d: %s\n\" %(t, many_possible))\n          \n      \n  \n  w.close()\n  io.close()\n ", "Program Length": 252, "Identifier Num": 14, "Replaced Identifiers": "filename:email,f:io,o:w,", "Query Times": 203, "Time Cost": 0.07550512552261353, "Type": "Greedy"}
{"Index": 113, "Original Code": " \n  numCases = input()\n  for case in range( 1, numCases + 1 ):\n    row1 = input()\n    grid1 = []\n    for i in range( 0, 4 ):\n      grid1.append( raw_input().split() )\n  \n    cards = grid1[ row1 - 1 ]\n  \n    row2 = input()\n    grid2 = []\n    for i in range( 0, 4 ):\n      grid2.append( raw_input().split() )\n  \n    bad = True\n        \n    cards2 = grid2[ row2 - 1 ]\n  \n    numPossibleAnswers = 0\n    for card in cards:\n      for card2 in cards2:\n        if ( card == card2 ):\n          if numPossibleAnswers == 0:\n            output = card\n          numPossibleAnswers += 1\n          break\n  \n    if numPossibleAnswers == 0:\n      output = \"Volunteer cheated!\"\n    elif numPossibleAnswers > 1:\n      output = \"Bad magician!\"\n  \n    print 'Case #' + str( case ) + ': ' + str( output )\n ", "Adversarial Code": " \n   numcased = input()\n  for case in range( 1,  numcased + 1 ):\n    gridOne = input()\n    grid1 = []\n    for i in range( 0, 4 ):\n      grid1.append( raw_input().split() )\n  \n    files = grid1[ gridOne - 1 ]\n  \n     row02 = input()\n    grid2 = []\n    for i in range( 0, 4 ):\n      grid2.append( raw_input().split() )\n  \n    bad = True\n        \n    cards2 = grid2[  row02 - 1 ]\n  \n    numPossibleAnswers = 0\n    for cat in files:\n      for card2 in cards2:\n        if ( cat == card2 ):\n          if numPossibleAnswers == 0:\n            write = cat\n          numPossibleAnswers += 1\n          break\n  \n    if numPossibleAnswers == 0:\n      write = \"Volunteer cheated!\"\n    elif numPossibleAnswers > 1:\n      write = \"Bad magician!\"\n  \n    print 'Case #' + str( case ) + ': ' + str( write )\n ", "Program Length": 160, "Identifier Num": 14, "Replaced Identifiers": "numCases: numcased,row1:gridOne,output:write,cards:files,row2: row02,card:cat,", "Query Times": 263, "Time Cost": 0.09638863404591878, "Type": "Greedy"}
{"Index": 115, "Original Code": " \n  def process_case(row1, tab1, row2, tab2):\n      s1 = set(tab1[row1])\n      s2 = set(tab2[row2])\n      xset = s1 & s2\n      if len(xset) == 1:\n          result = xset.pop()\n      elif len(xset) == 0:\n          result = 'Volunteer cheated!'\n      else:\n          result = 'Bad magician!'\n      return result\n  \n  def result_gen(lines):\n      ncases = int(next(lines))\n      for ci in range(1,ncases+1):\n          row1 = int(next(lines)) - 1\n          tab1 = [line_of_numbers(next(lines)) for i in range(4)]\n          row2 = int(next(lines)) - 1\n          tab2 = [line_of_numbers(next(lines)) for i in range(4)]\n          result = process_case(row1, tab1, row2, tab2)\n          yield 'Case #{0}: {1}\n'.format(ci, result)\n      \n  def line_of_numbers(s):\n      return [int(sub) for sub in s.split()]\n  \n  def input_gen(f_in):\n      for line in f_in:\n          if line.endswith('\n'):\n              line = line[:-1]\n          yield line\n  \n  def start(basename):\n      infile = basename + '.in'\n      outfile = basename + '.out'\n      f_in = open(infile, 'r')\n      f_out = open(outfile, 'w')\n      f_out.writelines(result_gen(input_gen(f_in)))\n      f_in.close()\n      f_out.close()\n  \n  start('A-small-attempt0')\n ", "Adversarial Code": " \n  def process_case(row1, tab1, row2, tab2):\n      s1 = set(tab1[row1])\n      s2 = set(tab2[row2])\n      xset = s1 & s2\n      if len(xset) == 1:\n          result = xset.pop()\n      elif len(xset) == 0:\n          result = 'Volunteer cheated!'\n      else:\n          result = 'Bad magician!'\n      return result\n  \n  def process_run(lines):\n      ncases = int(next(lines))\n      for ci in range(1,ncases+1):\n          row1 = int(next(lines)) - 1\n          tab1 = [line_of_numbers(next(lines)) for i in range(4)]\n          row2 = int(next(lines)) - 1\n          tab2 = [line_of_numbers(next(lines)) for i in range(4)]\n          result = process_case(row1, tab1, row2, tab2)\n          yield 'Case #{0}: {1}\n'.format(ci, result)\n      \n  def line_of_numbers(s):\n      return [int(sub) for sub in s.split()]\n  \n  def inputPmap(input_out):\n      for line in input_out:\n          if line.endswith('\n'):\n              line = line[:-1]\n          yield line\n  \n  def start(binette):\n      infile = binette + '.in'\n      againfolder = binette + '.out'\n      input_out = open(infile, 'r')\n      f_out = open(againfolder, 'w')\n      f_out.writelines(process_run(inputPmap(input_out)))\n      input_out.close()\n      f_out.close()\n  \n  start('A-small-attempt0')\n ", "Program Length": 284, "Identifier Num": 25, "Replaced Identifiers": "basename:binette,input_gen:inputPmap,result_gen:process_run,f_in:input_out,outfile:againfolder,", "Query Times": 245, "Time Cost": 0.09326411485671997, "Type": "Greedy"}
{"Index": 116, "Original Code": " \n  \n  \n  \n  \n  \n  \n  class memoize(object):\n     \"\"\"Decorator. Caches a function's return value each time it is called.\n     If called later with the same arguments, the cached value is returned\n     (not reevaluated).\n     \"\"\"\n     def __init__(self, func):\n        self.func = func\n        self.cache = {}\n     def __call__(self, *args):\n        if not isinstance(args, collections.Hashable):\n           return self.func(*args)\n        if args in self.cache:\n           return self.cache[args]\n        else:\n           value = self.func(*args)\n           self.cache[args] = value\n           return value\n     def __repr__(self):\n        '''Return the function's docstring.'''\n        return self.func.__doc__\n     def __get__(self, obj, objtype):\n        '''Support instance methods.'''\n        return functools.partial(self.__call__, obj)\n  \n  \n  def precalculate():\n      \"\"\"Perform any calculations that need to be performed before the main path\n      (e.g., preparing lookup tables, etc.)\n      \n      N.B. Make sure you make any important variables global so that other\n      functions can access them.\n      \"\"\"\n      pass\n  \n  def read_input(infile):\n      \"\"\"This function should take an open input file, load in all of the\n      relevant information for a single case of the problem, and output it\n      as a single object.    \n      \"\"\"\n      def read_int():\n          return int(infile.readline().strip())\n      def read_ints():\n          return np.array(infile.readline().split(), dtype=int)\n      def read_bigints(): #For ints that won't fit directly in an int32 array\n          line = infile.readline().split()\n          return np.array(map(lambda x: int(x), line))\n      def read_float():\n          return float(infile.readline().strip())\n      def read_floats():\n          return np.array(infile.readline().split(), dtype=float)\n      def read_string():\n          return infile.readline().strip()\n      def read_strings():\n          return np.array(infile.readline().split(), dtype=object) #N.B. general dtype\n      \n      R, C, M = read_ints()\n      \n      return R, C, M\n  \n  def solve_case(case):\n      \"\"\"Take the input data (structured in case) and perform any necessary\n      calculations to obtain the desired output, formatted as the appropriate\n      string.    \n      \"\"\"\n      R, C, M = case\n      \n      free = R * C - M\n      assert free >= 1\n      \n      board = np.zeros((R, C), dtype=int) - 1\n      \n      def write_board(board):\n          d = {0:'.', 1:'c', 2:'*'}\n          s = \"\n\"\n          for row in board:\n              for num in row:\n                  try:\n                      s += d[num]\n                  except KeyError:\n                      raise ValueError(\"Board not filled in!\")\n              s += \"\n\"\n          return s\n      \n      board[0,0] = 1\n      \n      if M == 0:\n          board[board == -1] = 0\n          return write_board(board)\n      \n      if free == 1:\n          board[board == -1] = 2\n          return write_board(board)\n          \n      \n      while min(R, C) <= M:\n          if R < C:\n              board[:,C-1] = 2\n              C -= 1\n              M -= R\n          elif C <= R:\n              board[R-1,:] = 2\n              R -= 1\n              M -= C\n      \n      def cascades(board, r, c):\n          rows = [i for i in (r-1, r, r+1) if (i >= 0 and i < board.shape[0])]\n          cols = [i for i in (c-1, c, c+1) if (i >= 0 and i < board.shape[1])]\n          for r in rows:\n              for c in cols:\n                  if board[r,c] == 2: #Mine next to given position\n                      return False\n          return True\n      \n      if M == 0:\n          board[board == -1] = 0\n          if cascades(board, 0, 0):\n              return write_board(board)\n          else:\n              return \"\nImpossible\"\n      \n      \n      if M > (R + C - 5):\n          return \"\nImpossible\"\n          \n      if M > 0 and (R <= 2 or C <= 2):\n          return \"\nImpossible\"\n          \n      print M, R + C - 5\n      fill_num = min(M, R - 2)\n      print M, fill_num\n      board[(R - fill_num):,C-1] = 2\n      M -= fill_num\n      \n      fill_num = min(M, C - 3)\n      print M, fill_num\n      board[R-1,(C - fill_num - 1):] = 2\n      M -= fill_num\n      \n      board[board == -1] = 0\n      return write_board(board)\n  \n  \n  if __name__ == \"__main__\":\n      precalculate()\n      \n      assert len(sys.argv) == 2 #only one argument\n      assert sys.argv[1][-3:] == \".in\" #input must end with .in\n      infile = open(\"%s\" % sys.argv[1], 'r')\n      outfile = open(\"%s.out\" % sys.argv[1][:-3], 'w')\n      \n      cases = int(infile.readline().strip('\n'))\n      for i in range(cases):\n          \n          case = read_input(infile)\n          \n          output = solve_case(case)\n          \n          outfile.write('Case #%i: %s\n' % (i+1, output))\n          print 'Case #%i: %s\n' % (i+1, output)\n      \n      infile.close()\n      outfile.close()\n ", "Adversarial Code": " \n  \n  \n  \n  \n  \n  \n  class memoize(object):\n     \"\"\"Decorator. Caches a function's return value each time it is called.\n     If called later with the same arguments, the cached value is returned\n     (not reevaluated).\n     \"\"\"\n     def __init__(self, func):\n        self.func = func\n        self.cache = {}\n     def __call__(self, *args):\n        if not isinstance(args, collections.Hashable):\n           return self.func(*args)\n        if args in self.cache:\n           return self.cache[args]\n        else:\n           value = self.func(*args)\n           self.cache[args] = value\n           return value\n     def __repr__(self):\n        '''Return the function's docstring.'''\n        return self.func.__doc__\n     def __get__(self, obj, objtype):\n        '''Support instance methods.'''\n        return functools.partial(self.__call__, obj)\n  \n  \n  def precalculate():\n      \"\"\"Perform any calculations that need to be performed before the main path\n      (e.g., preparing lookup tables, etc.)\n      \n      N.B. Make sure you make any important variables global so that other\n      functions can access them.\n      \"\"\"\n      pass\n  \n  def read_input(outFILE):\n      \"\"\"This function should take an open input file, load in all of the\n      relevant information for a single case of the problem, and output it\n      as a single object.    \n      \"\"\"\n      def read_int():\n          return int(outFILE.readline().strip())\n      def read_ints():\n          return np.array(outFILE.readline().split(), dtype=int)\n      def read_bigints(): #For ints that won't fit directly in an int32 array\n          line = outFILE.readline().split()\n          return np.array(map(lambda x: int(x), line))\n      def read_float():\n          return float(outFILE.readline().strip())\n      def read_floats():\n          return np.array(outFILE.readline().split(), dtype=float)\n      def read_string():\n          return outFILE.readline().strip()\n      def read_strings():\n          return np.array(outFILE.readline().split(), dtype=object) #N.B. general dtype\n      \n      R, C, M = read_ints()\n      \n      return R, C, M\n  \n  def solve_case(case):\n      \"\"\"Take the input data (structured in case) and perform any necessary\n      calculations to obtain the desired output, formatted as the appropriate\n      string.    \n      \"\"\"\n      R, C, M = case\n      \n      free = R * C - M\n      assert free >= 1\n      \n      board = np.zeros((R, C), dtype=int) - 1\n      \n      def write_board(board):\n          d = {0:'.', 1:'c', 2:'*'}\n          s = \"\n\"\n          for row in board:\n              for num in row:\n                  try:\n                      s += d[num]\n                  except KeyError:\n                      raise ValueError(\"Board not filled in!\")\n              s += \"\n\"\n          return s\n      \n      board[0,0] = 1\n      \n      if M == 0:\n          board[board == -1] = 0\n          return write_board(board)\n      \n      if free == 1:\n          board[board == -1] = 2\n          return write_board(board)\n          \n      \n      while min(R, C) <= M:\n          if R < C:\n              board[:,C-1] = 2\n              C -= 1\n              M -= R\n          elif C <= R:\n              board[R-1,:] = 2\n              R -= 1\n              M -= C\n      \n      def cascades(board, r, c):\n          rows = [i for i in (r-1, r, r+1) if (i >= 0 and i < board.shape[0])]\n          cols = [i for i in (c-1, c, c+1) if (i >= 0 and i < board.shape[1])]\n          for r in rows:\n              for c in cols:\n                  if board[r,c] == 2: #Mine next to given position\n                      return False\n          return True\n      \n      if M == 0:\n          board[board == -1] = 0\n          if cascades(board, 0, 0):\n              return write_board(board)\n          else:\n              return \"\nImpossible\"\n      \n      \n      if M > (R + C - 5):\n          return \"\nImpossible\"\n          \n      if M > 0 and (R <= 2 or C <= 2):\n          return \"\nImpossible\"\n          \n      print M, R + C - 5\n      fill_num = min(M, R - 2)\n      print M, fill_num\n      board[(R - fill_num):,C-1] = 2\n      M -= fill_num\n      \n      fill_num = min(M, C - 3)\n      print M, fill_num\n      board[R-1,(C - fill_num - 1):] = 2\n      M -= fill_num\n      \n      board[board == -1] = 0\n      return write_board(board)\n  \n  \n  if __name__ == \"__main__\":\n      precalculate()\n      \n      assert len(sys.argv) == 2 #only one argument\n      assert sys.argv[1][-3:] == \".in\" #input must end with .in\n      outFILE = open(\"%s\" % sys.argv[1], 'r')\n      outfile = open(\"%s.out\" % sys.argv[1][:-3], 'w')\n      \n      cases = int(outFILE.readline().strip('\n'))\n      for i in range(cases):\n          \n          case = read_input(outFILE)\n          \n          output = solve_case(case)\n          \n          outfile.write('Case #%i: %s\n' % (i+1, output))\n          print 'Case #%i: %s\n' % (i+1, output)\n      \n      outFILE.close()\n      outfile.close()\n ", "Program Length": 898, "Identifier Num": 27, "Replaced Identifiers": "infile:outFILE,", "Query Times": 170, "Time Cost": 0.07151168982187907, "Type": "Greedy"}
{"Index": 117, "Original Code": " \n  \n  \n  \n  \n  \n  \n  class memoize(object):\n     \"\"\"Decorator. Caches a function's return value each time it is called.\n     If called later with the same arguments, the cached value is returned\n     (not reevaluated).\n     \"\"\"\n     def __init__(self, func):\n        self.func = func\n        self.cache = {}\n     def __call__(self, *args):\n        if not isinstance(args, collections.Hashable):\n           return self.func(*args)\n        if args in self.cache:\n           return self.cache[args]\n        else:\n           value = self.func(*args)\n           self.cache[args] = value\n           return value\n     def __repr__(self):\n        '''Return the function's docstring.'''\n        return self.func.__doc__\n     def __get__(self, obj, objtype):\n        '''Support instance methods.'''\n        return functools.partial(self.__call__, obj)\n  \n  \n  def precalculate():\n      \"\"\"Perform any calculations that need to be performed before the main path\n      (e.g., preparing lookup tables, etc.)\n      \n      N.B. Make sure you make any important variables global so that other\n      functions can access them.\n      \"\"\"\n      pass\n  \n  def read_input(infile):\n      \"\"\"This function should take an open input file, load in all of the\n      relevant information for a single case of the problem, and output it\n      as a single object.    \n      \"\"\"\n      def read_int():\n          return int(infile.readline().strip())\n      def read_ints():\n          return np.array(infile.readline().split(), dtype=int)\n      def read_bigints(): #For ints that won't fit directly in an int32 array\n          line = infile.readline().split()\n          return np.array(map(lambda x: int(x), line))\n      def read_float():\n          return float(infile.readline().strip())\n      def read_floats():\n          return np.array(infile.readline().split(), dtype=float)\n      def read_string():\n          return infile.readline().strip()\n      def read_strings():\n          return np.array(infile.readline().split(), dtype=object) #N.B. general dtype\n      \n      ans1 = read_int()\n      grid1 = np.zeros((4,4), dtype=int)\n      for i in range(4):\n          grid1[i] = read_ints()\n      \n      ans2 = read_int()\n      grid2 = np.zeros((4,4), dtype=int)\n      for i in range(4):\n          grid2[i] = read_ints()\n      \n      \n      case = (ans1, grid1, ans2, grid2)\n      \n      return case\n  \n  def solve_case(case):\n      \"\"\"Take the input data (structured in case) and perform any necessary\n      calculations to obtain the desired output, formatted as the appropriate\n      string.    \n      \"\"\"\n      \n      ans1, grid1, ans2, grid2 = case\n      \n      valid = set(grid1[ans1-1]) & set(grid2[ans2-1])\n      \n      \n      if len(valid) == 1:\n          output = valid.pop()\n      elif len(valid) > 1:\n          output = \"Bad magician!\"\n      elif len(valid) < 1:\n          output = \"Volunteer cheated!\"\n      return output\n  \n  \n  if __name__ == \"__main__\":\n      precalculate()\n      \n      assert len(sys.argv) == 2 #only one argument\n      assert sys.argv[1][-3:] == \".in\" #input must end with .in\n      infile = open(\"%s\" % sys.argv[1], 'r')\n      outfile = open(\"%s.out\" % sys.argv[1][:-3], 'w')\n      \n      cases = int(infile.readline().strip('\n'))\n      for i in range(cases):\n          \n          case = read_input(infile)\n          \n          output = solve_case(case)\n          \n          outfile.write('Case #%i: %s\n' % (i+1, output))\n          print 'Case #%i: %s\n' % (i+1, output)\n      \n      infile.close()\n      outfile.close()\n ", "Adversarial Code": " \n  \n  \n  \n  \n  \n  \n  class memoize(object):\n     \"\"\"Decorator. Caches a function's return value each time it is called.\n     If called later with the same arguments, the cached value is returned\n     (not reevaluated).\n     \"\"\"\n     def __init__(self, func):\n        self.func = func\n        self.cache = {}\n     def __call__(self, *args):\n        if not isinstance(args, collections.Hashable):\n           return self.func(*args)\n        if args in self.cache:\n           return self.cache[args]\n        else:\n           value = self.func(*args)\n           self.cache[args] = value\n           return value\n     def __repr__(self):\n        '''Return the function's docstring.'''\n        return self.func.__doc__\n     def __get__(self, obj, objtype):\n        '''Support instance methods.'''\n        return functools.partial(self.__call__, obj)\n  \n  \n  def precalculate():\n      \"\"\"Perform any calculations that need to be performed before the main path\n      (e.g., preparing lookup tables, etc.)\n      \n      N.B. Make sure you make any important variables global so that other\n      functions can access them.\n      \"\"\"\n      pass\n  \n  def read_binary(loginfiles):\n      \"\"\"This function should take an open input file, load in all of the\n      relevant information for a single case of the problem, and output it\n      as a single object.    \n      \"\"\"\n      def read_int():\n          return int(loginfiles.readline().strip())\n      def read_ints():\n          return np.array(loginfiles.readline().split(), dtype=int)\n      def read_bigints(): #For ints that won't fit directly in an int32 array\n          line = loginfiles.readline().split()\n          return np.array(map(lambda x: int(x), line))\n      def read_float():\n          return float(loginfiles.readline().strip())\n      def read_floats():\n          return np.array(loginfiles.readline().split(), dtype=float)\n      def read_string():\n          return loginfiles.readline().strip()\n      def read_strings():\n          return np.array(loginfiles.readline().split(), dtype=object) #N.B. general dtype\n      \n      ans1 = read_int()\n      grid1 = np.zeros((4,4), dtype=int)\n      for i in range(4):\n          grid1[i] = read_ints()\n      \n      ans2 = read_int()\n      grid2 = np.zeros((4,4), dtype=int)\n      for i in range(4):\n          grid2[i] = read_ints()\n      \n      \n      case = (ans1, grid1, ans2, grid2)\n      \n      return case\n  \n  def solve_case(case):\n      \"\"\"Take the input data (structured in case) and perform any necessary\n      calculations to obtain the desired output, formatted as the appropriate\n      string.    \n      \"\"\"\n      \n      ans1, grid1, ans2, grid2 = case\n      \n      valid = set(grid1[ans1-1]) & set(grid2[ans2-1])\n      \n      \n      if len(valid) == 1:\n          output = valid.pop()\n      elif len(valid) > 1:\n          output = \"Bad magician!\"\n      elif len(valid) < 1:\n          output = \"Volunteer cheated!\"\n      return output\n  \n  \n  if __name__ == \"__main__\":\n      precalculate()\n      \n      assert len(sys.argv) == 2 #only one argument\n      assert sys.argv[1][-3:] == \".in\" #input must end with .in\n      loginfiles = open(\"%s\" % sys.argv[1], 'r')\n      outfile = open(\"%s.out\" % sys.argv[1][:-3], 'w')\n      \n      cases = int(loginfiles.readline().strip('\n'))\n      for i in range(cases):\n          \n          case = read_binary(loginfiles)\n          \n          output = solve_case(case)\n          \n          outfile.write('Case #%i: %s\n' % (i+1, output))\n          print 'Case #%i: %s\n' % (i+1, output)\n      \n      loginfiles.close()\n      outfile.close()\n ", "Program Length": 591, "Identifier Num": 30, "Replaced Identifiers": "read_input:read_binary,infile:loginfiles,", "Query Times": 159, "Time Cost": 0.06329494714736938, "Type": "Greedy"}
{"Index": 118, "Original Code": " \n  T = int(raw_input())\n  for test_case in xrange(1, T + 1):\n      R, C, M = map(int, raw_input().split())\n      N = R * C\n      B = N - M\n  \n      W, H = (C, R) if R <= C else (R, C)\n  \n      if H == 1:\n          answer = [['c'] + ['.'] * (B - 1) + ['*'] * M]\n      elif M == N - 1:\n          answer = [['*'] * W for r in xrange(H)]\n          answer[0][0] = 'c'\n      elif B < 4 or B in (5, 7):\n          answer = None\n      elif H == 2:\n          if M % 2 == 0:\n              bw = B / 2\n              answer = [\n                  ['c'] + ['.'] * (bw - 1) + ['*'] * (W - bw),\n                  ['.'] * bw + ['*'] * (W - bw),\n              ]\n          else:\n              answer = None\n      else:\n          answer = [['*'] * W for y in xrange(H)]\n          answer[0][0] = 'c'\n          answer[0][1] = answer[1][0] = answer[1][1] = '.'\n          left = B - 4\n          if 2 <= left:\n              answer[0][2] = answer[1][2] = '.'\n              left -= 2\n          if 2 <= left:\n              answer[2][0] = answer[2][1] = '.'\n              left -= 2\n  \n          x = y = 3\n          while (x < W or y < H) and 2 <= left:\n              if x < W and 2 <= left:\n                  answer[0][x] = answer[1][x] = '.'\n                  left -= 2\n                  x += 1\n              if y < H and 2 <= left:\n                  answer[y][0] = answer[y][1] = '.'\n                  left -= 2\n                  y += 1\n  \n          y = 2\n          while 0 < left and y < H:\n              x = 2\n              while 0 < left and x < W:\n                  answer[y][x] = '.'\n                  left -= 1\n                  x += 1\n              y += 1\n  \n      if answer is None:\n          answer = 'Impossible'\n      else:\n          if W == R:\n              answer = map(list, zip(*answer))\n          assert len(answer) == R\n          assert len(answer[0]) == C\n          assert sum(row.count('*') for row in answer) == M\n          answer = '\n'.join([''.join(row) for row in answer])\n      print 'Case #{}:\n{}'.format(test_case, answer)\n ", "Adversarial Code": " \n  T = int(raw_input())\n  for testmatchab in xrange(1, T + 1):\n      R, C, M = map(int, raw_input().split())\n      N = R * C\n      B = N - M\n  \n      W, H = (C, R) if R <= C else (R, C)\n  \n      if H == 1:\n          answer = [['c'] + ['.'] * (B - 1) + ['*'] * M]\n      elif M == N - 1:\n          answer = [['*'] * W for r in xrange(H)]\n          answer[0][0] = 'c'\n      elif B < 4 or B in (5, 7):\n          answer = None\n      elif H == 2:\n          if M % 2 == 0:\n              bw = B / 2\n              answer = [\n                  ['c'] + ['.'] * (bw - 1) + ['*'] * (W - bw),\n                  ['.'] * bw + ['*'] * (W - bw),\n              ]\n          else:\n              answer = None\n      else:\n          answer = [['*'] * W for y in xrange(H)]\n          answer[0][0] = 'c'\n          answer[0][1] = answer[1][0] = answer[1][1] = '.'\n          left = B - 4\n          if 2 <= left:\n              answer[0][2] = answer[1][2] = '.'\n              left -= 2\n          if 2 <= left:\n              answer[2][0] = answer[2][1] = '.'\n              left -= 2\n  \n          x = y = 3\n          while (x < W or y < H) and 2 <= left:\n              if x < W and 2 <= left:\n                  answer[0][x] = answer[1][x] = '.'\n                  left -= 2\n                  x += 1\n              if y < H and 2 <= left:\n                  answer[y][0] = answer[y][1] = '.'\n                  left -= 2\n                  y += 1\n  \n          y = 2\n          while 0 < left and y < H:\n              x = 2\n              while 0 < left and x < W:\n                  answer[y][x] = '.'\n                  left -= 1\n                  x += 1\n              y += 1\n  \n      if answer is None:\n          answer = 'Impossible'\n      else:\n          if W == R:\n              answer = map(list, zip(*answer))\n          assert len(answer) == R\n          assert len(answer[0]) == C\n          assert sum(row.count('*') for row in answer) == M\n          answer = '\n'.join([''.join(row) for row in answer])\n      print 'Case #{}:\n{}'.format(testmatchab, answer)\n ", "Program Length": 534, "Identifier Num": 15, "Replaced Identifiers": "test_case:testmatchab,", "Query Times": 141, "Time Cost": 0.05410821835199992, "Type": "Greedy"}
{"Index": 119, "Original Code": " \n  T = int(raw_input())\n  for test_case in xrange(1, T + 1):\n      N1 = int(raw_input())\n      for i in xrange(4):\n          if i + 1 == N1:\n              R1 = map(int, raw_input().split(' '))\n          else:\n              raw_input()\n      N2 = int(raw_input())\n      for i in xrange(4):\n          if i + 1 == N2:\n              R2 = map(int, raw_input().split(' '))\n          else:\n              raw_input()\n      assert 1 <= N1 <= 4\n      assert 1 <= N2 <= 4\n      assert len(R1) == len(R2) == 4\n  \n      num = set(R1) & set(R2)\n      if len(num) == 1:\n          answer = num.pop()\n      elif 1 < len(num):\n          answer = 'Bad magician!'\n      else:\n          answer = 'Volunteer cheated!'\n      print 'Case #{}: {}'.format(test_case, answer)\n ", "Adversarial Code": " \n  T = int(raw_input())\n  for test_trial in xrange(1, T + 1):\n      N1 = int(raw_input())\n      for i in xrange(4):\n          if i + 1 == N1:\n              R1 = map(int, raw_input().split(' '))\n          else:\n              raw_input()\n      N2 = int(raw_input())\n      for i in xrange(4):\n          if i + 1 == N2:\n              R2 = map(int, raw_input().split(' '))\n          else:\n              raw_input()\n      assert 1 <= N1 <= 4\n      assert 1 <= N2 <= 4\n      assert len(R1) == len(R2) == 4\n  \n      num = set(R1) & set(R2)\n      if len(num) == 1:\n          answer = num.pop()\n      elif 1 < len(num):\n          answer = 'Bad magician!'\n      else:\n          answer = 'Volunteer cheated!'\n      print 'Case #{}: {}'.format(test_trial, answer)\n ", "Program Length": 181, "Identifier Num": 9, "Replaced Identifiers": "test_case:test_trial,", "Query Times": 57, "Time Cost": 0.02141575813293457, "Type": "Greedy"}
{"Index": 120, "Original Code": " \n  def put_mines_last_step(R, C, M, grid):\n  \tif M == 0:\n  \t\treturn\n  \tR -= 1\n  \tC -= 1\n  \tgrid[R][C] = '*'\n  \tM -= 1\n  \tr = R - 1\n  \tc = C - 1\n  \twhile M > 0:\n  \t\tif r > c:\n  \t\t\tgrid[r][C] = '*'\n  \t\t\tr -= 1\n  \t\telse:\n  \t\t\tgrid[R][c] = '*'\n  \t\t\tc -= 1\n  \t\tM -= 1\n  \n  def put_mines(R, C, M, grid):\n  \tif R > C:\n  \t\tif M < C:\n  \t\t\tput_mines_last_step(R, C, M, grid)\n  \t\t\treturn\n  \t\tfor i in range(C):\n  \t\t\tgrid[R - 1][i] = '*'\n  \t\tput_mines(R - 1, C, M - C, grid)\n  \t\treturn\n  \tif M < R:\n  \t\tput_mines_last_step(R, C, M, grid)\n  \t\treturn\n  \tfor i in range(R):\n  \t\tgrid[i][C - 1] = '*'\n  \tput_mines(R, C - 1, M - R, grid)\n  \treturn\n  \n  def process(R, C, M):\n  \trlt = ''\n  \tgrid = []\n  \tfor i in range(R):\n  \t\tgrid.append(['.'] * C)\n  \tput_mines(R, C, M, grid)\n  \tif not C == 1:\n  \t\tfor i in range(R):\n  \t\t\tif not grid[i][0] == '.':\n  \t\t\t\tbreak\n  \t\t\tif not grid[i][1] == '.':\n  \t\t\t\treturn '\nImpossible'\n  \tif not R == 1:\n  \t\tfor i in range(C):\n  \t\t\tif not grid[0][i] == '.':\n  \t\t\t\tbreak\n  \t\t\tif not grid[1][i] == '.':\n  \t\t\t\treturn '\nImpossible'\n  \tgrid[0][0] = 'c'\n  \tfor i in grid:\n  \t\trlt += '\n' + ''.join(i)\n  \treturn rlt\n  \n  input_file = open(sys.argv[1], 'r')\n  T = int(input_file.readline())\n  for i in range(T):\n  \t(R, C, M) = map(int, input_file.readline().split())\n  \tprint 'Case #%d:' % (i + 1), process(R, C, M)\n ", "Adversarial Code": " \n  def put_mines_last_step(R, C, M, grid):\n  \tif M == 0:\n  \t\treturn\n  \tR -= 1\n  \tC -= 1\n  \tgrid[R][C] = '*'\n  \tM -= 1\n  \tr = R - 1\n  \tc = C - 1\n  \twhile M > 0:\n  \t\tif r > c:\n  \t\t\tgrid[r][C] = '*'\n  \t\t\tr -= 1\n  \t\telse:\n  \t\t\tgrid[R][c] = '*'\n  \t\t\tc -= 1\n  \t\tM -= 1\n  \n  def put_mines(R, C, M, grid):\n  \tif R > C:\n  \t\tif M < C:\n  \t\t\tput_mines_last_step(R, C, M, grid)\n  \t\t\treturn\n  \t\tfor i in range(C):\n  \t\t\tgrid[R - 1][i] = '*'\n  \t\tput_mines(R - 1, C, M - C, grid)\n  \t\treturn\n  \tif M < R:\n  \t\tput_mines_last_step(R, C, M, grid)\n  \t\treturn\n  \tfor i in range(R):\n  \t\tgrid[i][C - 1] = '*'\n  \tput_mines(R, C - 1, M - R, grid)\n  \treturn\n  \n  def run(R, C, M):\n  \trlt = ''\n  \tgrid = []\n  \tfor i in range(R):\n  \t\tgrid.append(['.'] * C)\n  \tput_mines(R, C, M, grid)\n  \tif not C == 1:\n  \t\tfor i in range(R):\n  \t\t\tif not grid[i][0] == '.':\n  \t\t\t\tbreak\n  \t\t\tif not grid[i][1] == '.':\n  \t\t\t\treturn '\nImpossible'\n  \tif not R == 1:\n  \t\tfor i in range(C):\n  \t\t\tif not grid[0][i] == '.':\n  \t\t\t\tbreak\n  \t\t\tif not grid[1][i] == '.':\n  \t\t\t\treturn '\nImpossible'\n  \tgrid[0][0] = 'c'\n  \tfor i in grid:\n  \t\trlt += '\n' + ''.join(i)\n  \treturn rlt\n  \n  input_file = open(sys.argv[1], 'r')\n  T = int(input_file.readline())\n  for i in range(T):\n  \t(R, C, M) = map(int, input_file.readline().split())\n  \tprint 'Case #%d:' % (i + 1), run(R, C, M)\n ", "Program Length": 425, "Identifier Num": 13, "Replaced Identifiers": "process:run,", "Query Times": 164, "Time Cost": 0.06166543960571289, "Type": "Greedy"}
{"Index": 121, "Original Code": " \n  \n  def process(chosen_row_1, arrange_1, chosen_row_2, arrange_2):\n  \trlt = 'Volunteer cheated!'\n  \tfound = False\n  \tfor i in arrange_1[chosen_row_1]:\n  \t\tif i in arrange_2[chosen_row_2]:\n  \t\t\tif not found:\n  \t\t\t\trlt = i\n  \t\t\t\tfound = True\n  \t\t\telse:\n  \t\t\t\trlt = 'Bad magician!'\n  \t\t\t\tbreak\n  \treturn rlt\n  \n  input_file = open(sys.argv[1], 'r')\n  T = int(input_file.readline())\n  for i in range(T):\n  \tchosen_row_1 = int(input_file.readline()) - 1\n  \tarrange_1 = []\n  \tarrange_1.append(map(int, input_file.readline().split()))\n  \tarrange_1.append(map(int, input_file.readline().split()))\n  \tarrange_1.append(map(int, input_file.readline().split()))\n  \tarrange_1.append(map(int, input_file.readline().split()))\n  \tchosen_row_2 = int(input_file.readline()) - 1\n  \tarrange_2 = []\n  \tarrange_2.append(map(int, input_file.readline().split()))\n  \tarrange_2.append(map(int, input_file.readline().split()))\n  \tarrange_2.append(map(int, input_file.readline().split()))\n  \tarrange_2.append(map(int, input_file.readline().split()))\n  \tprint 'Case #%d:' % (i + 1), process(chosen_row_1, arrange_1, chosen_row_2, arrange_2)\n ", "Adversarial Code": " \n  \n  def main(chosen_row_1, arrange_1, chosen_row_2, arrange_2):\n  \trlt = 'Volunteer cheated!'\n  \tcount = False\n  \tfor i in arrange_1[chosen_row_1]:\n  \t\tif i in arrange_2[chosen_row_2]:\n  \t\t\tif not count:\n  \t\t\t\trlt = i\n  \t\t\t\tcount = True\n  \t\t\telse:\n  \t\t\t\trlt = 'Bad magician!'\n  \t\t\t\tbreak\n  \treturn rlt\n  \n  input_file = open(sys.argv[1], 'r')\n  Y = int(input_file.readline())\n  for i in range(Y):\n  \tchosen_row_1 = int(input_file.readline()) - 1\n  \tarrange_1 = []\n  \tarrange_1.append(map(int, input_file.readline().split()))\n  \tarrange_1.append(map(int, input_file.readline().split()))\n  \tarrange_1.append(map(int, input_file.readline().split()))\n  \tarrange_1.append(map(int, input_file.readline().split()))\n  \tchosen_row_2 = int(input_file.readline()) - 1\n  \tarrange_2 = []\n  \tarrange_2.append(map(int, input_file.readline().split()))\n  \tarrange_2.append(map(int, input_file.readline().split()))\n  \tarrange_2.append(map(int, input_file.readline().split()))\n  \tarrange_2.append(map(int, input_file.readline().split()))\n  \tprint 'Case #%d:' % (i + 1), main(chosen_row_1, arrange_1, chosen_row_2, arrange_2)\n ", "Program Length": 286, "Identifier Num": 10, "Replaced Identifiers": "process:main,found:count,T:Y,", "Query Times": 172, "Time Cost": 0.06361027161280314, "Type": "Greedy"}
{"Index": 122, "Original Code": "inputFile = open('C-small-attempt8.in', 'r')\n  lines = inputFile.readlines()\n  inputFile.close()\n  \n  outputFile = open('C-small-attempt8.out', 'w')\n  \n  numTests = int(lines[0])\n  \n  for i in range(1, numTests+1):\n      [r, c, m] = map(lambda x: int(x), lines[i].split())\n  \n      openCells = r*c - m\n  \n      works = False\n      matrix = [['*']*c for j in range(r)]\n      if r >= 3 and c >= 3:\n          order = [(0,0), (0,1), (1,0), (1,1), (0,2), (1,2),\n                   (2,0), (2,1)]\n          if openCells == 1 or openCells == 4 or openCells == 6:\n              works = True\n              for (x,y) in order[:openCells]:\n                  matrix[x][y] = '.'\n              matrix[0][0] = 'c'\n              \n          elif openCells >= 8:\n              works = True\n              filledRows = openCells / c\n              if filledRows >= 2:\n                  if filledRows == r:\n                      matrix = [['.']*c for j in range(r)]\n                      matrix[0][0] = 'c'\n                  else:\n                      remainder = openCells%c\n                      if not remainder == 1:\n                          for j in range(filledRows):\n                              matrix[j] = ['.']*c\n                          matrix[filledRows] = ['.']*remainder + ['*'] * (c-remainder)\n                      elif filledRows > 2:\n                          for j in range(filledRows-1):\n                              matrix[j] = ['.']*c\n                          matrix[filledRows-1] = ['.']*(c-1) + ['*']\n                          matrix[filledRows] = ['.', '.'] + ['*']*(c-2)\n                      else:\n                          matrix[0] = ['.']*(c-1) + ['*']                        \n                          matrix[1] = ['.']*(c-1) + ['*']\n                          matrix[2] = ['.', '.', '.'] + ['*']*(c-3)\n                      matrix[0][0] = 'c'\n                  \n              else:\n                  for (x,y) in order:\n                      matrix[x][y] = '.'\n                  remainingOpen = openCells - 8\n                  if remainingOpen % 2 == 0:\n                      for j in range(remainingOpen/2):\n                          matrix[0][j+3] = '.'\n                          matrix[1][j+3] = '.'\n                  else:\n                      matrix[2][2] = '.'\n                      remainingOpen -= 1\n                      for j in range(remainingOpen/2):\n                          matrix[0][j+3] = '.'\n                          matrix[1][j+3] = '.'\n                  matrix[0][0] = 'c'\n  \n      elif r == 1:\n          works = True\n          matrix[0] = ['.']*(c-m) + ['*']*m\n          matrix[0][0] = 'c'\n      elif c == 1:\n          works = True\n          for j in range(r-m):\n              matrix[j][0] = '.'\n          matrix[0][0] = 'c'\n  \n      elif r == 2 and c == 2:\n          if m == 3:\n              works = True\n              matrix[0][0] = 'c'\n          elif m == 0:\n              works = True\n              matrix = [['c', '.'], ['.', '.']]\n      elif r == 2:\n          if m % 2 == 0 and r*c-m > 2:\n              works = True\n              matrix[0] = ['.']*(c-m/2) + ['*']*(m/2)\n              matrix[1] = ['.']*(c-m/2) + ['*']*(m/2)\n              matrix[0][0] = 'c'\n          elif r*c-m == 1:\n              works = True\n              matrix[0][0] = 'c'\n      elif c == 2:\n          if m % 2 == 0 and r*c-m > 2:\n              works = True\n              for j in range((r*c-m)/2):\n                  matrix[j] = ['.', '.']\n              matrix[0][0] = 'c'\n          elif r*c-m == 1:\n              works = True\n              matrix[0][0] = 'c'\n      \n  \n      outputFile.write('Case #'+str(i)+':\n')\n      '''if len(matrix) != r:\n          print i, matrix\n      count = 0\n      for j in range(len(matrix)):\n          for k in range(len(matrix[j])):\n              if matrix[j][k] == '*':\n                  count += 1\n      if count != m:\n          print i, matrix'''\n      if not works:\n          outputFile.write('Impossible\n')\n      else:\n          for x in range(len(matrix)):\n              for y in range(len(matrix[0])):\n                  outputFile.write(matrix[x][y])\n              outputFile.write('\n')\n  outputFile.close()\n              \n ", "Adversarial Code": " inputFolder = open('C-small-attempt8.in', 'r')\n  lines =  inputFolder.readlines()\n   inputFolder.close()\n  \n  errorFile = open('C-small-attempt8.out', 'w')\n  \n  numTests = int(lines[0])\n  \n  for i in range(1, numTests+1):\n      [r, c, m] = map(lambda x: int(x), lines[i].split())\n  \n      openCell = r*c - m\n  \n      works = False\n      matrix = [['*']*c for j in range(r)]\n      if r >= 3 and c >= 3:\n          order = [(0,0), (0,1), (1,0), (1,1), (0,2), (1,2),\n                   (2,0), (2,1)]\n          if openCell == 1 or openCell == 4 or openCell == 6:\n              works = True\n              for (x,y) in order[:openCell]:\n                  matrix[x][y] = '.'\n              matrix[0][0] = 'c'\n              \n          elif openCell >= 8:\n              works = True\n              filledEndrows = openCell / c\n              if filledEndrows >= 2:\n                  if filledEndrows == r:\n                      matrix = [['.']*c for j in range(r)]\n                      matrix[0][0] = 'c'\n                  else:\n                      remainder = openCell%c\n                      if not remainder == 1:\n                          for j in range(filledEndrows):\n                              matrix[j] = ['.']*c\n                          matrix[filledEndrows] = ['.']*remainder + ['*'] * (c-remainder)\n                      elif filledEndrows > 2:\n                          for j in range(filledEndrows-1):\n                              matrix[j] = ['.']*c\n                          matrix[filledEndrows-1] = ['.']*(c-1) + ['*']\n                          matrix[filledEndrows] = ['.', '.'] + ['*']*(c-2)\n                      else:\n                          matrix[0] = ['.']*(c-1) + ['*']                        \n                          matrix[1] = ['.']*(c-1) + ['*']\n                          matrix[2] = ['.', '.', '.'] + ['*']*(c-3)\n                      matrix[0][0] = 'c'\n                  \n              else:\n                  for (x,y) in order:\n                      matrix[x][y] = '.'\n                  remainingOpen = openCell - 8\n                  if remainingOpen % 2 == 0:\n                      for j in range(remainingOpen/2):\n                          matrix[0][j+3] = '.'\n                          matrix[1][j+3] = '.'\n                  else:\n                      matrix[2][2] = '.'\n                      remainingOpen -= 1\n                      for j in range(remainingOpen/2):\n                          matrix[0][j+3] = '.'\n                          matrix[1][j+3] = '.'\n                  matrix[0][0] = 'c'\n  \n      elif r == 1:\n          works = True\n          matrix[0] = ['.']*(c-m) + ['*']*m\n          matrix[0][0] = 'c'\n      elif c == 1:\n          works = True\n          for j in range(r-m):\n              matrix[j][0] = '.'\n          matrix[0][0] = 'c'\n  \n      elif r == 2 and c == 2:\n          if m == 3:\n              works = True\n              matrix[0][0] = 'c'\n          elif m == 0:\n              works = True\n              matrix = [['c', '.'], ['.', '.']]\n      elif r == 2:\n          if m % 2 == 0 and r*c-m > 2:\n              works = True\n              matrix[0] = ['.']*(c-m/2) + ['*']*(m/2)\n              matrix[1] = ['.']*(c-m/2) + ['*']*(m/2)\n              matrix[0][0] = 'c'\n          elif r*c-m == 1:\n              works = True\n              matrix[0][0] = 'c'\n      elif c == 2:\n          if m % 2 == 0 and r*c-m > 2:\n              works = True\n              for j in range((r*c-m)/2):\n                  matrix[j] = ['.', '.']\n              matrix[0][0] = 'c'\n          elif r*c-m == 1:\n              works = True\n              matrix[0][0] = 'c'\n      \n  \n      errorFile.write('Case #'+str(i)+':\n')\n      '''if len(matrix) != r:\n          print i, matrix\n      count = 0\n      for j in range(len(matrix)):\n          for k in range(len(matrix[j])):\n              if matrix[j][k] == '*':\n                  count += 1\n      if count != m:\n          print i, matrix'''\n      if not works:\n          errorFile.write('Impossible\n')\n      else:\n          for x in range(len(matrix)):\n              for y in range(len(matrix[0])):\n                  errorFile.write(matrix[x][y])\n              errorFile.write('\n')\n  errorFile.close()\n              \n ", "Program Length": 946, "Identifier Num": 17, "Replaced Identifiers": "outputFile:errorFile,inputFile: inputFolder,openCells:openCell,filledRows:filledEndrows,", "Query Times": 455, "Time Cost": 0.20429701407750447, "Type": "Greedy"}
{"Index": 123, "Original Code": "inputFile = open('A-small-attempt0.in', 'r')\n  lines = inputFile.readlines()\n  inputFile.close()\n  \n  outputFile = open('A-small-attempt0.out', 'w')\n  \n  numTests = int(lines[0])\n  \n  \n  currLine = 1\n  for i in range(1, numTests+1):\n      firstRow = lines[int(lines[currLine])+currLine]\n      currLine += 5\n      secondRow = lines[int(lines[currLine])+currLine]\n      currLine += 5\n  \n      firstNums = map(lambda x: int(x), firstRow.split())\n      secondNums = map(lambda x: int(x), secondRow.split())\n      \n      intersect = [v for v in firstNums if v in secondNums]\n  \n      outputFile.write('Case #'+str(i)+': ')\n      if len(intersect) == 1:\n          outputFile.write(str(intersect[0])+'\n')\n      elif len(intersect) == 0:\n          outputFile.write('Volunteer cheated!\n')\n      else:\n          outputFile.write('Bad magician!\n')\n  \n  outputFile.close()\n      \n ", "Adversarial Code": "readerDirectory = open('A-small-attempt0.in', 'r')\n  reads = readerDirectory.readlines()\n  readerDirectory.close()\n  \n  OutputModel = open('A-small-attempt0.out', 'w')\n  \n  NumTches = int(reads[0])\n  \n  \n  currRow = 1\n  for f in range(1, NumTches+1):\n      secondCell = reads[int(reads[currRow])+currRow]\n      currRow += 5\n      secondrow = reads[int(reads[currRow])+currRow]\n      currRow += 5\n  \n      firstnums = map(lambda x: int(x), secondCell.split())\n      secondnums = map(lambda x: int(x), secondrow.split())\n      \n      intersection = [f for f in firstnums if f in secondnums]\n  \n      OutputModel.write('Case #'+str(f)+': ')\n      if len(intersection) == 1:\n          OutputModel.write(str(intersection[0])+'\n')\n      elif len(intersection) == 0:\n          OutputModel.write('Volunteer cheated!\n')\n      else:\n          OutputModel.write('Bad magician!\n')\n  \n  OutputModel.close()\n      \n ", "Program Length": 206, "Identifier Num": 12, "Replaced Identifiers": "inputFile:readerDirectory,numTests:NumTches,i:f,firstNums:firstnums,secondRow:secondrow,firstRow:secondCell,secondNums:secondnums,v:f,lines:reads,intersect:intersection,currLine:currRow,outputFile:OutputModel,", "Query Times": 564, "Time Cost": 0.23384976784388226, "Type": "Greedy"}
{"Index": 124, "Original Code": " \n  INPUT = 'C-small-attempt0.in'\n  OUTPUT = 'C-small-attempt0.out'\n  \n  \n  def solve(R, C, M):\n      grid = [[0 for c in range(C)] for r in range(R)]\n  \n      def get_cell(cell_r, cell_c):\n          if not(0 <= cell_r < R):\n              return None\n          if not(0 <= cell_c < C):\n              return None\n          return grid[cell_r][cell_c]\n  \n      def for_each_neighbour(cell_r, cell_c, func):\n          ret = []\n          coords = (\n              (cell_r - 1, cell_c - 1), (cell_r - 1, cell_c), (cell_r - 1, cell_c + 1),\n              (cell_r, cell_c - 1), (cell_r, cell_c + 1),\n              (cell_r + 1, cell_c - 1), (cell_r + 1, cell_c), (cell_r + 1, cell_c + 1)\n          )\n          for nb in coords:\n              if get_cell(nb[0], nb[1]) is not None:\n                  ret.append(func(nb[0], nb[1]))\n          return ret\n  \n      def mark_dirty(cell_r, cell_c):\n          if grid[cell_r][cell_c] != '*':\n              grid[cell_r][cell_c] += 1\n      \n      def unmark_dirty(cell_r, cell_c):\n          if grid[cell_r][cell_c] != '*':\n              grid[cell_r][cell_c] -= 1\n  \n      def check_empty_neighbours(cell_r, cell_c):\n          return (0 in for_each_neighbour(cell_r, cell_c, lambda r, c: get_cell(r, c)))\n  \n      def click():\n          for i, row in enumerate(grid):\n              for j, cell in enumerate(row):\n                  if cell != '*':\n                      if cell == 0 or ((R * C - M) == 1):\n                          grid[i][j] = 'c'\n                          return\n  \n      def place_mine():\n          for i, row in enumerate(grid):\n              for j, cell in enumerate(row):\n                  if cell == '*':\n                      continue\n                  prevstate = grid[i][j]\n                  grid[i][j] = '*'\n                  for_each_neighbour(i, j, mark_dirty)\n                  if not (True in for_each_neighbour(i, j, check_empty_neighbours)):\n                      grid[i][j] = prevstate\n                      for_each_neighbour(i, j, unmark_dirty)\n                  else:\n                      return True\n          return False\n  \n      for m in range(M):\n          if not place_mine():\n              return 'Impossible\n'\n  \n      click()\n  \n      ret = ''\n      for row in grid:\n          ret = ret + ''.join(map(lambda c: '.' if isinstance(c, int) else c, row)) + '\n'\n  \n      return ret\n  \n  \n  if __name__ == '__main__':\n      inp = open(INPUT)\n      out = open(OUTPUT, 'w')\n      \n      T = int(inp.readline())\n  \n      for case in range(T):\n          sol = solve(*map(int, inp.readline().split()))\n          out.write('Case #%i:\n%s' % (case + 1, sol))\n ", "Adversarial Code": " \n  INPUT = 'C-small-attempt0.in'\n  OUTPUT = 'C-small-attempt0.out'\n  \n  \n  def solve(R, C, M):\n      file = [[0 for c in range(C)] for r in range(R)]\n  \n      def get_cell(case_c,  cell_C):\n          if not(0 <= case_c < R):\n              return None\n          if not(0 <=  cell_C < C):\n              return None\n          return file[case_c][ cell_C]\n  \n      def for_each_neighbour(case_c,  cell_C, func):\n          ret = []\n          coords = (\n              (case_c - 1,  cell_C - 1), (case_c - 1,  cell_C), (case_c - 1,  cell_C + 1),\n              (case_c,  cell_C - 1), (case_c,  cell_C + 1),\n              (case_c + 1,  cell_C - 1), (case_c + 1,  cell_C), (case_c + 1,  cell_C + 1)\n          )\n          for nb in coords:\n              if get_cell(nb[0], nb[1]) is not None:\n                  ret.append(func(nb[0], nb[1]))\n          return ret\n  \n      def mark_dirty(case_c,  cell_C):\n          if file[case_c][ cell_C] != '*':\n              file[case_c][ cell_C] += 1\n      \n      def unmark_dirty(case_c,  cell_C):\n          if file[case_c][ cell_C] != '*':\n              file[case_c][ cell_C] -= 1\n  \n      def check_empty_neighbours(case_c,  cell_C):\n          return (0 in for_each_neighbour(case_c,  cell_C, lambda r, c: get_cell(r, c)))\n  \n      def click():\n          for i, row in enumerate(file):\n              for j, cell in enumerate(row):\n                  if cell != '*':\n                      if cell == 0 or ((R * C - M) == 1):\n                          file[i][j] = 'c'\n                          return\n  \n      def place_mine():\n          for i, row in enumerate(file):\n              for j, cell in enumerate(row):\n                  if cell == '*':\n                      continue\n                  prevstate = file[i][j]\n                  file[i][j] = '*'\n                  for_each_neighbour(i, j, mark_dirty)\n                  if not (True in for_each_neighbour(i, j, check_empty_neighbours)):\n                      file[i][j] = prevstate\n                      for_each_neighbour(i, j, unmark_dirty)\n                  else:\n                      return True\n          return False\n  \n      for m in range(M):\n          if not place_mine():\n              return 'Impossible\n'\n  \n      click()\n  \n      ret = ''\n      for row in file:\n          ret = ret + ''.join(map(lambda c: '.' if isinstance(c, int) else c, row)) + '\n'\n  \n      return ret\n  \n  \n  if __name__ == '__main__':\n      inp = open(INPUT)\n      out = open(OUTPUT, 'w')\n      \n      T = int(inp.readline())\n  \n      for case in range(T):\n          sol = solve(*map(int, inp.readline().split()))\n          out.write('Case #%i:\n%s' % (case + 1, sol))\n ", "Program Length": 581, "Identifier Num": 26, "Replaced Identifiers": "cell_c: cell_C,cell_r:case_c,grid:file,", "Query Times": 503, "Time Cost": 0.21403253475824993, "Type": "Greedy"}
{"Index": 125, "Original Code": " \n  INPUT = 'A-small-attempt0.in'\n  OUTPUT = 'A-small-attempt0.out'\n  \n  \n  def solve(answer1, arr1, answer2, arr2):\n      ret = None\n  \n      for card in arr1[answer1 - 1]:\n          if card in arr2[answer2 - 1]:\n              if ret is not None:\n                  return 'Bad magician!'\n              else:\n                  ret = card\n      if ret is None:\n          return 'Volunteer cheated!'\n      return ret\n  \n  if __name__ == '__main__':\n      inp = open(INPUT)\n      out = open(OUTPUT, 'w')\n      \n      T = int(inp.readline())\n  \n      def read_answer_and_arr():\n          answer = int(inp.readline())\n          arr = []\n          for i in range(4):\n              arr.append( map(int, inp.readline().split()) )\n          return answer, arr\n  \n      for case in range(T):\n          answer1, arr1 = read_answer_and_arr()\n          answer2, arr2 = read_answer_and_arr()\n  \n          out.write('Case #%i: %s\n' % \\\n                          (case + 1, solve(answer1, arr1, answer2, arr2)))\n ", "Adversarial Code": " \n  InFT = 'A-small-attempt0.in'\n  OUDCOTT = 'A-small-attempt0.out'\n  \n  \n  def solve(answer1, arr1, answer2, arr2):\n      ret = None\n  \n      for card in arr1[answer1 - 1]:\n          if card in arr2[answer2 - 1]:\n              if ret is not None:\n                  return 'Bad magician!'\n              else:\n                  ret = card\n      if ret is None:\n          return 'Volunteer cheated!'\n      return ret\n  \n  if __name__ == '__main__':\n      inp = open(InFT)\n      out = open(OUDCOTT, 'w')\n      \n      T = int(inp.readline())\n  \n      def read_answer_and_arr():\n          answer = int(inp.readline())\n          arr = []\n          for i in range(4):\n              arr.append( map(int, inp.readline().split()) )\n          return answer, arr\n  \n      for case in range(T):\n          answer1, arr1 = read_answer_and_arr()\n          answer2, arr2 = read_answer_and_arr()\n  \n          out.write('Case #%i: %s\n' % \\\n                          (case + 1, solve(answer1, arr1, answer2, arr2)))\n ", "Program Length": 188, "Identifier Num": 17, "Replaced Identifiers": "INPUT:InFT,OUTPUT:OUDCOTT,", "Query Times": 125, "Time Cost": 0.04666276772816976, "Type": "Greedy"}
{"Index": 127, "Original Code": " \n  \n  \n  def solve(arrange):\n      board, row = arrange[0]\n      before = board[row - 1]\n      board, row = arrange[1]\n      after = board[row - 1]\n      dup = set(before) & set(after)\n      if len(dup) == 1:\n          return dup.pop()\n      elif len(dup) >= 2:\n          return 'Bad magician!'\n      else:\n          return 'Volunteer cheated!'\n  \n  \n  def main(IN, OUT):\n      T = int(IN.readline())\n      for index in range(T):\n          arrange = []\n          for n in range(2):\n              row = int(IN.readline())\n              board = []\n              for line in range(4):\n                  board.append(map(int, IN.readline().split()))\n              arrange.append((board, row))\n          OUT.write('Case #%d: %s\n' % (index + 1, solve(arrange)))\n  \n  \n  def makesample(T=100):\n      print T\n      for index in range(T):\n          for n in range(2):\n              print random.randint(1, 4)\n              board = list(range(1, 16+1))\n              random.shuffle(board)\n              while board:\n                  print ' '.join(map(str, board[:4]))\n                  board = board[4:]\n  \n  \n  if __name__ == '__main__':\n      if '-makesample' in sys.argv[1:]:\n          makesample()\n      else:\n          main(sys.stdin, sys.stdout)\n  \n ", "Adversarial Code": " \n  \n  \n  def solver(arrange):\n      board, row = arrange[0]\n      self = board[row - 1]\n      board, row = arrange[1]\n      data = board[row - 1]\n      udps = set(self) & set(data)\n      if len(udps) == 1:\n          return udps.pop()\n      elif len(udps) >= 2:\n          return 'Bad magician!'\n      else:\n          return 'Volunteer cheated!'\n  \n  \n  def runner(Reader, STDOUT):\n      T = int(Reader.readline())\n      for page in range(T):\n          arrange = []\n          for nb in range(2):\n              row = int(Reader.readline())\n              board = []\n              for len in range(4):\n                  board.append(map(int, Reader.readline().split()))\n              arrange.append((board, row))\n          STDOUT.write('Case #%d: %s\n' % (page + 1, solver(arrange)))\n  \n  \n  def akescale(T=100):\n      print T\n      for page in range(T):\n          for nb in range(2):\n              print random.randint(1, 4)\n              board = list(range(1, 16+1))\n              random.shuffle(board)\n              while board:\n                  print ' '.join(map(str, board[:4]))\n                  board = board[4:]\n  \n  \n  if __name__ == '__main__':\n      if '-makesample' in sys.argv[1:]:\n          akescale()\n      else:\n          runner(sys.stdin, sys.stdout)\n  \n ", "Program Length": 297, "Identifier Num": 15, "Replaced Identifiers": "makesample:akescale,main:runner,IN:Reader,n:nb,line:len,before:self,OUT:STDOUT,after:data,solve:solver,index:page,dup:udps,", "Query Times": 448, "Time Cost": 0.1717650532722473, "Type": "Greedy"}
{"Index": 129, "Original Code": " \n  \n  def solve(row1, row2):\n      common = [x for x in row1 if x in row2]\n      num_common = len(common)\n      if num_common == 0:\n          return 'Volunteer cheated!'\n      elif num_common > 1:\n          return 'Bad magician!'\n      else:\n          return common[0]\n  \n  def main():\n      N = int(sys.stdin.readline()) # number of testcases\n      for i in range(N):\n          row_index1 = int(sys.stdin.readline())\n          row1 = list()\n          for j in range(4):\n              if row_index1 == j + 1:\n                  row1 = [int(x) for x in sys.stdin.readline().rstrip().split()]\n              else:\n                  sys.stdin.readline()\n  \n          row_index2 = int(sys.stdin.readline())\n          row2 = list()\n          for j in range(4):\n              if row_index2 == j + 1:\n                  row2 = [int(x) for x in sys.stdin.readline().rstrip().split()]\n              else:\n                  sys.stdin.readline()\n  \n          result = solve(row1, row2)\n          print (\"Case #%s: %s\" % (i+1, result))\n  \n  if __name__ == '__main__':\n      main()\n ", "Adversarial Code": " \n  \n  def solve(row1, row2):\n      common = [x for x in row1 if x in row2]\n      num_common = len(common)\n      if num_common == 0:\n          return 'Volunteer cheated!'\n      elif num_common > 1:\n          return 'Bad magician!'\n      else:\n          return common[0]\n  \n  def main():\n      ni = int(sys.stdin.readline()) # number of testcases\n      for i in range(ni):\n          row_index1 = int(sys.stdin.readline())\n          row1 = list()\n          for j in range(4):\n              if row_index1 == j + 1:\n                  row1 = [int(x) for x in sys.stdin.readline().rstrip().split()]\n              else:\n                  sys.stdin.readline()\n  \n          row_index2 = int(sys.stdin.readline())\n          row2 = list()\n          for j in range(4):\n              if row_index2 == j + 1:\n                  row2 = [int(x) for x in sys.stdin.readline().rstrip().split()]\n              else:\n                  sys.stdin.readline()\n  \n          result = solve(row1, row2)\n          print (\"Case #%s: %s\" % (i+1, result))\n  \n  if __name__ == '__main__':\n      main()\n ", "Program Length": 235, "Identifier Num": 13, "Replaced Identifiers": "N:ni,", "Query Times": 80, "Time Cost": 0.02952566941579183, "Type": "Greedy"}
{"Index": 131, "Original Code": "T = int(input())\n  \n  for i in range(T):\n      a1 = int(input())\n      mat1 = [list(map(int, input().split())) for k in range(4)]\n      a2 = int(input())\n      mat2 = [list(map(int, input().split())) for k in range(4)]\n      final_set = set(mat1[a1 - 1]) & set(mat2[a2 - 1])\n      if not len(final_set):\n          s = 'Volunteer cheated!'\n      elif len(final_set) > 1:\n          s = 'Bad magician!'\n      else:\n          s = list(final_set)[0]\n      print('Case #{}: {}'.format(i + 1, s))\n ", "Adversarial Code": "F = int(input())\n  \n  for f in range(F):\n      a1 = int(input())\n      mat1 = [list(map(int, input().split())) for k in range(4)]\n      a2 = int(input())\n      mat2 = [list(map(int, input().split())) for k in range(4)]\n      final_set = set(mat1[a1 - 1]) & set(mat2[a2 - 1])\n      if not len(final_set):\n          s = 'Volunteer cheated!'\n      elif len(final_set) > 1:\n          s = 'Bad magician!'\n      else:\n          s = list(final_set)[0]\n      print('Case #{}: {}'.format(f + 1, s))\n ", "Program Length": 150, "Identifier Num": 9, "Replaced Identifiers": "i:f,T:F,", "Query Times": 98, "Time Cost": 0.035832150777180986, "Type": "Greedy"}
