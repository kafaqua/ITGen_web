{"Index": 0, "Original Code": null, "Adversarial Code": null, "Program Length": 429, "Identifier Num": 16, "Replaced Identifiers": null, "Query Times": 831, "Time Cost": 1.180852742989858, "Type": "0"}
{"Index": 1, "Original Code": null, "Adversarial Code": null, "Program Length": 249, "Identifier Num": 15, "Replaced Identifiers": null, "Query Times": 796, "Time Cost": 1.1217623790105185, "Type": "0"}
{"Index": 2, "Original Code": " def solve():\n      h, w, m = map(int, raw_input().split())\n      if h == 1:\n          print 'c' + '.' * (h * w - m - 1) + '*' * m\n      elif w == 1:\n          for c in 'c' + '.' * (h * w - m - 1) + '*' * m:\n              print c\n      elif h * w - m == 1:\n          print 'c' + '*' * (w - 1)\n          for _ in xrange(h-1):\n              print '*' * w\n      else:\n          m = h * w - m\n          for i in xrange(h-1):\n              for j in xrange(w-1):\n                  t = (i + 2) * 2 + (j + 2) * 2 - 4\n                  r = (i + 2) * (j + 2)\n                  if t <= m <= r:\n                      a = [['*'] * w for _ in xrange(h)]\n                      for k in xrange(i+2):\n                          a[k][0] = '.'\n                          a[k][1] = '.'\n                      for k in xrange(j+2):\n                          a[0][k] = '.'\n                          a[1][k] = '.'\n                      for y, x in product(range(2, i+2), range(2, j+2)):\n                          if y == 1 and x == 1:\n                              continue\n                          if t >= m:\n                              break\n                          a[y][x] = '.'\n                          t += 1\n                      a[0][0] = 'c'\n                      for s in a:\n                          print ''.join(s)\n                      return\n          print 'Impossible'\n  for t in xrange(int(raw_input())):\n      print \"Case #%d:\" % (t + 1)\n      solve()\n ", "Adversarial Code": " def  solving():\n      h, w, m = map(int, raw_input().split())\n      if h == 1:\n          print 'c' + '.' * (h * w - m - 1) + '*' * m\n      elif w == 1:\n          for c in 'c' + '.' * (h * w - m - 1) + '*' * m:\n              print c\n      elif h * w - m == 1:\n          print 'c' + '*' * (w - 1)\n          for _ in xrange(h-1):\n              print '*' * w\n      else:\n          m = h * w - m\n          for i in xrange(h-1):\n              for j in xrange(w-1):\n                  t = (i + 2) * 2 + (j + 2) * 2 - 4\n                  r = (i + 2) * (j + 2)\n                  if t <= m <= r:\n                      a = [['*'] * w for _ in xrange(h)]\n                      for k in xrange(i+2):\n                          a[k][0] = '.'\n                          a[k][1] = '.'\n                      for k in xrange(j+2):\n                          a[0][k] = '.'\n                          a[1][k] = '.'\n                      for y, x in product(range(2, i+2), range(2, j+2)):\n                          if y == 1 and x == 1:\n                              continue\n                          if t >= m:\n                              break\n                          a[y][x] = '.'\n                          t += 1\n                      a[0][0] = 'c'\n                      for s in a:\n                          print ''.join(s)\n                      return\n          print 'Impossible'\n  for t in xrange(int(raw_input())):\n      print \"Case #%d:\" % (t + 1)\n       solving()\n ", "Program Length": 349, "Identifier Num": 15, "Replaced Identifiers": "solve: solving,", "Query Times": 105, "Time Cost": 0.0522275964419047, "Type": "Greedy"}
{"Index": 3, "Original Code": null, "Adversarial Code": null, "Program Length": 146, "Identifier Num": 8, "Replaced Identifiers": null, "Query Times": 368, "Time Cost": 0.5950054287910461, "Type": "0"}
{"Index": 5, "Original Code": " \n  if __name__ == \"__main__\":\n  \tf = open( sys.argv[1] )\n  \tint(f.readline())\n  \t\t\n  \tnum = 1\n  \tl = f.readline()\n  \twhile l != \"\":\n  \t\trow1 = int(l)\n  \t\trows = [ f.readline() for x in range(4) ]\n  \t\trow1 = [int(x) for x in rows[row1-1].split()]\n  \n  \t\trow2 = int(f.readline())\n  \t\trows = [f.readline() for x in range(4)]\n  \t\trow2 = [int(x) for x in rows[row2-1].split()]\n  \n  \t\tresult = set(row1) & set(row2)\n  \t\tif len(result) == 1:\n  \t\t\toutput = str(result.pop())\n  \t\telif len(result) > 1:\n  \t\t\toutput = \"Bad magician!\"\n  \t\telse:\n  \t\t\toutput = \"Volunteer cheated!\"\n  \n  \t\tprint \"Case #\"+str(num)+\": \"+output\n  \t\tnum += 1\n  \t\tl = f.readline()\n  \t\t\n ", "Adversarial Code": " \n  if __name__ == \"__main__\":\n  \tfunction = open( sys.argv[1] )\n  \tint(function.readline())\n  \t\t\n  \tnum = 1\n  \tl = function.readline()\n  \twhile l != \"\":\n  \t\trow1 = int(l)\n  \t\trows = [ function.readline() for x in range(4) ]\n  \t\trow1 = [int(x) for x in rows[row1-1].split()]\n  \n  \t\trow2 = int(function.readline())\n  \t\trows = [function.readline() for x in range(4)]\n  \t\trow2 = [int(x) for x in rows[row2-1].split()]\n  \n  \t\tresult = set(row1) & set(row2)\n  \t\tif len(result) == 1:\n  \t\t\toutput = str(result.pop())\n  \t\telif len(result) > 1:\n  \t\t\toutput = \"Bad magician!\"\n  \t\telse:\n  \t\t\toutput = \"Volunteer cheated!\"\n  \n  \t\tprint \"Case #\"+str(num)+\": \"+output\n  \t\tnum += 1\n  \t\tl = function.readline()\n  \t\t\n ", "Program Length": 195, "Identifier Num": 9, "Replaced Identifiers": "f:function,", "Query Times": 97, "Time Cost": 0.050404584407806395, "Type": "Greedy"}
{"Index": 6, "Original Code": null, "Adversarial Code": null, "Program Length": 2012, "Identifier Num": 6, "Replaced Identifiers": null, "Query Times": 552, "Time Cost": 0.6643912712732951, "Type": "0"}
{"Index": 7, "Original Code": null, "Adversarial Code": null, "Program Length": 186, "Identifier Num": 10, "Replaced Identifiers": null, "Query Times": 529, "Time Cost": 0.8305768489837646, "Type": "0"}
{"Index": 8, "Original Code": "def make_string(R, C, M):\n      grid = [['.' for j in xrange(C)] for i in xrange(R)]\n      grid[-1][-1] = 'c'\n      t = M\n      for i in xrange(R):\n          for j in xrange(C):\n              if M:\n                  if forbidden(R, C, t, i, j):\n                      continue\n                  grid[i][j] = '*'\n                  M -= 1\n              else:\n                  break\n      s = ''\n      if M:\n          return 'Impossible'\n      for r in grid:\n          s += ''.join(r)+'\n'\n      return s[:-1]\n  \n  def forbidden(R, C, M, i, j):\n      a = M / C\n      b = M % C\n      if (R*C - M == 1):\n          return False\n  \n      if i >= (R-2) and j >= (C-2):\n          return True\n  \n      if i >= (R-2) and b:\n          if b % 2:\n              return True\n          if j < b/2:\n              return False\n          else:\n              return True\n      return False\n          \n  \n  f = open('Csmall.in', 'r')\n  g = open('outputC.txt', 'w')\n  \n  data = [[int(e) for e in line.strip(\"\n\").split(' ')] for line in f]\n  T = int(data.pop(0)[0])\n  for i, case in enumerate(data):\n      R, C, M = case[0], case[1], case[2]\n      num_cells = R*C\n      if (R-1) == 0 or (C-1) == 0:\n          s = make_string(R, C, M)\n          g.write('Case #%i:\n%s\n' %(i+1,s))\n          continue\n      else:\n          s = make_string(R, C, M)\n          g.write('Case #%i:\n%s\n' %(i+1, s))\n          \n  \n  f.close()\n  g.close()\n ", "Adversarial Code": "def makepystring(R, C, ME):\n      grid = [['.' for j in xrange(C)] for i in xrange(R)]\n      grid[-1][-1] = 'c'\n      t = ME\n      for i in xrange(R):\n          for j in xrange(C):\n              if ME:\n                  if forbidden(R, C, t, i, j):\n                      continue\n                  grid[i][j] = '*'\n                  ME -= 1\n              else:\n                  break\n      s = ''\n      if ME:\n          return 'Impossible'\n      for r in grid:\n          s += ''.join(r)+'\n'\n      return s[:-1]\n  \n  def forbidden(R, C, ME, i, j):\n      a = ME / C\n      b = ME % C\n      if (R*C - ME == 1):\n          return False\n  \n      if i >= (R-2) and j >= (C-2):\n          return True\n  \n      if i >= (R-2) and b:\n          if b % 2:\n              return True\n          if j < b/2:\n              return False\n          else:\n              return True\n      return False\n          \n  \n  f = open('Csmall.in', 'r')\n  g = open('outputC.txt', 'w')\n  \n  data = [[int(e) for e in line.strip(\"\n\").split(' ')] for line in f]\n  T = int(data.pop(0)[0])\n  for i, case in enumerate(data):\n      R, C, ME = case[0], case[1], case[2]\n      num_cells = R*C\n      if (R-1) == 0 or (C-1) == 0:\n          s = makepystring(R, C, ME)\n          g.write('Case #%i:\n%s\n' %(i+1,s))\n          continue\n      else:\n          s = makepystring(R, C, ME)\n          g.write('Case #%i:\n%s\n' %(i+1, s))\n          \n  \n  f.close()\n  g.close()\n ", "Program Length": 392, "Identifier Num": 21, "Replaced Identifiers": "M:ME,make_string:makepystring,", "Query Times": 196, "Time Cost": 0.09085541566212972, "Type": "Greedy"}
{"Index": 9, "Original Code": null, "Adversarial Code": null, "Program Length": 240, "Identifier Num": 16, "Replaced Identifiers": null, "Query Times": 795, "Time Cost": 1.2762864311536153, "Type": "0"}
{"Index": 10, "Original Code": " \n  if __name__ == \"__main__\":\n      f = sys.stdin\n      if len(sys.argv) >= 2:\n          fn = sys.argv[1]\n          if fn != '-':\n              f = open(fn)\n  \n      T = int(f.readline())\n      for _T in xrange(T):\n          R, C, M = map(int, f.readline().split())\n  \n          print \"Case #%d:\" % (_T+1)\n  \n          left = R * C - M\n  \n          if R == 1:\n              s = 'c'\n              s += '.' * (left - 1)\n              s += '*' * M\n              print s\n              continue\n          if C == 1:\n              print 'c'\n              for i in xrange(left - 1):\n                  print '.'\n              for i in xrange(M):\n                  print '*'\n              continue\n  \n          if left == 1:\n              print 'c' + '*' * (C-1)\n              for i in xrange(R-1):\n                  print '*' * C\n              continue\n  \n          if (R == 2 or C == 2) and (M % 2 == 1 or left == 2):\n              print \"Impossible\"\n              continue\n          if R == 2:\n              assert left not in (2, 3, 5, 7)\n              assert left >= 4\n              print 'c' + '.' * (left/2 - 1) + '*' * (M/2)\n              print '.' + '.' * (left/2 - 1) + '*' * (M/2)\n              continue\n          if C == 2:\n              assert left >= 4\n              assert left not in (2, 3, 5, 7)\n              print 'c.'\n              left -= 2\n              R -= 1\n              while left:\n                  print '..'\n                  left -= 2\n                  R -= 1\n              assert R >= 0\n              while R:\n                  print '**'\n                  R -= 1\n              continue\n  \n          assert R >= 3\n          assert C >= 3\n  \n          if left == 4:\n              print 'c.' + '*' * (C-2)\n              print '..' + '*' * (C-2)\n              for i in xrange(R-2):\n                  print '*' * C\n              continue\n  \n          if left in (2, 3, 5, 7):\n              print \"Impossible\"\n              continue\n  \n          assert left >= 6\n  \n          cols = max(3, (left + R-1) // R)\n  \n          if left % cols == 1:\n              assert left >= 10\n  \n              print 'c' + '.' * (cols - 1) + '*' * (C - cols)\n              left -= cols\n              R -= 1\n  \n              while left > cols + 1:\n                  print '.' * cols + '*' * (C - cols)\n                  left -= cols\n                  R -= 1\n              assert left == cols + 1\n              print '.' * (cols - 1) + '*' * (C - cols + 1)\n              print '.' * (2) + '*' * (C - 2)\n              R -= 2\n  \n              assert R >= 0\n  \n              while R:\n                  print '*' * C\n                  R -= 1\n              continue\n          else:\n              assert left >= 6\n  \n              print 'c' + '.' * (cols - 1) + '*' * (C - cols)\n              left -= cols\n              R -= 1\n  \n              while left > cols:\n                  print '.' * cols + '*' * (C - cols)\n                  left -= cols\n                  R -= 1\n              assert left >= 2\n              print '.' * (left) + '*' * (C - left)\n              R -= 1\n  \n              assert R >= 0\n  \n              while R:\n                  print '*' * C\n                  R -= 1\n              continue\n  \n          1/0\n ", "Adversarial Code": " \n  if __name__ == \"__main__\":\n      f = sys.stdin\n      if len(sys.argv) >= 2:\n          function = sys.argv[1]\n          if function != '-':\n              f = open(function)\n  \n      T = int(f.readline())\n      for _T in xrange(T):\n          R, C, M = map(int, f.readline().split())\n  \n          print \"Case #%d:\" % (_T+1)\n  \n          left = R * C - M\n  \n          if R == 1:\n              s = 'c'\n              s += '.' * (left - 1)\n              s += '*' * M\n              print s\n              continue\n          if C == 1:\n              print 'c'\n              for i in xrange(left - 1):\n                  print '.'\n              for i in xrange(M):\n                  print '*'\n              continue\n  \n          if left == 1:\n              print 'c' + '*' * (C-1)\n              for i in xrange(R-1):\n                  print '*' * C\n              continue\n  \n          if (R == 2 or C == 2) and (M % 2 == 1 or left == 2):\n              print \"Impossible\"\n              continue\n          if R == 2:\n              assert left not in (2, 3, 5, 7)\n              assert left >= 4\n              print 'c' + '.' * (left/2 - 1) + '*' * (M/2)\n              print '.' + '.' * (left/2 - 1) + '*' * (M/2)\n              continue\n          if C == 2:\n              assert left >= 4\n              assert left not in (2, 3, 5, 7)\n              print 'c.'\n              left -= 2\n              R -= 1\n              while left:\n                  print '..'\n                  left -= 2\n                  R -= 1\n              assert R >= 0\n              while R:\n                  print '**'\n                  R -= 1\n              continue\n  \n          assert R >= 3\n          assert C >= 3\n  \n          if left == 4:\n              print 'c.' + '*' * (C-2)\n              print '..' + '*' * (C-2)\n              for i in xrange(R-2):\n                  print '*' * C\n              continue\n  \n          if left in (2, 3, 5, 7):\n              print \"Impossible\"\n              continue\n  \n          assert left >= 6\n  \n          cols = max(3, (left + R-1) // R)\n  \n          if left % cols == 1:\n              assert left >= 10\n  \n              print 'c' + '.' * (cols - 1) + '*' * (C - cols)\n              left -= cols\n              R -= 1\n  \n              while left > cols + 1:\n                  print '.' * cols + '*' * (C - cols)\n                  left -= cols\n                  R -= 1\n              assert left == cols + 1\n              print '.' * (cols - 1) + '*' * (C - cols + 1)\n              print '.' * (2) + '*' * (C - 2)\n              R -= 2\n  \n              assert R >= 0\n  \n              while R:\n                  print '*' * C\n                  R -= 1\n              continue\n          else:\n              assert left >= 6\n  \n              print 'c' + '.' * (cols - 1) + '*' * (C - cols)\n              left -= cols\n              R -= 1\n  \n              while left > cols:\n                  print '.' * cols + '*' * (C - cols)\n                  left -= cols\n                  R -= 1\n              assert left >= 2\n              print '.' * (left) + '*' * (C - left)\n              R -= 1\n  \n              assert R >= 0\n  \n              while R:\n                  print '*' * C\n                  R -= 1\n              continue\n  \n          1/0\n ", "Program Length": 612, "Identifier Num": 11, "Replaced Identifiers": "fn:function,", "Query Times": 173, "Time Cost": 0.07645716667175292, "Type": "Greedy"}
{"Index": 11, "Original Code": " \n  if __name__ == \"__main__\":\n      f = sys.stdin\n      if len(sys.argv) >= 2:\n          fn = sys.argv[1]\n          if fn != '-':\n              f = open(fn)\n  \n      T = int(f.readline())\n      for _T in xrange(T):\n          a1 = int(f.readline())\n          l1 = [map(int, f.readline().split()) for _ in xrange(4)]\n          a2 = int(f.readline())\n          l2 = [map(int, f.readline().split()) for _ in xrange(4)]\n  \n          poss = list(set(l1[a1-1]) & set(l2[a2-1]))\n  \n          print \"Case #%d:\" % (_T + 1),\n          if len(poss) == 0:\n              print \"Volunteer cheated!\"\n          elif len(poss) == 1:\n              print poss[0]\n          else:\n              print \"Bad magician!\"\n ", "Adversarial Code": " \n  if __name__ == \"__main__\":\n      f = sys.stdin\n      if len(sys.argv) >= 2:\n          function = sys.argv[1]\n          if function != '-':\n              f = open(function)\n  \n      T = int(f.readline())\n      for _T in xrange(T):\n          a1 = int(f.readline())\n          l1 = [map(int, f.readline().split()) for _ in xrange(4)]\n          a2 = int(f.readline())\n          l2 = [map(int, f.readline().split()) for _ in xrange(4)]\n  \n          poss = list(set(l1[a1-1]) & set(l2[a2-1]))\n  \n          print \"Case #%d:\" % (_T + 1),\n          if len(poss) == 0:\n              print \"Volunteer cheated!\"\n          elif len(poss) == 1:\n              print poss[0]\n          else:\n              print \"Bad magician!\"\n ", "Program Length": 187, "Identifier Num": 10, "Replaced Identifiers": "fn:function,", "Query Times": 81, "Time Cost": 0.048071583112080894, "Type": "Greedy"}
{"Index": 13, "Original Code": " \n  \n  TEST_CASES = [\n      (\"\"\"3\n  2\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  3\n  1 2 5 4\n  3 11 6 15\n  9 10 7 12\n  13 14 8 16\n  2\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  2\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  2\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  3\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  \"\"\",\"\"\"Case #1: 7\n  Case #2: Bad magician!\n  Case #3: Volunteer cheated!\n  \"\"\"),\n      (\"\"\"1\n  1\n  15 9 16 5\n  6 10 1 3\n  2 4 12 11\n  13 14 8 7\n  1\n  5 10 9 6\n  12 15 1 11\n  14 16 4 2\n  13 3 8 7\"\"\",\"\"\"Case #1: Bad magician!\n  \"\"\")\n  ]\n  \n  BAD_MAGIC = \"Bad magician!\"\n  CHEATING = \"Volunteer cheated!\"\n  \n  def parse_input(input_reader):\n      case_count = int(input_reader.readline())\n      case_idx = 0\n      while case_count > case_idx:\n          case_idx += 1\n          rows = []\n          for loop_idx in (1,2):\n              row_idx = int(input_reader.readline())\n              for idx in (1,2,3,4):\n                  if idx == row_idx:\n                      rows.append(set(input_reader.readline().rstrip(\"\n\").split(\" \")))\n                  else:\n                      input_reader.readline()\n          input_values = {\"rows\":rows,\n                          \"case\":case_idx}\n          yield input_values\n  \n  \n  def solve_problem(output_writer=sys.stdout, **kwargs):\n      rows = kwargs['rows']\n      case = kwargs['case']\n      intersect = rows[0].intersection(rows[1])\n      if not intersect:\n          msg = CHEATING\n      elif len(intersect) == 1:\n          msg = intersect.pop()\n      else:\n          msg = BAD_MAGIC\n      print >>output_writer, \"Case #%d: %s\" % (case, msg)\n  \n  def solve_inputs(input_reader, output_writer):\n      \"\"\"\n      Loop through each problem input in input reader and solve it.\n  \n      Outputs responses to output_writer.\n      \"\"\"\n      for input_values in parse_input(input_reader):\n          solve_problem(output_writer=output_writer, **input_values)\n  \n  def run_tests():\n      \"\"\"\n      Check the sample input and output match.\n      \"\"\"\n      idx = 0\n      all_pass = True\n      for problem_input, expected_output in TEST_CASES:\n          idx += 1\n          input_reader = StringIO(problem_input)\n          output_writer = StringIO()\n          solve_inputs(input_reader, output_writer)\n          problem_output = output_writer.getvalue()\n          if problem_output == expected_output:\n              print \"Test %d: Success\" % idx\n          else:\n              all_pass = False\n              print \"Test %d: Failure\" % idx\n          input_reader.close()\n          output_writer.close()\n      if all_pass:\n          print \"All tests were successful!\"\n      else:\n          print \"Something didn't match - try again.\"\n          print problem_output\n  \n  def main():\n      parser = OptionParser()\n      parser.add_option(\"-f\", \"--file\",\n                        dest=\"filename_stem\",\n                        help=\"read input from FILE.in and write to FILE.out\",\n                        metavar=\"FILE\")\n  \n      (options, args) = parser.parse_args()\n      if options.filename_stem:\n          print \"Running in file mode.\"\n          input_reader = open(\"%s.in\" % options.filename_stem, \"r\")\n          output_writer = open(\"%s.out\" % options.filename_stem, \"w\")\n          solve_inputs(input_reader, output_writer)\n      else:\n          print \"Running in test mode.\"\n          run_tests()\n  \n  if __name__ == \"__main__\":\n      main()\n ", "Adversarial Code": " \n  \n  TEST_CASES = [\n      (\"\"\"3\n  2\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  3\n  1 2 5 4\n  3 11 6 15\n  9 10 7 12\n  13 14 8 16\n  2\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  2\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  2\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  3\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  \"\"\",\"\"\"Case #1: 7\n  Case #2: Bad magician!\n  Case #3: Volunteer cheated!\n  \"\"\"),\n      (\"\"\"1\n  1\n  15 9 16 5\n  6 10 1 3\n  2 4 12 11\n  13 14 8 7\n  1\n  5 10 9 6\n  12 15 1 11\n  14 16 4 2\n  13 3 8 7\"\"\",\"\"\"Case #1: Bad magician!\n  \"\"\")\n  ]\n  \n  BAD_MAGIC = \"Bad magician!\"\n  CHEATING = \"Volunteer cheated!\"\n  \n  def pack_input(inputFilewriter):\n      case_count = int(inputFilewriter.readline())\n      case_idy = 0\n      while case_count > case_idy:\n          case_idy += 1\n          rows = []\n          for loop_idx in (1,2):\n              row_idy = int(inputFilewriter.readline())\n              for idx in (1,2,3,4):\n                  if idx == row_idy:\n                      rows.append(set(inputFilewriter.readline().rstrip(\"\n\").split(\" \")))\n                  else:\n                      inputFilewriter.readline()\n          input_values = {\"rows\":rows,\n                          \"case\":case_idy}\n          yield input_values\n  \n  \n  def solve_problem(output_writer=sys.stdout, **kwargs):\n      rows = kwargs['rows']\n      case = kwargs['case']\n      intersect = rows[0].intersection(rows[1])\n      if not intersect:\n          msg = CHEATING\n      elif len(intersect) == 1:\n          msg = intersect.pop()\n      else:\n          msg = BAD_MAGIC\n      print >>output_writer, \"Case #%d: %s\" % (case, msg)\n  \n  def solve_inputs(inputFilewriter, output_writer):\n      \"\"\"\n      Loop through each problem input in input reader and solve it.\n  \n      Outputs responses to output_writer.\n      \"\"\"\n      for input_values in pack_input(inputFilewriter):\n          solve_problem(output_writer=output_writer, **input_values)\n  \n  def run_tests():\n      \"\"\"\n      Check the sample input and output match.\n      \"\"\"\n      idx = 0\n      all_pass = True\n      for problem_input, expected_output in TEST_CASES:\n          idx += 1\n          inputFilewriter = StringIO(problem_input)\n          output_writer = StringIO()\n          solve_inputs(inputFilewriter, output_writer)\n          problem_output = output_writer.getvalue()\n          if problem_output == expected_output:\n              print \"Test %d: Success\" % idx\n          else:\n              all_pass = False\n              print \"Test %d: Failure\" % idx\n          inputFilewriter.close()\n          output_writer.close()\n      if all_pass:\n          print \"All tests were successful!\"\n      else:\n          print \"Something didn't match - try again.\"\n          print problem_output\n  \n  def main():\n      parser = OptionParser()\n      parser.add_option(\"-f\", \"--file\",\n                        dest=\"filename_stem\",\n                        help=\"read input from FILE.in and write to FILE.out\",\n                        metavar=\"FILE\")\n  \n      (options, args) = parser.parse_args()\n      if options.filename_stem:\n          print \"Running in file mode.\"\n          inputFilewriter = open(\"%s.in\" % options.filename_stem, \"r\")\n          output_writer = open(\"%s.out\" % options.filename_stem, \"w\")\n          solve_inputs(inputFilewriter, output_writer)\n      else:\n          print \"Running in test mode.\"\n          run_tests()\n  \n  if __name__ == \"__main__\":\n      main()\n ", "Program Length": 406, "Identifier Num": 18, "Replaced Identifiers": "case_idx:case_idy,parse_input:pack_input,output_writer:output_writer,input_values:input_values,row_idx:row_idy,input_reader:inputFilewriter,", "Query Times": 271, "Time Cost": 0.15582356850306192, "Type": "Greedy"}
{"Index": 14, "Original Code": null, "Adversarial Code": null, "Program Length": 510, "Identifier Num": 21, "Replaced Identifiers": null, "Query Times": 1249, "Time Cost": 1.7780942797660828, "Type": "0"}
{"Index": 15, "Original Code": null, "Adversarial Code": null, "Program Length": 306, "Identifier Num": 23, "Replaced Identifiers": null, "Query Times": 1255, "Time Cost": 1.906643009185791, "Type": "0"}
{"Index": 17, "Original Code": " \n  def solve_case(answers, arrangements_of_cards, case_number):\n      first_candidates = arrangements_of_cards[0][answers[0] - 1]\n      second_candidates = arrangements_of_cards[1][answers[1] - 1]\n      answer = set(first_candidates) & set(second_candidates)\n      length_of_answer = len(answer)\n      if length_of_answer > 1:\n          print \"Case #%d: Bad magician!\" % case_number\n      elif length_of_answer < 1:\n          print \"Case #%d: Volunteer cheated!\" % case_number\n      else:\n          print \"Case #%d: %d\" % (case_number, answer.pop())\n  \n  r = sys.stdin\n  \n  if len(sys.argv) > 1:\n      r = open(sys.argv[1], 'r')\n  \n  total_cases = r.readline()\n  for case_number in range(1, int(total_cases) + 1):\n      answers = []\n      arrangements_of_cards = []\n      answers.append(int(r.readline()))\n      arrangements_of_cards.append([])\n      for row in range(0, 4):\n          arrangements_of_cards[0].append(map(int, r.readline().split(' ')))\n      answers.append(int(r.readline()))\n      arrangements_of_cards.append([])\n      for row in range(0, 4):\n          arrangements_of_cards[1].append(map(int, r.readline().split(' ')))\n      solve_case(answers, arrangements_of_cards, case_number)\n ", "Adversarial Code": " \n  def solving_choice(oldswers, arrangements_of_cards, example_language):\n      first_candidates = arrangements_of_cards[0][oldswers[0] - 1]\n      second_candidates = arrangements_of_cards[1][oldswers[1] - 1]\n      answer = set(first_candidates) & set(second_candidates)\n      length_of_answer = len(answer)\n      if length_of_answer > 1:\n          print \"Case #%d: Bad magician!\" % example_language\n      elif length_of_answer < 1:\n          print \"Case #%d: Volunteer cheated!\" % example_language\n      else:\n          print \"Case #%d: %d\" % (example_language, answer.pop())\n  \n  f = sys.stdin\n  \n  if len(sys.argv) > 1:\n      f = open(sys.argv[1], 'r')\n  \n  total00tests = f.readline()\n  for example_language in range(1, int(total00tests) + 1):\n      oldswers = []\n      arrangements_of_cards = []\n      oldswers.append(int(f.readline()))\n      arrangements_of_cards.append([])\n      for rown in range(0, 4):\n          arrangements_of_cards[0].append(map(int, f.readline().split(' ')))\n      oldswers.append(int(f.readline()))\n      arrangements_of_cards.append([])\n      for rown in range(0, 4):\n          arrangements_of_cards[1].append(map(int, f.readline().split(' ')))\n      solving_choice(oldswers, arrangements_of_cards, example_language)\n ", "Program Length": 259, "Identifier Num": 11, "Replaced Identifiers": "case_number:example_language,solve_case:solving_choice,r:f,answers:oldswers,row:rown,total_cases:total00tests,", "Query Times": 381, "Time Cost": 0.18017831246058147, "Type": "Greedy"}
{"Index": 19, "Original Code": " \n  \n  def compute(r1, m1, r2, m2):\n      valid1 = set(m1[r1 - 1])\n      valid2 = set(m2[r2 - 1])\n      valid = valid1 & valid2\n      if len(valid) == 0:\n          return 'Volunteer cheated!'\n      if len(valid) > 1:\n          return 'Bad magician!'\n      return valid.pop()\n  \n  \n  def parse_single():\n      r = int(sys.stdin.readline().strip())\n      m = []\n      for i in xrange(4):\n          m.append(map(int, sys.stdin.readline().strip().split()))\n      return r, m\n  \n  def parse():\n      r1, m1 = parse_single()\n      r2, m2 = parse_single()\n      return r1, m1, r2, m2\n  \n  \n  if __name__ == \"__main__\":\n      sys.setrecursionlimit(100000)\n      T = int(sys.stdin.readline().strip())\n      for i in xrange(T):\n          data = parse()\n          result = compute(*data)\n          print \"Case #%d: %s\" % (i + 1, result)\n ", "Adversarial Code": " \n  \n  def compute(r1, r0, dr1, m2):\n      valid1 = set(r0[r1 - 1])\n      valid2 = set(m2[dr1 - 1])\n      failed = valid1 & valid2\n      if len(failed) == 0:\n          return 'Volunteer cheated!'\n      if len(failed) > 1:\n          return 'Bad magician!'\n      return failed.pop()\n  \n  \n  def parse2multi():\n      nr = int(sys.stdin.readline().strip())\n      m = []\n      for i in xrange(4):\n          m.append(map(int, sys.stdin.readline().strip().split()))\n      return nr, m\n  \n  def process():\n      r1, r0 = parse2multi()\n      dr1, m2 = parse2multi()\n      return r1, r0, dr1, m2\n  \n  \n  if __name__ == \"__main__\":\n      sys.setrecursionlimit(100000)\n      T = int(sys.stdin.readline().strip())\n      for i in xrange(T):\n          response = process()\n          obj = compute(*response)\n          print \"Case #%d: %s\" % (i + 1, obj)\n ", "Program Length": 211, "Identifier Num": 16, "Replaced Identifiers": "valid:failed,data:response,result:obj,m1:r0,parse:process,r2:dr1,parse_single:parse2multi,r:nr,", "Query Times": 365, "Time Cost": 0.1975997765858968, "Type": "Greedy"}
{"Index": 20, "Original Code": " \n  def read_line():\n      return sys.stdin.readline().rstrip( '\n' )\n  \n  def read_integer():\n      return int( read_line() )\n  \n  def read_integers():\n      return [ int( x ) for x in read_line().split() ]\n  \n  def flip( grid ):\n      return [ bytearray( ''.join( chr( grid[ row ][ column ] ) for row in range( len( grid ) ) ) ) for column in range( len( grid[ 0 ] ) ) ]\n  \n  def grow( R, C, M ):\n      grid = [ bytearray( C*[ '*' ] ) for row in range( R ) ]\n      b = R*C - M\n      if C > R:\n          R, C, grid = C, R, flip( grid )\n          flipped = True\n      else:\n          flipped = False\n      if b < 2*C:\n          if b == 1:\n              grid[ 0 ][ 0 ] = 'c'\n          elif b == 3 and C >= 3:\n              grid[ 0 ][ : 3 ] = bytearray( '.c.' )\n          elif b % 2:\n              return\n          else:\n              grid[ 0 ][ : b//2 ] = bytearray( b//2*'.' )\n              grid[ 1 ][ : b//2 ] = bytearray( b//2*'.' )\n              grid[ 0 ][ 0 ] = 'c'\n      else:\n          r = 0\n          while b >= C:\n              grid[ r ] = bytearray( C*[ '.' ] )\n              b -= C\n              r += 1\n          if b:\n              if b >= 2:\n                  grid[ r ][ : b ] = b*'.'\n              elif C > 2 and r > 2:\n                  grid[ r - 1 ][ -1 ] = '*'\n                  grid[ r ][ : 2 ] = '..'\n              else:\n                  return\n          grid[ 0 ][ 0 ] = 'c'\n      return flip( grid ) if flipped else grid\n      \n  T = read_integer()\n  for t in range( T ):\n      print 'Case #%i:' % ( t + 1 )\n      R, C, M = read_integers()\n      grid = grow( R, C, M )\n      print '\n'.join( str( row ) for row in grid ) if grid else 'Impossible'\n ", "Adversarial Code": " \n  def write_file():\n      return sys.stdin.readline().rstrip( '\n' )\n  \n  def read64enum():\n      return int( write_file() )\n  \n  def readallnumERS():\n      return [ int( f ) for f in write_file().split() ]\n  \n  def FLipping( grid ):\n      return [ bytearray( ''.join( chr( grid[ model ][ pixel ] ) for model in range( len( grid ) ) ) ) for pixel in range( len( grid[ 0 ] ) ) ]\n  \n  def pack( RA, C, W ):\n      grid = [ bytearray( C*[ '*' ] ) for model in range( RA ) ]\n      nb = RA*C - W\n      if C > RA:\n          RA, C, grid = C, RA, FLipping( grid )\n           floped = True\n      else:\n           floped = False\n      if nb < 2*C:\n          if nb == 1:\n              grid[ 0 ][ 0 ] = 'c'\n          elif nb == 3 and C >= 3:\n              grid[ 0 ][ : 3 ] = bytearray( '.c.' )\n          elif nb % 2:\n              return\n          else:\n              grid[ 0 ][ : nb//2 ] = bytearray( nb//2*'.' )\n              grid[ 1 ][ : nb//2 ] = bytearray( nb//2*'.' )\n              grid[ 0 ][ 0 ] = 'c'\n      else:\n          r = 0\n          while nb >= C:\n              grid[ r ] = bytearray( C*[ '.' ] )\n              nb -= C\n              r += 1\n          if nb:\n              if nb >= 2:\n                  grid[ r ][ : nb ] = nb*'.'\n              elif C > 2 and r > 2:\n                  grid[ r - 1 ][ -1 ] = '*'\n                  grid[ r ][ : 2 ] = '..'\n              else:\n                  return\n          grid[ 0 ][ 0 ] = 'c'\n      return FLipping( grid ) if  floped else grid\n      \n  T = read64enum()\n  for t in range( T ):\n      print 'Case #%i:' % ( t + 1 )\n      RA, C, W = readallnumERS()\n      grid = pack( RA, C, W )\n      print '\n'.join( str( model ) for model in grid ) if grid else 'Impossible'\n ", "Program Length": 406, "Identifier Num": 17, "Replaced Identifiers": "read_line:write_file,read_integer:read64enum,grow:pack,t:t,T:T,r:r,column:pixel,row:model,flip:FLipping,flipped: floped,b:nb,read_integers:readallnumERS,M:W,x:f,R:RA,", "Query Times": 656, "Time Cost": 0.3455590605735779, "Type": "Greedy"}
{"Index": 21, "Original Code": " \n  def read_line():\n      return sys.stdin.readline().rstrip( '\n' )\n  \n  def read_integer():\n      return int( read_line() )\n  \n  def read_integers():\n      return [ int( x ) for x in read_line().split() ]\n  \n  def read_string():\n      return read_line().strip()\n  \n  def read_strings():\n      return read_line().split()\n  \n  def input_string_stack():\n      data = []\n      for line in sys.stdin.readlines():\n          data.extend( line.split() )\n      data.reverse()\n      return data\n  \n  def input_integer_stack():\n      return [ int( x ) for x in read_string_stack() ]\n  \n  class memoized( object ):\n     def __init__( self, function ):\n        self.function = function\n        self.cache = {}\n     def __call__( self, *arguments ):\n        try:\n           return self.cache[ arguments ]\n        except KeyError:\n           value = self.function( *arguments )\n           self.cache[ arguments ] = value\n           return value\n  \n  T = read_integer()\n  for t in range( T ):\n      row = read_integer()\n      candidates = set( [ read_integers() for index in range( 4 ) ][ row - 1 ] )\n      row = read_integer()\n      candidates &= set( [ read_integers() for index in range( 4 ) ][ row - 1 ] )\n      print 'Case #%i:' % ( t + 1 ), candidates.pop() if len( candidates ) == 1 else 'Bad magician!' if len( candidates ) > 1 else 'Volunteer cheated!'\n ", "Adversarial Code": " \n  def readamfile():\n      return sys.stdin.readline().rstrip( '\n' )\n  \n  def read_integer():\n      return int( readamfile() )\n  \n  def readableintegeters():\n      return [ int( x ) for x in readamfile().split() ]\n  \n  def readingnumber():\n      return readamfile().strip()\n  \n  def read_packs():\n      return readamfile().split()\n  \n  def input_string2stream():\n      data = []\n      for line in sys.stdin.readlines():\n          data.extend( line.split() )\n      data.reverse()\n      return data\n  \n  def input_integer_array():\n      return [ int( x ) for x in read_string_stack() ]\n  \n  class memoized( object ):\n     def __init____( self, file ):\n        self.file = file\n        self.array = {}\n     def __init___( self, *argsuration ):\n        try:\n           return self.array[ argsuration ]\n        except KeyError:\n           Value = self.file( *argsuration )\n           self.array[ argsuration ] = Value\n           return Value\n  \n  TN = read_integer()\n  for tt in range( TN ):\n      row = read_integer()\n      candidates = set( [ readableintegeters() for where in range( 4 ) ][ row - 1 ] )\n      row = read_integer()\n      candidates &= set( [ readableintegeters() for where in range( 4 ) ][ row - 1 ] )\n      print 'Case #%i:' % ( tt + 1 ), candidates.pop() if len( candidates ) == 1 else 'Bad magician!' if len( candidates ) > 1 else 'Volunteer cheated!'\n ", "Program Length": 297, "Identifier Num": 22, "Replaced Identifiers": "read_line:readamfile,read_strings:read_packs,function:file,read_string:readingnumber,read_integers:readableintegeters,input_integer_stack:input_integer_array,T:TN,index:where,cache:array,t:tt,__init__:__init____,input_string_stack:input_string2stream,__call__:__init___,value:Value,arguments:argsuration,", "Query Times": 510, "Time Cost": 0.3039072910944621, "Type": "Greedy"}
{"Index": 22, "Original Code": null, "Adversarial Code": null, "Program Length": 765, "Identifier Num": 17, "Replaced Identifiers": null, "Query Times": 1235, "Time Cost": 1.6266075174013774, "Type": "0"}
{"Index": 23, "Original Code": null, "Adversarial Code": null, "Program Length": 174, "Identifier Num": 9, "Replaced Identifiers": null, "Query Times": 451, "Time Cost": 0.7945874691009521, "Type": "0"}
{"Index": 24, "Original Code": " \n  \n  \n  def show_board(board):\n      for row in board:\n          print ''.join(row)\n  \n  \n  N = int(sys.stdin.readline())\n  \n  for T in range(1, N+1):\n      (R, C, M) = map(int, sys.stdin.readline().split(' '))\n      E = R*C-M # empty\n      possible, reverse, need_adjust, column_base = (False, False, False, False)\n      if C > R:\n          (R, C) = (C, R)\n          reverse = True\n  \n      W = 0\n      lastRow = 0\n      if E == 0:\n          pass\n      elif E == 1 or M == 0:\n          W = C\n          possible = True\n      elif C == 1:\n          W = 1\n          if E > 0:\n              possible = True\n      elif C == 2:\n          W = 2\n          lastRow = int(E / 2) + 1   # 1 base\n          if E % 2 == 0 and E >= 4:\n              possible = True\n      elif C >= 3:\n          for w in range(2, C+1):\n              lastRow = int(E / w) + 1   # 1 base\n              if lastRow > R: continue\n              lastRowNum = E % w\n              \n              if lastRow == 2 and lastRowNum == 0:\n                  pass\n              elif lastRow == 2:   # lastRow == 1 => impossible\n                  if lastRowNum == 0:\n                      W = w\n                      possible = True\n                      break\n              elif lastRow >= 3:\n                  if lastRowNum >= 2 or lastRowNum == 0:\n                      W = w\n                      possible = True\n                      break\n                  elif C >= 4 and lastRowNum == 1 and R >= 3:\n                      W = w\n                      possible = True\n                      need_adjust = True\n                      break\n          if not possible:\n              for w in range(2, R+1):\n                  lastRow = int(E / w) + 1   # 1 base\n                  if lastRow > R: continue\n                  lastRowNum = E % w\n                  if lastRow == 2 and lastRowNum == 0:\n                      pass\n                  elif lastRow == 2:   # lastRow == 1 => impossible\n                      if lastRowNum == 0:\n                          W = w\n                          possible = True\n                          column_base = True\n                          break\n                  elif lastRow >= 3:\n                      if lastRowNum >= 2 or lastRowNum == 0:\n                          W = w\n                          possible = True\n                          column_base = True\n                          break\n                      elif C >= 4 and lastRowNum == 1 and R >= 3:\n                          W = w\n                          possible = True\n                          need_adjust = True\n                          column_base = True\n                          break\n                                  \n      if not possible:\n          if reverse:\n              R, C = (C, R)        \n          ans = 'Impossible %sx%s M=%s' % (R, C, M)\n          print 'Case #%(T)s: %(ans)s' % locals()\n          continue\n  \n      board = [['*'] * C for i in range(R)]\n      for i in range(E):\n          if not column_base:\n              c = i % W\n              r = i / W\n          else:\n              r = i % W\n              c = i / W            \n          board[r][c] = '.'\n      if need_adjust:\n          board[lastRow-1][1], board[lastRow-2][-1] = board[lastRow-2][-1], board[lastRow-1][1]\n      if reverse:\n          board = map(list, zip(*board))\n          R, C = (C, R)\n  \n      clicked = False\n      for r in range(R):\n          if clicked: break\n          for c in range(C):\n              cell = board[r][c]\n              if cell != '.': continue\n              if E == 1:\n                  board[r][c] = 'c'\n                  clicked = True\n                  break\n              \n              if r >= 1  and c >= 1  and board[r-1][c-1] == '*': continue\n              if r >= 1              and board[r-1][c]   == '*': continue\n              if r >= 1  and c < C-1 and board[r-1][c+1] == '*': continue\n              if             c >= 1  and board[r][c-1]   == '*': continue\n              if             c < C-1 and board[r][c+1]   == '*': continue\n              if r < R-1 and c >= 1  and board[r+1][c-1] == '*': continue\n              if r < R-1             and board[r+1][c]   == '*': continue\n              if r < R-1 and c < C-1 and board[r+1][c+1] == '*': continue\n              board[r][c] = 'c'\n              clicked = True\n              break\n  \n      ans = 'Possible' if possible else 'Impossible'\n      print 'Case #%(T)s:' % locals()\n      show_board(board)\n ", "Adversarial Code": " \n  \n  \n  def show_board(board):\n      for ow in board:\n          print ''.join(ow)\n  \n  \n  N = int(sys.stdin.readline())\n  \n  for I in range(1, N+1):\n      (R, C, M) = map(int, sys.stdin.readline().split(' '))\n      E = R*C-M # empty\n      lpossible, original, know_change, attribute64base = (False, False, False, False)\n      if C > R:\n          (R, C) = (C, R)\n          original = True\n  \n      W = 0\n      variablerow = 0\n      if E == 0:\n          pass\n      elif E == 1 or M == 0:\n          W = C\n          lpossible = True\n      elif C == 1:\n          W = 1\n          if E > 0:\n              lpossible = True\n      elif C == 2:\n          W = 2\n          variablerow = int(E / 2) + 1   # 1 base\n          if E % 2 == 0 and E >= 4:\n              lpossible = True\n      elif C >= 3:\n          for w in range(2, C+1):\n              variablerow = int(E / w) + 1   # 1 base\n              if variablerow > R: continue\n              lastRowNum = E % w\n              \n              if variablerow == 2 and lastRowNum == 0:\n                  pass\n              elif variablerow == 2:   # lastRow == 1 => impossible\n                  if lastRowNum == 0:\n                      W = w\n                      lpossible = True\n                      break\n              elif variablerow >= 3:\n                  if lastRowNum >= 2 or lastRowNum == 0:\n                      W = w\n                      lpossible = True\n                      break\n                  elif C >= 4 and lastRowNum == 1 and R >= 3:\n                      W = w\n                      lpossible = True\n                      know_change = True\n                      break\n          if not lpossible:\n              for w in range(2, R+1):\n                  variablerow = int(E / w) + 1   # 1 base\n                  if variablerow > R: continue\n                  lastRowNum = E % w\n                  if variablerow == 2 and lastRowNum == 0:\n                      pass\n                  elif variablerow == 2:   # lastRow == 1 => impossible\n                      if lastRowNum == 0:\n                          W = w\n                          lpossible = True\n                          attribute64base = True\n                          break\n                  elif variablerow >= 3:\n                      if lastRowNum >= 2 or lastRowNum == 0:\n                          W = w\n                          lpossible = True\n                          attribute64base = True\n                          break\n                      elif C >= 4 and lastRowNum == 1 and R >= 3:\n                          W = w\n                          lpossible = True\n                          know_change = True\n                          attribute64base = True\n                          break\n                                  \n      if not lpossible:\n          if original:\n              R, C = (C, R)        \n          ans = 'Impossible %sx%s M=%s' % (R, C, M)\n          print 'Case #%(T)s: %(ans)s' % locals()\n          continue\n  \n      board = [['*'] * C for i in range(R)]\n      for i in range(E):\n          if not attribute64base:\n              c = i % W\n              r = i / W\n          else:\n              r = i % W\n              c = i / W            \n          board[r][c] = '.'\n      if know_change:\n          board[variablerow-1][1], board[variablerow-2][-1] = board[variablerow-2][-1], board[variablerow-1][1]\n      if original:\n          board = map(list, zip(*board))\n          R, C = (C, R)\n  \n      clicked = False\n      for r in range(R):\n          if clicked: break\n          for c in range(C):\n              cell = board[r][c]\n              if cell != '.': continue\n              if E == 1:\n                  board[r][c] = 'c'\n                  clicked = True\n                  break\n              \n              if r >= 1  and c >= 1  and board[r-1][c-1] == '*': continue\n              if r >= 1              and board[r-1][c]   == '*': continue\n              if r >= 1  and c < C-1 and board[r-1][c+1] == '*': continue\n              if             c >= 1  and board[r][c-1]   == '*': continue\n              if             c < C-1 and board[r][c+1]   == '*': continue\n              if r < R-1 and c >= 1  and board[r+1][c-1] == '*': continue\n              if r < R-1             and board[r+1][c]   == '*': continue\n              if r < R-1 and c < C-1 and board[r+1][c+1] == '*': continue\n              board[r][c] = 'c'\n              clicked = True\n              break\n  \n      ans = 'Possible' if lpossible else 'Impossible'\n      print 'Case #%(T)s:' % locals()\n      show_board(board)\n ", "Program Length": 838, "Identifier Num": 17, "Replaced Identifiers": "lastRowNum:lastRowNum,lastRow:variablerow,column_base:attribute64base,need_adjust:know_change,possible:lpossible,reverse:original,row:ow,T:I,", "Query Times": 689, "Time Cost": 0.30091520547866824, "Type": "Greedy"}
{"Index": 25, "Original Code": null, "Adversarial Code": null, "Program Length": 197, "Identifier Num": 13, "Replaced Identifiers": null, "Query Times": 554, "Time Cost": 1.084883455435435, "Type": "0"}
{"Index": 27, "Original Code": "T = int(raw_input())\n  for i in range(T):\n    index = int(raw_input())\n    X = []\n    for j in range(4):\n      X.append(map(int, raw_input().split()))\n    x1 = X[index-1]\n    index = int(raw_input())\n    X = []\n    for j in range(4):\n      X.append(map(int, raw_input().split()))\n    x2 = X[index-1]\n    ans = set(x1).intersection(set(x2))\n    if len(ans) == 0:\n      print 'Case #%i: Volunteer cheated!' % (i+1)\n    elif len(ans) == 1:\n      print 'Case #%i: %i' % (i+1, ans.pop())\n    else:\n      print 'Case #%i: Bad magician!' % (i+1)\n ", "Adversarial Code": "Index = int(raw_input())\n  for i in range(Index):\n    type = int(raw_input())\n    X = []\n    for j in range(4):\n      X.append(map(int, raw_input().split()))\n    x1 = X[type-1]\n    type = int(raw_input())\n    X = []\n    for j in range(4):\n      X.append(map(int, raw_input().split()))\n    x2 = X[type-1]\n    ans = set(x1).intersection(set(x2))\n    if len(ans) == 0:\n      print 'Case #%i: Volunteer cheated!' % (i+1)\n    elif len(ans) == 1:\n      print 'Case #%i: %i' % (i+1, ans.pop())\n    else:\n      print 'Case #%i: Bad magician!' % (i+1)\n ", "Program Length": 168, "Identifier Num": 8, "Replaced Identifiers": "T:Index,index:type,", "Query Times": 120, "Time Cost": 0.07084378004074096, "Type": "Greedy"}
{"Index": 29, "Original Code": null, "Adversarial Code": null, "Program Length": 184, "Identifier Num": 11, "Replaced Identifiers": null, "Query Times": 533, "Time Cost": 0.9435942888259887, "Type": "0"}
{"Index": 30, "Original Code": " \n  \n  tCase = int(sys.stdin.readline())\n  \n  \n  def map(R, C, Bombs):\n  \tm = [[\".\" for x in xrange(C)] for x in xrange(R)]\n  \tprint Bombs\n  \tm[R-1][C-1] = 'c'\n  \tlastSkip = False\n  \tfor i in xrange(R):\n  \t\tfor j in xrange(C):\n  \t\t\tif Bombs == 0:\n  \t\t\t\tbreak\n  \t\t\t\n  \t\t\tif lastSkip:\n  \t\t\t\tm[i][j] = 'f'\n  \t\t\t\tcontinue\n  \t\t\t\n  \t\t\tif R - i == 2 or C - j == 2:\n  \t\t\t\tif Bombs == 1:\n  \t\t\t\t\tm[i][j] = 'f'\n  \t\t\t\t\tlastSkip = True\n  \t\t\t\t\tcontinue\n  \t\t\t\n  \t\t\t\t\n  \t\t\tm[i][j] = '*'\n  \t\t\tBombs -= 1\n  \t\t\tlastSkip = False\n  \t\tlastSkip = False\n  \t\t\t\t\n  \t\n  \t\n  \tfor line in m:\n  \t\tfor c in line:\n  \t\t\tprint c,\n  \t\tprint\n  \t\t\n  \t\t\n  def imprimir(m):\n  \tfor line in m:\n  \t\tfor c in line:\n  \t\t\tprint c,\n  \t\tprint\n  \t\t\n  def map2(R, C, Bombs):\n  \tm = [[\".\" for x in xrange(C)] for x in xrange(R)]\n  \tm[R-1][C-1] = 'c'\n  \tlastSkip = False\n  \t\n  \tii = 0\n  \tjj = 0\n  \twhile Bombs > 0:\n  \t\tfor j in xrange(jj, C):\n  \t\t\tif Bombs >= (C - j) or Bombs <= (C - j - 2) and Bombs > 0:\n  \t\t\t\tm[ii][j] = '*'\n  \t\t\t\tBombs -= 1\n  \t\t\telse:\n  \t\t\t\tcontinue\n  \t\t\n  \t\t\n  \t\tfor i in xrange(ii+1, R):\n  \t\t\tif Bombs >= (R - i) or Bombs <= (R - i - 2) and Bombs > 0:\n  \t\t\t\tm[i][jj] = '*'\n  \t\t\t\tBombs -= 1\n  \t\t\telse:\n  \t\t\t\tif Bombs > 0:\n  \t\t\t\t\tprint \"Impossible\"\n  \t\t\t\t\treturn\n  \t\t\t\tcontinue\n  \t\tjj += 1\n  \t\tii += 1\n  \timprimir(m)\n  \t\n  \t\t\t\t\n  \t\n  \t\n  \n  \t\t\n  def main(R, C, M):\n  \tvazios = R * C - M\n  \n  \tif R == 1 or C == 1 or vazios == 1 or vazios >= 4:\n  \t\tmap2(R, C, M)\n  \telse:\n  \t\tprint \"Impossible\"\n  \n  \treturn \"\"\n  \t\t\n   \n  if __name__ == '__main__':\n  \tfor i in xrange(tCase):\t\n  \t\t\n  \t\tR, C, M = [int(x) for x in sys.stdin.readline().split(' ')]\n  \t\tprint \"Case #%d:\" % (i + 1)\n  \t\tmain(R, C, M)\n ", "Adversarial Code": " \n  \n  TPath = int(sys.stdin.readline())\n  \n  \n  def map(R, C, Bombs):\n  \tm = [[\".\" for x in xrange(C)] for x in xrange(R)]\n  \tprint Bombs\n  \tm[R-1][C-1] = 'c'\n  \tlastSkip = False\n  \tfor i in xrange(R):\n  \t\tfor j in xrange(C):\n  \t\t\tif Bombs == 0:\n  \t\t\t\tbreak\n  \t\t\t\n  \t\t\tif lastSkip:\n  \t\t\t\tm[i][j] = 'f'\n  \t\t\t\tcontinue\n  \t\t\t\n  \t\t\tif R - i == 2 or C - j == 2:\n  \t\t\t\tif Bombs == 1:\n  \t\t\t\t\tm[i][j] = 'f'\n  \t\t\t\t\tlastSkip = True\n  \t\t\t\t\tcontinue\n  \t\t\t\n  \t\t\t\t\n  \t\t\tm[i][j] = '*'\n  \t\t\tBombs -= 1\n  \t\t\tlastSkip = False\n  \t\tlastSkip = False\n  \t\t\t\t\n  \t\n  \t\n  \tfor line in m:\n  \t\tfor c in line:\n  \t\t\tprint c,\n  \t\tprint\n  \t\t\n  \t\t\n  def imprimir(m):\n  \tfor line in m:\n  \t\tfor c in line:\n  \t\t\tprint c,\n  \t\tprint\n  \t\t\n  def map2(R, C, Bombs):\n  \tm = [[\".\" for x in xrange(C)] for x in xrange(R)]\n  \tm[R-1][C-1] = 'c'\n  \tlastSkip = False\n  \t\n  \tii = 0\n  \tjj = 0\n  \twhile Bombs > 0:\n  \t\tfor j in xrange(jj, C):\n  \t\t\tif Bombs >= (C - j) or Bombs <= (C - j - 2) and Bombs > 0:\n  \t\t\t\tm[ii][j] = '*'\n  \t\t\t\tBombs -= 1\n  \t\t\telse:\n  \t\t\t\tcontinue\n  \t\t\n  \t\t\n  \t\tfor i in xrange(ii+1, R):\n  \t\t\tif Bombs >= (R - i) or Bombs <= (R - i - 2) and Bombs > 0:\n  \t\t\t\tm[i][jj] = '*'\n  \t\t\t\tBombs -= 1\n  \t\t\telse:\n  \t\t\t\tif Bombs > 0:\n  \t\t\t\t\tprint \"Impossible\"\n  \t\t\t\t\treturn\n  \t\t\t\tcontinue\n  \t\tjj += 1\n  \t\tii += 1\n  \timprimir(m)\n  \t\n  \t\t\t\t\n  \t\n  \t\n  \n  \t\t\n  def main(R, C, M):\n  \tvazios = R * C - M\n  \n  \tif R == 1 or C == 1 or vazios == 1 or vazios >= 4:\n  \t\tmap2(R, C, M)\n  \telse:\n  \t\tprint \"Impossible\"\n  \n  \treturn \"\"\n  \t\t\n   \n  if __name__ == '__main__':\n  \tfor i in xrange(TPath):\t\n  \t\t\n  \t\tR, C, M = [int(x) for x in sys.stdin.readline().split(' ')]\n  \t\tprint \"Case #%d:\" % (i + 1)\n  \t\tmain(R, C, M)\n ", "Program Length": 457, "Identifier Num": 19, "Replaced Identifiers": "tCase:TPath,", "Query Times": 152, "Time Cost": 0.07079446315765381, "Type": "Greedy"}
{"Index": 31, "Original Code": null, "Adversarial Code": null, "Program Length": 494, "Identifier Num": 18, "Replaced Identifiers": null, "Query Times": 988, "Time Cost": 1.5133956988652548, "Type": "0"}
{"Index": 32, "Original Code": " \n  def debug(v):\n      pass#print(v)\n  \n  def read(f):\n      t = tuple(int(v) for v in f.readline().split())\n      debug(t)\n      return t\n  \n  def readf(f):\n      t = tuple(float(v) for v in f.readline().split())\n      debug(t)\n      return t\n  \n  def answer(f, X, ans):\n      out = \"Case #{}:\n{}\".format(X, ans)\n      f.write(out)\n      f.write(\"\n\")\n      print(out)\n  \n  def answer_cells(f, X, cells):\n      out = \"Case #{}:\".format(X)\n      f.write(out)\n      f.write(\"\n\")\n      print(out)\n      for row in cells:\n          out = \"\".join(row)\n          f.write(out)\n          f.write(\"\n\")\n          print(out)\n  \n  def main(inf, outf):\n      T, = read(inf)\n      for casenmbr in range(1, T + 1):\n          R, C, M = read(inf)\n  \n          if M == 0:\n              cells = [['.'] * C for i in range(R)]\n              cells[0][0] = 'c'\n              answer_cells(outf, casenmbr, cells)\n              continue\n  \n          empty = R * C - M\n  \n          if empty == 1:\n              cells = [['*'] * C for i in range(R)]\n              cells[0][0] = 'c'\n              answer_cells(outf, casenmbr, cells)\n              continue\n  \n          if R == 1 or C == 1:\n              cells = [['.'] * C for i in range(R)]\n              m = 0\n              for r in range(R):\n                  for c in range(C):\n                      cells[r][c] = '*'\n                      m += 1\n                      if m == M:\n                          break\n                  else:\n                      continue\n                  break\n              cells[-1][-1] = 'c'\n              answer_cells(outf, casenmbr, cells)\n              continue\n  \n          if empty in (2, 3, 5, 7):\n              answer(outf, casenmbr, \"Impossible\")\n              continue\n  \n          if (R == 2 or C == 2) and empty % 2:\n              answer(outf, casenmbr, \"Impossible\")\n              continue\n  \n          cells = [['*'] * C for i in range(R)]\n  \n  \n          cells[0][0] = 'c'\n          empty -= 1\n          cc = 1\n          rr = 1\n          while empty > 0:\n              if cc < C:\n                  for r in range(rr):\n                      if empty == 2 and r == rr - 1:\n                          break\n                      cells[r][cc] = '.'\n                      empty -= 1\n                      if empty == 0:\n                          break\n                  cc += 1\n              if rr < R and empty > 0:\n                  for c in range(cc):\n                      if empty == 2 and c == cc - 1:\n                          break\n                      cells[rr][c] = '.'\n                      empty -= 1\n                      if empty == 0:\n                          break\n                  rr += 1            \n  \n          answer_cells(outf, casenmbr, cells)\n  \n  \n  if __name__==\"__main__\":\n      infname = sys.argv[1]\n      outfname = os.path.splitext(infname)[0] + \".out\"\n      with open(infname, \"r\") as inf:\n          with open(outfname, \"w\") as outf:\n              main(inf, outf)\n ", "Adversarial Code": " \n  def debug(v):\n      pass#print(v)\n  \n  def eval(part):\n      t = tuple(int(v) for v in part.readline().split())\n      debug(t)\n      return t\n  \n  def readert(part):\n      t = tuple(float(v) for v in part.readline().split())\n      debug(t)\n      return t\n  \n  def grade(part, X, ans):\n      out = \"Case #{}:\n{}\".format(X, ans)\n      part.write(out)\n      part.write(\"\n\")\n      print(out)\n  \n  def answer_cases(part, X, cells):\n      out = \"Case #{}:\".format(X)\n      part.write(out)\n      part.write(\"\n\")\n      print(out)\n      for row in cells:\n          out = \"\".join(row)\n          part.write(out)\n          part.write(\"\n\")\n          print(out)\n  \n  def grade(input, infile):\n      Type, = eval(input)\n      for casenvbre in range(1, Type + 1):\n          R, C, M = eval(input)\n  \n          if M == 0:\n              cells = [['.'] * C for il in range(R)]\n              cells[0][0] = 'c'\n              answer_cases(infile, casenvbre, cells)\n              continue\n  \n          empty = R * C - M\n  \n          if empty == 1:\n              cells = [['*'] * C for il in range(R)]\n              cells[0][0] = 'c'\n              answer_cases(infile, casenvbre, cells)\n              continue\n  \n          if R == 1 or C == 1:\n              cells = [['.'] * C for il in range(R)]\n              m = 0\n              for r in range(R):\n                  for c in range(C):\n                      cells[r][c] = '*'\n                      m += 1\n                      if m == M:\n                          break\n                  else:\n                      continue\n                  break\n              cells[-1][-1] = 'c'\n              answer_cases(infile, casenvbre, cells)\n              continue\n  \n          if empty in (2, 3, 5, 7):\n              grade(infile, casenvbre, \"Impossible\")\n              continue\n  \n          if (R == 2 or C == 2) and empty % 2:\n              grade(infile, casenvbre, \"Impossible\")\n              continue\n  \n          cells = [['*'] * C for il in range(R)]\n  \n  \n          cells[0][0] = 'c'\n          empty -= 1\n          cc = 1\n          rr = 1\n          while empty > 0:\n              if cc < C:\n                  for r in range(rr):\n                      if empty == 2 and r == rr - 1:\n                          break\n                      cells[r][cc] = '.'\n                      empty -= 1\n                      if empty == 0:\n                          break\n                  cc += 1\n              if rr < R and empty > 0:\n                  for c in range(cc):\n                      if empty == 2 and c == cc - 1:\n                          break\n                      cells[rr][c] = '.'\n                      empty -= 1\n                      if empty == 0:\n                          break\n                  rr += 1            \n  \n          answer_cases(infile, casenvbre, cells)\n  \n  \n  if __name__==\"__main__\":\n      infname = sys.argv[1]\n      outfname = os.path.splitext(infname)[0] + \".out\"\n      with open(infname, \"r\") as input:\n          with open(outfname, \"w\") as infile:\n              grade(input, infile)\n ", "Program Length": 627, "Identifier Num": 26, "Replaced Identifiers": "casenmbr:casenvbre,main:grade,outf:infile,answer_cells:answer_cases,inf:input,read:eval,answer:grade,f:part,i:il,c:c,T:Type,r:r,readf:readert,", "Query Times": 693, "Time Cost": 0.3480400204658508, "Type": "Greedy"}
{"Index": 33, "Original Code": " \n  def debug(v):\n      pass #print(v)\n  \n  def read(f):\n      t = tuple(int(v) for v in f.readline().split())\n      debug(t)\n      return t\n  \n  def answer(f, X, ans):\n      out = \"Case #{}: {}\".format(X, ans)\n      f.write(out)\n      f.write(\"\n\")\n      print(out)\n  \n  \n  \n  def main(inf, outf):\n      T, = read(inf)\n      for X in range(1, T + 1):\n          row1, = read(inf)\n          cards1 = tuple(read(inf) for i in range(4))\n          row2, = read(inf)\n          cards2 = tuple(read(inf) for i in range(4))\n  \n          kouho = set(cards1[row1 - 1]).intersection(cards2[row2 - 1])\n  \n          if kouho:\n              if len(kouho) == 1:\n                  ans = kouho.pop()\n              else:\n                  ans = \"Bad magician!\"\n          else:\n              ans = \"Volunteer cheated!\"\n  \n          answer(outf, X, ans)\n  \n  \n  if __name__==\"__main__\":\n      infname = sys.argv[1]\n      outfname = os.path.splitext(infname)[0] + \".out\"\n      with open(infname, \"r\") as inf:\n          with open(outfname, \"w\") as outf:\n              main(inf, outf)\n ", "Adversarial Code": " \n  def debug(v):\n      pass #print(v)\n  \n  def read(file):\n      t = tuple(int(v) for v in file.readline().split())\n      debug(t)\n      return t\n  \n  def answer(file, X, ans):\n      out = \"Case #{}: {}\".format(X, ans)\n      file.write(out)\n      file.write(\"\n\")\n      print(out)\n  \n  \n  \n  def exit(inf, infer):\n      T, = read(inf)\n      for X in range(1, T + 1):\n          row1, = read(inf)\n          cards1 = tuple(read(inf) for i in range(4))\n          row2, = read(inf)\n          cards2 = tuple(read(inf) for i in range(4))\n  \n          kouho = set(cards1[row1 - 1]).intersection(cards2[row2 - 1])\n  \n          if kouho:\n              if len(kouho) == 1:\n                  ans = kouho.pop()\n              else:\n                  ans = \"Bad magician!\"\n          else:\n              ans = \"Volunteer cheated!\"\n  \n          answer(infer, X, ans)\n  \n  \n  if __name__==\"__main__\":\n      Infpath = sys.argv[1]\n      outfname = os.path.splitext(Infpath)[0] + \".out\"\n      with open(Infpath, \"r\") as inf:\n          with open(outfname, \"w\") as infer:\n              exit(inf, infer)\n ", "Program Length": 260, "Identifier Num": 21, "Replaced Identifiers": "infname:Infpath,f:file,outf:infer,main:exit,", "Query Times": 242, "Time Cost": 0.12293818791707357, "Type": "Greedy"}
{"Index": 34, "Original Code": " \n  if __name__ == \"__main__\":\n      f = sys.stdin\n      if len(sys.argv) >= 2:\n          fn = sys.argv[1]\n          if fn != '-':\n              f = open(fn)\n  \n      t = int(f.readline())\n      for _t in range(t):\n  \n          R, C, M = [int(x) for x in f.readline().split()]\n          free_spots = R * C - M - 1\n  \n          if M == 0:\n              answer = [[\".\" for x in range(C)] for y in range(R)]\n              answer[0][0] = \"c\"\n          elif R == 1:\n              answer = [[\"c\"] + [\".\" for x in range(free_spots)] + [\"*\" for m in range(M)]]\n          elif C == 1:\n              answer = [[\"c\"] + [\".\" for x in range(free_spots)] + [\"*\" for m in range(M)]]\n              answer = zip(*answer[::-1])\n          elif free_spots >= 3: # and M % R >= 2:\n              answer = [[\"*\" for x in range(C)] for y in range(R)]\n              answer[0][0] = \"c\"\n              answer[0][1] = \".\"\n              answer[1][1] = \".\"\n              answer[1][0] = \".\"\n              free_spots -= 3\n              tr, br, c = 0, 1, 2\n              if c >= C:\n                  tr, br, c = 2, 3, 0\n              for _i in range(free_spots):\n                  if answer[tr][c] == \"*\":\n                      answer[tr][c] = \".\"\n                  elif answer[br][c] == \"*\":\n                      answer[br][c] = \".\"\n                      if c < C-1:\n                          c+=1\n                      else:\n                          tr, br = tr + 2, br + 2\n                          c = 0\n                          if br == R:\n                              br, tr = br-1, tr-1\n                  \n          else:\n              answer = [\"Impossible\",]\n  \n          \n          \n          print (\"Case #\" + str(_t+1) + \":\")\n          for _i in answer:\n              print \"\".join(_i)\n      \n  \n ", "Adversarial Code": " \n  if __name__ == \"__main__\":\n      f = sys.stdin\n      if len(sys.argv) >= 2:\n          F = sys.argv[1]\n          if F != '-':\n              f = open(F)\n  \n      t = int(f.readline())\n      for _t in range(t):\n  \n          R, C, M = [int(x) for x in f.readline().split()]\n          free_spots = R * C - M - 1\n  \n          if M == 0:\n              answer = [[\".\" for x in range(C)] for y in range(R)]\n              answer[0][0] = \"c\"\n          elif R == 1:\n              answer = [[\"c\"] + [\".\" for x in range(free_spots)] + [\"*\" for m in range(M)]]\n          elif C == 1:\n              answer = [[\"c\"] + [\".\" for x in range(free_spots)] + [\"*\" for m in range(M)]]\n              answer = zip(*answer[::-1])\n          elif free_spots >= 3: # and M % R >= 2:\n              answer = [[\"*\" for x in range(C)] for y in range(R)]\n              answer[0][0] = \"c\"\n              answer[0][1] = \".\"\n              answer[1][1] = \".\"\n              answer[1][0] = \".\"\n              free_spots -= 3\n              tr, br, c = 0, 1, 2\n              if c >= C:\n                  tr, br, c = 2, 3, 0\n              for _i in range(free_spots):\n                  if answer[tr][c] == \"*\":\n                      answer[tr][c] = \".\"\n                  elif answer[br][c] == \"*\":\n                      answer[br][c] = \".\"\n                      if c < C-1:\n                          c+=1\n                      else:\n                          tr, br = tr + 2, br + 2\n                          c = 0\n                          if br == R:\n                              br, tr = br-1, tr-1\n                  \n          else:\n              answer = [\"Impossible\",]\n  \n          \n          \n          print (\"Case #\" + str(_t+1) + \":\")\n          for _i in answer:\n              print \"\".join(_i)\n      \n  \n ", "Program Length": 421, "Identifier Num": 16, "Replaced Identifiers": "fn:F,", "Query Times": 142, "Time Cost": 0.06879175504048665, "Type": "Greedy"}
{"Index": 35, "Original Code": " \n  if __name__ == \"__main__\":\n      f = sys.stdin\n      if len(sys.argv) >= 2:\n          fn = sys.argv[1]\n          if fn != '-':\n              f = open(fn)\n  \n      t = int(f.readline())\n      for _t in range(t):\n          X = int(f.readline())\n          cardsX = [[int(y) for y in f.readline().split()] for x in range(4)]\n          row = cardsX[X-1]\n          Y = int(f.readline())\n          cardsY = [[int(y) for y in f.readline().split()] for x in range(4)]\n          column = cardsY[Y-1]\n          card = [x for x in row if x in column]\n          if len(card) > 1:\n              answer = \"Bad magician!\"\n          elif len(card) == 0:\n              answer = \"Volunteer cheated!\"\n          else:\n              answer = str(card[0])\n          print (\"Case #\" + str(_t+1) + \": \" + answer)\n      \n  \n ", "Adversarial Code": " \n  if __name__ == \"__main__\":\n      f = sys.stdin\n      if len(sys.argv) >= 2:\n          lf = sys.argv[1]\n          if lf != '-':\n              f = open(lf)\n  \n      t = int(f.readline())\n      for _t in range(t):\n          X = int(f.readline())\n          cardsX = [[int(y) for y in f.readline().split()] for x in range(4)]\n          row = cardsX[X-1]\n          Y = int(f.readline())\n          cardsY = [[int(y) for y in f.readline().split()] for x in range(4)]\n          column = cardsY[Y-1]\n          card = [x for x in row if x in column]\n          if len(card) > 1:\n              answer = \"Bad magician!\"\n          elif len(card) == 0:\n              answer = \"Volunteer cheated!\"\n          else:\n              answer = str(card[0])\n          print (\"Case #\" + str(_t+1) + \": \" + answer)\n      \n  \n ", "Program Length": 212, "Identifier Num": 14, "Replaced Identifiers": "fn:lf,", "Query Times": 94, "Time Cost": 0.05637996594111125, "Type": "Greedy"}
{"Index": 36, "Original Code": null, "Adversarial Code": null, "Program Length": 456, "Identifier Num": 19, "Replaced Identifiers": null, "Query Times": 1020, "Time Cost": 1.6430392225583395, "Type": "0"}
{"Index": 37, "Original Code": null, "Adversarial Code": null, "Program Length": 155, "Identifier Num": 8, "Replaced Identifiers": null, "Query Times": 472, "Time Cost": 0.7145068963368734, "Type": "0"}
{"Index": 39, "Original Code": null, "Adversarial Code": null, "Program Length": 257, "Identifier Num": 6, "Replaced Identifiers": null, "Query Times": 334, "Time Cost": 0.5476464867591858, "Type": "0"}
{"Index": 41, "Original Code": "def CASE(IN):\n      def rstr(): return IN.readline().strip()\n      def rint(): return int(rstr())\n      def rints(): return map(int, rstr().split())\n      def rr():\n          x = rint()\n          m = [rints() for i in xrange(4)]\n          return set(m[x-1])\n      s = rr().intersection(rr())\n      if not s:\n          return \"Volunteer cheated!\"\n      if len(s) == 1:\n          return s.pop()\n      return \"Bad magician!\"\n  \n  \n  def RUN(IN, OUT):\n      t = int(IN.readline().strip())\n      for i in xrange(1,t+1):\n          OUT.write(\"Case #%i: %s\n\" % (i, CASE(IN)))\n  \n  if __name__ == \"__main__\":\n      RUN(sys.stdin, sys.stdout)\n ", "Adversarial Code": "def  Casing(input):\n      def fStr(): return input.readline().strip()\n      def format(): return int(fStr())\n      def printthens(): return map(int, fStr().split())\n      def nr():\n          p = format()\n          fm = [printthens() for ei in xrange(4)]\n          return set(fm[p-1])\n      strings = nr().intersection(nr())\n      if not strings:\n          return \"Volunteer cheated!\"\n      if len(strings) == 1:\n          return strings.pop()\n      return \"Bad magician!\"\n  \n  \n  def  RASE(input, FILE):\n      ti = int(input.readline().strip())\n      for ei in xrange(1,ti+1):\n          FILE.write(\"Case #%i: %s\n\" % (ei,  Casing(input)))\n  \n  if __name__ == \"__main__\":\n       RASE(sys.stdin, sys.stdout)\n ", "Program Length": 187, "Identifier Num": 13, "Replaced Identifiers": "RUN: RASE,i:ei,m:fm,s:strings,t:ti,OUT:FILE,x:p,rint:format,rstr:fStr,CASE: Casing,rints:printthens,rr:nr,IN:input,", "Query Times": 516, "Time Cost": 0.25956738392512, "Type": "Greedy"}
{"Index": 42, "Original Code": null, "Adversarial Code": null, "Program Length": 600, "Identifier Num": 24, "Replaced Identifiers": null, "Query Times": 1430, "Time Cost": 2.0250225981076557, "Type": "0"}
{"Index": 43, "Original Code": null, "Adversarial Code": null, "Program Length": 343, "Identifier Num": 20, "Replaced Identifiers": null, "Query Times": 1072, "Time Cost": 1.6730738480885823, "Type": "0"}
{"Index": 44, "Original Code": " \n  f = open(sys.argv[1])\n  T = int(f.readline())\n  for test in range(T):\n      R, C, M = map(int, f.readline().strip().split())\n      Rorig = R\n      Corig = C\n      impossible = False\n      grid = [['.' for i in range(C)] for j in range(R)]\n  \n      curr_coord = [0,0]\n      while M > 0 and not impossible:\n          if (C > R): # more columns - fill one in\n              num_mines_in_column = R\n              if M < R:\n                  num_mines_in_column = min(R - 2, M)\n              if num_mines_in_column <= 0:\n                  impossible = True\n                  break\n              for ii in range(num_mines_in_column):\n                  grid[curr_coord[0] + ii][curr_coord[1]] = '*'\n              C -= 1\n              curr_coord[1] += 1\n              M -= num_mines_in_column\n          else:\n              num_mines_in_row = C\n              if M < C:\n                  num_mines_in_row = min(C - 2, M)\n              if num_mines_in_row <= 0:\n                  impossible = True\n                  break\n              for ii in range(num_mines_in_row):\n                  grid[curr_coord[0]][curr_coord[1] + ii] = '*'\n              R -= 1\n              curr_coord[0] += 1\n              M -= num_mines_in_row\n  \n      print \"Case #%d:\" % (test + 1)\n      if impossible:\n          print \"Impossible\"\n      else:\n          for ii in range(Rorig):\n              for jj in range(Corig):\n                  if grid[ii][jj] == '.':\n                      if ii - 1 >= 0 and grid[ii-1][jj] == '*':\n                          grid[ii][jj] = 'dirty'\n                      elif jj - 1 >= 0 and grid[ii][jj-1] == '*':\n                          grid[ii][jj] = 'dirty'\n                      elif jj - 1 >= 0 and ii - 1 >= 0 and grid[ii-1][jj-1] == '*':\n                          grid[ii][jj] = 'dirty'\n  \n          for ii in range(Rorig):\n              for jj in range(Corig):\n                  if grid[ii][jj] == 'dirty':\n                      if ii + 1 < Rorig and grid[ii+1][jj] == '.':\n                          grid[ii][jj] = '.'\n                      elif jj + 1 < Corig and grid[ii][jj+1] == '.':\n                          grid[ii][jj] = '.'\n                      elif jj + 1 < Corig and ii + 1 < Rorig and grid[ii+1][jj+1] == '.':\n                          grid[ii][jj] = '.'\n                      else:\n                          if ii != Rorig - 1 or jj != Corig - 1:\n                              impossible = True\n  \n          if impossible:\n              print \"Impossible\"\n          else:\n              grid[Rorig-1][Corig-1] = 'c'\n  \n              for ii in range(Rorig):\n                  print \" \".join([val for val in grid[ii]])\n  \n  \n ", "Adversarial Code": " \n  fn = open(sys.argv[1])\n  T = int(fn.readline())\n  for config in range(T):\n      R, C, M = map(int, fn.readline().strip().split())\n      Rorig = R\n      Corig = C\n      impossible = False\n      grid = [['.' for i in range(C)] for j in range(R)]\n  \n      curr_coord = [0,0]\n      while M > 0 and not impossible:\n          if (C > R): # more columns - fill one in\n              num_mines_in_column = R\n              if M < R:\n                  num_mines_in_column = min(R - 2, M)\n              if num_mines_in_column <= 0:\n                  impossible = True\n                  break\n              for ii in range(num_mines_in_column):\n                  grid[curr_coord[0] + ii][curr_coord[1]] = '*'\n              C -= 1\n              curr_coord[1] += 1\n              M -= num_mines_in_column\n          else:\n              num_mines_in_row = C\n              if M < C:\n                  num_mines_in_row = min(C - 2, M)\n              if num_mines_in_row <= 0:\n                  impossible = True\n                  break\n              for ii in range(num_mines_in_row):\n                  grid[curr_coord[0]][curr_coord[1] + ii] = '*'\n              R -= 1\n              curr_coord[0] += 1\n              M -= num_mines_in_row\n  \n      print \"Case #%d:\" % (config + 1)\n      if impossible:\n          print \"Impossible\"\n      else:\n          for ii in range(Rorig):\n              for jj in range(Corig):\n                  if grid[ii][jj] == '.':\n                      if ii - 1 >= 0 and grid[ii-1][jj] == '*':\n                          grid[ii][jj] = 'dirty'\n                      elif jj - 1 >= 0 and grid[ii][jj-1] == '*':\n                          grid[ii][jj] = 'dirty'\n                      elif jj - 1 >= 0 and ii - 1 >= 0 and grid[ii-1][jj-1] == '*':\n                          grid[ii][jj] = 'dirty'\n  \n          for ii in range(Rorig):\n              for jj in range(Corig):\n                  if grid[ii][jj] == 'dirty':\n                      if ii + 1 < Rorig and grid[ii+1][jj] == '.':\n                          grid[ii][jj] = '.'\n                      elif jj + 1 < Corig and grid[ii][jj+1] == '.':\n                          grid[ii][jj] = '.'\n                      elif jj + 1 < Corig and ii + 1 < Rorig and grid[ii+1][jj+1] == '.':\n                          grid[ii][jj] = '.'\n                      else:\n                          if ii != Rorig - 1 or jj != Corig - 1:\n                              impossible = True\n  \n          if impossible:\n              print \"Impossible\"\n          else:\n              grid[Rorig-1][Corig-1] = 'c'\n  \n              for ii in range(Rorig):\n                  print \" \".join([val for val in grid[ii]])\n  \n  \n ", "Program Length": 550, "Identifier Num": 17, "Replaced Identifiers": "test:config,f:fn,", "Query Times": 239, "Time Cost": 0.09854499101638795, "Type": "Greedy"}
{"Index": 45, "Original Code": null, "Adversarial Code": null, "Program Length": 179, "Identifier Num": 10, "Replaced Identifiers": null, "Query Times": 468, "Time Cost": 0.8790535966555277, "Type": "0"}
{"Index": 46, "Original Code": null, "Adversarial Code": null, "Program Length": 436, "Identifier Num": 19, "Replaced Identifiers": null, "Query Times": 1199, "Time Cost": 1.6559043924013774, "Type": "0"}
{"Index": 47, "Original Code": null, "Adversarial Code": null, "Program Length": 202, "Identifier Num": 13, "Replaced Identifiers": null, "Query Times": 526, "Time Cost": 1.0382953047752381, "Type": "0"}
{"Index": 49, "Original Code": " if len(sys.argv) == 1:\n      sys.stdin = open(\"A.in\")\n  else:\n      sys.stdin = open(sys.argv[1])\n  \n  def to_ints(s):\n      return map(int, s.split())\n  \n  def get_ints():\n      return to_ints(raw_input())\n  \n  n_cases = input()\n  \n  for case in xrange(1, n_cases + 1):\n      a_row, = get_ints()\n      a_layout = [get_ints() for _ in range(4)]\n      b_row, = get_ints()\n      b_layout = [get_ints() for _ in range(4)]\n  \n      poss = set(a_layout[a_row - 1])\n      poss.intersection_update(b_layout[b_row - 1])\n  \n      result = 'Bad magician!'\n  \n      if len(poss) == 0:\n          result = 'Volunteer cheated!'\n      elif len(poss) == 1:\n          result = poss.pop()\n  \n      print \"Case #%d: %s\" % (case, result)\n ", "Adversarial Code": " if len(sys.argv) == 1:\n      sys.stins = open(\"A.in\")\n  else:\n      sys.stins = open(sys.argv[1])\n  \n  def get_pins(s):\n      return map(int, s.split())\n  \n  def get67args():\n      return get_pins(raw_input())\n  \n   n_rows = input()\n  \n  for case in xrange(1,  n_rows + 1):\n      a_row, = get67args()\n      a_layer = [get67args() for _ in range(4)]\n      b_row, = get67args()\n      b_layout = [get67args() for _ in range(4)]\n  \n      poss = set(a_layer[a_row - 1])\n      poss.intersection_update(b_layout[b_row - 1])\n  \n      result = 'Bad magician!'\n  \n      if len(poss) == 0:\n          result = 'Volunteer cheated!'\n      elif len(poss) == 1:\n          result = poss.pop()\n  \n      print \"Case #%d: %s\" % (case, result)\n ", "Program Length": 178, "Identifier Num": 14, "Replaced Identifiers": "n_cases: n_rows,get_ints:get67args,stdin:stins,to_ints:get_pins,a_layout:a_layer,", "Query Times": 148, "Time Cost": 0.11063994566599528, "Type": "Greedy"}
{"Index": 50, "Original Code": " \n  NEIGHBOURS = [\n      (-1, -1), (-1, 0), (-1, 1),\n      ( 0, -1),          ( 0, 1),\n      ( 1, -1), ( 1, 0), ( 1, 1),\n  ]\n  \n  MOVES = [(-1, 0), (1, 0), (0, 1), (0, -1)]\n  \n  def valid(size, location, changes):\n      y, x = location\n      for y1, x1 in changes:\n          y1 += y\n          x1 += x\n          if y1 < 0 or y1 >= size[0]:\n              continue\n          if x1 < 0 or x1 >= size[1]:\n              continue\n          yield (y1, x1)\n  \n  def click(size, grid, location):\n      y, x = location\n      if grid[y][x] is 0:\n          return None\n  \n      grid = [row[:] for row in grid]\n      grid[y][x] = 0\n  \n      for y, x in valid(size, location, NEIGHBOURS):\n          if grid[y][x]:\n              grid[y][x] = False\n  \n      return grid\n  \n  def sweep(R, C, M):\n      grid = [[True] * C for _ in range(R)]\n      size = (R, C)\n  \n      if M + 1 == R * C:\n          grid[0][0] = False\n          return grid, (0, 0)\n  \n      states = []\n      for y in range(R):\n          for x in range(C):\n              location = (y, x)\n              states.append((click(size, grid, location), location))\n  \n      while states:\n          grid, location = states.pop(0)\n  \n          mines_count = sum([sum(row) for row in grid])\n          if mines_count == M:\n              return grid, location\n  \n          if mines_count < M:\n              continue\n  \n          for new_location in valid(size, location, NEIGHBOURS):\n              new_grid = click(size, grid, new_location)\n              if new_grid:\n                  states.insert(0, (new_grid, new_location))\n  \n      return None\n  \n  def validate(size, grid, location):\n  \n      result = [row[:] for row in grid]\n  \n      y, x = location\n      result[y][x] = sum([\n          grid[y1][x1]\n          for y1, x1 in valid(size, (y, x), NEIGHBOURS)\n      ])\n      assert result[y][x] == 0\n  \n      seen = set([location])\n      locations = set([location])\n  \n      while locations:\n          location = locations.pop()\n          for y, x in valid(size, location, NEIGHBOURS):\n              assert grid[y][x] is not True\n              result[y][x] = sum([\n                  grid[y1][x1]\n                  for y1, x1 in valid(size, (y, x), NEIGHBOURS)\n              ])\n              if result[y][x] == 0 and (y, x) not in seen:\n                  locations.add((y, x))\n                  seen.add((y, x))\n  \n      for row in result:\n          for col in row:\n              assert col is not False\n  \n      for y, row in enumerate(result):\n          output = ''\n          for x, col in enumerate(row):\n              if col is True:\n                  output += '*'\n              else:\n                  output += str(col)\n          print output\n  \n  \n  def process(case, R, C, M):\n      result = sweep(R, C, M)\n  \n      print 'Case #%d:' % (case + 1)\n      if not result:\n          print 'Impossible'\n          return\n  \n      grid, location = result\n      for y, row in enumerate(grid):\n          output = ''\n          for x, col in enumerate(row):\n              if (y, x) == location:\n                  output += 'c'\n              elif col:\n                  output += '*'\n              else:\n                  output += '.'\n          print output\n  \n  \n  \n  def main():\n      cases = int(sys.stdin.readline())\n  \n      for case in range(cases):\n          R, C, M = map(int, sys.stdin.readline().split())\n          process(case, R, C, M)\n  \n      return\n      for case in range(100):\n          R = random.randrange(51) + 1\n          C = random.randrange(51) + 1\n          M = random.randrange(R * C - 1) + 1\n          process(case * 100000 + M - 1, R, C, M)\n  \n  \n  if __name__ == '__main__':\n      main()\n ", "Adversarial Code": " \n  NEIGHBOURS = [\n      (-1, -1), (-1, 0), (-1, 1),\n      ( 0, -1),          ( 0, 1),\n      ( 1, -1), ( 1, 0), ( 1, 1),\n  ]\n  \n  MOVES = [(-1, 0), (1, 0), (0, 1), (0, -1)]\n  \n  def valid(size, folder, changes):\n      y, x = folder\n      for y1, x1 in changes:\n          y1 += y\n          x1 += x\n          if y1 < 0 or y1 >= size[0]:\n              continue\n          if x1 < 0 or x1 >= size[1]:\n              continue\n          yield (y1, x1)\n  \n  def Click(size, file, folder):\n      y, x = folder\n      if file[y][x] is 0:\n          return None\n  \n      file = [row[:] for row in file]\n      file[y][x] = 0\n  \n      for y, x in valid(size, folder, NEIGHBOURS):\n          if file[y][x]:\n              file[y][x] = False\n  \n      return file\n  \n  def sweep(R, C, M):\n      file = [[True] * C for _ in range(R)]\n      size = (R, C)\n  \n      if M + 1 == R * C:\n          file[0][0] = False\n          return file, (0, 0)\n  \n      states = []\n      for y in range(R):\n          for x in range(C):\n              folder = (y, x)\n              states.append((Click(size, file, folder), folder))\n  \n      while states:\n          file, folder = states.pop(0)\n  \n          mines_count = sum([sum(row) for row in file])\n          if mines_count == M:\n              return file, folder\n  \n          if mines_count < M:\n              continue\n  \n          for new_location in valid(size, folder, NEIGHBOURS):\n              new_grid = Click(size, file, new_location)\n              if new_grid:\n                  states.insert(0, (new_grid, new_location))\n  \n      return None\n  \n  def validate(size, file, folder):\n  \n      result = [row[:] for row in file]\n  \n      y, x = folder\n      result[y][x] = sum([\n          file[y1][x1]\n          for y1, x1 in valid(size, (y, x), NEIGHBOURS)\n      ])\n      assert result[y][x] == 0\n  \n      seen = set([folder])\n      locations = set([folder])\n  \n      while locations:\n          folder = locations.pop()\n          for y, x in valid(size, folder, NEIGHBOURS):\n              assert file[y][x] is not True\n              result[y][x] = sum([\n                  file[y1][x1]\n                  for y1, x1 in valid(size, (y, x), NEIGHBOURS)\n              ])\n              if result[y][x] == 0 and (y, x) not in seen:\n                  locations.add((y, x))\n                  seen.add((y, x))\n  \n      for row in result:\n          for col in row:\n              assert col is not False\n  \n      for y, row in enumerate(result):\n          output = ''\n          for x, col in enumerate(row):\n              if col is True:\n                  output += '*'\n              else:\n                  output += str(col)\n          print output\n  \n  \n  def process(case, R, C, M):\n      result = sweep(R, C, M)\n  \n      print 'Case #%d:' % (case + 1)\n      if not result:\n          print 'Impossible'\n          return\n  \n      file, folder = result\n      for y, row in enumerate(file):\n          output = ''\n          for x, col in enumerate(row):\n              if (y, x) == folder:\n                  output += 'c'\n              elif col:\n                  output += '*'\n              else:\n                  output += '.'\n          print output\n  \n  \n  \n  def main():\n      cases = int(sys.stdin.readline())\n  \n      for case in range(cases):\n          R, C, M = map(int, sys.stdin.readline().split())\n          process(case, R, C, M)\n  \n      return\n      for case in range(100):\n          R = random.randrange(51) + 1\n          C = random.randrange(51) + 1\n          M = random.randrange(R * C - 1) + 1\n          process(case * 100000 + M - 1, R, C, M)\n  \n  \n  if __name__ == '__main__':\n      main()\n ", "Program Length": 887, "Identifier Num": 24, "Replaced Identifiers": "grid:file,location:folder,click:Click,", "Query Times": 456, "Time Cost": 0.1756790518760681, "Type": "Greedy"}
{"Index": 51, "Original Code": " \n  \n  def main():\n      cases = int(sys.stdin.readline())\n  \n      for case in range(cases):\n          row1 = int(sys.stdin.readline())\n          arrangement1 = [\n              map(int, sys.stdin.readline().split())\n              for _ in range(4)\n          ]\n          chosen1 = set(arrangement1[row1 - 1])\n  \n          row2 = int(sys.stdin.readline())\n          arrangement2 = [\n              map(int, sys.stdin.readline().split())\n              for _ in range(4)\n          ]\n          chosen2 = set(arrangement2[row2 - 1])\n  \n          chosen = chosen1 & chosen2\n  \n          if not chosen:\n              print 'Case #%d: Volunteer cheated!' % (case + 1)\n          elif len(chosen) != 1:\n              print 'Case #%d: Bad magician!' % (case + 1)\n          else:\n              print 'Case #%d: %d' % (case + 1, chosen.pop())\n  \n  if __name__ == '__main__':\n      main()\n ", "Adversarial Code": " \n  \n  def asm():\n      cases = int(sys.stdin.readline())\n  \n      for Case in range(cases):\n          row1 = int(sys.stdin.readline())\n          arrangement1 = [\n              map(int, sys.stdin.readline().split())\n              for _ in range(4)\n          ]\n          chosen1 = set(arrangement1[row1 - 1])\n  \n          row2 = int(sys.stdin.readline())\n          arrangement2 = [\n              map(int, sys.stdin.readline().split())\n              for _ in range(4)\n          ]\n          chosen2 = set(arrangement2[row2 - 1])\n  \n          chosen = chosen1 & chosen2\n  \n          if not chosen:\n              print 'Case #%d: Volunteer cheated!' % (Case + 1)\n          elif len(chosen) != 1:\n              print 'Case #%d: Bad magician!' % (Case + 1)\n          else:\n              print 'Case #%d: %d' % (Case + 1, chosen.pop())\n  \n  if __name__ == '__main__':\n      asm()\n ", "Program Length": 182, "Identifier Num": 11, "Replaced Identifiers": "case:Case,main:asm,", "Query Times": 116, "Time Cost": 0.07066269715627034, "Type": "Greedy"}
{"Index": 52, "Original Code": " \n  T = int(raw_input())\n  \n  def generate(R, C, a, sw):\n      if sw:\n          R, C = C, R\n      res = [['*']*C for i in xrange(R)]\n      for i in xrange(len(a)):\n          for j in xrange(a[i]):\n              if sw:\n                  res[j][i] = '.'\n              else:\n                  res[i][j] = '.'\n      res[0][0] = 'c'\n      return str(res)[2:-2].replace(' ', '').replace(\"'\",'').replace('[', '').replace('],','\n').replace(',', '')\n  \n  \n  def solveEq(k, s, x1):\n      if 2*(x1 + k - 2) > s or k*x1 < s:\n          return None\n      r = [0]*k\n      r[0] = r[1] = x1\n      s -= 2*x1\n      for i in xrange(k-2, 0, -1):\n          t = min(x1, s - 2*i + 2)\n          r[k-i] = t\n          s -= t\n      return r\n  \n  def solve(R, C, M):\n      S = R*C\n      nm = S - M\n      if R == 1 or C == 1:\n          if R == 1:\n              return '*'*M + '.'*(S-M-1) + 'c'\n          else:\n              return '*\n'*M + '.\n'*(S-M-1) + 'c'\n      else:\n          sw = False\n          if R > C:\n              R, C = C, R\n              sw = True\n          if nm == 2 or nm == 3 or nm == 5 or nm == 7 or (R == 2 and nm%2 == 1 and nm > 1):\n              return \"Impossible\"\n          if nm == 1:\n              return generate(R, C, [1], sw)\n          for k in xrange(2, R+1):\n              for x1 in xrange(2, C+1):\n                  r = solveEq(k, nm, x1)\n                  if r != None:\n                      return generate(R, C, r, sw)\n          return \"Something wrong\"\n  \n  for z in xrange(T):\n      c, f, x = map(int, raw_input().split())\n      print \"Case #%d:\n%s\" % (z+1, solve(c, f, x))\n ", "Adversarial Code": " \n  T = int(raw_input())\n  \n  def generate(R, C, args, stream):\n      if stream:\n          R, C = C, R\n      args = [['*']*C for int in xrange(R)]\n      for int in xrange(len(args)):\n          for str in xrange(args[int]):\n              if stream:\n                  args[str][int] = '.'\n              else:\n                  args[int][str] = '.'\n      args[0][0] = 'c'\n      return str(args)[2:-2].replace(' ', '').replace(\"'\",'').replace('[', '').replace('],','\n').replace(',', '')\n  \n  \n  def solveGequal(ko, si, wn):\n      if 2*(wn + ko - 2) > si or ko*wn < si:\n          return None\n      ru = [0]*ko\n      ru[0] = ru[1] = wn\n      si -= 2*wn\n      for int in xrange(ko-2, 0, -1):\n          tf = min(wn, si - 2*int + 2)\n          ru[ko-int] = tf\n          si -= tf\n      return ru\n  \n  def solve(R, C, MI):\n      NS = R*C\n      NL = NS - MI\n      if R == 1 or C == 1:\n          if R == 1:\n              return '*'*MI + '.'*(NS-MI-1) + 'c'\n          else:\n              return '*\n'*M + '.\n'*(S-M-1) + 'c'\n      else:\n          stream = False\n          if R > C:\n              R, C = C, R\n              stream = True\n          if NL == 2 or NL == 3 or NL == 5 or NL == 7 or (R == 2 and NL%2 == 1 and NL > 1):\n              return \"Impossible\"\n          if NL == 1:\n              return generate(R, C, [1], stream)\n          for ko in xrange(2, R+1):\n              for wn in xrange(2, C+1):\n                  ru = solveGequal(ko, NL, wn)\n                  if ru != None:\n                      return generate(R, C, ru, stream)\n          return \"Something wrong\"\n  \n  for z in xrange(T):\n      c, f, x = map(int, raw_input().split())\n      print \"Case #%d:\n%si\" % (z+1, solve(c, f, x))\n ", "Program Length": 475, "Identifier Num": 23, "Replaced Identifiers": "x1:wn,M:MI,i:int,res:args,z:z,r:ru,k:ko,j:str,S:NS,nm:NL,a:args,solveEq:solveGequal,t:tf,s:si,sw:stream,", "Query Times": 750, "Time Cost": 0.3666855533917745, "Type": "Greedy"}
{"Index": 53, "Original Code": "T = int(raw_input())\n  \n  def readSq(n):\n      res = []\n      for i in xrange(n):\n          res.append(set(map(int, raw_input().split())))\n      return res\n  \n  def solve():\n      a1 = int(raw_input())\n      s1 = readSq(4)\n      a2 = int(raw_input())\n      s2 = readSq(4)\n      ans = s1[a1-1] & s2[a2-1]\n      if len(ans) == 0:\n          return \"Volunteer cheated!\"\n      if len(ans) > 1:\n          return \"Bad magician!\"\n      return str(list(ans)[0])\n  \n  for z in xrange(T):\n      print \"Case #%d: %s\" % (z+1, solve())\n ", "Adversarial Code": "O = int(raw_input())\n  \n  def  readSql(n):\n      resources = []\n      for f in xrange(n):\n          resources.append(set(map(int, raw_input().split())))\n      return resources\n  \n  def setsolve():\n       a3 = int(raw_input())\n      a01 =  readSql(4)\n       a02 = int(raw_input())\n      a4 =  readSql(4)\n      ans = a01[ a3-1] & a4[ a02-1]\n      if len(ans) == 0:\n          return \"Volunteer cheated!\"\n      if len(ans) > 1:\n          return \"Bad magician!\"\n      return str(list(ans)[0])\n  \n  for z in xrange(O):\n      print \"Case #%d: %s\" % (z+1, setsolve())\n ", "Program Length": 147, "Identifier Num": 12, "Replaced Identifiers": "solve:setsolve,T:O,s1:a01,a1: a3,a2: a02,s2:a4,res:resources,i:f,readSq: readSql,", "Query Times": 291, "Time Cost": 0.1659798542658488, "Type": "Greedy"}
{"Index": 54, "Original Code": " \n  T = int(input())\n  \n  for n in range(1, T+1):\n      print(\"Case #%d:\" % n)\n      (R, C, M) = (int(x) for x in input().split())\n      dots = R*C - M\n      if M == 0:\n          print(\"\n\".join([\"c\"+(C-1)*\".\"] + (R-1)*[C*\".\"]))\n      elif dots == 0:\n          print(\"Impossible\")\n      elif R == 1:\n          assert C - M > 0\n          print(\"c\"+(C-M-1)*\".\"+M*\"*\")\n      elif C == 1:\n          assert R - M > 0\n          print(\"c\n\"+(R-M-1)*\".\n\"+M*\"*\n\", end='')\n      elif dots == 1:\n          print(\"\n\".join([\"c\"+ (C-1)*\"*\"] + (R-1)*[C*\"*\"]))\n      elif dots > 3:\n          if (dots == 5) or (dots == 7):\n              print(\"Impossible\")\n              continue\n          if (R == 2) or (C == 2):\n              if dots%2 != 0 :\n                  print(\"Impossible\")\n                  continue\n              elif R == 2:\n                  l = int(dots/2)\n                  print(\"c\"+(l-1)*\".\"+(C-l)*\"*\")\n                  print(l*\".\"+(C-l)*\"*\")\n                  continue\n              elif C == 2:\n                  l = int(dots/2)\n                  print(\"c.\")\n                  print((l-1)*\"..\n\", end='')\n                  print(int(M/2)*\"**\n\", end='')\n                  continue\n          (lines, extra) = divmod(dots, C)\n          temp = []\n          if (lines >= 2) and (extra != 1):\n              temp.append(\"c\"+(C-1)*\".\")\n              temp.extend((lines-1)*[C*\".\"])\n              temp.append(extra*\".\"+(C-extra)*\"*\")\n              temp.extend((R-lines-1)*[C*\"*\"])\n              print(\"\n\".join(temp))\n              continue\n          elif (lines > 2) and (extra == 1):\n              temp.append(\"c\"+(C-1)*\".\")\n              temp.extend((lines-2)*[C*\".\"])\n              temp.append((C-1)*\".\"+\"*\")\n              temp.append(\"..\"+ (C-2)*\"*\")\n              temp.extend((R-lines-1)*[C*\"*\"])\n              print(\"\n\".join(temp))\n              continue\n          elif (lines == 2) and (extra == 1):\n              temp.append(\"c\"+(C-2)*\".\"+\"*\")\n              temp.append((C-1)*\".\"+\"*\")\n              temp.append(3*\".\"+(C-3)*\"*\")\n              temp.extend((R-3)*[C*\"*\"])\n              print(\"\n\".join(temp))\n              continue\n          elif lines < 2:\n              (l, rem) = divmod(dots, 2)\n              if rem == 1:\n                  l -= 1\n                  rem += 2\n              temp.append(\"c\"+(l-1)*\".\"+(C-l)*\"*\")\n              temp.append(l*\".\"+(C-l)*\"*\")\n              temp.append(rem*\".\"+(C-rem)*\"*\")\n              temp.extend( (R-3)*[ C*\"*\" ])\n              print(\"\n\".join(temp))\n              continue\n      else:\n          print(\"Impossible\")\n  \n ", "Adversarial Code": " \n  time = int(input())\n  \n  for n in range(1, time+1):\n      print(\"Case #%d:\" % n)\n      (UR, Cu, MQ) = (int(xxxxxxxx) for xxxxxxxx in input().split())\n      dots = UR*Cu - MQ\n      if MQ == 0:\n          print(\"\n\".join([\"c\"+(Cu-1)*\".\"] + (UR-1)*[Cu*\".\"]))\n      elif dots == 0:\n          print(\"Impossible\")\n      elif UR == 1:\n          assert Cu - MQ > 0\n          print(\"c\"+(Cu-MQ-1)*\".\"+MQ*\"*\")\n      elif Cu == 1:\n          assert UR - MQ > 0\n          print(\"c\n\"+(R-M-1)*\".\n\"+M*\"*\n\", anch='')\n      elif dots == 1:\n          print(\"\n\".join([\"c\"+ (Cu-1)*\"*\"] + (UR-1)*[Cu*\"*\"]))\n      elif dots > 3:\n          if (dots == 5) or (dots == 7):\n              print(\"Impossible\")\n              continue\n          if (UR == 2) or (Cu == 2):\n              if dots%2 != 0 :\n                  print(\"Impossible\")\n                  continue\n              elif UR == 2:\n                  l = int(dots/2)\n                  print(\"c\"+(l-1)*\".\"+(Cu-l)*\"*\")\n                  print(l*\".\"+(Cu-l)*\"*\")\n                  continue\n              elif Cu == 2:\n                  l = int(dots/2)\n                  print(\"c.\")\n                  print((l-1)*\"..\n\", anch='')\n                  print(int(MQ/2)*\"**\n\", anch='')\n                  continue\n          (lines, extra) = divmod(dots, Cu)\n          temp = []\n          if (lines >= 2) and (extra != 1):\n              temp.append(\"c\"+(Cu-1)*\".\")\n              temp.extend((lines-1)*[Cu*\".\"])\n              temp.append(extra*\".\"+(Cu-extra)*\"*\")\n              temp.extend((UR-lines-1)*[Cu*\"*\"])\n              print(\"\n\".join(temp))\n              continue\n          elif (lines > 2) and (extra == 1):\n              temp.append(\"c\"+(Cu-1)*\".\")\n              temp.extend((lines-2)*[Cu*\".\"])\n              temp.append((Cu-1)*\".\"+\"*\")\n              temp.append(\"..\"+ (Cu-2)*\"*\")\n              temp.extend((UR-lines-1)*[Cu*\"*\"])\n              print(\"\n\".join(temp))\n              continue\n          elif (lines == 2) and (extra == 1):\n              temp.append(\"c\"+(Cu-2)*\".\"+\"*\")\n              temp.append((Cu-1)*\".\"+\"*\")\n              temp.append(3*\".\"+(Cu-3)*\"*\")\n              temp.extend((UR-3)*[Cu*\"*\"])\n              print(\"\n\".join(temp))\n              continue\n          elif lines < 2:\n              (l, rem) = divmod(dots, 2)\n              if rem == 1:\n                  l -= 1\n                  rem += 2\n              temp.append(\"c\"+(l-1)*\".\"+(Cu-l)*\"*\")\n              temp.append(l*\".\"+(Cu-l)*\"*\")\n              temp.append(rem*\".\"+(Cu-rem)*\"*\")\n              temp.extend( (UR-3)*[ Cu*\"*\" ])\n              print(\"\n\".join(temp))\n              continue\n      else:\n          print(\"Impossible\")\n  \n ", "Program Length": 742, "Identifier Num": 10, "Replaced Identifiers": "end:anch,T:time,l:l,temp:temp,C:Cu,R:UR,x:xxxxxxxx,M:MQ,", "Query Times": 476, "Time Cost": 0.23893149693806967, "Type": "Greedy"}
{"Index": 55, "Original Code": " ncases = int(input())\n  \n  for n in range(1, ncases+1):\n      row = int(input())\n      for m in range(1, 5):\n          if m == row:\n              r1list = [int(x) for x in input().split()]\n              assert len(r1list) == 4\n          else:\n              tmp = input()\n      row = int(input())\n      for m in range(1,5):\n          if m == row:\n              r2list = [int(x) for x in input().split()]\n              assert len(r1list) == 4\n          else:\n              tmp = input()\n      nset = set(r1list) & set(r2list)\n      if len(nset) == 1:\n          print(\"Case #%d:\" % n, nset.pop())\n      elif len(nset) > 1:\n          print(\"Case #%d:\" % n, \"Bad magician!\")\n      else:\n          print(\"Case #%d:\" % n, \"Volunteer cheated!\")\n ", "Adversarial Code": " bcases = int(input())\n  \n  for n in range(1, bcases+1):\n      row = int(input())\n      for m in range(1, 5):\n          if m == row:\n              r1list = [int(x) for x in input().split()]\n              assert len(r1list) == 4\n          else:\n              tmp = input()\n      row = int(input())\n      for m in range(1,5):\n          if m == row:\n              r2list = [int(x) for x in input().split()]\n              assert len(r1list) == 4\n          else:\n              tmp = input()\n      nset = set(r1list) & set(r2list)\n      if len(nset) == 1:\n          print(\"Case #%d:\" % n, nset.pop())\n      elif len(nset) > 1:\n          print(\"Case #%d:\" % n, \"Bad magician!\")\n      else:\n          print(\"Case #%d:\" % n, \"Volunteer cheated!\")\n ", "Program Length": 187, "Identifier Num": 9, "Replaced Identifiers": "ncases:bcases,", "Query Times": 62, "Time Cost": 0.05517564217249552, "Type": "Greedy"}
{"Index": 57, "Original Code": null, "Adversarial Code": null, "Program Length": 230, "Identifier Num": 13, "Replaced Identifiers": null, "Query Times": 693, "Time Cost": 1.0650844653447469, "Type": "0"}
{"Index": 58, "Original Code": " \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n   \n  \n  \n  \n  \n  def debug(*args):\n      print(*args, file=sys.stderr)\n  \n  fin = sys.stdin\n  T = int(fin.readline())\n  for case in range(1, T + 1):\n      RR, CC, M = map(int, fin.readline().split())\n      R, C = None, None\n      blocks = RR*CC - M\n      inverse = False\n      if RR > CC:\n          inverse = True\n          R, C = CC, RR\n      else:\n          R, C = RR, CC\n      result = None\n      if R == 1:\n          result = [('.' * blocks) + ('*' * M)]\n      elif R == 2:\n          if blocks == 1:\n              result = ['.' + ('*' * (C-1)), '*' * C]\n          elif blocks % 2 == 0 and blocks != 2:\n              cc = blocks // 2\n              result = [('.' * cc) + ('*' * (C - cc)), ('.' * cc) + ('*' * (C - cc))] \n          else:\n              result = None\n      else:\n          if blocks == 1:\n              result = ['*' * C] * R\n          elif blocks == 4:\n              result = ['..' + (C-2)*'*']*2\n              result += ['*'*C] * (R-2)\n          elif blocks == 6:\n              result = ['...' + (C-3)*'*']*2\n              result += ['*'*C] * (R-2)\n          for rows in range(3, R+1):\n              for columns in range(rows, C+1):\n                  size = rows * columns\n                  if size - blocks >= 0:\n                      if size - blocks <= columns - 2: \n                          result = []\n                          for r in range(rows):\n                              if r < rows - 1:\n                                  result.append(('.' * columns) + ('*' * (C - columns)))\n                              else:\n                                  cc = columns - (size - blocks)\n                                  result.append(('.' * cc) + ('*' * (C - cc)))\n                          for r in range(R - rows):\n                              result.append('*' * C)\n                      elif size - blocks == columns - 1 and rows >= 4:\n                          result = []\n                          for r in range(rows):\n                              if r < rows - 2:\n                                  result.append(('.' * columns) + ('*' * (C - columns)))\n                              elif r == rows - 2:\n                                  cc = columns - 1\n                                  result.append(('.' * cc) + ('*' * (C - cc)))\n                              else:\n                                  cc = 2\n                                  result.append(('.' * cc) + ('*' * (C - cc)))\n                          for r in range(R - rows):\n                              result.append('*' * C)\n                      \n  \n  \n  \n      print(\"Case #%d: \" % (case))\n      if result is None:\n          debug('impossible', blocks, RR, CC)\n          print(\"Impossible\")\n      else:\n          mines = 0\n          for r in range(RR):\n              row = ''\n              for c in range(CC):\n                  rr, cc = r, c\n                  if inverse:\n                      rr, cc = c, r\n                  if rr == 0 and cc == 0:\n                      row += 'c'\n                  else:\n                      row += result[rr][cc]\n                      if result[rr][cc] == '*':\n                          mines += 1\n              print(row)\n          if mines != M:\n              raise Exception(\"%d != %d %d x %d\" % (mines, M, RR, CC))\n              \n  \n  \n ", "Adversarial Code": " \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n   \n  \n  \n  \n  \n  def debug(*args):\n      print(*args, file=sys.stderr)\n  \n  rb = sys.stdin\n  T = int(rb.readline())\n  for case in range(1, T + 1):\n      RR, CC, M = map(int, rb.readline().split())\n      R, C = None, None\n      blocks = RR*CC - M\n      inverse = False\n      if RR > CC:\n          inverse = True\n          R, C = CC, RR\n      else:\n          R, C = RR, CC\n      result = None\n      if R == 1:\n          result = [('.' * blocks) + ('*' * M)]\n      elif R == 2:\n          if blocks == 1:\n              result = ['.' + ('*' * (C-1)), '*' * C]\n          elif blocks % 2 == 0 and blocks != 2:\n              cc = blocks // 2\n              result = [('.' * cc) + ('*' * (C - cc)), ('.' * cc) + ('*' * (C - cc))] \n          else:\n              result = None\n      else:\n          if blocks == 1:\n              result = ['*' * C] * R\n          elif blocks == 4:\n              result = ['..' + (C-2)*'*']*2\n              result += ['*'*C] * (R-2)\n          elif blocks == 6:\n              result = ['...' + (C-3)*'*']*2\n              result += ['*'*C] * (R-2)\n          for rows in range(3, R+1):\n              for columns in range(rows, C+1):\n                  size = rows * columns\n                  if size - blocks >= 0:\n                      if size - blocks <= columns - 2: \n                          result = []\n                          for r in range(rows):\n                              if r < rows - 1:\n                                  result.append(('.' * columns) + ('*' * (C - columns)))\n                              else:\n                                  cc = columns - (size - blocks)\n                                  result.append(('.' * cc) + ('*' * (C - cc)))\n                          for r in range(R - rows):\n                              result.append('*' * C)\n                      elif size - blocks == columns - 1 and rows >= 4:\n                          result = []\n                          for r in range(rows):\n                              if r < rows - 2:\n                                  result.append(('.' * columns) + ('*' * (C - columns)))\n                              elif r == rows - 2:\n                                  cc = columns - 1\n                                  result.append(('.' * cc) + ('*' * (C - cc)))\n                              else:\n                                  cc = 2\n                                  result.append(('.' * cc) + ('*' * (C - cc)))\n                          for r in range(R - rows):\n                              result.append('*' * C)\n                      \n  \n  \n  \n      print(\"Case #%d: \" % (case))\n      if result is None:\n          debug('impossible', blocks, RR, CC)\n          print(\"Impossible\")\n      else:\n          mines = 0\n          for r in range(RR):\n              row = ''\n              for c in range(CC):\n                  rr, cc = r, c\n                  if inverse:\n                      rr, cc = c, r\n                  if rr == 0 and cc == 0:\n                      row += 'c'\n                  else:\n                      row += result[rr][cc]\n                      if result[rr][cc] == '*':\n                          mines += 1\n              print(row)\n          if mines != M:\n              raise Exception(\"%d != %d %d x %d\" % (mines, M, RR, CC))\n              \n  \n  \n ", "Program Length": 685, "Identifier Num": 17, "Replaced Identifiers": "fin:rb,", "Query Times": 204, "Time Cost": 0.08975270589192709, "Type": "Greedy"}
{"Index": 59, "Original Code": " \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  def debug(*args):\n      print(*args, file=sys.stderr)\n  \n  fin = sys.stdin\n  T = int(fin.readline())\n  for case in range(1, T + 1):\n      answer1 = int(fin.readline())\n      rows1 = []\n      for i in range(4):\n          rows1.append(set(map(int, fin.readline().split())))\n      answer2 = int(fin.readline())\n      rows2 = []\n      for i in range(4):\n          rows2.append(set(map(int, fin.readline().split())))\n  \n      possibilities1 = rows1[answer1-1]\n      possibilities2 = rows2[answer2-1]\n  \n      numbers = possibilities1.intersection(possibilities2)\n      result = None\n      if len(numbers) == 1:\n          result = list(numbers)[0]\n      elif len(numbers) == 0:\n          result = 'Volunteer cheated!'\n      else:\n          result = 'Bad magician!'\n  \n  \n      print(\"Case #%d: %s\" % (case, result))\n  \n ", "Adversarial Code": " \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  def main(*args):\n      print(*args, file=sys.stderr)\n  \n  ini = sys.stdin\n  T = int(ini.readline())\n  for case in range(1, T + 1):\n      answer1 = int(ini.readline())\n      rows1 = []\n      for i in range(4):\n          rows1.append(set(map(int, ini.readline().split())))\n      answer2 = int(ini.readline())\n      rows2 = []\n      for i in range(4):\n          rows2.append(set(map(int, ini.readline().split())))\n  \n      possibilities1 = rows1[answer1-1]\n      possibilities2 = rows2[answer2-1]\n  \n      numbers = possibilities1.intersection(possibilities2)\n      result = None\n      if len(numbers) == 1:\n          result = list(numbers)[0]\n      elif len(numbers) == 0:\n          result = 'Volunteer cheated!'\n      else:\n          result = 'Bad magician!'\n  \n  \n      print(\"Case #%d: %s\" % (case, result))\n  \n ", "Program Length": 203, "Identifier Num": 13, "Replaced Identifiers": "fin:ini,debug:main,", "Query Times": 125, "Time Cost": 0.06793182293574015, "Type": "Greedy"}
{"Index": 61, "Original Code": " \n  def read_row():\n  \ta = int(sys.stdin.readline().strip())\n  \tfor j in range(a - 1):\n  \t\tsys.stdin.readline()\n  \tread_set = set(sys.stdin.readline().strip().split(\" \"))\n  \tfor j in range(5 - a - 1):\n  \t\tsys.stdin.readline()\n  \t\t\n  \treturn read_set\n  \n  \n  t = int(sys.stdin.readline().strip())\n  \n  for i in range(t):\n  \tprint \"Case #\" + str(i + 1) + \":\",\n  \n  \tset1 = read_row()\n  \tset2 = read_row()\n  \t\n  \tintersect = set1.intersection(set2)\n  \t\n  \tif 1 == len(intersect):\n  \t\tprint intersect.pop()\n  \telif 0 == len(intersect):\n  \t\tprint \"Volunteer cheated!\"\n  \telse:\n  \t\tprint \"Bad magician!\"\n ", "Adversarial Code": " \n  def read_Row():\n  \tdata = int(sys.stdin.readline().strip())\n  \tfor jp in range(data - 1):\n  \t\tsys.stdin.readline()\n  \treadfSet = set(sys.stdin.readline().strip().split(\" \"))\n  \tfor jp in range(5 - data - 1):\n  \t\tsys.stdin.readline()\n  \t\t\n  \treturn readfSet\n  \n  \n  f = int(sys.stdin.readline().strip())\n  \n  for xi in range(f):\n  \tprint \"Case #\" + str(xi + 1) + \":\",\n  \n  \tcase3 = read_Row()\n  \tsetTwo = read_Row()\n  \t\n  \tInterect = case3.intersection(setTwo)\n  \t\n  \tif 1 == len(Interect):\n  \t\tprint Interect.pop()\n  \telif 0 == len(Interect):\n  \t\tprint \"Volunteer cheated!\"\n  \telse:\n  \t\tprint \"Bad magician!\"\n ", "Program Length": 162, "Identifier Num": 9, "Replaced Identifiers": "read_row:read_Row,set1:case3,j:jp,t:f,a:data,i:xi,intersect:Interect,read_set:readfSet,set2:setTwo,", "Query Times": 327, "Time Cost": 0.18121804396311442, "Type": "Greedy"}
{"Index": 62, "Original Code": null, "Adversarial Code": null, "Program Length": 835, "Identifier Num": 24, "Replaced Identifiers": null, "Query Times": 1438, "Time Cost": 2.1269960006078086, "Type": "0"}
{"Index": 63, "Original Code": null, "Adversarial Code": null, "Program Length": 363, "Identifier Num": 21, "Replaced Identifiers": null, "Query Times": 1097, "Time Cost": 1.7080320835113525, "Type": "0"}
{"Index": 65, "Original Code": " \n  \n  \n  def read_grid(f):\n  \treturn [\n  \t\t[int(x) for x in line.split()]\n  \t\tfor line in [f.readline() for _ in range(4)]\n  \t]\n  \n  def read_case(f):\n  \tanswer1 = int(f.readline())\n  \tgrid1 = read_grid(f)\n  \tanswer2 = int(f.readline())\n  \tgrid2 = read_grid(f)\n  \treturn (grid1[answer1 - 1], grid2[answer2 - 1])\n  \n  \n  def solve(r1, r2):\n  \tres = set(r1) & set(r2)\n  \tif len(res) == 0:\n  \t\treturn 'Volunteer cheated!'\n  \tif len(res) == 1:\n  \t\treturn list(res)[0]\n  \treturn 'Bad magician!'\n  \n  \n  \n  def main():\n  \tfn = sys.argv[1]\n  \twith open(fn, encoding='utf-8') as f:\n  \t\tncases = int(f.readline())\n  \t\tfor case in range(1, ncases + 1):\n  \t\t\trow1, row2 = read_case(f)\n  \t\t\tsolution = solve(row1, row2)\n  \t\t\tprint('Case #{}: {}'.format(case, solution))\n  \n  \n  if __name__ == '__main__':\n  \tmain()\n ", "Adversarial Code": " \n  \n  \n  def readfcase(http):\n  \treturn [\n  \t\t[int(X) for X in file.split()]\n  \t\tfor file in [http.readline() for len in range(4)]\n  \t]\n  \n  def read_case(http):\n  \tresponseOne = int(http.readline())\n  \t grid01 = readfcase(http)\n  \tAnswer1 = int(http.readline())\n  \tgridtwo = readfcase(http)\n  \treturn ( grid01[responseOne - 1], gridtwo[Answer1 - 1])\n  \n  \n  def resolve(R2, R0):\n  \tgrid = set(R2) & set(R0)\n  \tif len(grid) == 0:\n  \t\treturn 'Volunteer cheated!'\n  \tif len(grid) == 1:\n  \t\treturn list(grid)[0]\n  \treturn 'Bad magician!'\n  \n  \n  \n  def python():\n  \tfn = sys.argv[1]\n  \twith open(fn, encoding='utf-8') as http:\n  \t\tncasing = int(http.readline())\n  \t\tfor nce in range(1, ncasing + 1):\n  \t\t\trows2, line2 = read_case(http)\n  \t\t\tSolver = resolve(rows2, line2)\n  \t\t\tprint('Case #{}: {}'.format(nce, Solver))\n  \n  \n  if __name__ == '__main__':\n  \tpython()\n ", "Program Length": 223, "Identifier Num": 21, "Replaced Identifiers": "f:http,solve:resolve,case:nce,row2:line2,ncases:ncasing,row1:rows2,line:file,res:grid,x:X,_:len,solution:Solver,main:python,grid1: grid01,grid2:gridtwo,answer1:responseOne,answer2:Answer1,r1:R2,r2:R0,read_grid:readfcase,", "Query Times": 592, "Time Cost": 0.33609240452448524, "Type": "Greedy"}
{"Index": 66, "Original Code": " \n  lines = [line.strip() for line in open(sys.argv[1])]\n  count = int(lines[0])\n  \n  for i in xrange(count):\n      R,C,M = map(int, lines[i+1].split())\n      print \"Case #%s:\" % (i+1)\n  \n      w = max(R,C)\n      h = min(R,C)\n      X = R*C - M\n      assert X > 0\n  \n      if X == 1:\n          rows = ['c' + ('*' * (w-1))] + (h-1) * ['*' * w]\n      elif h == 1:\n          rows = ['c' + '.' * (X-1) + '*' * M]\n      elif X == 4:\n              rows = [\n                  'c.' + '*' * (w-2),\n                  '..' + '*' * (w-2),\n              ] + ['*' * w] * (h-2)\n      elif h == 2:\n          if X%2 == 1 or X == 2:\n              rows = None\n          else:\n              rows = [\n                  'c' + '.' * (X/2-1) + '*' * (M/2),\n                  '.' + '.' * (X/2-1) + '*' * (M/2)\n              ]\n      elif X <= 5 or X == 7:\n          rows = None\n  \n      elif X%2 == 0 and X <= w*2:\n          r = X/2\n          rows = [\n              'c' + '.' * (r - 1) + '*' * (w-r),\n                    '.' * r       + '*' * (w-r),\n          ] + ['*' * w] * (h-2)\n  \n      elif X <= w*3 and (X % 3) != 1:\n          n = (X+1) / 3\n          t = X - 2*n\n          rows = [\n              'c' + '.' * (n-1) + '*' * (w-n),\n                    '.' * n     + '*' * (w-n),\n                    '.' * t     + '*' * (w-t)\n          ] + ['*' * w] * (h-3)\n      else:\n          n = X / w\n          t = X % w\n          if t == 1:\n              rows = (\n                      ['c' + (w-1) * '.']\n                  +   ['.' * w] * (n-2)\n                  +   ['.' * (w-1) + '*']\n                  +   ['..' + '*' * (w-2)]\n                  +   ['*' * w] * (h - n - 1)\n              )\n          else:\n              k = 1 if t == 0 else 0\n              rows = (\n                      ['c' + (w-1) * '.']\n                  +   ['.' * w] * (n-1)\n                  +   ['.' * t + '*' * (w-t)] * (1 - k)\n                  +   ['*' * w] * (h - n - 1 + k)\n              )\n  \n      if rows:\n          if R > C:\n              rows = [\"\".join(row[i] for row in rows) for i in xrange(R)]\n  \n          for row in rows:\n              print row\n  \n          assert len(rows) == R\n          assert len(rows[0]) == C\n          assert sum(1 for row in rows for col in row if col == '*') == M\n  \n      else:\n          print \"Impossible\"\n  \n ", "Adversarial Code": " \n  lines = [file.strip() for file in open(sys.argv[1])]\n  call = int(lines[0])\n  \n  for i in xrange(call):\n      R,C,M = map(int, lines[i+1].split())\n      print \"Case #%s:\" % (i+1)\n  \n      w = max(R,C)\n      h = min(R,C)\n      Event = R*C - M\n      assert Event > 0\n  \n      if Event == 1:\n          rows = ['c' + ('*' * (w-1))] + (h-1) * ['*' * w]\n      elif h == 1:\n          rows = ['c' + '.' * (Event-1) + '*' * M]\n      elif Event == 4:\n              rows = [\n                  'c.' + '*' * (w-2),\n                  '..' + '*' * (w-2),\n              ] + ['*' * w] * (h-2)\n      elif h == 2:\n          if Event%2 == 1 or Event == 2:\n              rows = None\n          else:\n              rows = [\n                  'c' + '.' * (Event/2-1) + '*' * (M/2),\n                  '.' + '.' * (Event/2-1) + '*' * (M/2)\n              ]\n      elif Event <= 5 or Event == 7:\n          rows = None\n  \n      elif Event%2 == 0 and Event <= w*2:\n          r = Event/2\n          rows = [\n              'c' + '.' * (r - 1) + '*' * (w-r),\n                    '.' * r       + '*' * (w-r),\n          ] + ['*' * w] * (h-2)\n  \n      elif Event <= w*3 and (Event % 3) != 1:\n          n = (Event+1) / 3\n          t = Event - 2*n\n          rows = [\n              'c' + '.' * (n-1) + '*' * (w-n),\n                    '.' * n     + '*' * (w-n),\n                    '.' * t     + '*' * (w-t)\n          ] + ['*' * w] * (h-3)\n      else:\n          n = Event / w\n          t = Event % w\n          if t == 1:\n              rows = (\n                      ['c' + (w-1) * '.']\n                  +   ['.' * w] * (n-2)\n                  +   ['.' * (w-1) + '*']\n                  +   ['..' + '*' * (w-2)]\n                  +   ['*' * w] * (h - n - 1)\n              )\n          else:\n              k = 1 if t == 0 else 0\n              rows = (\n                      ['c' + (w-1) * '.']\n                  +   ['.' * w] * (n-1)\n                  +   ['.' * t + '*' * (w-t)] * (1 - k)\n                  +   ['*' * w] * (h - n - 1 + k)\n              )\n  \n      if rows:\n          if R > C:\n              rows = [\"\".join(row[i] for row in rows) for i in xrange(R)]\n  \n          for row in rows:\n              print row\n  \n          assert len(rows) == R\n          assert len(rows[0]) == C\n          assert sum(1 for row in rows for col in row if col == '*') == M\n  \n      else:\n          print \"Impossible\"\n  \n ", "Program Length": 652, "Identifier Num": 14, "Replaced Identifiers": "line:file,X:Event,count:call,", "Query Times": 264, "Time Cost": 0.11469408273696899, "Type": "Greedy"}
{"Index": 67, "Original Code": " \n  \n  lines = [map(int, line.strip().split(\" \")) for line in open(sys.argv[1]).readlines()]\n  [count] = lines[0]\n  assert count * 10 + 1 == len(lines)\n  \n  for i in xrange(count):\n      base = i*10\n      [n1] = lines[base+1]\n      [n2] = lines[base+6]\n      row1 = set(lines[base+1+n1])\n      row2 = set(lines[base+6+n2])\n      common = row1.intersection(row2)\n      print \"Case #%s:\" % (i+1),\n      if len(common) == 1:\n          print list(common)[0]\n      elif not common:\n          print \"Volunteer cheated!\"\n      else:\n          print \"Bad magician!\"\n ", "Adversarial Code": " \n  \n  lines = [map(int, line.strip().split(\" \")) for line in open(sys.argv[1]).readlines()]\n  [file] = lines[0]\n  assert file * 10 + 1 == len(lines)\n  \n  for i in xrange(file):\n      base = i*10\n      [n1] = lines[base+1]\n      [n2] = lines[base+6]\n      row1 = set(lines[base+1+n1])\n      row2 = set(lines[base+6+n2])\n      common = row1.intersection(row2)\n      print \"Case #%s:\" % (i+1),\n      if len(common) == 1:\n          print list(common)[0]\n      elif not common:\n          print \"Volunteer cheated!\"\n      else:\n          print \"Bad magician!\"\n ", "Program Length": 156, "Identifier Num": 10, "Replaced Identifiers": "count:file,", "Query Times": 69, "Time Cost": 0.05320322116216024, "Type": "Greedy"}
{"Index": 68, "Original Code": null, "Adversarial Code": null, "Program Length": 781, "Identifier Num": 21, "Replaced Identifiers": null, "Query Times": 1193, "Time Cost": 1.7290993769963583, "Type": "0"}
{"Index": 69, "Original Code": null, "Adversarial Code": null, "Program Length": 359, "Identifier Num": 28, "Replaced Identifiers": null, "Query Times": 1316, "Time Cost": 2.202369729677836, "Type": "0"}
{"Index": 70, "Original Code": " \n  lines = iter('''\n  13\n  5 5 23\n  3 1 1\n  1 3 1\n  2 2 1\n  4 7 3\n  10 10 82\n  10 1 4\n  1 10 5\n  2 10 8\n  10 2 8\n  2 10 9\n  10 2 7\n  5 3 3\n  '''.splitlines(False)[1:])\n  out = sys.stdout\n  \n  sys.setrecursionlimit(1500)\n  \n  \n  class MyException(Exception):\n  \tpass\n  lines = iter(open(r'C-small-attempt7.in').readlines(False))\n  out = open('c-small.answer', 'w')\n  \n  def solve(C, R, M):\n  \tboard = [['.']*C for _ in range(R)]\n  \tboard[-1][-1] = 'c'\n  \ttry:\n  \t\tfor r in range(R-2):\n  \t\t\tfor c in range(C-2):\n  \t\t\t\tif r == R-3 and c == C-3:\n  \t\t\t\t\traise StopIteration()\n  \t\t\t\tboard[r][c] = '*'\n  \t\t\t\tM -= 1\n  \t\t\t\tif M == 0:\n  \t\t\t\t\treturn board \n  \texcept StopIteration:\n  \t\tpass\n  \t\t\n  \tif M % 2 == 0:\n  \t\tfor r in range(R-3):\n  \t\t\tboard[r][C-1] = '*'\n  \t\t\tboard[r][C-2] = '*'\n  \t\t\tM -= 2\n  \t\t\tif M == 0:\n  \t\t\t\treturn board\n  \t\tfor c in range(C-3):\n  \t\t\tboard[R-1][c] = '*'\n  \t\t\tboard[R-2][c] = '*'\n  \t\t\tM -= 2\n  \t\t\tif M == 0:\n  \t\t\t\treturn board\n  \t\t\n  \t\t\n  \t\traise MyException()\n  \telse:\n  \t\tboard[R-3][C-3] = '*'\n  \t\tM -= 1\n  \t\tif M == 0:\n  \t\t\treturn board\n  \t\tfor r in range(R-2):\n  \t\t\tboard[r][C-1] = '*'\n  \t\t\tboard[r][C-2] = '*'\n  \t\t\tM -= 2\n  \t\t\tif M == 0:\n  \t\t\t\treturn board\n  \t\tfor c in range(C-2):\n  \t\t\tboard[R-1][c] = '*'\n  \t\t\tboard[R-2][c] = '*'\n  \t\t\tM -= 2\n  \t\t\tif M == 0:\n  \t\t\t\treturn board\n  \t\t\n  \t\traise MyException()\n  \t\t\n  \t\n  caseCnt = int(next(lines))\n  \n  for case in range(1, caseCnt+1):\n  \tR,C,M = map(int, next(lines).split())\n  \t\n  \tprint('Case #%d:'%case, file=out)\n  \tif M == 0:\n  \t\tprint('c' + '.'*(C-1), file=out)\n  \t\tfor _ in range(R-1):\n  \t\t\tprint('.'*C, file=out)\n  \telif R*C==M+1:\n  \t\tprint('c' + '*'*(C-1), file=out)\n  \t\tfor _ in range(R-1):\n  \t\t\tprint('*'*C, file=out)\n  \telif C == 1 and R == 1:\n  \t\tprint('Impossible', file=out)\n  \telif C == 1:\n  \t\tif M > R-1:\n  \t\t\tprint('Impossible', file=out)\n  \t\telse:\n  \t\t\tprint('c', file=out)\n  \t\t\tfor _ in range(R-M-1):\n  \t\t\t\tprint('.', file=out)\n  \t\t\tfor _ in range(M):\n  \t\t\t\tprint('*', file=out)\n  \telif R == 1:\n  \t\tif M > C-1:\n  \t\t\tprint('Impossible', file=out)\n  \t\telse:\n  \t\t\tprint('c' + '.'*(C-M-1) + '*'*M, file=out)\n  \telif C == 2:\n  \t\tif M %2 or M//2 > R-2:\n  \t\t\tprint('Impossible', file=out)\n  \t\telse:\n  \t\t\tprint('c.', file=out)\n  \t\t\tfor _ in range(R-M//2-1):\n  \t\t\t\tprint('..', file=out)\n  \t\t\tfor _ in range(M//2):\n  \t\t\t\tprint('**', file=out)\n  \telif R == 2:\n  \t\tif M %2 or M//2 > C-2:\n  \t\t\tprint('Impossible', file=out)\n  \t\telse:\n  \t\t\tprint('c' + '.'*(C-M//2-1) + '*'*(M//2), file=out)\n  \t\t\tprint(      '.'*(C-M//2)   + '*'*(M//2), file=out)\n  \telif M > R*C-4:\n  \t\tprint('Impossible', file=out)\n  \telse:\n  \t\ttry:\n  \t\t\tboard = solve(C, R, M)\n  \t\t\tfor line in board:\n  \t\t\t\tprint(''.join(line), file=out)\n  \t\texcept MyException:\n  \t\t\tprint('Impossible', file=out)\n  \t\n  \t\n ", "Adversarial Code": " \n  users = iter('''\n  13\n  5 5 23\n  3 1 1\n  1 3 1\n  2 2 1\n  4 7 3\n  10 10 82\n  10 1 4\n  1 10 5\n  2 10 8\n  10 2 8\n  2 10 9\n  10 2 7\n  5 3 3\n  '''.splitlines(False)[1:])\n  problem = sys.stdout\n  \n  sys.setrecursionlimit(1500)\n  \n  \n  class MyException(Exception):\n  \tpass\n  users = iter(open(r'C-small-attempt7.in').readlines(False))\n  problem = open('c-small.answer', 'w')\n  \n  def solve(AC, Review, OR):\n  \tcatch = [['.']*AC for _ in range(Review)]\n  \tcatch[-1][-1] = 'c'\n  \ttry:\n  \t\tfor w in range(Review-2):\n  \t\t\tfor coll in range(AC-2):\n  \t\t\t\tif w == Review-3 and coll == AC-3:\n  \t\t\t\t\traise StopIteration()\n  \t\t\t\tcatch[w][coll] = '*'\n  \t\t\t\tOR -= 1\n  \t\t\t\tif OR == 0:\n  \t\t\t\t\treturn catch \n  \texcept StopIteration:\n  \t\tpass\n  \t\t\n  \tif OR % 2 == 0:\n  \t\tfor w in range(Review-3):\n  \t\t\tcatch[w][AC-1] = '*'\n  \t\t\tcatch[w][AC-2] = '*'\n  \t\t\tOR -= 2\n  \t\t\tif OR == 0:\n  \t\t\t\treturn catch\n  \t\tfor coll in range(AC-3):\n  \t\t\tcatch[Review-1][coll] = '*'\n  \t\t\tcatch[Review-2][coll] = '*'\n  \t\t\tOR -= 2\n  \t\t\tif OR == 0:\n  \t\t\t\treturn catch\n  \t\t\n  \t\t\n  \t\traise MyException()\n  \telse:\n  \t\tcatch[Review-3][AC-3] = '*'\n  \t\tOR -= 1\n  \t\tif OR == 0:\n  \t\t\treturn catch\n  \t\tfor w in range(Review-2):\n  \t\t\tcatch[w][AC-1] = '*'\n  \t\t\tcatch[w][AC-2] = '*'\n  \t\t\tOR -= 2\n  \t\t\tif OR == 0:\n  \t\t\t\treturn catch\n  \t\tfor coll in range(AC-2):\n  \t\t\tcatch[Review-1][coll] = '*'\n  \t\t\tcatch[Review-2][coll] = '*'\n  \t\t\tOR -= 2\n  \t\t\tif OR == 0:\n  \t\t\t\treturn catch\n  \t\t\n  \t\traise MyException()\n  \t\t\n  \t\n  caseCnt = int(next(users))\n  \n  for case in range(1, caseCnt+1):\n  \tReview,AC,OR = map(int, next(users).split())\n  \t\n  \tprint('Case #%d:'%case, file=problem)\n  \tif OR == 0:\n  \t\tprint('c' + '.'*(AC-1), file=problem)\n  \t\tfor _ in range(Review-1):\n  \t\t\tprint('.'*AC, file=problem)\n  \telif Review*AC==OR+1:\n  \t\tprint('c' + '*'*(AC-1), file=problem)\n  \t\tfor _ in range(Review-1):\n  \t\t\tprint('*'*AC, file=problem)\n  \telif AC == 1 and Review == 1:\n  \t\tprint('Impossible', file=problem)\n  \telif AC == 1:\n  \t\tif OR > Review-1:\n  \t\t\tprint('Impossible', file=problem)\n  \t\telse:\n  \t\t\tprint('c', file=problem)\n  \t\t\tfor _ in range(Review-OR-1):\n  \t\t\t\tprint('.', file=problem)\n  \t\t\tfor _ in range(OR):\n  \t\t\t\tprint('*', file=problem)\n  \telif Review == 1:\n  \t\tif OR > AC-1:\n  \t\t\tprint('Impossible', file=problem)\n  \t\telse:\n  \t\t\tprint('c' + '.'*(AC-OR-1) + '*'*OR, file=problem)\n  \telif AC == 2:\n  \t\tif OR %2 or OR//2 > Review-2:\n  \t\t\tprint('Impossible', file=problem)\n  \t\telse:\n  \t\t\tprint('c.', file=problem)\n  \t\t\tfor _ in range(Review-OR//2-1):\n  \t\t\t\tprint('..', file=problem)\n  \t\t\tfor _ in range(OR//2):\n  \t\t\t\tprint('**', file=problem)\n  \telif Review == 2:\n  \t\tif OR %2 or OR//2 > AC-2:\n  \t\t\tprint('Impossible', file=problem)\n  \t\telse:\n  \t\t\tprint('c' + '.'*(AC-OR//2-1) + '*'*(OR//2), file=problem)\n  \t\t\tprint(      '.'*(AC-OR//2)   + '*'*(OR//2), file=problem)\n  \telif OR > Review*AC-4:\n  \t\tprint('Impossible', file=problem)\n  \telse:\n  \t\ttry:\n  \t\t\tcatch = solve(AC, Review, OR)\n  \t\t\tfor line in catch:\n  \t\t\t\tprint(''.join(line), file=problem)\n  \t\texcept MyException:\n  \t\t\tprint('Impossible', file=problem)\n  \t\n  \t\n ", "Program Length": 842, "Identifier Num": 12, "Replaced Identifiers": "caseCnt:caseCnt,case:case,M:OR,board:catch,C:AC,R:Review,out:problem,r:w,c:coll,lines:users,", "Query Times": 716, "Time Cost": 0.2878018140792847, "Type": "Greedy"}
{"Index": 72, "Original Code": null, "Adversarial Code": null, "Program Length": 1789, "Identifier Num": 19, "Replaced Identifiers": null, "Query Times": 1147, "Time Cost": 1.7760732094446818, "Type": "0"}
{"Index": 73, "Original Code": null, "Adversarial Code": null, "Program Length": 863, "Identifier Num": 19, "Replaced Identifiers": null, "Query Times": 1141, "Time Cost": 1.5696903665860493, "Type": "0"}
{"Index": 75, "Original Code": " \n  \n  def Solve(F1,r1,F2,r2):\n      s1=set(F1[r1-1])\n      s2=set(F2[r2-1])\n      sx=s1.intersection(s2)\n      if len(sx)>1:\n          return \"Bad magician!\"\n      elif len(sx)==0:\n          return \"Volunteer cheated!\"\n      else:\n          return sx.__iter__().next()\n  \n  \n  \n  def parse(infile):\n      r1=int(infile.readline().strip())\n      F1=[]\n      for i in xrange(4):\n          F1.append( map(int, infile.readline().split() ))\n      r2=int(infile.readline().strip())\n      F2=[]\n      for i in xrange(4):\n          F2.append( map(int, infile.readline().split() ))\n      return F1,r1,F2,r2\n  \n  \n  \n  class GCJ_Parser( object ):\n      def __init__(self,fname):\n          self.infile=open(fname,'r')\n          self.NumCases=int(self.infile.readline().strip() )\n          self.caseNum=0\n  \n      def __iter__(self): return self\n  \n      def next(self):\n          if self.caseNum==self.NumCases: raise StopIteration\n          self.caseNum += 1\n          args=parse(self.infile)\n          return self.caseNum , args\n  \n  \n  def runmain():\n      myCases=GCJ_Parser(sys.argv[1])\n  \n      outname=sys.argv[1].rstrip('.in')+'.out'\n      if os.path.isfile(outname):\n          oldout=outname+'.old'\n          ii=0\n          while os.path.isfile(oldout):\n              ii+=1\n              oldout=outname+'.old'+str(ii)\n          os.rename(outname,oldout)\n          print 'Rename: %s -> %s'%(outname,oldout)   \n   \n      outfile=open(outname,'w')\n  \n      for iCase, args in myCases:\n          answer=Solve(*args)\n  \n          print 'Case #'+str(iCase)+':',answer\n          print >> outfile, 'Case #'+str(iCase)+':',answer\n  \n  \n  \n  \n  if __name__=='__main__':\n      runmain()\n ", "Adversarial Code": " \n  \n  def Resolver(F3,r1,F2,R8):\n      s1=set(F3[r1-1])\n      S52=set(F2[R8-1])\n      ssxs1.intersection(S52)\n      if len(sx)>1:\n          return \"Bad magician!\"\n      elif len(sx)==0:\n          return \"Volunteer cheated!\"\n      else:\n          return ssx__call___().next()\n  \n  \n  \n  def case(binline):\n      r1=int(binline.readline().strip())\n      F3=[]\n      for i in xrange(4):\n          F3.append( map(int, binline.readline().split() ))\n      R8=int(binline.readline().strip())\n      F2=[]\n      for i in xrange(4):\n          F2.append( map(int, binline.readline().split() ))\n      return F3,r1,F2,R8\n  \n  \n  \n  class GCJ_Parser( object ):\n      def __call____(self,flatno):\n          sselfbinline=open(flatno,'r')\n          sselfNNumberCasesint(sselfbinline.readline().strip() )\n          self.caseNum=0\n  \n      def __call___(self): return self\n  \n      def next(self):\n          if self.cascaseNumelf.NumberCases: raise StopIteration\n          self.caseNum += 1\n          lines=case(sselfbinline)\n          return self.caseNum , lines\n  \n  \n  def runmain():\n      myCases=GCJ_Parser(sys.argv[1])\n  \n      outname=sys.argv[1].rstrip('.in')+'.out'\n      if os.path.isfile(outname):\n          oldout=outname+'.old'\n          ii=0\n          while os.path.isfile(oldout):\n              ii+=1\n              oldout=outname+'.old'+str(ii)\n          os.rename(outname,oldout)\n          print 'Rename: %s -> %s'%(outname,oldout)   \n   \n      outfile=open(outname,'w')\n  \n      for i iSection lines in myCases:\n          answexampleolver(*lines)\n  \n          print 'Case #'+str( iSection)+':',example\n          print >> outfile, 'Case #'+str( iSection)+':',example\n  \n  \n  \n  \n  if __name__=='__main__':\n      runmain()\n ", "Program Length": 412, "Identifier Num": 27, "Replaced Identifiers": "Solve:Resolver,parse:case,runmain:runmain,__init__:__call____,__iter__:__call___,next:next,F1:F3,r1:r1,F2:F2,r2:R8,s1:s1,s2:S52,sx:sx,infile:binline,i:i,self:self,fname:flatno,NumCases:NumberCases,caseNum:caseNum,args:lines,myCases:myCases,outname:outname,oldout:oldout,ii:ii,outfile:outfile,iCase: iSection,answer:example,", "Query Times": 1211, "Time Cost": 1.6297048608462015, "Type": "GA"}
{"Index": 76, "Original Code": null, "Adversarial Code": null, "Program Length": 656, "Identifier Num": 16, "Replaced Identifiers": null, "Query Times": 1040, "Time Cost": 1.2365410248438518, "Type": "0"}
{"Index": 77, "Original Code": null, "Adversarial Code": null, "Program Length": 225, "Identifier Num": 13, "Replaced Identifiers": null, "Query Times": 618, "Time Cost": 0.9134883522987366, "Type": "0"}
{"Index": 78, "Original Code": " \n  \n  '''\n  ...\n  ...\n  ...\n  ...\n  ...\n  '''\n  \n  for i in range(int(input())):\n  \n      r, c, m = tuple(map(int, str.split(input())))\n      count = r * c - m\n      field = dict(map(lambda c: (c, \"*\"), itertools.product(range(c), range(r))))\n      answer = \"Impossible\"\n  \n      if m == 0:\n  \n          answer = field\n  \n      elif 1 in (r, c):\n  \n          for p in itertools.islice(itertools.product(range(c), range(r)), count):\n  \n              field[p] = \".\"\n  \n          answer = field\n  \n      elif count in (0, 2, 3, 5, 7):\n  \n          pass\n  \n      elif count == 1:\n  \n          answer = field\n  \n      elif count // 2 < c or count == c * 2 + 1:\n  \n          if count % 2 != 0:\n  \n              tail = 3\n              ncount = count - 3\n  \n          else:\n  \n              tail = 0\n              ncount = count\n  \n          for x in range(ncount // 2):\n  \n              field[(x, 0)] = field[(x, 1)] = \".\"\n  \n          for x in range(tail):\n  \n              field[(x, 2)] = \".\"\n  \n          answer = field\n  \n      elif not (c == 2 and count % c == 1):\n  \n          for x in range(c):\n  \n              field[(x, 0)] = field[(x, 1)] = \".\"\n  \n          count -= 2 * c\n          tail = 0\n          if count % c == 1:\n  \n              tail = 2\n              count -= 1\n  \n          y = 2\n          while count > 0:\n  \n              rx = min(count, c)\n              for x in range(rx):\n  \n                  field[(x, y)] = \".\"\n  \n              count -= rx\n              y += 1\n  \n          for x in range(tail):\n  \n              field[(x, y)] = \".\"\n  \n          answer = field\n  \n      field[(0, 0)] = \"c\"\n      print(str.format(\"Case #{}:\", i + 1))\n      if isinstance(answer, dict):\n  \n          for y in range(r):\n  \n              print(str.join(\"\", map(lambda x: field[(x, y)], range(c))))\n  \n      else:\n  \n          print(answer)\n ", "Adversarial Code": " \n  \n  '''\n  ...\n  ...\n  ...\n  ...\n  ...\n  '''\n  \n  for i in range(int(input())):\n  \n      r, c, m = tuple(map(int, str.split(input())))\n      count = r * c - m\n      Field = dict(map(lambda c: (c, \"*\"), itertools.product(range(c), range(r))))\n      question = \"Impossible\"\n  \n      if m == 0:\n  \n          question = Field\n  \n      elif 1 in (r, c):\n  \n          for p in itertools.islice(itertools.product(range(c), range(r)), count):\n  \n              Field[p] = \".\"\n  \n          question = Field\n  \n      elif count in (0, 2, 3, 5, 7):\n  \n          pass\n  \n      elif count == 1:\n  \n          question = Field\n  \n      elif count // 2 < c or count == c * 2 + 1:\n  \n          if count % 2 != 0:\n  \n              tail = 3\n              ncount = count - 3\n  \n          else:\n  \n              tail = 0\n              ncount = count\n  \n          for x in range(ncount // 2):\n  \n              Field[(x, 0)] = Field[(x, 1)] = \".\"\n  \n          for x in range(tail):\n  \n              Field[(x, 2)] = \".\"\n  \n          question = Field\n  \n      elif not (c == 2 and count % c == 1):\n  \n          for x in range(c):\n  \n              Field[(x, 0)] = Field[(x, 1)] = \".\"\n  \n          count -= 2 * c\n          tail = 0\n          if count % c == 1:\n  \n              tail = 2\n              count -= 1\n  \n          y = 2\n          while count > 0:\n  \n              rx = min(count, c)\n              for x in range(rx):\n  \n                  Field[(x, y)] = \".\"\n  \n              count -= rx\n              y += 1\n  \n          for x in range(tail):\n  \n              Field[(x, y)] = \".\"\n  \n          question = Field\n  \n      Field[(0, 0)] = \"c\"\n      print(str.format(\"Case #{}:\", i + 1))\n      if isinstance(question, dict):\n  \n          for y in range(r):\n  \n              print(str.join(\"\", map(lambda x: Field[(x, y)], range(c))))\n  \n      else:\n  \n          print(question)\n ", "Program Length": 436, "Identifier Num": 13, "Replaced Identifiers": "field:Field,answer:question,", "Query Times": 272, "Time Cost": 0.08764243125915527, "Type": "Greedy"}
{"Index": 79, "Original Code": "def read_case():\n  \n      answer = int(input())\n      lines = tuple(map(lambda _: set(str.split(input())), range(4)))\n      return lines[answer - 1]\n  \n  \n  for i in range(int(input())):\n  \n      intersection = read_case() & read_case()\n      count = len(intersection)\n      if count == 1:\n  \n          answer = intersection.pop()\n  \n      elif count > 1:\n  \n          answer = \"Bad magician!\"\n  \n      elif count < 1:\n  \n          answer = \"Volunteer cheated!\"\n  \n      print(str.format(\"Case #{}: {}\", i + 1, answer))\n ", "Adversarial Code": "def read_line():\n  \n      line = int(input())\n      comments = tuple(map(lambda _: set(str.split(input())), range(4)))\n      return comments[line - 1]\n  \n  \n  for ind in range(int(input())):\n  \n      INTERsections = read_line() & read_line()\n      code = len(INTERsections)\n      if code == 1:\n  \n          line = INTERsections.pop()\n  \n      elif code > 1:\n  \n          line = \"Bad magician!\"\n  \n      elif code < 1:\n  \n          line = \"Volunteer cheated!\"\n  \n      print(str.format(\"Case #{}: {}\", ind + 1, line))\n ", "Program Length": 118, "Identifier Num": 6, "Replaced Identifiers": "intersection:INTERsections,answer:line,lines:comments,count:code,i:ind,read_case:read_line,", "Query Times": 287, "Time Cost": 0.11340028444925944, "Type": "Greedy"}
{"Index": 80, "Original Code": " \n  class Solver(object):\n      def __init__(self):\n          pass\n      \n      def solve(self, inputs):\n          R, C, M = [int(x) for x in inputs[0].split()]\n          mp = []\n          for r in range(R):\n              mp.append(['.']*C)\n          mp[0][0] = 'c'\n          outputs = []\n          if M == 0:\n              for row in mp:\n                  outputs.append(''.join(row))\n              return outputs\n          rr, cc, rm = R, C, M\n          while rm >= min(rr, cc):\n              if rr <= cc:\n                  for r in range(rr):\n                      mp[r][cc-1] = '*'\n                  cc -= 1\n                  rm -= rr\n              else:\n                  for c in range(cc):\n                      mp[rr-1][c] = '*'\n                  rr -= 1\n                  rm -= cc\n          \n          if rm == 0:\n              if (min(rr, cc), max(rr, cc)) == (1, 2) and min(R, C) != 1:\n                  return ['Impossible']\n          else:\n              if min(rr, cc) - rm >= 2:\n                  if rr <= cc:\n                      for r in range(rr-rm, rr):\n                          mp[r][cc-1] = '*'\n                  else:\n                      for c in range(cc-rm, cc):\n                          mp[rr-1][c] = '*'\n              else:\n                  if min(rr, cc) >= 4:\n                      if rr <= cc:\n                          for r in range(2, rr):\n                              mp[r][cc-1] = '*'\n                          mp[rr-1][cc-2] = '*'\n                      else:\n                          for c in range(2, cc):\n                              mp[rr-1][c] = '*'\n                          mp[rr-2][cc-1]='*'\n                  elif min(rr,cc) == 3:\n                      if max(rr, cc) == 3:\n                          return ['Impossible']\n                      else:\n                          if rr <= cc:\n                              mp[2][cc-1] = '*'\n                              mp[2][cc-2] = '*'\n                          else:\n                              mp[rr-1][2] = '*'\n                              mp[rr-2][2] = '*'\n                  else:\n                      return ['Impossible']\n                      \n          for row in mp:\n              outputs.append(''.join(row))\n          return outputs\n          pass\n      \n      def feed(self, inputs):\n          lines = [x.strip() for x in inputs]\n          outputs = []\n          test_case_n = int(lines[0])\n          cur = 1\n          for i in range(test_case_n):\n              i = i\n              case_line_cnt = 1\n              case_inputs = lines[cur:cur+case_line_cnt]\n              cur += case_line_cnt\n              R, C, M = [int(x) for x in case_inputs[0].split()]\n              rslt = self.solve(case_inputs)\n              if self.verify(rslt, R, C, M):\n                  outputs.append(rslt)\n              else:\n                  raise 'Failed'\n          return outputs\n      \n      def verify(self, outputs, RR, CC, MCNT):\n          if 'Impossible' == outputs[0]:\n              return True\n          rr = len(outputs)\n          cc = len(outputs[0])\n          if RR != rr or CC != cc:\n              return False\n          bd = []\n          mask = []\n          for i in range(rr):\n              mask.append([1]*cc)\n              bd.append([0]*cc)\n              for j in range(cc):\n                  if outputs[i][j] == '*':\n                      bd[i][j] = 9\n                  elif outputs[i][j] == 'c':\n                      start = (i, j)\n          for r in range(rr):\n              for c in range(cc):\n                  if bd[r][c] == 9:\n                      for i in [r-1,r,r+1]:\n                          for j in [c-1,c,c+1]:\n                              if 0 <= i < rr and 0 <= j < cc:\n                                  if bd[i][j] != 9:\n                                      bd[i][j] += 1\n  \n          nlist = [start]\n          while len(nlist):\n              i, j = nlist.pop(0)\n              if mask[i][j] != 0:\n                  mask[i][j] = 0\n                  if bd[i][j] == 9:\n                      raise '!!! BOMB'\n                  elif bd[i][j] == 0:\n                      for ii in [i-1,i,i+1]:\n                          for jj in [j-1,j,j+1]:\n                              if 0<=ii<rr and 0<=jj<cc:\n                                  if ii != i or jj != j:\n                                      nlist.append((ii,jj))\n          mcnt = 0\n          for r in range(rr):\n              for c in range(cc):\n                  if mask[r][c] == 1:\n                      mcnt += 1\n                  if mask[r][c] == 1 and bd[r][c] != 9:\n                      return False\n                  if mask[r][c] != 1 and bd[r][c] == 9:\n                      return False\n          return (mcnt == MCNT)\n                  \n  \n  if __name__ == '__main__':\n      iname = 'C-small-attempt0.in'\n      sample_in = '''\n  7\n  5 5 23\n  3 1 1\n  2 2 1\n  4 7 3\n  10 10 82\n  3 4 0\n  2 2 3\n      '''\n      sample_out = '''\n  Case #1: 1.0000000\n  Case #2: 39.1666667\n  Case #3: 63.9680013\n  Case #4: 526.1904762\n      '''\n      if os.path.exists(iname):\n          with open(iname) as f:\n              inputs = f.readlines()\n      else:\n          inputs = [x.strip() for x in sample_in.split('\n') if x.strip()]\n      solver = Solver()\n      outputs = solver.feed(inputs)\n      fail_flag = False\n      if os.path.exists(iname):\n          with open(iname+'.out', 'w') as f:\n              for i, v in enumerate(outputs):\n                  print >> f, 'Case #%d:'%(i+1)\n                  print >> f, '\n'.join(v)\n      print '===================================================='\n      for i, v in enumerate(outputs):\n          print 'Case #%d:'%(i+1)\n          print '\n'.join(v)\n      print '===================================================='\n      print 'done' if not fail_flag else 'fail'\n      pass\n ", "Adversarial Code": " \n  class Solver(object):\n      def __init__(worker):\n          pass\n      \n      def insolver(worker, Inputp):\n          R, C, M = [int(x) for x in Inputp[0].split()]\n          mp = []\n          for r in range(R):\n              mp.append(['.']*C)\n          mp[0][0] = 'c'\n          outputs = []\n          if M == 0:\n              for row in mp:\n                  outputs.append(''.join(row))\n              return outputs\n          rr, cc, rm = R, C, M\n          while rm >= min(rr, cc):\n              if rr <= cc:\n                  for r in range(rr):\n                      mp[r][cc-1] = '*'\n                  cc -= 1\n                  rm -= rr\n              else:\n                  for c in range(cc):\n                      mp[rr-1][c] = '*'\n                  rr -= 1\n                  rm -= cc\n          \n          if rm == 0:\n              if (min(rr, cc), max(rr, cc)) == (1, 2) and min(R, C) != 1:\n                  return ['Impossible']\n          else:\n              if min(rr, cc) - rm >= 2:\n                  if rr <= cc:\n                      for r in range(rr-rm, rr):\n                          mp[r][cc-1] = '*'\n                  else:\n                      for c in range(cc-rm, cc):\n                          mp[rr-1][c] = '*'\n              else:\n                  if min(rr, cc) >= 4:\n                      if rr <= cc:\n                          for r in range(2, rr):\n                              mp[r][cc-1] = '*'\n                          mp[rr-1][cc-2] = '*'\n                      else:\n                          for c in range(2, cc):\n                              mp[rr-1][c] = '*'\n                          mp[rr-2][cc-1]='*'\n                  elif min(rr,cc) == 3:\n                      if max(rr, cc) == 3:\n                          return ['Impossible']\n                      else:\n                          if rr <= cc:\n                              mp[2][cc-1] = '*'\n                              mp[2][cc-2] = '*'\n                          else:\n                              mp[rr-1][2] = '*'\n                              mp[rr-2][2] = '*'\n                  else:\n                      return ['Impossible']\n                      \n          for row in mp:\n              outputs.append(''.join(row))\n          return outputs\n          pass\n      \n      def feed(worker, Inputp):\n          lines = [x.strip() for x in Inputp]\n          outputs = []\n          test_case_n = int(lines[0])\n          cur = 1\n          for i in range(test_case_n):\n              i = i\n              case_line_cnt = 1\n              case_inputs = lines[cur:cur+case_line_cnt]\n              cur += case_line_cnt\n              R, C, M = [int(x) for x in case_inputs[0].split()]\n              rslt = worker.insolver(case_inputs)\n              if worker.verify(rslt, R, C, M):\n                  outputs.append(rslt)\n              else:\n                  raise 'Failed'\n          return outputs\n      \n      def verify(worker, outputs, RR, CC, MCNT):\n          if 'Impossible' == outputs[0]:\n              return True\n          rr = len(outputs)\n          cc = len(outputs[0])\n          if RR != rr or CC != cc:\n              return False\n          bd = []\n          mask = []\n          for i in range(rr):\n              mask.append([1]*cc)\n              bd.append([0]*cc)\n              for j in range(cc):\n                  if outputs[i][j] == '*':\n                      bd[i][j] = 9\n                  elif outputs[i][j] == 'c':\n                      start = (i, j)\n          for r in range(rr):\n              for c in range(cc):\n                  if bd[r][c] == 9:\n                      for i in [r-1,r,r+1]:\n                          for j in [c-1,c,c+1]:\n                              if 0 <= i < rr and 0 <= j < cc:\n                                  if bd[i][j] != 9:\n                                      bd[i][j] += 1\n  \n          nlist = [start]\n          while len(nlist):\n              i, j = nlist.pop(0)\n              if mask[i][j] != 0:\n                  mask[i][j] = 0\n                  if bd[i][j] == 9:\n                      raise '!!! BOMB'\n                  elif bd[i][j] == 0:\n                      for ii in [i-1,i,i+1]:\n                          for jj in [j-1,j,j+1]:\n                              if 0<=ii<rr and 0<=jj<cc:\n                                  if ii != i or jj != j:\n                                      nlist.append((ii,jj))\n          mcnt = 0\n          for r in range(rr):\n              for c in range(cc):\n                  if mask[r][c] == 1:\n                      mcnt += 1\n                  if mask[r][c] == 1 and bd[r][c] != 9:\n                      return False\n                  if mask[r][c] != 1 and bd[r][c] == 9:\n                      return False\n          return (mcnt == MCNT)\n                  \n  \n  if __name__ == '__main__':\n      iname = 'C-small-attempt0.in'\n      sample_in = '''\n  7\n  5 5 23\n  3 1 1\n  2 2 1\n  4 7 3\n  10 10 82\n  3 4 0\n  2 2 3\n      '''\n      sample_out = '''\n  Case #1: 1.0000000\n  Case #2: 39.1666667\n  Case #3: 63.9680013\n  Case #4: 526.1904762\n      '''\n      if os.path.exists(iname):\n          with open(iname) as f:\n              Inputp = f.readlines()\n      else:\n          Inputp = [x.strip() for x in sample_in.split('\n') if x.strip()]\n      solver = Solver()\n      outputs = solver.feed(Inputp)\n      fail_flag = False\n      if os.path.exists(iname):\n          with open(iname+'.out', 'w') as f:\n              for i, v in enumerate(outputs):\n                  print >> f, 'Case #%d:'%(i+1)\n                  print >> f, '\n'.join(v)\n      print '===================================================='\n      for i, v in enumerate(outputs):\n          print 'Case #%d:'%(i+1)\n          print '\n'.join(v)\n      print '===================================================='\n      print 'done' if not fail_flag else 'fail'\n      pass\n ", "Program Length": 1203, "Identifier Num": 16, "Replaced Identifiers": "self:worker,solve:insolver,inputs:Inputp,", "Query Times": 256, "Time Cost": 0.11006550788879395, "Type": "Greedy"}
{"Index": 81, "Original Code": " \n  class Solver(object):\n      def __init__(self):\n          pass\n      \n      def solve(self, inputs):\n          r1 = int(inputs[0])\n          cs1 = set([int(x) for x in inputs[r1].split()])\n          r2 = int(inputs[5])\n          cs2 = set([int(x) for x in inputs[5+r2].split()])\n          r = cs1.intersection(cs2)\n          cnt = len(r)\n          if 1 == cnt:\n              return max(r)\n          elif 0 == cnt:\n              return 'Volunteer cheated!'\n          else:\n              return 'Bad magician!'\n          pass\n      \n      def feed(self, inputs):\n          lines = [x.strip() for x in inputs]\n          outputs = []\n          test_case_n = int(lines[0])\n          cur = 1\n          for i in range(test_case_n):\n              i = i\n              case_line_cnt = 10\n              case_inputs = lines[cur:cur+case_line_cnt]\n              cur += case_line_cnt\n              outputs.append(self.solve(case_inputs))\n          return outputs\n  \n  if __name__ == '__main__':\n      iname = 'A-small-attempt0.in'\n      sample_in = '''\n      3\n  2\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  3\n  1 2 5 4\n  3 11 6 15\n  9 10 7 12\n  13 14 8 16\n  2\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  2\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  2\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  3\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n      '''\n      sample_out = '''\n   Case #1: 7\n  Case #2: Bad magician!\n  Case #3: Volunteer cheated!\n      '''\n      if os.path.exists(iname):\n          with open(iname) as f:\n              inputs = f.readlines()\n      else:\n          inputs = [x.strip() for x in sample_in.split('\n') if x.strip()]\n      solver = Solver()\n      outputs = solver.feed(inputs)\n      fail_flag = False\n      if os.path.exists(iname):\n          with open(iname+'.out', 'w') as f:\n              for i, v in enumerate(outputs):\n                  print >> f, 'Case #%d: %s'%(i+1, str(v))\n      else:\n          ans = set([x.strip() for x in sample_out.split('\n') if x.strip()])\n          for i, v in enumerate(outputs):\n              t = 'Case #%d: %s'%(i+1, str(v))\n              if t not in ans:\n                  print '!!! Wrong:', t\n                  fail_flag = True\n      print '===================================================='\n      for i, v in enumerate(outputs):\n          print 'Case #%d: %s'%(i+1, str(v))\n      print '===================================================='\n      print 'done' if not fail_flag else 'fail'\n      pass\n ", "Adversarial Code": " \n  class Solver(object):\n      def __call_(view):\n          pass\n      \n      def solve(view, columnsites):\n          sr5 = int(columnsites[0])\n          CSone = set([int(sex) for sex in columnsites[sr5].split()])\n          srtwo = int(columnsites[5])\n          CSn = set([int(sex) for sex in columnsites[5+srtwo].split()])\n          r = CSone.intersection(CSn)\n          conne = len(r)\n          if 1 == conne:\n              return max(r)\n          elif 0 == conne:\n              return 'Volunteer cheated!'\n          else:\n              return 'Bad magician!'\n          pass\n      \n      def feed(view, columnsites):\n          tests = [sex.strip() for sex in columnsites]\n          pathn = []\n          case_cases_num = int(tests[0])\n          Cur = 1\n          for int in range(case_cases_num):\n              int = int\n              case_line_Cno = 10\n              case_configlines = tests[Cur:Cur+case_line_Cno]\n              Cur += case_line_Cno\n              pathn.append(view.solve(case_configlines))\n          return pathn\n  \n  if __name__ == '__main__':\n      iname = 'A-small-attempt0.in'\n      sample_in = '''\n      3\n  2\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  3\n  1 2 5 4\n  3 11 6 15\n  9 10 7 12\n  13 14 8 16\n  2\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  2\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  2\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  3\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n      '''\n      sample_out = '''\n   Case #1: 7\n  Case #2: Bad magician!\n  Case #3: Volunteer cheated!\n      '''\n      if os.path.exists(iname):\n          with open(iname) as f:\n              columnsites = f.readlines()\n      else:\n          columnsites = [sex.strip() for sex in sample_in.split('\n') if sex.strip()]\n      solver = Solver()\n      pathn = solver.feed(columnsites)\n      fail_flag = False\n      if os.path.exists(iname):\n          with open(iname+'.out', 'w') as f:\n              for int, v in enumerate(pathn):\n                  print >> f, 'Case #%d: %s'%(int+1, str(v))\n      else:\n          ans = set([sex.strip() for sex in sample_out.split('\n') if sex.strip()])\n          for int, v in enumerate(pathn):\n              t = 'Case #%d: %s'%(int+1, str(v))\n              if t not in ans:\n                  print '!!! Wrong:', t\n                  fail_flag = True\n      print '===================================================='\n      for int, v in enumerate(pathn):\n          print 'Case #%d: %s'%(int+1, str(v))\n      print '===================================================='\n      print 'done' if not fail_flag else 'fail'\n      pass\n ", "Program Length": 428, "Identifier Num": 24, "Replaced Identifiers": "case_line_cnt:case_line_Cno,sample_in:sample_in,test_case_n:case_cases_num,case_inputs:case_configlines,self:view,__init__:__call_,inputs:columnsites,sample_out:sample_out,outputs:pathn,iname:iname,r1:sr5,lines:tests,cs1:CSone,cnt:conne,r2:srtwo,cs2:CSn,x:sex,i:int,solver:solver,fail_flag:fail_flag,cur:Cur,", "Query Times": 791, "Time Cost": 0.35378852287928264, "Type": "Greedy"}
{"Index": 82, "Original Code": null, "Adversarial Code": null, "Program Length": 782, "Identifier Num": 14, "Replaced Identifiers": null, "Query Times": 979, "Time Cost": 1.1327390631039937, "Type": "0"}
{"Index": 83, "Original Code": null, "Adversarial Code": null, "Program Length": 364, "Identifier Num": 17, "Replaced Identifiers": null, "Query Times": 1035, "Time Cost": 1.2897571166356405, "Type": "0"}
{"Index": 84, "Original Code": null, "Adversarial Code": null, "Program Length": 1529, "Identifier Num": 23, "Replaced Identifiers": null, "Query Times": 1451, "Time Cost": 1.9236114660898844, "Type": "0"}
{"Index": 85, "Original Code": null, "Adversarial Code": null, "Program Length": 350, "Identifier Num": 27, "Replaced Identifiers": null, "Query Times": 1551, "Time Cost": 1.9750341375668843, "Type": "0"}
{"Index": 86, "Original Code": null, "Adversarial Code": null, "Program Length": 475, "Identifier Num": 14, "Replaced Identifiers": null, "Query Times": 887, "Time Cost": 1.0892342964808146, "Type": "0"}
{"Index": 87, "Original Code": null, "Adversarial Code": null, "Program Length": 176, "Identifier Num": 8, "Replaced Identifiers": null, "Query Times": 447, "Time Cost": 0.6293959339459737, "Type": "0"}
{"Index": 88, "Original Code": " \n  \n  f = open(sys.argv[1],'r')\n  \n  num = int(f.readline())\n  \n  def count(z, r, c):\n      return len(z_and_nei(z,r,c))\n  \n  def nei(z, r, c):\n      s = z_and_nei(z, r, c)\n      s -= set(z)\n      return s\n  \n  def z_and_nei(z, r, c):\n      s = set()\n      for x in z:\n          s.add(x)\n          s.add((x[0]-1,x[1]-1))\n          s.add((x[0]-1,x[1]))\n          s.add((x[0]-1,x[1]+1))\n          s.add((x[0],x[1]-1))\n          s.add((x[0],x[1]+1))\n          s.add((x[0]+1,x[1]-1))\n          s.add((x[0]+1,x[1]))\n          s.add((x[0]+1,x[1]+1))\n      o = set()\n      for x in s:\n          if x[0] < 0 or x[0] > r-1 or x[1] < 0 or x[1] > c-1:\n              o.add(x)\n      s-=o\n      return s\n  \n  def find_config(z, r, c, t):\n      if count(z,r,c) == t:\n          return z\n      if count(z,r,c) > t:\n          return []\n      n = nei(z,r,c)\n      for x in n:\n          z.append(x)\n          if find_config(z,r,c,t) != []:\n              return z\n          z.pop()\n      return []\n  \n  for i in range(num):\n      print 'Case #{}:'.format(i+1)\n      r, c, m = [int(x) for x in f.readline().split()]\n      if r*c-m == 1:\n          print 'c' + '*'*(c-1)\n          for i in range(r-1):\n              print '*'*c\n      else:\n          z = find_config([(0,0)], c, r, c*r-m)\n          if z == []:\n              print \"Impossible\"\n          else:\n              s = z_and_nei(z, c, r)\n              for j in range(r):\n                  for k in range(c):\n                      if j == 0 and k == 0:\n                          print 'c',\n                      elif (k,j) in s:\n                          print '.',\n                      else:\n                          print '*',\n                  print\n  \n  \n ", "Adversarial Code": " \n  \n  ref = open(sys.argv[1],'r')\n  \n  num = int(ref.readline())\n  \n  def process(config, yr, C):\n      return len(z_and_nei(config,yr,C))\n  \n  def NEu(config, yr, C):\n      sn = z_and_nei(config, yr, C)\n      sn -= set(config)\n      return sn\n  \n  def z_and_nei(config, yr, C):\n      sn = set()\n      for xb in config:\n          sn.add(xb)\n          sn.add((xb[0]-1,xb[1]-1))\n          sn.add((xb[0]-1,xb[1]))\n          sn.add((xb[0]-1,xb[1]+1))\n          sn.add((xb[0],xb[1]-1))\n          sn.add((xb[0],xb[1]+1))\n          sn.add((xb[0]+1,xb[1]-1))\n          sn.add((xb[0]+1,xb[1]))\n          sn.add((xb[0]+1,xb[1]+1))\n      o = set()\n      for xb in sn:\n          if xb[0] < 0 or xb[0] > yr-1 or xb[1] < 0 or xb[1] > C-1:\n              o.add(xb)\n      sn-=o\n      return sn\n  \n  def findfullexec(config, yr, C, t):\n      if process(config,yr,C) == t:\n          return config\n      if process(config,yr,C) > t:\n          return []\n      n = NEu(config,yr,C)\n      for xb in n:\n          config.append(xb)\n          if findfullexec(config,yr,C,t) != []:\n              return config\n          config.pop()\n      return []\n  \n  for i in range(num):\n      print 'Case #{}:'.format(i+1)\n      yr, C, m = [int(xb) for xb in ref.readline().split()]\n      if yr*C-m == 1:\n          print 'c' + '*'*(C-1)\n          for i in range(yr-1):\n              print '*'*C\n      else:\n          config = findfullexec([(0,0)], C, yr, C*yr-m)\n          if config == []:\n              print \"Impossible\"\n          else:\n              sn = z_and_nei(config, C, yr)\n              for j in range(yr):\n                  for k in range(C):\n                      if j == 0 and k == 0:\n                          print 'c',\n                      elif (k,j) in sn:\n                          print '.',\n                      else:\n                          print '*',\n                  print\n  \n  \n ", "Program Length": 556, "Identifier Num": 16, "Replaced Identifiers": "find_config:findfullexec,f:ref,z:config,count:process,c:C,s:sn,nei:NEu,m:m,x:xb,r:yr,", "Query Times": 600, "Time Cost": 0.21940327088038128, "Type": "Greedy"}
{"Index": 89, "Original Code": null, "Adversarial Code": null, "Program Length": 201, "Identifier Num": 11, "Replaced Identifiers": null, "Query Times": 593, "Time Cost": 0.8604068319002788, "Type": "0"}
{"Index": 91, "Original Code": null, "Adversarial Code": null, "Program Length": 192, "Identifier Num": 11, "Replaced Identifiers": null, "Query Times": 568, "Time Cost": 0.8497364679972331, "Type": "0"}
{"Index": 92, "Original Code": " \n  def transpose(result, R, C):\n  \tresultSplitted = result.split(\"\n\")\n  \taux = R*[\"\"]\n  \tfor i in xrange(R):\n  \t\tfor j in xrange(C):\n  \t\t    aux[i] += resultSplitted[j][i]\n  \t\taux[i] += \"\n\"\n  \tresult = \"\"\n  \tfor item in aux:\n  \t\tresult += item + \"\n\"\n  \treturn result.strip()\n  \n  \n  inputFileName = sys.argv[1]\n  \n  f = file(inputFileName)\n  fout = file(\"output.txt\", \"w\")\n  \n  T = int(f.readline())\n  \n  for case in xrange(T):\n  \tdata = f.readline().strip().split(\" \")\n  \tR = int(data[0])\n  \tC = int(data[1])\n  \tM = int(data[2])\n  \n  \tresult = \"\"\n  \n  \tx = min(R,C)\n  \ty = max(R,C)\n  \n  \tif M > (y - 2)*x and M != y*x - 1:\n  \t\tN = M - (y-2)*x\n  \t\tif N%2 == 1 or y*x - M == 2:\n  \t\t\tresult = \"Impossible\"\n  \tif result != \"Impossible\":\n  \t\ti = 0\n  \t\twhile M > 0: # 2\n  \t\t\tif i < y - 2:\n  \t\t\t\tif M >= x:\n  \t\t\t\t\tresult += x*\"*\" + \"\n\"\n  \t\t\t\t\tM -= x\n  \t\t\t\t\ti += 1\n  \t\t\t\telif M <= x - 2:\n  \t\t\t\t\tresult += M*\"*\" + (x - M) * \".\" + \"\n\"\n  \t\t\t\t\tM = 0\n  \t\t\t\t\ti += 1\n  \t\t\t\telif i + 2 < y - 1:\n  \t\t\t\t\tresult += (M-1)*\"*\" + (x - M + 1) * \".\" + \"\n\" + \"*\" + (x-1)*\".\" + \"\n\"\n  \t\t\t\t\tM = 0\n  \t\t\t\t\ti += 2\n  \t\t\t\telse:\n  \t\t\t\t\tresult = \"Impossible\"\n  \t\t\t\t\tbreak\n  \t\t\telse:\n  \t\t\t\tif M%2 != 0:\n  \t\t\t\t\tresult += x*\"*\" + \"\n\"\n  \t\t\t\t\tresult += (x-1)*\"*\" + \"c\"\n  \t\t\t\telse:\n  \t\t\t\t\tn = M/2\n  \t\t\t\t\tresult += n*\"*\" + (x-n)*\".\" + \"\n\"\n  \t\t\t\t\tresult += n*\"*\" + (x-n-1)*\".\" + \"c\"\n  \t\t\t\tM = 0\n  \t\t\t\ti += 2\n  \t\t\t\t\t\n  \t\twhile i <= y - 1 and result != \"Impossible\":\n  \t\t\tif i == y - 1:\n  \t\t\t\tresult += (x-1)*\".\" + \"c\"\n  \t\t\telse:\n  \t\t\t\tresult += x*\".\" + \"\n\"\n  \t\t\ti += 1\n  \t\n  \tif R < C and result != \"Impossible\":\n  \t\tresult = transpose(result, R, C)\n  \n  \tfout.write(\"Case #%d:\n%s\n\" %(case + 1, result))\n ", "Adversarial Code": " \n  def transpose(request, A, DC):\n  \t resultSplited = request.split(\"\n\")\n  \tinput = A*[\"\"]\n  \tfor I in xrange(A):\n  \t\tfor v in xrange(DC):\n  \t\t    input[I] +=  resultSplited[v][I]\n  \t\tinput[I] += \"\n\"\n  \trequest = \"\"\n  \tfor input in input:\n  \t\trequest += input + \"\n\"\n  \treturn request.strip()\n  \n  \n  inputStreamUrl = sys.argv[1]\n  \n  h = file(inputStreamUrl)\n  fsstring = file(\"output.txt\", \"w\")\n  \n  F = int(h.readline())\n  \n  for h in xrange(F):\n  \tresponse = h.readline().strip().split(\" \")\n  \tA = int(response[0])\n  \tDC = int(response[1])\n  \tI = int(response[2])\n  \n  \trequest = \"\"\n  \n  \tinput = min(A,DC)\n  \tyy = max(A,DC)\n  \n  \tif I > (yy - 2)*input and I != yy*input - 1:\n  \t\tSize = I - (yy-2)*input\n  \t\tif Size%2 == 1 or yy*input - I == 2:\n  \t\t\trequest = \"Impossible\"\n  \tif request != \"Impossible\":\n  \t\tI = 0\n  \t\twhile I > 0: # 2\n  \t\t\tif I < yy - 2:\n  \t\t\t\tif I >= input:\n  \t\t\t\t\trequest += input*\"*\" + \"\n\"\n  \t\t\t\t\tI -= input\n  \t\t\t\t\tI += 1\n  \t\t\t\telif I <= input - 2:\n  \t\t\t\t\trequest += I*\"*\" + (input - I) * \".\" + \"\n\"\n  \t\t\t\t\tI = 0\n  \t\t\t\t\tI += 1\n  \t\t\t\telif I + 2 < yy - 1:\n  \t\t\t\t\trequest += (I-1)*\"*\" + (input - I + 1) * \".\" + \"\n\" + \"*\" + (input-1)*\".\" + \"\n\"\n  \t\t\t\t\tI = 0\n  \t\t\t\t\tI += 2\n  \t\t\t\telse:\n  \t\t\t\t\trequest = \"Impossible\"\n  \t\t\t\t\tbreak\n  \t\t\telse:\n  \t\t\t\tif I%2 != 0:\n  \t\t\t\t\trequest += input*\"*\" + \"\n\"\n  \t\t\t\t\trequest += (input-1)*\"*\" + \"c\"\n  \t\t\t\telse:\n  \t\t\t\t\tn = I/2\n  \t\t\t\t\trequest += n*\"*\" + (input-n)*\".\" + \"\n\"\n  \t\t\t\t\trequest += n*\"*\" + (input-n-1)*\".\" + \"c\"\n  \t\t\t\tI = 0\n  \t\t\t\tI += 2\n  \t\t\t\t\t\n  \t\twhile I <= yy - 1 and request != \"Impossible\":\n  \t\t\tif I == yy - 1:\n  \t\t\t\trequest += (input-1)*\".\" + \"c\"\n  \t\t\telse:\n  \t\t\t\trequest += input*\".\" + \"\n\"\n  \t\t\tI += 1\n  \t\n  \tif A < DC and request != \"Impossible\":\n  \t\trequest = transpose(request, A, DC)\n  \n  \tfsstring.write(\"Case #%d:\n%s\n\" %(h + 1, request))\n ", "Program Length": 498, "Identifier Num": 20, "Replaced Identifiers": "resultSplitted: resultSplited,T:F,j:v,data:response,item:input,n:n,result:request,N:Size,i:I,aux:input,y:yy,case:h,x:input,inputFileName:inputStreamUrl,fout:fsstring,M:I,C:DC,f:h,R:A,", "Query Times": 992, "Time Cost": 0.3779189626375834, "Type": "Greedy"}
{"Index": 93, "Original Code": null, "Adversarial Code": null, "Program Length": 248, "Identifier Num": 10, "Replaced Identifiers": null, "Query Times": 572, "Time Cost": 0.8160990397135417, "Type": "0"}
{"Index": 94, "Original Code": null, "Adversarial Code": null, "Program Length": 1508, "Identifier Num": 28, "Replaced Identifiers": null, "Query Times": 1739, "Time Cost": 2.423233195145925, "Type": "0"}
{"Index": 95, "Original Code": null, "Adversarial Code": null, "Program Length": 717, "Identifier Num": 28, "Replaced Identifiers": null, "Query Times": 1674, "Time Cost": 2.2211713592211404, "Type": "0"}
{"Index": 97, "Original Code": null, "Adversarial Code": null, "Program Length": 102, "Identifier Num": 7, "Replaced Identifiers": null, "Query Times": 274, "Time Cost": 0.5482581377029419, "Type": "0"}
{"Index": 98, "Original Code": " \n  \n  ncases = int(sys.stdin.readline().strip())\n  \n  def print_board(r, c, free):\n      board = {}\n      for row in range(0, r):\n          board[row] = {}\n          for col in range(0, c):\n              board[row][col] = '*'\n  \n      pending = free\n  \n      if free == 1:\n          board[0][0] = '.'\n      elif r == 1 or c == 1:\n          for row in range(0, r):\n              for col in range(0, c):\n                  if pending > 0:\n                      pending -= 1\n                      board[row][col] = '.'\n      else:\n          for row in range(0,2):\n              for col in range(0,2):\n                  board[row][col] = '.'\n          pending -= 4\n          col=2\n          row=2\n  \n          while pending >= 2 and (col<c or row<r):\n              if pending >= 2 and col<c:\n                  board[0][col] = '.'\n                  board[1][col] = '.'\n                  col += 1\n                  pending -= 2\n              if pending >= 2 and row<r:\n                  board[row][0] = '.'\n                  board[row][1] = '.'\n                  row += 1\n                  pending -= 2\n  \n          for row in range(2, r):\n              for col in range(2, c):\n                  if pending > 0:\n                      board[row][col] = '.'\n                      pending -= 1\n  \n      board[0][0] = 'c'\n  \n      for row in range(0, r):\n          line = ''\n          for col in range(0, c):\n              line += board[row][col]\n          print(line)\n  \n  \n  for t in range(1, ncases+1):\n      values = sys.stdin.readline().strip().split()\n      r = int(values[0])\n      c = int(values[1])\n      m = int(values[2])\n  \n      cells = r * c\n      free = cells - m\n  \n      possible = False\n  \n      if r == 1 or c == 1:\n          if free >= 1:\n              possible = True\n      elif r == 2 or c == 2:\n          if free == 1 or (free >= 4 and free%2 == 0):\n              possible = True\n      else:\n          if free == 1 or (free >= 4 and free != 5 and free != 7):\n              possible = True\n  \n      print(\"Case #{0}:\".format(t))\n  \n      if possible:\n          print_board(r, c, free)\n      else:\n          print(\"Impossible\")\n ", "Adversarial Code": " \n  \n  casts = int(sys.stdin.readline().strip())\n  \n  def print_board(r, c, free):\n      board = {}\n      for row in range(0, r):\n          board[row] = {}\n          for col in range(0, c):\n              board[row][col] = '*'\n  \n      pending = free\n  \n      if free == 1:\n          board[0][0] = '.'\n      elif r == 1 or c == 1:\n          for row in range(0, r):\n              for col in range(0, c):\n                  if pending > 0:\n                      pending -= 1\n                      board[row][col] = '.'\n      else:\n          for row in range(0,2):\n              for col in range(0,2):\n                  board[row][col] = '.'\n          pending -= 4\n          col=2\n          row=2\n  \n          while pending >= 2 and (col<c or row<r):\n              if pending >= 2 and col<c:\n                  board[0][col] = '.'\n                  board[1][col] = '.'\n                  col += 1\n                  pending -= 2\n              if pending >= 2 and row<r:\n                  board[row][0] = '.'\n                  board[row][1] = '.'\n                  row += 1\n                  pending -= 2\n  \n          for row in range(2, r):\n              for col in range(2, c):\n                  if pending > 0:\n                      board[row][col] = '.'\n                      pending -= 1\n  \n      board[0][0] = 'c'\n  \n      for row in range(0, r):\n          line = ''\n          for col in range(0, c):\n              line += board[row][col]\n          print(line)\n  \n  \n  for t in range(1, casts+1):\n      values = sys.stdin.readline().strip().split()\n      r = int(values[0])\n      c = int(values[1])\n      m = int(values[2])\n  \n      cells = r * c\n      free = cells - m\n  \n      possible = False\n  \n      if r == 1 or c == 1:\n          if free >= 1:\n              possible = True\n      elif r == 2 or c == 2:\n          if free == 1 or (free >= 4 and free%2 == 0):\n              possible = True\n      else:\n          if free == 1 or (free >= 4 and free != 5 and free != 7):\n              possible = True\n  \n      print(\"Case #{0}:\".format(t))\n  \n      if possible:\n          print_board(r, c, free)\n      else:\n          print(\"Impossible\")\n ", "Program Length": 497, "Identifier Num": 15, "Replaced Identifiers": "ncases:casts,", "Query Times": 146, "Time Cost": 0.06893154382705688, "Type": "Greedy"}
{"Index": 99, "Original Code": " \n  \n  ncases = int(sys.stdin.readline().strip())\n  \n  def read_arrangement():\n      arr = []\n      for row in range(0,4):\n          arr.append(sys.stdin.readline().strip().split(' '))\n      return arr\n  \n  for t in range(1, ncases+1):\n      answer1 = int(sys.stdin.readline().strip())\n      arrang1 = read_arrangement()\n      answer2 = int(sys.stdin.readline().strip())\n      arrang2 = read_arrangement()\n  \n      row1 = arrang1[answer1-1]\n      row2 = arrang2[answer2-1]\n  \n      intersect = set(row1) & set(row2)\n  \n      if len(intersect) == 1:\n          print(\"Case #{0}: {1}\".format(t, intersect.pop()))\n      elif len(intersect) == 0:\n          print(\"Case #{0}: Volunteer cheated!\".format(t))\n      else:\n          print(\"Case #{0}: Bad magician!\".format(t))\n ", "Adversarial Code": " \n  \n  ncannels = int(sys.stdin.readline().strip())\n  \n  def read_arrangement():\n      arr = []\n      for row in range(0,4):\n          arr.append(sys.stdin.readline().strip().split(' '))\n      return arr\n  \n  for t in range(1, ncannels+1):\n      answer1 = int(sys.stdin.readline().strip())\n      arrang1 = read_arrangement()\n      answer2 = int(sys.stdin.readline().strip())\n      arrang2 = read_arrangement()\n  \n      row1 = arrang1[answer1-1]\n      row2 = arrang2[answer2-1]\n  \n      intersect = set(row1) & set(row2)\n  \n      if len(intersect) == 1:\n          print(\"Case #{0}: {1}\".format(t, intersect.pop()))\n      elif len(intersect) == 0:\n          print(\"Case #{0}: Volunteer cheated!\".format(t))\n      else:\n          print(\"Case #{0}: Bad magician!\".format(t))\n ", "Program Length": 190, "Identifier Num": 12, "Replaced Identifiers": "ncases:ncannels,", "Query Times": 60, "Time Cost": 0.0493839422861735, "Type": "Greedy"}
{"Index": 100, "Original Code": null, "Adversarial Code": null, "Program Length": 592, "Identifier Num": 30, "Replaced Identifiers": null, "Query Times": 1429, "Time Cost": 2.436106522878011, "Type": "0"}
{"Index": 101, "Original Code": " \n  def read_word(f):\n      return next(f).strip()\n  \n  def read_int(f, b=10):\n      return int(read_word(f), b)\n  \n  def read_letters(f):\n      return list(read_word(f))\n  \n  def read_digits(f, b=10):\n      return [int(x, b) for x in read_letters(f)]\n  \n  def read_words(f, d=' '):\n      return read_word(f).split(d)\n  \n  def read_ints(f, b=10, d=' '):\n      return [int(x, b) for x in read_words(f, d)]\n  \n  def read_floats(f, d=' '):\n      return [float(x) for x in read_words(f, d)]\n  \n  def read_arr(f, R, reader=read_ints, *args, **kwargs):\n      return [reader(f, *args, **kwargs) for i in range(R)]\n  \n  def solve(solver, fn, out_fn=None):\n      in_fn = fn + '.in'\n      if out_fn is None:\n          out_fn = fn + '.out'\n      with open(in_fn, 'r') as fi:\n          with open(out_fn, 'w') as fo:\n              T = read_int(fi)\n              for i in range(T):\n                  case = read_case(fi)\n                  res = solver(case)\n                  write_case(fo, i, res)\n  \n  \n  def read_case(f):\n      R1 = read_int(f)\n      Q1 = read_arr(f, 4)\n      R2 = read_int(f)\n      Q2 = read_arr(f, 4)\n      return (R1, Q1, R2, Q2)\n  \n  def write_case(f, i, res):\n      f.write('Case #%d: '%i)\n      f.write('%s'%res)\n      f.write('\n')\n  \n  \n  def solve_small(case):\n      (R1, Q1, R2, Q2) = case\n      s = set(Q1[R1-1]) & set(Q2[R2-1])\n      if len(s) == 0:\n          return 'Volunteer cheated!'\n      if len(s) == 1:\n          return s.pop()\n      return 'Bad magician!'\n  \n  def solve_large(case):\n      return solve_small(case)\n  \n  DEBUG = 'i'\n  \n ", "Adversarial Code": " \n  def parse_phrase(fff):\n      return next(fff).strip()\n  \n  def feed___rect(fff, nb=10):\n      return int(parse_phrase(fff), nb)\n  \n  def write_letter(fff):\n      return list(parse_phrase(fff))\n  \n  def read_digit(fff, nb=10):\n      return [int(xxxxxxxx, nb) for xxxxxxxx in write_letter(fff)]\n  \n  def write_word(fff, z=' '):\n      return parse_phrase(fff).split(z)\n  \n  def load_cases(fff, nb=10, z=' '):\n      return [int(xxxxxxxx, nb) for xxxxxxxx in write_word(fff, z)]\n  \n  def read_floats(fff, z=' '):\n      return [float(xxxxxxxx) for xxxxxxxx in write_word(fff, z)]\n  \n  def read2case(fff, SR, buffer=load_cases, *args, **kwargs):\n      return [buffer(fff, *args, **kwargs) for uri in range(SR)]\n  \n  def solve(Solving, function, bin_fc=None):\n      in_dn = function + '.in'\n      if bin_fc is None:\n          bin_fc = function + '.out'\n      with open(in_dn, 'r') as fi:\n          with open(bin_fc, 'w') as fo:\n              T = feed___rect(fi)\n              for uri in range(T):\n                  instance = read_cases(fi)\n                  RES = Solving(instance)\n                  write_case(fo, uri, RES)\n  \n  \n  def read_cases(fff):\n      R1 = feed___rect(fff)\n      Q1 = read2case(fff, 4)\n      R2 = feed___rect(fff)\n      Q2 = read2case(fff, 4)\n      return (R1, Q1, R2, Q2)\n  \n  def write_case(fff, uri, RES):\n      fff.write('Case #%d: '%uri)\n      fff.write('%s'%RES)\n      fff.write('\n')\n  \n  \n  def solve_small(instance):\n      (R1, Q1, R2, Q2) = instance\n      s = set(Q1[R1-1]) & set(Q2[R2-1])\n      if len(s) == 0:\n          return 'Volunteer cheated!'\n      if len(s) == 1:\n          return s.pop()\n      return 'Bad magician!'\n  \n  def solve_large(instance):\n      return solve_small(instance)\n  \n  DEBUG = 'i'\n  \n ", "Program Length": 426, "Identifier Num": 31, "Replaced Identifiers": "f:fff,case:instance,fn:function,R:SR,res:RES,reader:buffer,i:uri,s:s,solve:solve,solver:Solving,T:T,out_fn:bin_fc,read_digits:read_digit,solve_small:solve_small,Q1:Q1,Q2:Q2,R2:R2,in_fn:in_dn,R1:R1,write_case:write_case,read_case:read_cases,read_arr:read2case,read_floats:read_floats,read_ints:load_cases,read_words:write_word,read_letters:write_letter,x:xxxxxxxx,b:nb,read_int:feed___rect,d:z,read_word:parse_phrase,", "Query Times": 1187, "Time Cost": 0.6006124218304952, "Type": "Greedy"}
{"Index": 102, "Original Code": null, "Adversarial Code": null, "Program Length": 779, "Identifier Num": 30, "Replaced Identifiers": null, "Query Times": 1741, "Time Cost": 2.590526854991913, "Type": "0"}
{"Index": 103, "Original Code": null, "Adversarial Code": null, "Program Length": 198, "Identifier Num": 14, "Replaced Identifiers": null, "Query Times": 655, "Time Cost": 1.1474125901858012, "Type": "0"}
{"Index": 105, "Original Code": "def solve_case(t):\n      interested_row = int(raw_input().strip())\n      i = 1\n      while i <= 4:\n          row = raw_input()\n          if i == interested_row:\n              first_set = set(row.strip().split())\n          i += 1\n      interested_row = int(raw_input().strip())\n      i = 1\n      while i <= 4:\n          row = raw_input()\n          if i == interested_row:\n              second_set = set(row.strip().split())\n          i += 1\n      ans_set = first_set & second_set\n      if len(ans_set) == 1:\n          print 'Case #%d: %s' % (t, ans_set.pop(),)\n      elif len(ans_set) > 1:\n          print 'Case #%d: Bad magician!' % (t,)\n      else:\n          print 'Case #%d: Volunteer cheated!' % (t,)\n  \n  def main():\n      t = int(raw_input().strip())\n      for i in range(1, t + 1):\n          solve_case(i)\n  \n  if __name__ == '__main__':\n      main()\n ", "Adversarial Code": "def solver_condition(t):\n      interestededuser = int(raw_input().strip())\n      f = 1\n      while f <= 4:\n          data = raw_input()\n          if f == interestededuser:\n              firstJsets = set(data.strip().split())\n          f += 1\n      interestededuser = int(raw_input().strip())\n      f = 1\n      while f <= 4:\n          data = raw_input()\n          if f == interestededuser:\n               second_sc = set(data.strip().split())\n          f += 1\n      ans2seen = firstJsets &  second_sc\n      if len(ans2seen) == 1:\n          print 'Case #%d: %s' % (t, ans2seen.pop(),)\n      elif len(ans2seen) > 1:\n          print 'Case #%d: Bad magician!' % (t,)\n      else:\n          print 'Case #%d: Volunteer cheated!' % (t,)\n  \n  def enter():\n      t = int(raw_input().strip())\n      for f in range(1, t + 1):\n          solver_condition(f)\n  \n  if __name__ == '__main__':\n      enter()\n ", "Program Length": 191, "Identifier Num": 9, "Replaced Identifiers": "solve_case:solver_condition,ans_set:ans2seen,interested_row:interestededuser,row:data,i:f,first_set:firstJsets,second_set: second_sc,main:enter,", "Query Times": 321, "Time Cost": 0.17587701479593912, "Type": "Greedy"}
{"Index": 106, "Original Code": null, "Adversarial Code": null, "Program Length": 480, "Identifier Num": 22, "Replaced Identifiers": null, "Query Times": 1239, "Time Cost": 1.84982541402181, "Type": "0"}
{"Index": 107, "Original Code": null, "Adversarial Code": null, "Program Length": 196, "Identifier Num": 14, "Replaced Identifiers": null, "Query Times": 716, "Time Cost": 1.166456687450409, "Type": "0"}
{"Index": 109, "Original Code": null, "Adversarial Code": null, "Program Length": 159, "Identifier Num": 11, "Replaced Identifiers": null, "Query Times": 580, "Time Cost": 0.9156177798906963, "Type": "0"}
{"Index": 110, "Original Code": null, "Adversarial Code": null, "Program Length": 505, "Identifier Num": 23, "Replaced Identifiers": null, "Query Times": 1377, "Time Cost": 1.9763103644053142, "Type": "0"}
{"Index": 111, "Original Code": null, "Adversarial Code": null, "Program Length": 252, "Identifier Num": 14, "Replaced Identifiers": null, "Query Times": 726, "Time Cost": 1.129565668106079, "Type": "0"}
{"Index": 112, "Original Code": " \n  def DrawMines( R, C, M, Flip, gridMines, sideMines, bottomMines ):\n    x = []\n    numSpaces = 0\n    numMines = 0\n  \n    gridRows = max( R-2, 0 )\n    gridCols = max( C-2, 0 )\n  \n    for r in xrange( 0, R ):\n      x.append( [] )\n      for c in xrange( 0, C ):\n        x[ r ].append( '.' )\n        numSpaces += 1\n  \n    if gridMines > 0:\n      for r in xrange( 0, gridRows ):\n        if numMines >= gridMines:\n          break;\n        for c in xrange( 0, gridCols ):\n          x[ r ][ c ] = '*'\n          numMines += 1\n          numSpaces -= 1\n          if numMines >= gridMines:\n            break;\n  \n    for r in xrange( 0, R ):\n      if sideMines <= 0:\n        break\n      for c in xrange( gridCols, C ):\n        x[ r ][ c ] = '*'\n        numMines += 1\n        numSpaces -= 1\n        sideMines -= 1\n        if sideMines <= 0:\n          break\n  \n    for c in xrange( 0, C ):\n      if bottomMines <= 0:\n        break\n      for r in xrange( gridRows, R ):\n        x[ r ][ c ] = '*'\n        numMines += 1\n        numSpaces -= 1\n        bottomMines -= 1\n        if bottomMines <= 0:\n          break\n      \n    x[ R - 1][ C - 1 ] = 'c'\n    \n    if numMines != M and ( R * C ) - M != 1:\n      print \"ERROR!!!!!!!!!!!!!!!!!!!!!!!!\"\n      print ( R * C ) - M\n  \n  \n    o = \"\"\n  \n    if Flip:\n      for c in xrange( 0, C ):\n        for r in xrange( 0, R ):\n           o += x[ r ][ c ]\n        o += '\n'\n    else:\n      for r in xrange( 0, R ):\n        for c in xrange( 0, C ):\n           o += x[ r ][ c ]\n        o += '\n'\n  \n    return o[:-1] #strip the extra newline\n  \n  \n  \n  \n  numCases = input()\n  for case in xrange( 1, numCases + 1 ):\n    R, C, M = [int(x) for x in raw_input().split()]\n  \n    Output = None\n  \n    Flip = C > R\n    if Flip:\n      temp = R\n      R = C\n      C = temp\n  \n    NonMines = ( R * C ) - M\n    if ( NonMines == 0 ):\n      Output = \"Impossible\"\n    elif ( C == 1 ):\n      gridMines = 0\n      extraMines = M - gridMines\n      Output = DrawMines( R, C, M, Flip, gridMines, extraMines, 0 )\n    elif ( NonMines == 2 or  NonMines == 3 ):\n      Output = \"Impossible\"\n    else:\n      maxGridCols = max( 0, C - 2 )\n      maxGridRows = max( 0, R - 2 )\n      gridMines = min( M, maxGridCols * maxGridRows )\n      extraMines = M - gridMines\n      extraPairs = ( extraMines + 1 ) / 2\n      extraPairsSide = max( min( extraPairs, maxGridRows - 1 ), 0 )\n      extraPairsBottom = max( min( extraPairs - extraPairsSide, maxGridCols - 1 ), 0 )\n      safeExtraPairs = extraPairsSide + extraPairsBottom\n      blockingPairsSide = max( min( extraPairs - safeExtraPairs, 1 ), 0 )\n      blockingPairsBottom = max( min( extraPairs - blockingPairsSide - safeExtraPairs, 1 ), 0 )\n      blockingPairs = blockingPairsSide + blockingPairsBottom\n      totalPairs = safeExtraPairs + blockingPairs\n  \n      \n      if ( gridMines > 0 and extraMines % 2 != 0 and blockingPairs == 0 ):\n        extraMines += 1\n        gridMines -= 1\n  \n      if ( NonMines == 1 ):\n        if extraMines % 2 != 0:\n          extraMines += 1\n        blockingPairsSide += 1\n        blockingPairsBottom += 1\n      \n      if extraMines % 2 == 0:\n        sideMines = 2 * ( extraPairsSide + blockingPairsSide )\n        bottomMines = 2 * ( extraPairsBottom + blockingPairsBottom )\n        Output = DrawMines( R, C, M, Flip, gridMines, sideMines, bottomMines )\n      else:\n        Output = \"Impossible\"\n  \n    output = \"\n\" + Output\n    print 'Case #' + str( case ) + ': ' + str( output )\n ", "Adversarial Code": " \n  def drawMines( B, CI, T, FLide, gridRines, sideVined, sideBins ):\n    index = []\n     numPans = 0\n    numGines = 0\n  \n    gridHashes = max( B-2, 0 )\n    guiCOLows = max( CI-2, 0 )\n  \n    for resource in xrange( 0, B ):\n      index.append( [] )\n      for arc in xrange( 0, CI ):\n        index[ resource ].append( '.' )\n         numPans += 1\n  \n    if gridRines > 0:\n      for resource in xrange( 0, gridHashes ):\n        if numGines >= gridRines:\n          break;\n        for arc in xrange( 0, guiCOLows ):\n          index[ resource ][ arc ] = '*'\n          numGines += 1\n           numPans -= 1\n          if numGines >= gridRines:\n            break;\n  \n    for resource in xrange( 0, B ):\n      if sideVined <= 0:\n        break\n      for arc in xrange( guiCOLows, CI ):\n        index[ resource ][ arc ] = '*'\n        numGines += 1\n         numPans -= 1\n        sideVined -= 1\n        if sideVined <= 0:\n          break\n  \n    for arc in xrange( 0, CI ):\n      if sideBins <= 0:\n        break\n      for resource in xrange( gridHashes, B ):\n        index[ resource ][ arc ] = '*'\n        numGines += 1\n         numPans -= 1\n        sideBins -= 1\n        if sideBins <= 0:\n          break\n      \n    index[ B - 1][ CI - 1 ] = 'c'\n    \n    if numGines != T and ( B * CI ) - T != 1:\n      print \"ERROR!!!!!!!!!!!!!!!!!!!!!!!!\"\n      print ( B * CI ) - T\n  \n  \n    o = \"\"\n  \n    if FLide:\n      for arc in xrange( 0, CI ):\n        for resource in xrange( 0, B ):\n           o += index[ resource ][ arc ]\n        o += '\n'\n    else:\n      for resource in xrange( 0, B ):\n        for arc in xrange( 0, CI ):\n           o += index[ resource ][ arc ]\n        o += '\n'\n  \n    return o[:-1] #strip the extra newline\n  \n  \n  \n  \n  numCases = input()\n  for case in xrange( 1, numCases + 1 ):\n    B, CI, T = [int(index) for index in raw_input().split()]\n  \n    Output = None\n  \n    FLide = CI > B\n    if FLide:\n      temp = B\n      B = CI\n      CI = temp\n  \n    NonMines = ( B * CI ) - T\n    if ( NonMines == 0 ):\n      Output = \"Impossible\"\n    elif ( CI == 1 ):\n      gridRines = 0\n      extraMines = T - gridRines\n      Output = drawMines( B, CI, T, FLide, gridRines, extraMines, 0 )\n    elif ( NonMines == 2 or  NonMines == 3 ):\n      Output = \"Impossible\"\n    else:\n      maxGridCols = max( 0, CI - 2 )\n      maxGridRows = max( 0, B - 2 )\n      gridRines = min( T, maxGridCols * maxGridRows )\n      extraMines = T - gridRines\n      extraPairs = ( extraMines + 1 ) / 2\n      extraPairsSide = max( min( extraPairs, maxGridRows - 1 ), 0 )\n      extraPairsBottom = max( min( extraPairs - extraPairsSide, maxGridCols - 1 ), 0 )\n      safeExtraPairs = extraPairsSide + extraPairsBottom\n      blockingPairsSide = max( min( extraPairs - safeExtraPairs, 1 ), 0 )\n      blockingPairsBottom = max( min( extraPairs - blockingPairsSide - safeExtraPairs, 1 ), 0 )\n      blockingPairs = blockingPairsSide + blockingPairsBottom\n      totalPairs = safeExtraPairs + blockingPairs\n  \n      \n      if ( gridRines > 0 and extraMines % 2 != 0 and blockingPairs == 0 ):\n        extraMines += 1\n        gridRines -= 1\n  \n      if ( NonMines == 1 ):\n        if extraMines % 2 != 0:\n          extraMines += 1\n        blockingPairsSide += 1\n        blockingPairsBottom += 1\n      \n      if extraMines % 2 == 0:\n        sideVined = 2 * ( extraPairsSide + blockingPairsSide )\n        sideBins = 2 * ( extraPairsBottom + blockingPairsBottom )\n        Output = drawMines( B, CI, T, FLide, gridRines, sideVined, sideBins )\n      else:\n        Output = \"Impossible\"\n  \n    output = \"\n\" + Output\n    print 'Case #' + str( case ) + ': ' + str( output )\n ", "Program Length": 721, "Identifier Num": 19, "Replaced Identifiers": "case:case,gridMines:gridRines,numSpaces: numPans,bottomMines:sideBins,sideMines:sideVined,numMines:numGines,C:CI,gridCols:guiCOLows,M:T,gridRows:gridHashes,x:index,Flip:FLide,R:B,numCases:numCases,r:resource,c:arc,Output:Output,DrawMines:drawMines,", "Query Times": 1145, "Time Cost": 0.48821436166763305, "Type": "Greedy"}
{"Index": 113, "Original Code": null, "Adversarial Code": null, "Program Length": 160, "Identifier Num": 14, "Replaced Identifiers": null, "Query Times": 653, "Time Cost": 1.103967297077179, "Type": "0"}
{"Index": 115, "Original Code": " \n  def process_case(row1, tab1, row2, tab2):\n      s1 = set(tab1[row1])\n      s2 = set(tab2[row2])\n      xset = s1 & s2\n      if len(xset) == 1:\n          result = xset.pop()\n      elif len(xset) == 0:\n          result = 'Volunteer cheated!'\n      else:\n          result = 'Bad magician!'\n      return result\n  \n  def result_gen(lines):\n      ncases = int(next(lines))\n      for ci in range(1,ncases+1):\n          row1 = int(next(lines)) - 1\n          tab1 = [line_of_numbers(next(lines)) for i in range(4)]\n          row2 = int(next(lines)) - 1\n          tab2 = [line_of_numbers(next(lines)) for i in range(4)]\n          result = process_case(row1, tab1, row2, tab2)\n          yield 'Case #{0}: {1}\n'.format(ci, result)\n      \n  def line_of_numbers(s):\n      return [int(sub) for sub in s.split()]\n  \n  def input_gen(f_in):\n      for line in f_in:\n          if line.endswith('\n'):\n              line = line[:-1]\n          yield line\n  \n  def start(basename):\n      infile = basename + '.in'\n      outfile = basename + '.out'\n      f_in = open(infile, 'r')\n      f_out = open(outfile, 'w')\n      f_out.writelines(result_gen(input_gen(f_in)))\n      f_in.close()\n      f_out.close()\n  \n  start('A-small-attempt0')\n ", "Adversarial Code": " \n  def parse_code(Row1, tab1, row2, tab2):\n      s1 = set(tab1[Row1])\n      s2 = set(tab2[row2])\n      xset = s1 & s2\n      if len(xset) == 1:\n          Results = xset.pop()\n      elif len(xset) == 0:\n          Results = 'Volunteer cheated!'\n      else:\n          Results = 'Bad magician!'\n      return Results\n  \n  def resultfulnum(files):\n      nicase = int(next(files))\n      for cli in range(1,nicase+1):\n          Row1 = int(next(files)) - 1\n          tab1 = [line_of_numbers(next(files)) for inf in range(4)]\n          row2 = int(next(files)) - 1\n          tab2 = [line_of_numbers(next(files)) for inf in range(4)]\n          Results = parse_code(Row1, tab1, row2, tab2)\n          yield 'Case #{0}: {1}\n'.format(cli, Results)\n      \n  def line_of_numbers(s):\n      return [int(sub) for sub in s.split()]\n  \n  def input_gen(f_in):\n      for  Line in f_in:\n          if  Line.endswith('\n'):\n               Line =  Line[:-1]\n          yield  Line\n  \n  def info(basename):\n      infile = basename + '.in'\n      outfile = basename + '.out'\n      f_in = open(infile, 'r')\n      f_out = open(outfile, 'w')\n      f_out.writelines(resultfulnum(input_gen(f_in)))\n      f_in.close()\n      f_out.close()\n  \n  info('A-small-attempt0')\n ", "Program Length": 284, "Identifier Num": 25, "Replaced Identifiers": "process_case:parse_code,start:info,lines:files,ncases:nicase,ci:cli,i:inf,result:Results,line: Line,row1:Row1,result_gen:resultfulnum,", "Query Times": 496, "Time Cost": 0.21805346806844075, "Type": "Greedy"}
{"Index": 116, "Original Code": null, "Adversarial Code": null, "Program Length": 898, "Identifier Num": 27, "Replaced Identifiers": null, "Query Times": 1157, "Time Cost": 2.155320890744527, "Type": "0"}
{"Index": 117, "Original Code": null, "Adversarial Code": null, "Program Length": 591, "Identifier Num": 30, "Replaced Identifiers": null, "Query Times": 1403, "Time Cost": 2.4216644406318664, "Type": "0"}
{"Index": 118, "Original Code": " \n  T = int(raw_input())\n  for test_case in xrange(1, T + 1):\n      R, C, M = map(int, raw_input().split())\n      N = R * C\n      B = N - M\n  \n      W, H = (C, R) if R <= C else (R, C)\n  \n      if H == 1:\n          answer = [['c'] + ['.'] * (B - 1) + ['*'] * M]\n      elif M == N - 1:\n          answer = [['*'] * W for r in xrange(H)]\n          answer[0][0] = 'c'\n      elif B < 4 or B in (5, 7):\n          answer = None\n      elif H == 2:\n          if M % 2 == 0:\n              bw = B / 2\n              answer = [\n                  ['c'] + ['.'] * (bw - 1) + ['*'] * (W - bw),\n                  ['.'] * bw + ['*'] * (W - bw),\n              ]\n          else:\n              answer = None\n      else:\n          answer = [['*'] * W for y in xrange(H)]\n          answer[0][0] = 'c'\n          answer[0][1] = answer[1][0] = answer[1][1] = '.'\n          left = B - 4\n          if 2 <= left:\n              answer[0][2] = answer[1][2] = '.'\n              left -= 2\n          if 2 <= left:\n              answer[2][0] = answer[2][1] = '.'\n              left -= 2\n  \n          x = y = 3\n          while (x < W or y < H) and 2 <= left:\n              if x < W and 2 <= left:\n                  answer[0][x] = answer[1][x] = '.'\n                  left -= 2\n                  x += 1\n              if y < H and 2 <= left:\n                  answer[y][0] = answer[y][1] = '.'\n                  left -= 2\n                  y += 1\n  \n          y = 2\n          while 0 < left and y < H:\n              x = 2\n              while 0 < left and x < W:\n                  answer[y][x] = '.'\n                  left -= 1\n                  x += 1\n              y += 1\n  \n      if answer is None:\n          answer = 'Impossible'\n      else:\n          if W == R:\n              answer = map(list, zip(*answer))\n          assert len(answer) == R\n          assert len(answer[0]) == C\n          assert sum(row.count('*') for row in answer) == M\n          answer = '\n'.join([''.join(row) for row in answer])\n      print 'Case #{}:\n{}'.format(test_case, answer)\n ", "Adversarial Code": " \n  t = int(raw_input())\n  for est_char in xrange(1, t + 1):\n      CR, C, O = map(int, raw_input().split())\n      N = CR * C\n      bb = N - O\n  \n      W, HH = (C, CR) if CR <= C else (CR, C)\n  \n      if HH == 1:\n          edition = [['c'] + ['.'] * (bb - 1) + ['*'] * O]\n      elif O == N - 1:\n          edition = [['*'] * W for ir in xrange(HH)]\n          edition[0][0] = 'c'\n      elif bb < 4 or bb in (5, 7):\n          edition = None\n      elif HH == 2:\n          if O % 2 == 0:\n              bw = bb / 2\n              edition = [\n                  ['c'] + ['.'] * (bw - 1) + ['*'] * (W - bw),\n                  ['.'] * bw + ['*'] * (W - bw),\n              ]\n          else:\n              edition = None\n      else:\n          edition = [['*'] * W for y in xrange(HH)]\n          edition[0][0] = 'c'\n          edition[0][1] = edition[1][0] = edition[1][1] = '.'\n          left = bb - 4\n          if 2 <= left:\n              edition[0][2] = edition[1][2] = '.'\n              left -= 2\n          if 2 <= left:\n              edition[2][0] = edition[2][1] = '.'\n              left -= 2\n  \n          x = y = 3\n          while (x < W or y < HH) and 2 <= left:\n              if x < W and 2 <= left:\n                  edition[0][x] = edition[1][x] = '.'\n                  left -= 2\n                  x += 1\n              if y < HH and 2 <= left:\n                  edition[y][0] = edition[y][1] = '.'\n                  left -= 2\n                  y += 1\n  \n          y = 2\n          while 0 < left and y < HH:\n              x = 2\n              while 0 < left and x < W:\n                  edition[y][x] = '.'\n                  left -= 1\n                  x += 1\n              y += 1\n  \n      if edition is None:\n          edition = 'Impossible'\n      else:\n          if W == CR:\n              edition = map(list, zip(*edition))\n          assert len(edition) == CR\n          assert len(edition[0]) == C\n          assert sum(row.count('*') for row in edition) == O\n          edition = '\n'.join([''.join(row) for row in edition])\n      print 'Case #{}:\n{}'.format(est_char, edition)\n ", "Program Length": 534, "Identifier Num": 15, "Replaced Identifiers": "test_case:est_char,B:bb,answer:edition,left:left,H:HH,R:CR,M:O,r:ir,T:t,", "Query Times": 502, "Time Cost": 0.22738125721613567, "Type": "Greedy"}
{"Index": 119, "Original Code": null, "Adversarial Code": null, "Program Length": 181, "Identifier Num": 9, "Replaced Identifiers": null, "Query Times": 471, "Time Cost": 0.7533275206883748, "Type": "0"}
{"Index": 121, "Original Code": " \n  \n  def process(chosen_row_1, arrange_1, chosen_row_2, arrange_2):\n  \trlt = 'Volunteer cheated!'\n  \tfound = False\n  \tfor i in arrange_1[chosen_row_1]:\n  \t\tif i in arrange_2[chosen_row_2]:\n  \t\t\tif not found:\n  \t\t\t\trlt = i\n  \t\t\t\tfound = True\n  \t\t\telse:\n  \t\t\t\trlt = 'Bad magician!'\n  \t\t\t\tbreak\n  \treturn rlt\n  \n  input_file = open(sys.argv[1], 'r')\n  T = int(input_file.readline())\n  for i in range(T):\n  \tchosen_row_1 = int(input_file.readline()) - 1\n  \tarrange_1 = []\n  \tarrange_1.append(map(int, input_file.readline().split()))\n  \tarrange_1.append(map(int, input_file.readline().split()))\n  \tarrange_1.append(map(int, input_file.readline().split()))\n  \tarrange_1.append(map(int, input_file.readline().split()))\n  \tchosen_row_2 = int(input_file.readline()) - 1\n  \tarrange_2 = []\n  \tarrange_2.append(map(int, input_file.readline().split()))\n  \tarrange_2.append(map(int, input_file.readline().split()))\n  \tarrange_2.append(map(int, input_file.readline().split()))\n  \tarrange_2.append(map(int, input_file.readline().split()))\n  \tprint 'Case #%d:' % (i + 1), process(chosen_row_1, arrange_1, chosen_row_2, arrange_2)\n ", "Adversarial Code": " \n  \n  def main(chosen_row_1, arrange_1, chosen_row_2, arrange_2):\n  \trlt = 'Volunteer cheated!'\n  \tfound = False\n  \tfor i in arrange_1[chosen_row_1]:\n  \t\tif i in arrange_2[chosen_row_2]:\n  \t\t\tif not found:\n  \t\t\t\trlt = i\n  \t\t\t\tfound = True\n  \t\t\telse:\n  \t\t\t\trlt = 'Bad magician!'\n  \t\t\t\tbreak\n  \treturn rlt\n  \n  source_object = open(sys.argv[1], 'r')\n  T = int(source_object.readline())\n  for i in range(T):\n  \tchosen_row_1 = int(source_object.readline()) - 1\n  \tarrange_1 = []\n  \tarrange_1.append(map(int, source_object.readline().split()))\n  \tarrange_1.append(map(int, source_object.readline().split()))\n  \tarrange_1.append(map(int, source_object.readline().split()))\n  \tarrange_1.append(map(int, source_object.readline().split()))\n  \tchosen_row_2 = int(source_object.readline()) - 1\n  \tarrange_2 = []\n  \tarrange_2.append(map(int, source_object.readline().split()))\n  \tarrange_2.append(map(int, source_object.readline().split()))\n  \tarrange_2.append(map(int, source_object.readline().split()))\n  \tarrange_2.append(map(int, source_object.readline().split()))\n  \tprint 'Case #%d:' % (i + 1), main(chosen_row_1, arrange_1, chosen_row_2, arrange_2)\n ", "Program Length": 286, "Identifier Num": 10, "Replaced Identifiers": "process:main,input_file:source_object,", "Query Times": 215, "Time Cost": 0.09966991345087688, "Type": "Greedy"}
{"Index": 122, "Original Code": null, "Adversarial Code": null, "Program Length": 946, "Identifier Num": 17, "Replaced Identifiers": null, "Query Times": 1284, "Time Cost": 1.541843330860138, "Type": "0"}
{"Index": 123, "Original Code": null, "Adversarial Code": null, "Program Length": 206, "Identifier Num": 12, "Replaced Identifiers": null, "Query Times": 698, "Time Cost": 1.0037224094072978, "Type": "0"}
{"Index": 124, "Original Code": null, "Adversarial Code": null, "Program Length": 581, "Identifier Num": 26, "Replaced Identifiers": null, "Query Times": 1493, "Time Cost": 2.1340290268262225, "Type": "0"}
{"Index": 125, "Original Code": null, "Adversarial Code": null, "Program Length": 188, "Identifier Num": 17, "Replaced Identifiers": null, "Query Times": 907, "Time Cost": 1.3734505971272786, "Type": "0"}
{"Index": 127, "Original Code": " \n  \n  \n  def solve(arrange):\n      board, row = arrange[0]\n      before = board[row - 1]\n      board, row = arrange[1]\n      after = board[row - 1]\n      dup = set(before) & set(after)\n      if len(dup) == 1:\n          return dup.pop()\n      elif len(dup) >= 2:\n          return 'Bad magician!'\n      else:\n          return 'Volunteer cheated!'\n  \n  \n  def main(IN, OUT):\n      T = int(IN.readline())\n      for index in range(T):\n          arrange = []\n          for n in range(2):\n              row = int(IN.readline())\n              board = []\n              for line in range(4):\n                  board.append(map(int, IN.readline().split()))\n              arrange.append((board, row))\n          OUT.write('Case #%d: %s\n' % (index + 1, solve(arrange)))\n  \n  \n  def makesample(T=100):\n      print T\n      for index in range(T):\n          for n in range(2):\n              print random.randint(1, 4)\n              board = list(range(1, 16+1))\n              random.shuffle(board)\n              while board:\n                  print ' '.join(map(str, board[:4]))\n                  board = board[4:]\n  \n  \n  if __name__ == '__main__':\n      if '-makesample' in sys.argv[1:]:\n          makesample()\n      else:\n          main(sys.stdin, sys.stdout)\n  \n ", "Adversarial Code": " \n  \n  \n  def setsolver(variride):\n      case, offset = variride[0]\n      now = case[offset - 1]\n      case, offset = variride[1]\n      future = case[offset - 1]\n      Duping = set(now) & set(future)\n      if len(Duping) == 1:\n          return Duping.pop()\n      elif len(Duping) >= 2:\n          return 'Bad magician!'\n      else:\n          return 'Volunteer cheated!'\n  \n  \n  def output(FILE, TER):\n      _ = int(FILE.readline())\n      for index in range(_):\n          variride = []\n          for un in range(2):\n              offset = int(FILE.readline())\n              case = []\n              for lines in range(4):\n                  case.append(map(int, FILE.readline().split()))\n              variride.append((case, offset))\n          TER.write('Case #%d: %s\n' % (index + 1, setsolver(variride)))\n  \n  \n  def makesample(_=100):\n      print _\n      for index in range(_):\n          for un in range(2):\n              print random.randint(1, 4)\n              case = list(range(1, 16+1))\n              random.shuffle(case)\n              while case:\n                  print ' '.join(map(str, case[:4]))\n                  case = case[4:]\n  \n  \n  if __name__ == '__main__':\n      if '-makesample' in sys.argv[1:]:\n          makesample()\n      else:\n          output(sys.stdin, sys.stdout)\n  \n ", "Program Length": 297, "Identifier Num": 15, "Replaced Identifiers": "main:output,OUT:TER,dup:Duping,before:now,after:future,line:lines,arrange:variride,board:case,n:un,row:offset,T:_,solve:setsolver,IN:FILE,", "Query Times": 627, "Time Cost": 0.2836548566818237, "Type": "Greedy"}
{"Index": 129, "Original Code": " \n  \n  def solve(row1, row2):\n      common = [x for x in row1 if x in row2]\n      num_common = len(common)\n      if num_common == 0:\n          return 'Volunteer cheated!'\n      elif num_common > 1:\n          return 'Bad magician!'\n      else:\n          return common[0]\n  \n  def main():\n      N = int(sys.stdin.readline()) # number of testcases\n      for i in range(N):\n          row_index1 = int(sys.stdin.readline())\n          row1 = list()\n          for j in range(4):\n              if row_index1 == j + 1:\n                  row1 = [int(x) for x in sys.stdin.readline().rstrip().split()]\n              else:\n                  sys.stdin.readline()\n  \n          row_index2 = int(sys.stdin.readline())\n          row2 = list()\n          for j in range(4):\n              if row_index2 == j + 1:\n                  row2 = [int(x) for x in sys.stdin.readline().rstrip().split()]\n              else:\n                  sys.stdin.readline()\n  \n          result = solve(row1, row2)\n          print (\"Case #%s: %s\" % (i+1, result))\n  \n  if __name__ == '__main__':\n      main()\n ", "Adversarial Code": " \n  \n  def solve(Row1, Row1):\n      common = [x for x in Row1 if x in Row1]\n       num_compatible = len(common)\n      if  num_compatible == 0:\n          return 'Volunteer cheated!'\n      elif  num_compatible > 1:\n          return 'Bad magician!'\n      else:\n          return common[0]\n  \n  def connect():\n      size = int(sys.stdin.readline()) # number of testcases\n      for i in range(size):\n          row_Indexon = int(sys.stdin.readline())\n          Row1 = list()\n          for j in range(4):\n              if row_Indexon == j + 1:\n                  Row1 = [int(x) for x in sys.stdin.readline().rstrip().split()]\n              else:\n                  sys.stdin.readline()\n  \n          row_Index0 = int(sys.stdin.readline())\n          Row1 = list()\n          for j in range(4):\n              if row_Index0 == j + 1:\n                  Row1 = [int(x) for x in sys.stdin.readline().rstrip().split()]\n              else:\n                  sys.stdin.readline()\n  \n          result = solve(Row1, Row1)\n          print (\"Case #%s: %s\" % (i+1, result))\n  \n  if __name__ == '__main__':\n      connect()\n ", "Program Length": 235, "Identifier Num": 13, "Replaced Identifiers": "main:connect,row2:Row1,row1:Row1,row_index1:row_Indexon,num_common: num_compatible,row_index2:row_Index0,N:size,", "Query Times": 271, "Time Cost": 0.14641684293746948, "Type": "Greedy"}
{"Index": 131, "Original Code": null, "Adversarial Code": null, "Program Length": 150, "Identifier Num": 9, "Replaced Identifiers": null, "Query Times": 413, "Time Cost": 0.752575159072876, "Type": "0"}
