{"Index": 0, "Original Code": null, "Adversarial Code": null, "Program Length": 429, "Identifier Num": 16, "Replaced Identifiers": null, "Query Times": 2515, "Time Cost": 1.378208347161611, "Type": "0"}
{"Index": 1, "Original Code": null, "Adversarial Code": null, "Program Length": 249, "Identifier Num": 15, "Replaced Identifiers": null, "Query Times": 2898, "Time Cost": 1.3801101962725322, "Type": "0"}
{"Index": 2, "Original Code": " def solve():\n      h, w, m = map(int, raw_input().split())\n      if h == 1:\n          print 'c' + '.' * (h * w - m - 1) + '*' * m\n      elif w == 1:\n          for c in 'c' + '.' * (h * w - m - 1) + '*' * m:\n              print c\n      elif h * w - m == 1:\n          print 'c' + '*' * (w - 1)\n          for _ in xrange(h-1):\n              print '*' * w\n      else:\n          m = h * w - m\n          for i in xrange(h-1):\n              for j in xrange(w-1):\n                  t = (i + 2) * 2 + (j + 2) * 2 - 4\n                  r = (i + 2) * (j + 2)\n                  if t <= m <= r:\n                      a = [['*'] * w for _ in xrange(h)]\n                      for k in xrange(i+2):\n                          a[k][0] = '.'\n                          a[k][1] = '.'\n                      for k in xrange(j+2):\n                          a[0][k] = '.'\n                          a[1][k] = '.'\n                      for y, x in product(range(2, i+2), range(2, j+2)):\n                          if y == 1 and x == 1:\n                              continue\n                          if t >= m:\n                              break\n                          a[y][x] = '.'\n                          t += 1\n                      a[0][0] = 'c'\n                      for s in a:\n                          print ''.join(s)\n                      return\n          print 'Impossible'\n  for t in xrange(int(raw_input())):\n      print \"Case #%d:\" % (t + 1)\n      solve()\n ", "Adversarial Code": " def  solved():\n      bh, wx, hm = map(int, raw_input().split())\n      if bh == 1:\n          print 'c' + '.' * (bh * wx - hm - 1) + '*' * hm\n      elif wx == 1:\n          for mac in 'c' + '.' * (bh * wx - hm - 1) + '*' * hm:\n              print mac\n      elif bh * wx - hm == 1:\n          print 'c' + '*' * (wx - 1)\n          for f in xrange(bh-1):\n              print '*' * wx\n      else:\n          hm = bh * wx - hm\n          for I in xrange(bh-1):\n              for jc in xrange(wx-1):\n                  e = (I + 2) * 2 + (jc + 2) * 2 - 4\n                  u = (I + 2) * (jc + 2)\n                  if e <= hm <= u:\n                      n = [['*'] * wx for f in xrange(bh)]\n                      for work in xrange(I+2):\n                          n[work][0] = '.'\n                          n[work][1] = '.'\n                      for work in xrange(jc+2):\n                          n[0][work] = '.'\n                          n[1][work] = '.'\n                      for ey, v in product(u(2, I+2), u(2, jc+2)):\n                          if ey == 1 and v == 1:\n                              continue\n                          if e >= hm:\n                              break\n                          n[ey][v] = '.'\n                          e += 1\n                      n[0][0] = 'c'\n                      for storage in n:\n                          print ''.join(storage)\n                      return\n          print 'Impossible'\n  for e in xrange(int(raw_input())):\n      print \"Case #%d:\" % (e + 1)\n       solved()\n ", "Program Length": 349, "Identifier Num": 15, "Replaced Identifiers": "w:wx,h:bh,x:v,k:work,y:ey,i:I,m:hm,s:storage,t:e,r:u,_:f,j:jc,c:mac,solve:Solution,a:n,", "Query Times": 2121, "Time Cost": 1.1974016308784485, "Type": "mhm"}
{"Index": 3, "Original Code": null, "Adversarial Code": null, "Program Length": 146, "Identifier Num": 8, "Replaced Identifiers": null, "Query Times": 2316, "Time Cost": 1.2776238203048706, "Type": "0"}
{"Index": 5, "Original Code": " \n  if __name__ == \"__main__\":\n  \tf = open( sys.argv[1] )\n  \tint(f.readline())\n  \t\t\n  \tnum = 1\n  \tl = f.readline()\n  \twhile l != \"\":\n  \t\trow1 = int(l)\n  \t\trows = [ f.readline() for x in range(4) ]\n  \t\trow1 = [int(x) for x in rows[row1-1].split()]\n  \n  \t\trow2 = int(f.readline())\n  \t\trows = [f.readline() for x in range(4)]\n  \t\trow2 = [int(x) for x in rows[row2-1].split()]\n  \n  \t\tresult = set(row1) & set(row2)\n  \t\tif len(result) == 1:\n  \t\t\toutput = str(result.pop())\n  \t\telif len(result) > 1:\n  \t\t\toutput = \"Bad magician!\"\n  \t\telse:\n  \t\t\toutput = \"Volunteer cheated!\"\n  \n  \t\tprint \"Case #\"+str(num)+\": \"+output\n  \t\tnum += 1\n  \t\tl = f.readline()\n  \t\t\n ", "Adversarial Code": " \n  if __name__ == \"__main__\":\n  \thttp = open( sys.argv[1] )\n  \tint(http.readline())\n  \t\t\n  \tnum = 1\n  \til = http.readline()\n  \twhile il != \"\":\n  \t\trow1 = int(il)\n  \t\trows = [ http.readline() for x in range(4) ]\n  \t\trow1 = [int(x) for x in rows[row1-1].split()]\n  \n  \t\trow2 = int(http.readline())\n  \t\trows = [http.readline() for x in range(4)]\n  \t\trow2 = [int(x) for x in rows[row2-1].split()]\n  \n  \t\tpair = set(row1) & set(row2)\n  \t\tif len(pair) == 1:\n  \t\t\toutput = str(pair.pop())\n  \t\telif len(pair) > 1:\n  \t\t\toutput = \"Bad magician!\"\n  \t\telse:\n  \t\t\toutput = \"Volunteer cheated!\"\n  \n  \t\tprint \"Case #\"+str(num)+\": \"+output\n  \t\tnum += 1\n  \t\til = http.readline()\n  \t\t\n ", "Program Length": 195, "Identifier Num": 9, "Replaced Identifiers": "result:pair,l:il,f:http,", "Query Times": 93, "Time Cost": 0.05233811140060425, "Type": "mhm"}
{"Index": 6, "Original Code": null, "Adversarial Code": null, "Program Length": 2012, "Identifier Num": 6, "Replaced Identifiers": null, "Query Times": 2910, "Time Cost": 2.5254766901334125, "Type": "0"}
{"Index": 7, "Original Code": null, "Adversarial Code": null, "Program Length": 186, "Identifier Num": 10, "Replaced Identifiers": null, "Query Times": 2720, "Time Cost": 1.3779345591862997, "Type": "0"}
{"Index": 8, "Original Code": "def make_string(R, C, M):\n      grid = [['.' for j in xrange(C)] for i in xrange(R)]\n      grid[-1][-1] = 'c'\n      t = M\n      for i in xrange(R):\n          for j in xrange(C):\n              if M:\n                  if forbidden(R, C, t, i, j):\n                      continue\n                  grid[i][j] = '*'\n                  M -= 1\n              else:\n                  break\n      s = ''\n      if M:\n          return 'Impossible'\n      for r in grid:\n          s += ''.join(r)+'\n'\n      return s[:-1]\n  \n  def forbidden(R, C, M, i, j):\n      a = M / C\n      b = M % C\n      if (R*C - M == 1):\n          return False\n  \n      if i >= (R-2) and j >= (C-2):\n          return True\n  \n      if i >= (R-2) and b:\n          if b % 2:\n              return True\n          if j < b/2:\n              return False\n          else:\n              return True\n      return False\n          \n  \n  f = open('Csmall.in', 'r')\n  g = open('outputC.txt', 'w')\n  \n  data = [[int(e) for e in line.strip(\"\n\").split(' ')] for line in f]\n  T = int(data.pop(0)[0])\n  for i, case in enumerate(data):\n      R, C, M = case[0], case[1], case[2]\n      num_cells = R*C\n      if (R-1) == 0 or (C-1) == 0:\n          s = make_string(R, C, M)\n          g.write('Case #%i:\n%s\n' %(i+1,s))\n          continue\n      else:\n          s = make_string(R, C, M)\n          g.write('Case #%i:\n%s\n' %(i+1, s))\n          \n  \n  f.close()\n  g.close()\n ", "Adversarial Code": "def make_string(R, C, M):\n      grid = [['.' for j in xrange(C)] for i in xrange(R)]\n      grid[-1][-1] = 'c'\n      t = M\n      for i in xrange(R):\n          for j in xrange(C):\n              if M:\n                  if  forgotten(R, C, t, i, j):\n                      continue\n                  grid[i][j] = '*'\n                  M -= 1\n              else:\n                  break\n      s = ''\n      if M:\n          return 'Impossible'\n      for r in grid:\n          s += ''.join(r)+'\n'\n      return s[:-1]\n  \n  def  forgotten(R, C, M, i, j):\n      a = M / C\n      b = M % C\n      if (R*C - M == 1):\n          return False\n  \n      if i >= (R-2) and j >= (C-2):\n          return True\n  \n      if i >= (R-2) and b:\n          if b % 2:\n              return True\n          if j < b/2:\n              return False\n          else:\n              return True\n      return False\n          \n  \n  f = open('Csmall.in', 'r')\n  g = open('outputC.txt', 'w')\n  \n  data = [[int(e) for e in line.strip(\"\n\").split(' ')] for line in f]\n  T = int(data.pop(0)[0])\n  for i, case in enumerate(data):\n      R, C, M = case[0], case[1], case[2]\n      num_cells = R*C\n      if (R-1) == 0 or (C-1) == 0:\n          s = make_string(R, C, M)\n          g.write('Case #%i:\n%s\n' %(i+1,s))\n          continue\n      else:\n          s = make_string(R, C, M)\n          g.write('Case #%i:\n%s\n' %(i+1, s))\n          \n  \n  f.close()\n  g.close()\n ", "Program Length": 392, "Identifier Num": 21, "Replaced Identifiers": "forbidden: forgotten,", "Query Times": 21, "Time Cost": 0.027131056785583495, "Type": "mhm"}
{"Index": 9, "Original Code": null, "Adversarial Code": null, "Program Length": 240, "Identifier Num": 16, "Replaced Identifiers": null, "Query Times": 2672, "Time Cost": 1.4197981039683023, "Type": "0"}
{"Index": 10, "Original Code": " \n  if __name__ == \"__main__\":\n      f = sys.stdin\n      if len(sys.argv) >= 2:\n          fn = sys.argv[1]\n          if fn != '-':\n              f = open(fn)\n  \n      T = int(f.readline())\n      for _T in xrange(T):\n          R, C, M = map(int, f.readline().split())\n  \n          print \"Case #%d:\" % (_T+1)\n  \n          left = R * C - M\n  \n          if R == 1:\n              s = 'c'\n              s += '.' * (left - 1)\n              s += '*' * M\n              print s\n              continue\n          if C == 1:\n              print 'c'\n              for i in xrange(left - 1):\n                  print '.'\n              for i in xrange(M):\n                  print '*'\n              continue\n  \n          if left == 1:\n              print 'c' + '*' * (C-1)\n              for i in xrange(R-1):\n                  print '*' * C\n              continue\n  \n          if (R == 2 or C == 2) and (M % 2 == 1 or left == 2):\n              print \"Impossible\"\n              continue\n          if R == 2:\n              assert left not in (2, 3, 5, 7)\n              assert left >= 4\n              print 'c' + '.' * (left/2 - 1) + '*' * (M/2)\n              print '.' + '.' * (left/2 - 1) + '*' * (M/2)\n              continue\n          if C == 2:\n              assert left >= 4\n              assert left not in (2, 3, 5, 7)\n              print 'c.'\n              left -= 2\n              R -= 1\n              while left:\n                  print '..'\n                  left -= 2\n                  R -= 1\n              assert R >= 0\n              while R:\n                  print '**'\n                  R -= 1\n              continue\n  \n          assert R >= 3\n          assert C >= 3\n  \n          if left == 4:\n              print 'c.' + '*' * (C-2)\n              print '..' + '*' * (C-2)\n              for i in xrange(R-2):\n                  print '*' * C\n              continue\n  \n          if left in (2, 3, 5, 7):\n              print \"Impossible\"\n              continue\n  \n          assert left >= 6\n  \n          cols = max(3, (left + R-1) // R)\n  \n          if left % cols == 1:\n              assert left >= 10\n  \n              print 'c' + '.' * (cols - 1) + '*' * (C - cols)\n              left -= cols\n              R -= 1\n  \n              while left > cols + 1:\n                  print '.' * cols + '*' * (C - cols)\n                  left -= cols\n                  R -= 1\n              assert left == cols + 1\n              print '.' * (cols - 1) + '*' * (C - cols + 1)\n              print '.' * (2) + '*' * (C - 2)\n              R -= 2\n  \n              assert R >= 0\n  \n              while R:\n                  print '*' * C\n                  R -= 1\n              continue\n          else:\n              assert left >= 6\n  \n              print 'c' + '.' * (cols - 1) + '*' * (C - cols)\n              left -= cols\n              R -= 1\n  \n              while left > cols:\n                  print '.' * cols + '*' * (C - cols)\n                  left -= cols\n                  R -= 1\n              assert left >= 2\n              print '.' * (left) + '*' * (C - left)\n              R -= 1\n  \n              assert R >= 0\n  \n              while R:\n                  print '*' * C\n                  R -= 1\n              continue\n  \n          1/0\n ", "Adversarial Code": " \n  if __name__ == \"__main__\":\n      f = sys.stdin\n      if len(sys.argv) >= 2:\n          fn = sys.argv[1]\n          if fn != '-':\n              f = open(fn)\n  \n      T = int(f.readline())\n      for _T in xrange(T):\n          R, CNN, M = map(int, f.readline().split())\n  \n          print \"Case #%d:\" % (_T+1)\n  \n          key = R * CNN - M\n  \n          if R == 1:\n              s = 'c'\n              s += '.' * (key - 1)\n              s += '*' * M\n              print s\n              continue\n          if CNN == 1:\n              print 'c'\n              for i in xrange(key - 1):\n                  print '.'\n              for i in xrange(M):\n                  print '*'\n              continue\n  \n          if key == 1:\n              print 'c' + '*' * (CNN-1)\n              for i in xrange(R-1):\n                  print '*' * CNN\n              continue\n  \n          if (R == 2 or CNN == 2) and (M % 2 == 1 or key == 2):\n              print \"Impossible\"\n              continue\n          if R == 2:\n              assert key not in (2, 3, 5, 7)\n              assert key >= 4\n              print 'c' + '.' * (key/2 - 1) + '*' * (M/2)\n              print '.' + '.' * (key/2 - 1) + '*' * (M/2)\n              continue\n          if CNN == 2:\n              assert key >= 4\n              assert key not in (2, 3, 5, 7)\n              print 'c.'\n              key -= 2\n              R -= 1\n              while key:\n                  print '..'\n                  key -= 2\n                  R -= 1\n              assert R >= 0\n              while R:\n                  print '**'\n                  R -= 1\n              continue\n  \n          assert R >= 3\n          assert CNN >= 3\n  \n          if key == 4:\n              print 'c.' + '*' * (CNN-2)\n              print '..' + '*' * (CNN-2)\n              for i in xrange(R-2):\n                  print '*' * CNN\n              continue\n  \n          if key in (2, 3, 5, 7):\n              print \"Impossible\"\n              continue\n  \n          assert key >= 6\n  \n          cols = max(3, (key + R-1) // R)\n  \n          if key % cols == 1:\n              assert key >= 10\n  \n              print 'c' + '.' * (cols - 1) + '*' * (CNN - cols)\n              key -= cols\n              R -= 1\n  \n              while key > cols + 1:\n                  print '.' * cols + '*' * (CNN - cols)\n                  key -= cols\n                  R -= 1\n              assert key == cols + 1\n              print '.' * (cols - 1) + '*' * (CNN - cols + 1)\n              print '.' * (2) + '*' * (CNN - 2)\n              R -= 2\n  \n              assert R >= 0\n  \n              while R:\n                  print '*' * CNN\n                  R -= 1\n              continue\n          else:\n              assert key >= 6\n  \n              print 'c' + '.' * (cols - 1) + '*' * (CNN - cols)\n              key -= cols\n              R -= 1\n  \n              while key > cols:\n                  print '.' * cols + '*' * (CNN - cols)\n                  key -= cols\n                  R -= 1\n              assert key >= 2\n              print '.' * (key) + '*' * (CNN - key)\n              R -= 1\n  \n              assert R >= 0\n  \n              while R:\n                  print '*' * CNN\n                  R -= 1\n              continue\n  \n          1/0\n ", "Program Length": 612, "Identifier Num": 11, "Replaced Identifiers": "left:key,C:CNN,", "Query Times": 62, "Time Cost": 0.047226206461588545, "Type": "mhm"}
{"Index": 11, "Original Code": " \n  if __name__ == \"__main__\":\n      f = sys.stdin\n      if len(sys.argv) >= 2:\n          fn = sys.argv[1]\n          if fn != '-':\n              f = open(fn)\n  \n      T = int(f.readline())\n      for _T in xrange(T):\n          a1 = int(f.readline())\n          l1 = [map(int, f.readline().split()) for _ in xrange(4)]\n          a2 = int(f.readline())\n          l2 = [map(int, f.readline().split()) for _ in xrange(4)]\n  \n          poss = list(set(l1[a1-1]) & set(l2[a2-1]))\n  \n          print \"Case #%d:\" % (_T + 1),\n          if len(poss) == 0:\n              print \"Volunteer cheated!\"\n          elif len(poss) == 1:\n              print poss[0]\n          else:\n              print \"Bad magician!\"\n ", "Adversarial Code": " \n  if __name__ == \"__main__\":\n      f = sys.stdin\n      if len(sys.argv) >= 2:\n          fn = sys.argv[1]\n          if fn != '-':\n              f = open(fn)\n  \n      T = int(f.readline())\n      for _T in xrange(T):\n          a1 = int(f.readline())\n          l1 = [map(int, f.readline().split()) for _ in xrange(4)]\n          areaII = int(f.readline())\n          l2 = [map(int, f.readline().split()) for _ in xrange(4)]\n  \n          poss = list(set(l1[a1-1]) & set(l2[areaII-1]))\n  \n          print \"Case #%d:\" % (_T + 1),\n          if len(poss) == 0:\n              print \"Volunteer cheated!\"\n          elif len(poss) == 1:\n              print poss[0]\n          else:\n              print \"Bad magician!\"\n ", "Program Length": 187, "Identifier Num": 10, "Replaced Identifiers": "a2:areaII,", "Query Times": 31, "Time Cost": 0.027070605754852296, "Type": "mhm"}
{"Index": 13, "Original Code": " \n  \n  TEST_CASES = [\n      (\"\"\"3\n  2\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  3\n  1 2 5 4\n  3 11 6 15\n  9 10 7 12\n  13 14 8 16\n  2\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  2\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  2\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  3\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  \"\"\",\"\"\"Case #1: 7\n  Case #2: Bad magician!\n  Case #3: Volunteer cheated!\n  \"\"\"),\n      (\"\"\"1\n  1\n  15 9 16 5\n  6 10 1 3\n  2 4 12 11\n  13 14 8 7\n  1\n  5 10 9 6\n  12 15 1 11\n  14 16 4 2\n  13 3 8 7\"\"\",\"\"\"Case #1: Bad magician!\n  \"\"\")\n  ]\n  \n  BAD_MAGIC = \"Bad magician!\"\n  CHEATING = \"Volunteer cheated!\"\n  \n  def parse_input(input_reader):\n      case_count = int(input_reader.readline())\n      case_idx = 0\n      while case_count > case_idx:\n          case_idx += 1\n          rows = []\n          for loop_idx in (1,2):\n              row_idx = int(input_reader.readline())\n              for idx in (1,2,3,4):\n                  if idx == row_idx:\n                      rows.append(set(input_reader.readline().rstrip(\"\n\").split(\" \")))\n                  else:\n                      input_reader.readline()\n          input_values = {\"rows\":rows,\n                          \"case\":case_idx}\n          yield input_values\n  \n  \n  def solve_problem(output_writer=sys.stdout, **kwargs):\n      rows = kwargs['rows']\n      case = kwargs['case']\n      intersect = rows[0].intersection(rows[1])\n      if not intersect:\n          msg = CHEATING\n      elif len(intersect) == 1:\n          msg = intersect.pop()\n      else:\n          msg = BAD_MAGIC\n      print >>output_writer, \"Case #%d: %s\" % (case, msg)\n  \n  def solve_inputs(input_reader, output_writer):\n      \"\"\"\n      Loop through each problem input in input reader and solve it.\n  \n      Outputs responses to output_writer.\n      \"\"\"\n      for input_values in parse_input(input_reader):\n          solve_problem(output_writer=output_writer, **input_values)\n  \n  def run_tests():\n      \"\"\"\n      Check the sample input and output match.\n      \"\"\"\n      idx = 0\n      all_pass = True\n      for problem_input, expected_output in TEST_CASES:\n          idx += 1\n          input_reader = StringIO(problem_input)\n          output_writer = StringIO()\n          solve_inputs(input_reader, output_writer)\n          problem_output = output_writer.getvalue()\n          if problem_output == expected_output:\n              print \"Test %d: Success\" % idx\n          else:\n              all_pass = False\n              print \"Test %d: Failure\" % idx\n          input_reader.close()\n          output_writer.close()\n      if all_pass:\n          print \"All tests were successful!\"\n      else:\n          print \"Something didn't match - try again.\"\n          print problem_output\n  \n  def main():\n      parser = OptionParser()\n      parser.add_option(\"-f\", \"--file\",\n                        dest=\"filename_stem\",\n                        help=\"read input from FILE.in and write to FILE.out\",\n                        metavar=\"FILE\")\n  \n      (options, args) = parser.parse_args()\n      if options.filename_stem:\n          print \"Running in file mode.\"\n          input_reader = open(\"%s.in\" % options.filename_stem, \"r\")\n          output_writer = open(\"%s.out\" % options.filename_stem, \"w\")\n          solve_inputs(input_reader, output_writer)\n      else:\n          print \"Running in test mode.\"\n          run_tests()\n  \n  if __name__ == \"__main__\":\n      main()\n ", "Adversarial Code": " \n  \n  TEST_CACIONS = [\n      (\"\"\"3\n  2\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  3\n  1 2 5 4\n  3 11 6 15\n  9 10 7 12\n  13 14 8 16\n  2\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  2\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  2\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  3\n  1 2 3 4\n  5 6 7 8\n  9 10 11 12\n  13 14 15 16\n  \"\"\",\"\"\"Case #1: 7\n  Case #2: Bad magician!\n  Case #3: Volunteer cheated!\n  \"\"\"),\n      (\"\"\"1\n  1\n  15 9 16 5\n  6 10 1 3\n  2 4 12 11\n  13 14 8 7\n  1\n  5 10 9 6\n  12 15 1 11\n  14 16 4 2\n  13 3 8 7\"\"\",\"\"\"Case #1: Bad magician!\n  \"\"\")\n  ]\n  \n  BAD_LOGICK = \"Bad magician!\"\n  CHPEating = \"Volunteer cheated!\"\n  \n  def pack_input( input_writer):\n      case64group = int( input_writer.readline())\n      case_inxs = 0\n      while case64group > case_inxs:\n          case_inxs += 1\n          rows = []\n          for loop_idx in (1,2):\n              row___intxs = int( input_writer.readline())\n              for  idxs in (1,2,3,4):\n                  if  idxs == row___intxs:\n                      rows.append(set( input_writer.readline().rstrip(\"\n\").split(\" \")))\n                  else:\n                       input_writer.readline()\n          input_vals = {\"rows\":rows,\n                          \"case\":case_inxs}\n          yield input_vals\n  \n  \n  def solve_problem(output_writer=sys.stdout, **kwargs):\n      rows = kwargs['rows']\n      base = kwargs['case']\n      overract = rows[0].intersection(rows[1])\n      if not overract:\n          bug = CHPEating\n      elif len(overract) == 1:\n          bug = overract.pop()\n      else:\n          bug = BAD_LOGICK\n      print >>output_writer, \"Case #%d: %s\" % (base, bug)\n  \n  def solve_pulltests( input_writer, output_writer):\n      \"\"\"\n      Loop through each problem input in input reader and solve it.\n  \n      Outputs responses to output_writer.\n      \"\"\"\n      for input_vals in pack_input( input_writer):\n          solve_problem(output_writer=output_writer, **input_vals)\n  \n  def run_tests():\n      \"\"\"\n      Check the sample input and output match.\n      \"\"\"\n       idxs = 0\n      all_pass = True\n      for problem_input, expected_output in TEST_CACIONS:\n           idxs += 1\n           input_writer = StringIO(problem_input)\n          output_writer = StringIO()\n          solve_pulltests( input_writer, output_writer)\n          problem_output = output_writer.getvalue()\n          if problem_output == expected_output:\n              print \"Test %d: Success\" %  idxs\n          else:\n              all_pass = False\n              print \"Test %d: Failure\" %  idxs\n           input_writer.close()\n          output_writer.close()\n      if all_pass:\n          print \"All tests were successful!\"\n      else:\n          print \"Something didn't match - try again.\"\n          print problem_output\n  \n  def main():\n      parser = OptionParser()\n      parser.add_option(\"-f\", \"--file\",\n                        dest=\"filename_stem\",\n                        help=\"read input from FILE.in and write to FILE.out\",\n                        metavar=\"FILE\")\n  \n      (options, args) = parser.parse_args()\n      if options.filename_stem:\n          print \"Running in file mode.\"\n           input_writer = open(\"%s.in\" % options.filename_stem, \"r\")\n          output_writer = open(\"%s.out\" % options.filename_stem, \"w\")\n          solve_pulltests( input_writer, output_writer)\n      else:\n          print \"Running in test mode.\"\n          run_tests()\n  \n  if __name__ == \"__main__\":\n      main()\n ", "Program Length": 406, "Identifier Num": 18, "Replaced Identifiers": "case_count:case64group,CHEATING:CHPEating,row_idx:row___intxs,TEST_CASES:TEST_CACIONS,input_reader:jsonFiledriver,intersect:overract,case:base,case_idx:case_inxs,input_values:input_vals,solve_inputs:solve_pulltests,BAD_MAGIC:BAD_LOGICK,msg:bug,parse_input:pack_input,idx: idxs,", "Query Times": 860, "Time Cost": 0.5145959814389547, "Type": "mhm"}
{"Index": 14, "Original Code": null, "Adversarial Code": null, "Program Length": 510, "Identifier Num": 21, "Replaced Identifiers": null, "Query Times": 2708, "Time Cost": 1.580699904759725, "Type": "0"}
{"Index": 15, "Original Code": null, "Adversarial Code": null, "Program Length": 306, "Identifier Num": 23, "Replaced Identifiers": null, "Query Times": 2820, "Time Cost": 1.5324287295341492, "Type": "0"}
{"Index": 17, "Original Code": " \n  def solve_case(answers, arrangements_of_cards, case_number):\n      first_candidates = arrangements_of_cards[0][answers[0] - 1]\n      second_candidates = arrangements_of_cards[1][answers[1] - 1]\n      answer = set(first_candidates) & set(second_candidates)\n      length_of_answer = len(answer)\n      if length_of_answer > 1:\n          print \"Case #%d: Bad magician!\" % case_number\n      elif length_of_answer < 1:\n          print \"Case #%d: Volunteer cheated!\" % case_number\n      else:\n          print \"Case #%d: %d\" % (case_number, answer.pop())\n  \n  r = sys.stdin\n  \n  if len(sys.argv) > 1:\n      r = open(sys.argv[1], 'r')\n  \n  total_cases = r.readline()\n  for case_number in range(1, int(total_cases) + 1):\n      answers = []\n      arrangements_of_cards = []\n      answers.append(int(r.readline()))\n      arrangements_of_cards.append([])\n      for row in range(0, 4):\n          arrangements_of_cards[0].append(map(int, r.readline().split(' ')))\n      answers.append(int(r.readline()))\n      arrangements_of_cards.append([])\n      for row in range(0, 4):\n          arrangements_of_cards[1].append(map(int, r.readline().split(' ')))\n      solve_case(answers, arrangements_of_cards, case_number)\n ", "Adversarial Code": " \n  def solvelibtrial(oldswards, arrangements_of_cards, example64language):\n      first_candidates = arrangements_of_cards[0][oldswards[0] - 1]\n      second_centares = arrangements_of_cards[1][oldswards[1] - 1]\n      duration = set(first_candidates) & set(second_centares)\n      length_of_video = len(duration)\n      if length_of_video > 1:\n          print \"Case #%d: Bad magician!\" % example64language\n      elif length_of_video < 1:\n          print \"Case #%d: Volunteer cheated!\" % example64language\n      else:\n          print \"Case #%d: %d\" % (example64language, duration.pop())\n  \n  l = sys.stdin\n  \n  if len(sys.argv) > 1:\n      l = open(sys.argv[1], 'r')\n  \n  max_cases = l.readline()\n  for example64language in range(1, int(max_cases) + 1):\n      oldswards = []\n      arrangements_of_cards = []\n      oldswards.append(int(l.readline()))\n      arrangements_of_cards.append([])\n      for by in range(0, 4):\n          arrangements_of_cards[0].append(map(int, l.readline().split(' ')))\n      oldswards.append(int(l.readline()))\n      arrangements_of_cards.append([])\n      for by in range(0, 4):\n          arrangements_of_cards[1].append(map(int, l.readline().split(' ')))\n      solvelibtrial(oldswards, arrangements_of_cards, example64language)\n ", "Program Length": 259, "Identifier Num": 11, "Replaced Identifiers": "answer:duration,answers:oldswards,length_of_answer:length_of_video,second_candidates:second_centares,total_cases:max_cases,r:l,solve_case:solvelibtrial,row:by,case_number:example64language,", "Query Times": 503, "Time Cost": 0.31117948293685915, "Type": "mhm"}
{"Index": 19, "Original Code": null, "Adversarial Code": null, "Program Length": 211, "Identifier Num": 16, "Replaced Identifiers": null, "Query Times": 2774, "Time Cost": 1.490349288781484, "Type": "0"}
{"Index": 20, "Original Code": " \n  def read_line():\n      return sys.stdin.readline().rstrip( '\n' )\n  \n  def read_integer():\n      return int( read_line() )\n  \n  def read_integers():\n      return [ int( x ) for x in read_line().split() ]\n  \n  def flip( grid ):\n      return [ bytearray( ''.join( chr( grid[ row ][ column ] ) for row in range( len( grid ) ) ) ) for column in range( len( grid[ 0 ] ) ) ]\n  \n  def grow( R, C, M ):\n      grid = [ bytearray( C*[ '*' ] ) for row in range( R ) ]\n      b = R*C - M\n      if C > R:\n          R, C, grid = C, R, flip( grid )\n          flipped = True\n      else:\n          flipped = False\n      if b < 2*C:\n          if b == 1:\n              grid[ 0 ][ 0 ] = 'c'\n          elif b == 3 and C >= 3:\n              grid[ 0 ][ : 3 ] = bytearray( '.c.' )\n          elif b % 2:\n              return\n          else:\n              grid[ 0 ][ : b//2 ] = bytearray( b//2*'.' )\n              grid[ 1 ][ : b//2 ] = bytearray( b//2*'.' )\n              grid[ 0 ][ 0 ] = 'c'\n      else:\n          r = 0\n          while b >= C:\n              grid[ r ] = bytearray( C*[ '.' ] )\n              b -= C\n              r += 1\n          if b:\n              if b >= 2:\n                  grid[ r ][ : b ] = b*'.'\n              elif C > 2 and r > 2:\n                  grid[ r - 1 ][ -1 ] = '*'\n                  grid[ r ][ : 2 ] = '..'\n              else:\n                  return\n          grid[ 0 ][ 0 ] = 'c'\n      return flip( grid ) if flipped else grid\n      \n  T = read_integer()\n  for t in range( T ):\n      print 'Case #%i:' % ( t + 1 )\n      R, C, M = read_integers()\n      grid = grow( R, C, M )\n      print '\n'.join( str( row ) for row in grid ) if grid else 'Impossible'\n ", "Adversarial Code": " \n  def readNewsample():\n      return sys.stdin.readline().rstrip( '\n' )\n  \n  def write_Integer():\n      return int( readNewsample() )\n  \n  def read_integers():\n      return [ int( dx ) for dx in readNewsample().split() ]\n  \n  def Flipped( grid ):\n      return [ bytearray( ''.join( chr( grid[ row ][ pixel ] ) for row in range( len( grid ) ) ) ) for pixel in range( len( grid[ 0 ] ) ) ]\n  \n  def grow( R, C, M ):\n      grid = [ bytearray( C*[ '*' ] ) for row in range( R ) ]\n      block = R*C - M\n      if C > R:\n          R, C, grid = C, R, Flipped( grid )\n          flided = True\n      else:\n          flided = False\n      if block < 2*C:\n          if block == 1:\n              grid[ 0 ][ 0 ] = 'c'\n          elif block == 3 and C >= 3:\n              grid[ 0 ][ : 3 ] = bytearray( '.c.' )\n          elif block % 2:\n              return\n          else:\n              grid[ 0 ][ : block//2 ] = bytearray( block//2*'.' )\n              grid[ 1 ][ : block//2 ] = bytearray( block//2*'.' )\n              grid[ 0 ][ 0 ] = 'c'\n      else:\n          rb = 0\n          while block >= C:\n              grid[ rb ] = bytearray( C*[ '.' ] )\n              block -= C\n              rb += 1\n          if block:\n              if block >= 2:\n                  grid[ rb ][ : block ] = block*'.'\n              elif C > 2 and rb > 2:\n                  grid[ rb - 1 ][ -1 ] = '*'\n                  grid[ rb ][ : 2 ] = '..'\n              else:\n                  return\n          grid[ 0 ][ 0 ] = 'c'\n      return Flipped( grid ) if flided else grid\n      \n  WT = write_Integer()\n  for d in range( WT ):\n      print 'Case #%i:' % ( d + 1 )\n      R, C, M = read_integers()\n      grid = grow( R, C, M )\n      print '\n'.join( str( row ) for row in grid ) if grid else 'Impossible'\n ", "Program Length": 406, "Identifier Num": 17, "Replaced Identifiers": "T:WT,column:pixel,t:d,r:rb,b:block,flip:Flipped,flipped:flided,x:dx,read_integer:write_Integer,read_line:readNewsample,", "Query Times": 284, "Time Cost": 0.16464092334111533, "Type": "mhm"}
{"Index": 21, "Original Code": null, "Adversarial Code": null, "Program Length": 297, "Identifier Num": 22, "Replaced Identifiers": null, "Query Times": 2348, "Time Cost": 1.428019650777181, "Type": "0"}
{"Index": 22, "Original Code": null, "Adversarial Code": null, "Program Length": 765, "Identifier Num": 17, "Replaced Identifiers": null, "Query Times": 2476, "Time Cost": 1.61142547527949, "Type": "0"}
{"Index": 23, "Original Code": null, "Adversarial Code": null, "Program Length": 174, "Identifier Num": 9, "Replaced Identifiers": null, "Query Times": 2615, "Time Cost": 1.4246405164400737, "Type": "0"}
{"Index": 24, "Original Code": " \n  \n  \n  def show_board(board):\n      for row in board:\n          print ''.join(row)\n  \n  \n  N = int(sys.stdin.readline())\n  \n  for T in range(1, N+1):\n      (R, C, M) = map(int, sys.stdin.readline().split(' '))\n      E = R*C-M # empty\n      possible, reverse, need_adjust, column_base = (False, False, False, False)\n      if C > R:\n          (R, C) = (C, R)\n          reverse = True\n  \n      W = 0\n      lastRow = 0\n      if E == 0:\n          pass\n      elif E == 1 or M == 0:\n          W = C\n          possible = True\n      elif C == 1:\n          W = 1\n          if E > 0:\n              possible = True\n      elif C == 2:\n          W = 2\n          lastRow = int(E / 2) + 1   # 1 base\n          if E % 2 == 0 and E >= 4:\n              possible = True\n      elif C >= 3:\n          for w in range(2, C+1):\n              lastRow = int(E / w) + 1   # 1 base\n              if lastRow > R: continue\n              lastRowNum = E % w\n              \n              if lastRow == 2 and lastRowNum == 0:\n                  pass\n              elif lastRow == 2:   # lastRow == 1 => impossible\n                  if lastRowNum == 0:\n                      W = w\n                      possible = True\n                      break\n              elif lastRow >= 3:\n                  if lastRowNum >= 2 or lastRowNum == 0:\n                      W = w\n                      possible = True\n                      break\n                  elif C >= 4 and lastRowNum == 1 and R >= 3:\n                      W = w\n                      possible = True\n                      need_adjust = True\n                      break\n          if not possible:\n              for w in range(2, R+1):\n                  lastRow = int(E / w) + 1   # 1 base\n                  if lastRow > R: continue\n                  lastRowNum = E % w\n                  if lastRow == 2 and lastRowNum == 0:\n                      pass\n                  elif lastRow == 2:   # lastRow == 1 => impossible\n                      if lastRowNum == 0:\n                          W = w\n                          possible = True\n                          column_base = True\n                          break\n                  elif lastRow >= 3:\n                      if lastRowNum >= 2 or lastRowNum == 0:\n                          W = w\n                          possible = True\n                          column_base = True\n                          break\n                      elif C >= 4 and lastRowNum == 1 and R >= 3:\n                          W = w\n                          possible = True\n                          need_adjust = True\n                          column_base = True\n                          break\n                                  \n      if not possible:\n          if reverse:\n              R, C = (C, R)        \n          ans = 'Impossible %sx%s M=%s' % (R, C, M)\n          print 'Case #%(T)s: %(ans)s' % locals()\n          continue\n  \n      board = [['*'] * C for i in range(R)]\n      for i in range(E):\n          if not column_base:\n              c = i % W\n              r = i / W\n          else:\n              r = i % W\n              c = i / W            \n          board[r][c] = '.'\n      if need_adjust:\n          board[lastRow-1][1], board[lastRow-2][-1] = board[lastRow-2][-1], board[lastRow-1][1]\n      if reverse:\n          board = map(list, zip(*board))\n          R, C = (C, R)\n  \n      clicked = False\n      for r in range(R):\n          if clicked: break\n          for c in range(C):\n              cell = board[r][c]\n              if cell != '.': continue\n              if E == 1:\n                  board[r][c] = 'c'\n                  clicked = True\n                  break\n              \n              if r >= 1  and c >= 1  and board[r-1][c-1] == '*': continue\n              if r >= 1              and board[r-1][c]   == '*': continue\n              if r >= 1  and c < C-1 and board[r-1][c+1] == '*': continue\n              if             c >= 1  and board[r][c-1]   == '*': continue\n              if             c < C-1 and board[r][c+1]   == '*': continue\n              if r < R-1 and c >= 1  and board[r+1][c-1] == '*': continue\n              if r < R-1             and board[r+1][c]   == '*': continue\n              if r < R-1 and c < C-1 and board[r+1][c+1] == '*': continue\n              board[r][c] = 'c'\n              clicked = True\n              break\n  \n      ans = 'Possible' if possible else 'Impossible'\n      print 'Case #%(T)s:' % locals()\n      show_board(board)\n ", "Adversarial Code": " \n  \n  \n  def showpychannel(card):\n      for row in card:\n          print ''.join(row)\n  \n  \n  N = int(sys.stdin.readline())\n  \n  for D in range(1, N+1):\n      (R, C, CM) = map(int, sys.stdin.readline().split(' '))\n      E = R*C-CM # empty\n      possible, reverse, need_adjust, attribute64base = (False, False, False, False)\n      if C > R:\n          (R, C) = (C, R)\n          reverse = True\n  \n      W = 0\n      lastRow = 0\n      if E == 0:\n          pass\n      elif E == 1 or CM == 0:\n          W = C\n          possible = True\n      elif C == 1:\n          W = 1\n          if E > 0:\n              possible = True\n      elif C == 2:\n          W = 2\n          lastRow = int(E / 2) + 1   # 1 base\n          if E % 2 == 0 and E >= 4:\n              possible = True\n      elif C >= 3:\n          for w in range(2, C+1):\n              lastRow = int(E / w) + 1   # 1 base\n              if lastRow > R: continue\n              lastRowNum = E % w\n              \n              if lastRow == 2 and lastRowNum == 0:\n                  pass\n              elif lastRow == 2:   # lastRow == 1 => impossible\n                  if lastRowNum == 0:\n                      W = w\n                      possible = True\n                      break\n              elif lastRow >= 3:\n                  if lastRowNum >= 2 or lastRowNum == 0:\n                      W = w\n                      possible = True\n                      break\n                  elif C >= 4 and lastRowNum == 1 and R >= 3:\n                      W = w\n                      possible = True\n                      need_adjust = True\n                      break\n          if not possible:\n              for w in range(2, R+1):\n                  lastRow = int(E / w) + 1   # 1 base\n                  if lastRow > R: continue\n                  lastRowNum = E % w\n                  if lastRow == 2 and lastRowNum == 0:\n                      pass\n                  elif lastRow == 2:   # lastRow == 1 => impossible\n                      if lastRowNum == 0:\n                          W = w\n                          possible = True\n                          attribute64base = True\n                          break\n                  elif lastRow >= 3:\n                      if lastRowNum >= 2 or lastRowNum == 0:\n                          W = w\n                          possible = True\n                          attribute64base = True\n                          break\n                      elif C >= 4 and lastRowNum == 1 and R >= 3:\n                          W = w\n                          possible = True\n                          need_adjust = True\n                          attribute64base = True\n                          break\n                                  \n      if not possible:\n          if reverse:\n              R, C = (C, R)        \n          ans = 'Impossible %sx%s M=%s' % (R, C, CM)\n          print 'Case #%(T)s: %(ans)s' % locals()\n          continue\n  \n      card = [['*'] * C for i in range(R)]\n      for i in range(E):\n          if not attribute64base:\n              c = i % W\n              r = i / W\n          else:\n              r = i % W\n              c = i / W            \n          card[r][c] = '.'\n      if need_adjust:\n          card[lastRow-1][1], card[lastRow-2][-1] = card[lastRow-2][-1], card[lastRow-1][1]\n      if reverse:\n          card = map(list, zip(*card))\n          R, C = (C, R)\n  \n      clicked = False\n      for r in range(R):\n          if clicked: break\n          for c in range(C):\n              cell = card[r][c]\n              if cell != '.': continue\n              if E == 1:\n                  card[r][c] = 'c'\n                  clicked = True\n                  break\n              \n              if r >= 1  and c >= 1  and card[r-1][c-1] == '*': continue\n              if r >= 1              and card[r-1][c]   == '*': continue\n              if r >= 1  and c < C-1 and card[r-1][c+1] == '*': continue\n              if             c >= 1  and card[r][c-1]   == '*': continue\n              if             c < C-1 and card[r][c+1]   == '*': continue\n              if r < R-1 and c >= 1  and card[r+1][c-1] == '*': continue\n              if r < R-1             and card[r+1][c]   == '*': continue\n              if r < R-1 and c < C-1 and card[r+1][c+1] == '*': continue\n              card[r][c] = 'c'\n              clicked = True\n              break\n  \n      ans = 'Possible' if possible else 'Impossible'\n      print 'Case #%(T)s:' % locals()\n      showpychannel(card)\n ", "Program Length": 838, "Identifier Num": 17, "Replaced Identifiers": "column_base:attribute64base,board:card,M:CM,T:D,show_board:showpychannel,", "Query Times": 136, "Time Cost": 0.0939389189084371, "Type": "mhm"}
{"Index": 25, "Original Code": null, "Adversarial Code": null, "Program Length": 197, "Identifier Num": 13, "Replaced Identifiers": null, "Query Times": 1973, "Time Cost": 1.3560985922813416, "Type": "0"}
{"Index": 27, "Original Code": "T = int(raw_input())\n  for i in range(T):\n    index = int(raw_input())\n    X = []\n    for j in range(4):\n      X.append(map(int, raw_input().split()))\n    x1 = X[index-1]\n    index = int(raw_input())\n    X = []\n    for j in range(4):\n      X.append(map(int, raw_input().split()))\n    x2 = X[index-1]\n    ans = set(x1).intersection(set(x2))\n    if len(ans) == 0:\n      print 'Case #%i: Volunteer cheated!' % (i+1)\n    elif len(ans) == 1:\n      print 'Case #%i: %i' % (i+1, ans.pop())\n    else:\n      print 'Case #%i: Bad magician!' % (i+1)\n ", "Adversarial Code": "CI = int(raw_input())\n  for ci in range(CI):\n    loc = int(raw_input())\n    X = []\n    for ji in range(4):\n      X.append(map(int, raw_input().split()))\n    x1 = X[loc-1]\n    loc = int(raw_input())\n    X = []\n    for ji in range(4):\n      X.append(map(int, raw_input().split()))\n    X1 = X[loc-1]\n    an = set(x1).intersection(set(X1))\n    if len(an) == 0:\n      print 'Case #%i: Volunteer cheated!' % (ci+1)\n    elif len(an) == 1:\n      print 'Case #%i: %i' % (ci+1, an.pop())\n    else:\n      print 'Case #%i: Bad magician!' % (ci+1)\n ", "Program Length": 168, "Identifier Num": 8, "Replaced Identifiers": "index:loc,ans:an,T:CI,j:ji,i:ci,x2:X1,", "Query Times": 472, "Time Cost": 0.24467579126358033, "Type": "mhm"}
{"Index": 29, "Original Code": null, "Adversarial Code": null, "Program Length": 184, "Identifier Num": 11, "Replaced Identifiers": null, "Query Times": 2551, "Time Cost": 1.4386161684989929, "Type": "0"}
{"Index": 30, "Original Code": " \n  \n  tCase = int(sys.stdin.readline())\n  \n  \n  def map(R, C, Bombs):\n  \tm = [[\".\" for x in xrange(C)] for x in xrange(R)]\n  \tprint Bombs\n  \tm[R-1][C-1] = 'c'\n  \tlastSkip = False\n  \tfor i in xrange(R):\n  \t\tfor j in xrange(C):\n  \t\t\tif Bombs == 0:\n  \t\t\t\tbreak\n  \t\t\t\n  \t\t\tif lastSkip:\n  \t\t\t\tm[i][j] = 'f'\n  \t\t\t\tcontinue\n  \t\t\t\n  \t\t\tif R - i == 2 or C - j == 2:\n  \t\t\t\tif Bombs == 1:\n  \t\t\t\t\tm[i][j] = 'f'\n  \t\t\t\t\tlastSkip = True\n  \t\t\t\t\tcontinue\n  \t\t\t\n  \t\t\t\t\n  \t\t\tm[i][j] = '*'\n  \t\t\tBombs -= 1\n  \t\t\tlastSkip = False\n  \t\tlastSkip = False\n  \t\t\t\t\n  \t\n  \t\n  \tfor line in m:\n  \t\tfor c in line:\n  \t\t\tprint c,\n  \t\tprint\n  \t\t\n  \t\t\n  def imprimir(m):\n  \tfor line in m:\n  \t\tfor c in line:\n  \t\t\tprint c,\n  \t\tprint\n  \t\t\n  def map2(R, C, Bombs):\n  \tm = [[\".\" for x in xrange(C)] for x in xrange(R)]\n  \tm[R-1][C-1] = 'c'\n  \tlastSkip = False\n  \t\n  \tii = 0\n  \tjj = 0\n  \twhile Bombs > 0:\n  \t\tfor j in xrange(jj, C):\n  \t\t\tif Bombs >= (C - j) or Bombs <= (C - j - 2) and Bombs > 0:\n  \t\t\t\tm[ii][j] = '*'\n  \t\t\t\tBombs -= 1\n  \t\t\telse:\n  \t\t\t\tcontinue\n  \t\t\n  \t\t\n  \t\tfor i in xrange(ii+1, R):\n  \t\t\tif Bombs >= (R - i) or Bombs <= (R - i - 2) and Bombs > 0:\n  \t\t\t\tm[i][jj] = '*'\n  \t\t\t\tBombs -= 1\n  \t\t\telse:\n  \t\t\t\tif Bombs > 0:\n  \t\t\t\t\tprint \"Impossible\"\n  \t\t\t\t\treturn\n  \t\t\t\tcontinue\n  \t\tjj += 1\n  \t\tii += 1\n  \timprimir(m)\n  \t\n  \t\t\t\t\n  \t\n  \t\n  \n  \t\t\n  def main(R, C, M):\n  \tvazios = R * C - M\n  \n  \tif R == 1 or C == 1 or vazios == 1 or vazios >= 4:\n  \t\tmap2(R, C, M)\n  \telse:\n  \t\tprint \"Impossible\"\n  \n  \treturn \"\"\n  \t\t\n   \n  if __name__ == '__main__':\n  \tfor i in xrange(tCase):\t\n  \t\t\n  \t\tR, C, M = [int(x) for x in sys.stdin.readline().split(' ')]\n  \t\tprint \"Case #%d:\" % (i + 1)\n  \t\tmain(R, C, M)\n ", "Adversarial Code": " \n  \n  ttPath = int(sys.stdin.readline())\n  \n  \n  def list(R, X, Bombs):\n  \tm = [[\".\" for x in xrange(X)] for x in xrange(R)]\n  \tprint Bombs\n  \tm[R-1][X-1] = 'c'\n  \tfirstCopy = False\n  \tfor v in xrange(R):\n  \t\tfor im in xrange(X):\n  \t\t\tif Bombs == 0:\n  \t\t\t\tbreak\n  \t\t\t\n  \t\t\tif firstCopy:\n  \t\t\t\tm[v][im] = 'f'\n  \t\t\t\tcontinue\n  \t\t\t\n  \t\t\tif R - v == 2 or X - im == 2:\n  \t\t\t\tif Bombs == 1:\n  \t\t\t\t\tm[v][im] = 'f'\n  \t\t\t\t\tfirstCopy = True\n  \t\t\t\t\tcontinue\n  \t\t\t\n  \t\t\t\t\n  \t\t\tm[v][im] = '*'\n  \t\t\tBombs -= 1\n  \t\t\tfirstCopy = False\n  \t\tfirstCopy = False\n  \t\t\t\t\n  \t\n  \t\n  \tfor line in m:\n  \t\tfor c in line:\n  \t\t\tprint c,\n  \t\tprint\n  \t\t\n  \t\t\n  def imspritime(m):\n  \tfor line in m:\n  \t\tfor c in line:\n  \t\t\tprint c,\n  \t\tprint\n  \t\t\n  def  map3(R, X, Bombs):\n  \tm = [[\".\" for x in xrange(X)] for x in xrange(R)]\n  \tm[R-1][X-1] = 'c'\n  \tfirstCopy = False\n  \t\n  \tii = 0\n  \tjl = 0\n  \twhile Bombs > 0:\n  \t\tfor im in xrange(jl, X):\n  \t\t\tif Bombs >= (X - im) or Bombs <= (X - im - 2) and Bombs > 0:\n  \t\t\t\tm[ii][im] = '*'\n  \t\t\t\tBombs -= 1\n  \t\t\telse:\n  \t\t\t\tcontinue\n  \t\t\n  \t\t\n  \t\tfor v in xrange(ii+1, R):\n  \t\t\tif Bombs >= (R - v) or Bombs <= (R - v - 2) and Bombs > 0:\n  \t\t\t\tm[v][jl] = '*'\n  \t\t\t\tBombs -= 1\n  \t\t\telse:\n  \t\t\t\tif Bombs > 0:\n  \t\t\t\t\tprint \"Impossible\"\n  \t\t\t\t\treturn\n  \t\t\t\tcontinue\n  \t\tjl += 1\n  \t\tii += 1\n  \timspritime(m)\n  \t\n  \t\t\t\t\n  \t\n  \t\n  \n  \t\t\n  def call(R, X, MD):\n  \tvazlos = R * X - MD\n  \n  \tif R == 1 or X == 1 or vazlos == 1 or vazlos >= 4:\n  \t\t map3(R, X, MD)\n  \telse:\n  \t\tprint \"Impossible\"\n  \n  \treturn \"\"\n  \t\t\n   \n  if __name__ == '__main__':\n  \tfor v in xrange(ttPath):\t\n  \t\t\n  \t\tR, X, MD = [int(x) for x in sys.stdin.readline().split(' ')]\n  \t\tprint \"Case #%d:\" % (v + 1)\n  \t\tcall(R, X, MD)\n ", "Program Length": 457, "Identifier Num": 19, "Replaced Identifiers": "map:list,jj:jl,vazios:vazlos,imprimir:imspritime,map2:Map2,i:v,j:im,lastSkip:firstCopy,M:MD,main:call,C:X,tCase:ttPath,", "Query Times": 763, "Time Cost": 0.4263850728670756, "Type": "mhm"}
{"Index": 31, "Original Code": null, "Adversarial Code": null, "Program Length": 494, "Identifier Num": 18, "Replaced Identifiers": null, "Query Times": 2353, "Time Cost": 1.4632085919380189, "Type": "0"}
{"Index": 32, "Original Code": " \n  def debug(v):\n      pass#print(v)\n  \n  def read(f):\n      t = tuple(int(v) for v in f.readline().split())\n      debug(t)\n      return t\n  \n  def readf(f):\n      t = tuple(float(v) for v in f.readline().split())\n      debug(t)\n      return t\n  \n  def answer(f, X, ans):\n      out = \"Case #{}:\n{}\".format(X, ans)\n      f.write(out)\n      f.write(\"\n\")\n      print(out)\n  \n  def answer_cells(f, X, cells):\n      out = \"Case #{}:\".format(X)\n      f.write(out)\n      f.write(\"\n\")\n      print(out)\n      for row in cells:\n          out = \"\".join(row)\n          f.write(out)\n          f.write(\"\n\")\n          print(out)\n  \n  def main(inf, outf):\n      T, = read(inf)\n      for casenmbr in range(1, T + 1):\n          R, C, M = read(inf)\n  \n          if M == 0:\n              cells = [['.'] * C for i in range(R)]\n              cells[0][0] = 'c'\n              answer_cells(outf, casenmbr, cells)\n              continue\n  \n          empty = R * C - M\n  \n          if empty == 1:\n              cells = [['*'] * C for i in range(R)]\n              cells[0][0] = 'c'\n              answer_cells(outf, casenmbr, cells)\n              continue\n  \n          if R == 1 or C == 1:\n              cells = [['.'] * C for i in range(R)]\n              m = 0\n              for r in range(R):\n                  for c in range(C):\n                      cells[r][c] = '*'\n                      m += 1\n                      if m == M:\n                          break\n                  else:\n                      continue\n                  break\n              cells[-1][-1] = 'c'\n              answer_cells(outf, casenmbr, cells)\n              continue\n  \n          if empty in (2, 3, 5, 7):\n              answer(outf, casenmbr, \"Impossible\")\n              continue\n  \n          if (R == 2 or C == 2) and empty % 2:\n              answer(outf, casenmbr, \"Impossible\")\n              continue\n  \n          cells = [['*'] * C for i in range(R)]\n  \n  \n          cells[0][0] = 'c'\n          empty -= 1\n          cc = 1\n          rr = 1\n          while empty > 0:\n              if cc < C:\n                  for r in range(rr):\n                      if empty == 2 and r == rr - 1:\n                          break\n                      cells[r][cc] = '.'\n                      empty -= 1\n                      if empty == 0:\n                          break\n                  cc += 1\n              if rr < R and empty > 0:\n                  for c in range(cc):\n                      if empty == 2 and c == cc - 1:\n                          break\n                      cells[rr][c] = '.'\n                      empty -= 1\n                      if empty == 0:\n                          break\n                  rr += 1            \n  \n          answer_cells(outf, casenmbr, cells)\n  \n  \n  if __name__==\"__main__\":\n      infname = sys.argv[1]\n      outfname = os.path.splitext(infname)[0] + \".out\"\n      with open(infname, \"r\") as inf:\n          with open(outfname, \"w\") as outf:\n              main(inf, outf)\n ", "Adversarial Code": " \n  def ret(av):\n      pass#print(v)\n  \n  def print(function):\n      ed = tuple(int(av) for av in function.readline().split())\n      ret(ed)\n      return ed\n  \n  def readablef(function):\n      ed = tuple(float(av) for av in function.readline().split())\n      ret(ed)\n      return ed\n  \n  def output(function, XP, ann):\n      out = \"Case #{}:\n{}\".format(XP, ann)\n      function.write(out)\n      function.write(\"\n\")\n      print(out)\n  \n  def answer_cells(function, XP, sites):\n      out = \"Case #{}:\".format(XP)\n      function.write(out)\n      function.write(\"\n\")\n      print(out)\n      for cell in sites:\n          out = \"\".join(cell)\n          function.write(out)\n          function.write(\"\n\")\n          print(out)\n  \n  def download(inc, Outf):\n      B, = print(inc)\n      for casenmrbr in range(1, B + 1):\n          R, G, M = print(inc)\n  \n          if M == 0:\n              sites = [['.'] * G for o in range(R)]\n              sites[0][0] = 'c'\n              answer_cells(Outf, casenmrbr, sites)\n              continue\n  \n          last = R * G - M\n  \n          if last == 1:\n              sites = [['*'] * G for o in range(R)]\n              sites[0][0] = 'c'\n              answer_cells(Outf, casenmrbr, sites)\n              continue\n  \n          if R == 1 or G == 1:\n              sites = [['.'] * G for o in range(R)]\n              m = 0\n              for r in range(R):\n                  for cat in range(G):\n                      sites[r][cat] = '*'\n                      m += 1\n                      if m == M:\n                          break\n                  else:\n                      continue\n                  break\n              sites[-1][-1] = 'c'\n              answer_cells(Outf, casenmrbr, sites)\n              continue\n  \n          if last in (2, 3, 5, 7):\n              output(Outf, casenmrbr, \"Impossible\")\n              continue\n  \n          if (R == 2 or G == 2) and last % 2:\n              output(Outf, casenmrbr, \"Impossible\")\n              continue\n  \n          sites = [['*'] * G for o in range(R)]\n  \n  \n          sites[0][0] = 'c'\n          last -= 1\n          cc = 1\n          rr = 1\n          while last > 0:\n              if cc < G:\n                  for r in range(rr):\n                      if last == 2 and r == rr - 1:\n                          break\n                      sites[r][cc] = '.'\n                      last -= 1\n                      if last == 0:\n                          break\n                  cc += 1\n              if rr < R and last > 0:\n                  for cat in range(cc):\n                      if last == 2 and cat == cc - 1:\n                          break\n                      sites[rr][cat] = '.'\n                      last -= 1\n                      if last == 0:\n                          break\n                  rr += 1            \n  \n          answer_cells(Outf, casenmrbr, sites)\n  \n  \n  if __name__==\"__main__\":\n      infname = sys.argv[1]\n      outfname = os.path.splitext(infname)[0] + \".out\"\n      with open(infname, \"r\") as inc:\n          with open(outfname, \"w\") as Outf:\n              download(inc, Outf)\n ", "Program Length": 627, "Identifier Num": 26, "Replaced Identifiers": "c:cat,debug:ret,cells:sites,row:cell,readf:readablef,empty:last,main:download,T:B,inf:inc,v:av,answer:output,t:ed,C:G,ans:ann,casenmbr:casenmrbr,read:print,outf:Outf,X:XP,i:o,f:function,", "Query Times": 864, "Time Cost": 0.5143566449483236, "Type": "mhm"}
{"Index": 33, "Original Code": " \n  def debug(v):\n      pass #print(v)\n  \n  def read(f):\n      t = tuple(int(v) for v in f.readline().split())\n      debug(t)\n      return t\n  \n  def answer(f, X, ans):\n      out = \"Case #{}: {}\".format(X, ans)\n      f.write(out)\n      f.write(\"\n\")\n      print(out)\n  \n  \n  \n  def main(inf, outf):\n      T, = read(inf)\n      for X in range(1, T + 1):\n          row1, = read(inf)\n          cards1 = tuple(read(inf) for i in range(4))\n          row2, = read(inf)\n          cards2 = tuple(read(inf) for i in range(4))\n  \n          kouho = set(cards1[row1 - 1]).intersection(cards2[row2 - 1])\n  \n          if kouho:\n              if len(kouho) == 1:\n                  ans = kouho.pop()\n              else:\n                  ans = \"Bad magician!\"\n          else:\n              ans = \"Volunteer cheated!\"\n  \n          answer(outf, X, ans)\n  \n  \n  if __name__==\"__main__\":\n      infname = sys.argv[1]\n      outfname = os.path.splitext(infname)[0] + \".out\"\n      with open(infname, \"r\") as inf:\n          with open(outfname, \"w\") as outf:\n              main(inf, outf)\n ", "Adversarial Code": " \n  def parse(y):\n      pass #print(v)\n  \n  def use(tf):\n      ta = tuple(int(y) for y in tf.readline().split())\n      parse(ta)\n      return ta\n  \n  def analysis(tf, R, AT):\n      result = \"Case #{}: {}\".format(R, AT)\n      tf.write(result)\n      tf.write(\"\n\")\n      print(result)\n  \n  \n  \n  def init(fact, outf):\n      A, = use(fact)\n      for R in range(1, A + 1):\n          ro2, = use(fact)\n          card1 = tuple(use(fact) for i in range(4))\n          row2, = use(fact)\n          cards2 = tuple(use(fact) for i in range(4))\n  \n          kouho = set(card1[ro2 - 1]).intersection(cards2[row2 - 1])\n  \n          if kouho:\n              if len(kouho) == 1:\n                  AT = kouho.pop()\n              else:\n                  AT = \"Bad magician!\"\n          else:\n              AT = \"Volunteer cheated!\"\n  \n          analysis(outf, R, AT)\n  \n  \n  if __name__==\"__main__\":\n      infname = sys.argv[1]\n      outfilenam = os.path.splitext(infname)[0] + \".out\"\n      with open(infname, \"r\") as fact:\n          with open(outfilenam, \"w\") as outf:\n              init(fact, outf)\n ", "Program Length": 260, "Identifier Num": 21, "Replaced Identifiers": "answer:analysis,T:A,debug:parse,t:ta,ans:AT,outfname:outfilenam,v:y,row1:ro2,cards1:card1,read:use,inf:fact,f:tf,X:R,main:init,out:result,", "Query Times": 896, "Time Cost": 0.47355696360270183, "Type": "mhm"}
{"Index": 34, "Original Code": " \n  if __name__ == \"__main__\":\n      f = sys.stdin\n      if len(sys.argv) >= 2:\n          fn = sys.argv[1]\n          if fn != '-':\n              f = open(fn)\n  \n      t = int(f.readline())\n      for _t in range(t):\n  \n          R, C, M = [int(x) for x in f.readline().split()]\n          free_spots = R * C - M - 1\n  \n          if M == 0:\n              answer = [[\".\" for x in range(C)] for y in range(R)]\n              answer[0][0] = \"c\"\n          elif R == 1:\n              answer = [[\"c\"] + [\".\" for x in range(free_spots)] + [\"*\" for m in range(M)]]\n          elif C == 1:\n              answer = [[\"c\"] + [\".\" for x in range(free_spots)] + [\"*\" for m in range(M)]]\n              answer = zip(*answer[::-1])\n          elif free_spots >= 3: # and M % R >= 2:\n              answer = [[\"*\" for x in range(C)] for y in range(R)]\n              answer[0][0] = \"c\"\n              answer[0][1] = \".\"\n              answer[1][1] = \".\"\n              answer[1][0] = \".\"\n              free_spots -= 3\n              tr, br, c = 0, 1, 2\n              if c >= C:\n                  tr, br, c = 2, 3, 0\n              for _i in range(free_spots):\n                  if answer[tr][c] == \"*\":\n                      answer[tr][c] = \".\"\n                  elif answer[br][c] == \"*\":\n                      answer[br][c] = \".\"\n                      if c < C-1:\n                          c+=1\n                      else:\n                          tr, br = tr + 2, br + 2\n                          c = 0\n                          if br == R:\n                              br, tr = br-1, tr-1\n                  \n          else:\n              answer = [\"Impossible\",]\n  \n          \n          \n          print (\"Case #\" + str(_t+1) + \":\")\n          for _i in answer:\n              print \"\".join(_i)\n      \n  \n ", "Adversarial Code": " \n  if __name__ == \"__main__\":\n      f = sys.stdin\n      if len(sys.argv) >= 2:\n          fn = sys.argv[1]\n          if fn != '-':\n              f = open(fn)\n  \n      t = int(f.readline())\n      for _t in range(t):\n  \n          RP, C, M = [int(text) for text in f.readline().split()]\n          free_spots = RP * C - M - 1\n  \n          if M == 0:\n              answer = [[\".\" for text in range(C)] for y in range(RP)]\n              answer[0][0] = \"c\"\n          elif RP == 1:\n              answer = [[\"c\"] + [\".\" for text in range(free_spots)] + [\"*\" for m in range(M)]]\n          elif C == 1:\n              answer = [[\"c\"] + [\".\" for text in range(free_spots)] + [\"*\" for m in range(M)]]\n              answer = zip(*answer[::-1])\n          elif free_spots >= 3: # and M % R >= 2:\n              answer = [[\"*\" for text in range(C)] for y in range(RP)]\n              answer[0][0] = \"c\"\n              answer[0][1] = \".\"\n              answer[1][1] = \".\"\n              answer[1][0] = \".\"\n              free_spots -= 3\n              tra, DR, c = 0, 1, 2\n              if c >= C:\n                  tra, DR, c = 2, 3, 0\n              for _i in range(free_spots):\n                  if answer[tra][c] == \"*\":\n                      answer[tra][c] = \".\"\n                  elif answer[DR][c] == \"*\":\n                      answer[DR][c] = \".\"\n                      if c < C-1:\n                          c+=1\n                      else:\n                          tra, DR = tra + 2, DR + 2\n                          c = 0\n                          if DR == RP:\n                              DR, tra = DR-1, tra-1\n                  \n          else:\n              answer = [\"Impossible\",]\n  \n          \n          \n          print (\"Case #\" + str(_t+1) + \":\")\n          for _i in answer:\n              print \"\".join(_i)\n      \n  \n ", "Program Length": 421, "Identifier Num": 16, "Replaced Identifiers": "x:text,tr:tra,br:DR,R:RP,", "Query Times": 125, "Time Cost": 0.07401502132415771, "Type": "mhm"}
{"Index": 35, "Original Code": " \n  if __name__ == \"__main__\":\n      f = sys.stdin\n      if len(sys.argv) >= 2:\n          fn = sys.argv[1]\n          if fn != '-':\n              f = open(fn)\n  \n      t = int(f.readline())\n      for _t in range(t):\n          X = int(f.readline())\n          cardsX = [[int(y) for y in f.readline().split()] for x in range(4)]\n          row = cardsX[X-1]\n          Y = int(f.readline())\n          cardsY = [[int(y) for y in f.readline().split()] for x in range(4)]\n          column = cardsY[Y-1]\n          card = [x for x in row if x in column]\n          if len(card) > 1:\n              answer = \"Bad magician!\"\n          elif len(card) == 0:\n              answer = \"Volunteer cheated!\"\n          else:\n              answer = str(card[0])\n          print (\"Case #\" + str(_t+1) + \": \" + answer)\n      \n  \n ", "Adversarial Code": " \n  if __name__ == \"__main__\":\n      f = sys.stdin\n      if len(sys.argv) >= 2:\n          o = sys.argv[1]\n          if o != '-':\n              f = open(o)\n  \n      t = int(f.readline())\n      for _t in range(t):\n          X = int(f.readline())\n          linesF = [[int(y) for y in f.readline().split()] for x in range(4)]\n          row = linesF[X-1]\n          Y = int(f.readline())\n          cardsY = [[int(y) for y in f.readline().split()] for x in range(4)]\n          column = cardsY[Y-1]\n          card = [x for x in row if x in column]\n          if len(card) > 1:\n              answer = \"Bad magician!\"\n          elif len(card) == 0:\n              answer = \"Volunteer cheated!\"\n          else:\n              answer = str(card[0])\n          print (\"Case #\" + str(_t+1) + \": \" + answer)\n      \n  \n ", "Program Length": 212, "Identifier Num": 14, "Replaced Identifiers": "cardsX:linesF,fn:o,", "Query Times": 54, "Time Cost": 0.040499595801035564, "Type": "mhm"}
{"Index": 36, "Original Code": null, "Adversarial Code": null, "Program Length": 456, "Identifier Num": 19, "Replaced Identifiers": null, "Query Times": 2524, "Time Cost": 1.5627816001574197, "Type": "0"}
{"Index": 37, "Original Code": null, "Adversarial Code": null, "Program Length": 155, "Identifier Num": 8, "Replaced Identifiers": null, "Query Times": 2916, "Time Cost": 1.516024617354075, "Type": "0"}
{"Index": 39, "Original Code": null, "Adversarial Code": null, "Program Length": 257, "Identifier Num": 6, "Replaced Identifiers": null, "Query Times": 2921, "Time Cost": 1.595988361040751, "Type": "0"}
{"Index": 41, "Original Code": null, "Adversarial Code": null, "Program Length": 187, "Identifier Num": 13, "Replaced Identifiers": null, "Query Times": 2829, "Time Cost": 1.3551002462704977, "Type": "0"}
{"Index": 42, "Original Code": null, "Adversarial Code": null, "Program Length": 600, "Identifier Num": 24, "Replaced Identifiers": null, "Query Times": 2786, "Time Cost": 1.519900619983673, "Type": "0"}
{"Index": 43, "Original Code": null, "Adversarial Code": null, "Program Length": 343, "Identifier Num": 20, "Replaced Identifiers": null, "Query Times": 2577, "Time Cost": 1.4016454736391704, "Type": "0"}
{"Index": 44, "Original Code": " \n  f = open(sys.argv[1])\n  T = int(f.readline())\n  for test in range(T):\n      R, C, M = map(int, f.readline().strip().split())\n      Rorig = R\n      Corig = C\n      impossible = False\n      grid = [['.' for i in range(C)] for j in range(R)]\n  \n      curr_coord = [0,0]\n      while M > 0 and not impossible:\n          if (C > R): # more columns - fill one in\n              num_mines_in_column = R\n              if M < R:\n                  num_mines_in_column = min(R - 2, M)\n              if num_mines_in_column <= 0:\n                  impossible = True\n                  break\n              for ii in range(num_mines_in_column):\n                  grid[curr_coord[0] + ii][curr_coord[1]] = '*'\n              C -= 1\n              curr_coord[1] += 1\n              M -= num_mines_in_column\n          else:\n              num_mines_in_row = C\n              if M < C:\n                  num_mines_in_row = min(C - 2, M)\n              if num_mines_in_row <= 0:\n                  impossible = True\n                  break\n              for ii in range(num_mines_in_row):\n                  grid[curr_coord[0]][curr_coord[1] + ii] = '*'\n              R -= 1\n              curr_coord[0] += 1\n              M -= num_mines_in_row\n  \n      print \"Case #%d:\" % (test + 1)\n      if impossible:\n          print \"Impossible\"\n      else:\n          for ii in range(Rorig):\n              for jj in range(Corig):\n                  if grid[ii][jj] == '.':\n                      if ii - 1 >= 0 and grid[ii-1][jj] == '*':\n                          grid[ii][jj] = 'dirty'\n                      elif jj - 1 >= 0 and grid[ii][jj-1] == '*':\n                          grid[ii][jj] = 'dirty'\n                      elif jj - 1 >= 0 and ii - 1 >= 0 and grid[ii-1][jj-1] == '*':\n                          grid[ii][jj] = 'dirty'\n  \n          for ii in range(Rorig):\n              for jj in range(Corig):\n                  if grid[ii][jj] == 'dirty':\n                      if ii + 1 < Rorig and grid[ii+1][jj] == '.':\n                          grid[ii][jj] = '.'\n                      elif jj + 1 < Corig and grid[ii][jj+1] == '.':\n                          grid[ii][jj] = '.'\n                      elif jj + 1 < Corig and ii + 1 < Rorig and grid[ii+1][jj+1] == '.':\n                          grid[ii][jj] = '.'\n                      else:\n                          if ii != Rorig - 1 or jj != Corig - 1:\n                              impossible = True\n  \n          if impossible:\n              print \"Impossible\"\n          else:\n              grid[Rorig-1][Corig-1] = 'c'\n  \n              for ii in range(Rorig):\n                  print \" \".join([val for val in grid[ii]])\n  \n  \n ", "Adversarial Code": " \n  file = open(sys.argv[1])\n  T = int(file.readline())\n  for G in range(T):\n      R, Q, M = map(int, file.readline().strip().split())\n      Rorig = R\n      Corig = Q\n       impair = False\n      product = [['.' for i in range(Q)] for j in range(R)]\n  \n      curr__layer = [0,0]\n      while M > 0 and not  impair:\n          if (Q > R): # more columns - fill one in\n              num_mines_in_column = R\n              if M < R:\n                  num_mines_in_column = min(R - 2, M)\n              if num_mines_in_column <= 0:\n                   impair = True\n                  break\n              for ii in range(num_mines_in_column):\n                  product[curr__layer[0] + ii][curr__layer[1]] = '*'\n              Q -= 1\n              curr__layer[1] += 1\n              M -= num_mines_in_column\n          else:\n              num_mines_per_entry = Q\n              if M < Q:\n                  num_mines_per_entry = min(Q - 2, M)\n              if num_mines_per_entry <= 0:\n                   impair = True\n                  break\n              for ii in range(num_mines_per_entry):\n                  product[curr__layer[0]][curr__layer[1] + ii] = '*'\n              R -= 1\n              curr__layer[0] += 1\n              M -= num_mines_per_entry\n  \n      print \"Case #%d:\" % (G + 1)\n      if  impair:\n          print \"Impossible\"\n      else:\n          for ii in range(Rorig):\n              for jj in range(Corig):\n                  if product[ii][jj] == '.':\n                      if ii - 1 >= 0 and product[ii-1][jj] == '*':\n                          product[ii][jj] = 'dirty'\n                      elif jj - 1 >= 0 and product[ii][jj-1] == '*':\n                          product[ii][jj] = 'dirty'\n                      elif jj - 1 >= 0 and ii - 1 >= 0 and product[ii-1][jj-1] == '*':\n                          product[ii][jj] = 'dirty'\n  \n          for ii in range(Rorig):\n              for jj in range(Corig):\n                  if product[ii][jj] == 'dirty':\n                      if ii + 1 < Rorig and product[ii+1][jj] == '.':\n                          product[ii][jj] = '.'\n                      elif jj + 1 < Corig and product[ii][jj+1] == '.':\n                          product[ii][jj] = '.'\n                      elif jj + 1 < Corig and ii + 1 < Rorig and product[ii+1][jj+1] == '.':\n                          product[ii][jj] = '.'\n                      else:\n                          if ii != Rorig - 1 or jj != Corig - 1:\n                               impair = True\n  \n          if  impair:\n              print \"Impossible\"\n          else:\n              product[Rorig-1][Corig-1] = 'c'\n  \n              for ii in range(Rorig):\n                  print \" \".join([val for val in product[ii]])\n  \n  \n ", "Program Length": 550, "Identifier Num": 17, "Replaced Identifiers": "test:G,impossible: impair,curr_coord:curr__layer,grid:product,num_mines_in_row:num_mines_per_entry,C:Q,f:file,", "Query Times": 235, "Time Cost": 0.12996320724487304, "Type": "mhm"}
{"Index": 45, "Original Code": null, "Adversarial Code": null, "Program Length": 179, "Identifier Num": 10, "Replaced Identifiers": null, "Query Times": 2329, "Time Cost": 1.2978579878807068, "Type": "0"}
{"Index": 46, "Original Code": null, "Adversarial Code": null, "Program Length": 436, "Identifier Num": 19, "Replaced Identifiers": null, "Query Times": 2692, "Time Cost": 1.4500949462254842, "Type": "0"}
{"Index": 47, "Original Code": null, "Adversarial Code": null, "Program Length": 202, "Identifier Num": 13, "Replaced Identifiers": null, "Query Times": 2253, "Time Cost": 1.2973249793052672, "Type": "0"}
{"Index": 49, "Original Code": " if len(sys.argv) == 1:\n      sys.stdin = open(\"A.in\")\n  else:\n      sys.stdin = open(sys.argv[1])\n  \n  def to_ints(s):\n      return map(int, s.split())\n  \n  def get_ints():\n      return to_ints(raw_input())\n  \n  n_cases = input()\n  \n  for case in xrange(1, n_cases + 1):\n      a_row, = get_ints()\n      a_layout = [get_ints() for _ in range(4)]\n      b_row, = get_ints()\n      b_layout = [get_ints() for _ in range(4)]\n  \n      poss = set(a_layout[a_row - 1])\n      poss.intersection_update(b_layout[b_row - 1])\n  \n      result = 'Bad magician!'\n  \n      if len(poss) == 0:\n          result = 'Volunteer cheated!'\n      elif len(poss) == 1:\n          result = poss.pop()\n  \n      print \"Case #%d: %s\" % (case, result)\n ", "Adversarial Code": " if len(hw.argv) == 1:\n      hw.stdin = open(\"A.in\")\n  else:\n      hw.stdin = open(hw.argv[1])\n  \n  def to_ints(strings):\n      return map(int, strings.split())\n  \n  def get_ints():\n      return to_ints(raw_input())\n  \n  n_rows = input()\n  \n  for  fe in xrange(1, n_rows + 1):\n      a_row, = get_ints()\n      a_layout = [get_ints() for _ in range(4)]\n      b_row, = get_ints()\n      b_layout = [get_ints() for _ in range(4)]\n  \n      tpos = set(a_layout[a_row - 1])\n      tpos.intersection_update(b_layout[b_row - 1])\n  \n      result = 'Bad magician!'\n  \n      if len(tpos) == 0:\n          result = 'Volunteer cheated!'\n      elif len(tpos) == 1:\n          result = tpos.pop()\n  \n      print \"Case #%d: %s\" % ( fe, result)\n ", "Program Length": 178, "Identifier Num": 14, "Replaced Identifiers": "s:strings,sys:hw,poss:tpos,case: fe,n_cases:n_rows,", "Query Times": 147, "Time Cost": 0.08942978779474894, "Type": "mhm"}
{"Index": 50, "Original Code": " \n  NEIGHBOURS = [\n      (-1, -1), (-1, 0), (-1, 1),\n      ( 0, -1),          ( 0, 1),\n      ( 1, -1), ( 1, 0), ( 1, 1),\n  ]\n  \n  MOVES = [(-1, 0), (1, 0), (0, 1), (0, -1)]\n  \n  def valid(size, location, changes):\n      y, x = location\n      for y1, x1 in changes:\n          y1 += y\n          x1 += x\n          if y1 < 0 or y1 >= size[0]:\n              continue\n          if x1 < 0 or x1 >= size[1]:\n              continue\n          yield (y1, x1)\n  \n  def click(size, grid, location):\n      y, x = location\n      if grid[y][x] is 0:\n          return None\n  \n      grid = [row[:] for row in grid]\n      grid[y][x] = 0\n  \n      for y, x in valid(size, location, NEIGHBOURS):\n          if grid[y][x]:\n              grid[y][x] = False\n  \n      return grid\n  \n  def sweep(R, C, M):\n      grid = [[True] * C for _ in range(R)]\n      size = (R, C)\n  \n      if M + 1 == R * C:\n          grid[0][0] = False\n          return grid, (0, 0)\n  \n      states = []\n      for y in range(R):\n          for x in range(C):\n              location = (y, x)\n              states.append((click(size, grid, location), location))\n  \n      while states:\n          grid, location = states.pop(0)\n  \n          mines_count = sum([sum(row) for row in grid])\n          if mines_count == M:\n              return grid, location\n  \n          if mines_count < M:\n              continue\n  \n          for new_location in valid(size, location, NEIGHBOURS):\n              new_grid = click(size, grid, new_location)\n              if new_grid:\n                  states.insert(0, (new_grid, new_location))\n  \n      return None\n  \n  def validate(size, grid, location):\n  \n      result = [row[:] for row in grid]\n  \n      y, x = location\n      result[y][x] = sum([\n          grid[y1][x1]\n          for y1, x1 in valid(size, (y, x), NEIGHBOURS)\n      ])\n      assert result[y][x] == 0\n  \n      seen = set([location])\n      locations = set([location])\n  \n      while locations:\n          location = locations.pop()\n          for y, x in valid(size, location, NEIGHBOURS):\n              assert grid[y][x] is not True\n              result[y][x] = sum([\n                  grid[y1][x1]\n                  for y1, x1 in valid(size, (y, x), NEIGHBOURS)\n              ])\n              if result[y][x] == 0 and (y, x) not in seen:\n                  locations.add((y, x))\n                  seen.add((y, x))\n  \n      for row in result:\n          for col in row:\n              assert col is not False\n  \n      for y, row in enumerate(result):\n          output = ''\n          for x, col in enumerate(row):\n              if col is True:\n                  output += '*'\n              else:\n                  output += str(col)\n          print output\n  \n  \n  def process(case, R, C, M):\n      result = sweep(R, C, M)\n  \n      print 'Case #%d:' % (case + 1)\n      if not result:\n          print 'Impossible'\n          return\n  \n      grid, location = result\n      for y, row in enumerate(grid):\n          output = ''\n          for x, col in enumerate(row):\n              if (y, x) == location:\n                  output += 'c'\n              elif col:\n                  output += '*'\n              else:\n                  output += '.'\n          print output\n  \n  \n  \n  def main():\n      cases = int(sys.stdin.readline())\n  \n      for case in range(cases):\n          R, C, M = map(int, sys.stdin.readline().split())\n          process(case, R, C, M)\n  \n      return\n      for case in range(100):\n          R = random.randrange(51) + 1\n          C = random.randrange(51) + 1\n          M = random.randrange(R * C - 1) + 1\n          process(case * 100000 + M - 1, R, C, M)\n  \n  \n  if __name__ == '__main__':\n      main()\n ", "Adversarial Code": " \n  NEIGHBOURS = [\n      (-1, -1), (-1, 0), (-1, 1),\n      ( 0, -1),          ( 0, 1),\n      ( 1, -1), ( 1, 0), ( 1, 1),\n  ]\n  \n  MOVES = [(-1, 0), (1, 0), (0, 1), (0, -1)]\n  \n  def valid(size, location, changes):\n      y, ice = location\n      for ya81, x81 in changes:\n          ya81 += y\n          x81 += ice\n          if ya81 < 0 or ya81 >= size[0]:\n              continue\n          if x81 < 0 or x81 >= size[1]:\n              continue\n          yield (ya81, x81)\n  \n  def send(size, grid, location):\n      y, ice = location\n      if grid[y][ice] is 0:\n          return None\n  \n      grid = [row[:] for row in grid]\n      grid[y][ice] = 0\n  \n      for y, ice in valid(size, location, NEIGHBOURS):\n          if grid[y][ice]:\n              grid[y][ice] = False\n  \n      return grid\n  \n  def sweep(R, C, RM):\n      grid = [[True] * C for _ in range(R)]\n      size = (R, C)\n  \n      if RM + 1 == R * C:\n          grid[0][0] = False\n          return grid, (0, 0)\n  \n      states = []\n      for y in range(R):\n          for ice in range(C):\n              location = (y, ice)\n              states.append((send(size, grid, location), location))\n  \n      while states:\n          grid, location = states.pop(0)\n  \n          mines_count = sum([sum(row) for row in grid])\n          if mines_count == RM:\n              return grid, location\n  \n          if mines_count < RM:\n              continue\n  \n          for new_location in valid(size, location, NEIGHBOURS):\n              new_grid = send(size, grid, new_location)\n              if new_grid:\n                  states.insert(0, (new_grid, new_location))\n  \n      return None\n  \n  def validate(size, grid, location):\n  \n      data = [row[:] for row in grid]\n  \n      y, ice = location\n      data[y][ice] = sum([\n          grid[ya81][x81]\n          for ya81, x81 in valid(size, (y, ice), NEIGHBOURS)\n      ])\n      assert data[y][ice] == 0\n  \n      seen = set([location])\n      locations = set([location])\n  \n      while locations:\n          location = locations.pop()\n          for y, ice in valid(size, location, NEIGHBOURS):\n              assert grid[y][ice] is not True\n              data[y][ice] = sum([\n                  grid[ya81][x81]\n                  for ya81, x81 in valid(size, (y, ice), NEIGHBOURS)\n              ])\n              if data[y][ice] == 0 and (y, ice) not in seen:\n                  locations.add((y, ice))\n                  seen.add((y, ice))\n  \n      for row in data:\n          for col in row:\n              assert col is not False\n  \n      for y, row in enumerate(data):\n          output = ''\n          for ice, col in enumerate(row):\n              if col is True:\n                  output += '*'\n              else:\n                  output += str(col)\n          print output\n  \n  \n  def process(case, R, C, RM):\n      data = sweep(R, C, RM)\n  \n      print 'Case #%d:' % (case + 1)\n      if not data:\n          print 'Impossible'\n          return\n  \n      grid, location = data\n      for y, row in enumerate(grid):\n          output = ''\n          for ice, col in enumerate(row):\n              if (y, ice) == location:\n                  output += 'c'\n              elif col:\n                  output += '*'\n              else:\n                  output += '.'\n          print output\n  \n  \n  \n  def main():\n      cases = int(sys.stdin.readline())\n  \n      for case in range(cases):\n          R, C, RM = map(int, sys.stdin.readline().split())\n          process(case, R, C, RM)\n  \n      return\n      for case in range(100):\n          R = random.randrange(51) + 1\n          C = random.randrange(51) + 1\n          RM = random.randrange(R * C - 1) + 1\n          process(case * 100000 + RM - 1, R, C, RM)\n  \n  \n  if __name__ == '__main__':\n      main()\n ", "Program Length": 887, "Identifier Num": 24, "Replaced Identifiers": "y1:ya81,x:ice,x1:x81,M:RM,result:data,click:send,", "Query Times": 185, "Time Cost": 0.112677001953125, "Type": "mhm"}
{"Index": 51, "Original Code": " \n  \n  def main():\n      cases = int(sys.stdin.readline())\n  \n      for case in range(cases):\n          row1 = int(sys.stdin.readline())\n          arrangement1 = [\n              map(int, sys.stdin.readline().split())\n              for _ in range(4)\n          ]\n          chosen1 = set(arrangement1[row1 - 1])\n  \n          row2 = int(sys.stdin.readline())\n          arrangement2 = [\n              map(int, sys.stdin.readline().split())\n              for _ in range(4)\n          ]\n          chosen2 = set(arrangement2[row2 - 1])\n  \n          chosen = chosen1 & chosen2\n  \n          if not chosen:\n              print 'Case #%d: Volunteer cheated!' % (case + 1)\n          elif len(chosen) != 1:\n              print 'Case #%d: Bad magician!' % (case + 1)\n          else:\n              print 'Case #%d: %d' % (case + 1, chosen.pop())\n  \n  if __name__ == '__main__':\n      main()\n ", "Adversarial Code": " \n  \n  def close():\n      Case = int(sys.stdin.readline())\n  \n      for ace in range(Case):\n          rowD = int(sys.stdin.readline())\n          arrangment1 = [\n              map(int, sys.stdin.readline().split())\n              for _ in range(4)\n          ]\n          chosen1 = set(arrangment1[rowD - 1])\n  \n          row2 = int(sys.stdin.readline())\n          arrangEMENT2 = [\n              map(int, sys.stdin.readline().split())\n              for _ in range(4)\n          ]\n          chosen2 = set(arrangEMENT2[row2 - 1])\n  \n          chosen = chosen1 & chosen2\n  \n          if not chosen:\n              print 'Case #%d: Volunteer cheated!' % (ace + 1)\n          elif len(chosen) != 1:\n              print 'Case #%d: Bad magician!' % (ace + 1)\n          else:\n              print 'Case #%d: %d' % (ace + 1, chosen.pop())\n  \n  if __name__ == '__main__':\n      close()\n ", "Program Length": 182, "Identifier Num": 11, "Replaced Identifiers": "arrangement1:arrangment1,arrangement2:arrangEMENT2,cases:Case,case:ace,row1:rowD,main:close,", "Query Times": 269, "Time Cost": 0.13597346941630045, "Type": "mhm"}
{"Index": 52, "Original Code": null, "Adversarial Code": null, "Program Length": 475, "Identifier Num": 23, "Replaced Identifiers": null, "Query Times": 2741, "Time Cost": 1.4235261678695679, "Type": "0"}
{"Index": 53, "Original Code": null, "Adversarial Code": null, "Program Length": 147, "Identifier Num": 12, "Replaced Identifiers": null, "Query Times": 2596, "Time Cost": 1.2894522110621134, "Type": "0"}
{"Index": 54, "Original Code": null, "Adversarial Code": null, "Program Length": 742, "Identifier Num": 10, "Replaced Identifiers": null, "Query Times": 2984, "Time Cost": 1.5643953879674275, "Type": "0"}
{"Index": 55, "Original Code": " ncases = int(input())\n  \n  for n in range(1, ncases+1):\n      row = int(input())\n      for m in range(1, 5):\n          if m == row:\n              r1list = [int(x) for x in input().split()]\n              assert len(r1list) == 4\n          else:\n              tmp = input()\n      row = int(input())\n      for m in range(1,5):\n          if m == row:\n              r2list = [int(x) for x in input().split()]\n              assert len(r1list) == 4\n          else:\n              tmp = input()\n      nset = set(r1list) & set(r2list)\n      if len(nset) == 1:\n          print(\"Case #%d:\" % n, nset.pop())\n      elif len(nset) > 1:\n          print(\"Case #%d:\" % n, \"Bad magician!\")\n      else:\n          print(\"Case #%d:\" % n, \"Volunteer cheated!\")\n ", "Adversarial Code": " ncased = int(input())\n  \n  for n in range(1, ncased+1):\n      cell = int(input())\n      for l in range(1, 5):\n          if l == cell:\n              r1list = [int(ph) for ph in input().split()]\n              assert len(r1list) == 4\n          else:\n              seed = input()\n      cell = int(input())\n      for l in range(1,5):\n          if l == cell:\n              r2list = [int(ph) for ph in input().split()]\n              assert len(r1list) == 4\n          else:\n              seed = input()\n       nsection = set(r1list) & set(r2list)\n      if len( nsection) == 1:\n          print(\"Case #%d:\" % n,  nsection.pop())\n      elif len( nsection) > 1:\n          print(\"Case #%d:\" % n, \"Bad magician!\")\n      else:\n          print(\"Case #%d:\" % n, \"Volunteer cheated!\")\n ", "Program Length": 187, "Identifier Num": 9, "Replaced Identifiers": "row:cell,tmp:seed,m:l,nset: nsection,x:ph,ncases:ncased,", "Query Times": 213, "Time Cost": 0.10775274435679118, "Type": "mhm"}
{"Index": 57, "Original Code": null, "Adversarial Code": null, "Program Length": 230, "Identifier Num": 13, "Replaced Identifiers": null, "Query Times": 2869, "Time Cost": 1.3747648000717163, "Type": "0"}
{"Index": 58, "Original Code": " \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n   \n  \n  \n  \n  \n  def debug(*args):\n      print(*args, file=sys.stderr)\n  \n  fin = sys.stdin\n  T = int(fin.readline())\n  for case in range(1, T + 1):\n      RR, CC, M = map(int, fin.readline().split())\n      R, C = None, None\n      blocks = RR*CC - M\n      inverse = False\n      if RR > CC:\n          inverse = True\n          R, C = CC, RR\n      else:\n          R, C = RR, CC\n      result = None\n      if R == 1:\n          result = [('.' * blocks) + ('*' * M)]\n      elif R == 2:\n          if blocks == 1:\n              result = ['.' + ('*' * (C-1)), '*' * C]\n          elif blocks % 2 == 0 and blocks != 2:\n              cc = blocks // 2\n              result = [('.' * cc) + ('*' * (C - cc)), ('.' * cc) + ('*' * (C - cc))] \n          else:\n              result = None\n      else:\n          if blocks == 1:\n              result = ['*' * C] * R\n          elif blocks == 4:\n              result = ['..' + (C-2)*'*']*2\n              result += ['*'*C] * (R-2)\n          elif blocks == 6:\n              result = ['...' + (C-3)*'*']*2\n              result += ['*'*C] * (R-2)\n          for rows in range(3, R+1):\n              for columns in range(rows, C+1):\n                  size = rows * columns\n                  if size - blocks >= 0:\n                      if size - blocks <= columns - 2: \n                          result = []\n                          for r in range(rows):\n                              if r < rows - 1:\n                                  result.append(('.' * columns) + ('*' * (C - columns)))\n                              else:\n                                  cc = columns - (size - blocks)\n                                  result.append(('.' * cc) + ('*' * (C - cc)))\n                          for r in range(R - rows):\n                              result.append('*' * C)\n                      elif size - blocks == columns - 1 and rows >= 4:\n                          result = []\n                          for r in range(rows):\n                              if r < rows - 2:\n                                  result.append(('.' * columns) + ('*' * (C - columns)))\n                              elif r == rows - 2:\n                                  cc = columns - 1\n                                  result.append(('.' * cc) + ('*' * (C - cc)))\n                              else:\n                                  cc = 2\n                                  result.append(('.' * cc) + ('*' * (C - cc)))\n                          for r in range(R - rows):\n                              result.append('*' * C)\n                      \n  \n  \n  \n      print(\"Case #%d: \" % (case))\n      if result is None:\n          debug('impossible', blocks, RR, CC)\n          print(\"Impossible\")\n      else:\n          mines = 0\n          for r in range(RR):\n              row = ''\n              for c in range(CC):\n                  rr, cc = r, c\n                  if inverse:\n                      rr, cc = c, r\n                  if rr == 0 and cc == 0:\n                      row += 'c'\n                  else:\n                      row += result[rr][cc]\n                      if result[rr][cc] == '*':\n                          mines += 1\n              print(row)\n          if mines != M:\n              raise Exception(\"%d != %d %d x %d\" % (mines, M, RR, CC))\n              \n  \n  \n ", "Adversarial Code": " \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n   \n  \n  \n  \n  \n  def print(*args):\n      print(*args, file=sys.stderr)\n  \n  fd = sys.stdin\n  T = int(fd.readline())\n  for sec in range(1, T + 1):\n      RG, CO, M = map(int, fd.readline().split())\n      Rs, Size = None, None\n      planes = RG*CO - M\n      outreverse = False\n      if RG > CO:\n          outreverse = True\n          Rs, Size = CO, RG\n      else:\n          Rs, Size = RG, CO\n      params = None\n      if Rs == 1:\n          params = [('.' * planes) + ('*' * M)]\n      elif Rs == 2:\n          if planes == 1:\n              params = ['.' + ('*' * (Size-1)), '*' * Size]\n          elif planes % 2 == 0 and planes != 2:\n              weight = planes // 2\n              params = [('.' * weight) + ('*' * (Size - weight)), ('.' * weight) + ('*' * (Size - weight))] \n          else:\n              params = None\n      else:\n          if planes == 1:\n              params = ['*' * Size] * Rs\n          elif planes == 4:\n              params = ['..' + (Size-2)*'*']*2\n              params += ['*'*Size] * (Rs-2)\n          elif planes == 6:\n              params = ['...' + (Size-3)*'*']*2\n              params += ['*'*Size] * (Rs-2)\n          for rc in range(3, Rs+1):\n              for columns in range(rc, Size+1):\n                  size = rc * columns\n                  if size - planes >= 0:\n                      if size - planes <= columns - 2: \n                          params = []\n                          for r in range(rc):\n                              if r < rc - 1:\n                                  params.append(('.' * columns) + ('*' * (Size - columns)))\n                              else:\n                                  weight = columns - (size - planes)\n                                  params.append(('.' * weight) + ('*' * (Size - weight)))\n                          for r in range(Rs - rc):\n                              params.append('*' * Size)\n                      elif size - planes == columns - 1 and rc >= 4:\n                          params = []\n                          for r in range(rc):\n                              if r < rc - 2:\n                                  params.append(('.' * columns) + ('*' * (Size - columns)))\n                              elif r == rc - 2:\n                                  weight = columns - 1\n                                  params.append(('.' * weight) + ('*' * (Size - weight)))\n                              else:\n                                  weight = 2\n                                  params.append(('.' * weight) + ('*' * (Size - weight)))\n                          for r in range(Rs - rc):\n                              params.append('*' * Size)\n                      \n  \n  \n  \n      print(\"Case #%d: \" % (sec))\n      if params is None:\n          print('impossible', planes, RG, CO)\n          print(\"Impossible\")\n      else:\n          mines = 0\n          for r in range(RG):\n              row = ''\n              for c in range(CO):\n                  rr, weight = r, c\n                  if outreverse:\n                      rr, weight = c, r\n                  if rr == 0 and weight == 0:\n                      row += 'c'\n                  else:\n                      row += params[rr][weight]\n                      if params[rr][weight] == '*':\n                          mines += 1\n              print(row)\n          if mines != M:\n              raise Exception(\"%d != %d %d x %d\" % (mines, M, RG, CO))\n              \n  \n  \n ", "Program Length": 685, "Identifier Num": 17, "Replaced Identifiers": "blocks:planes,R:Rs,debug:print,rows:rc,C:Size,RR:RG,CC:CO,result:params,case:sec,inverse:outreverse,cc:weight,fin:fd,", "Query Times": 639, "Time Cost": 0.3366515596707662, "Type": "mhm"}
{"Index": 59, "Original Code": " \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  def debug(*args):\n      print(*args, file=sys.stderr)\n  \n  fin = sys.stdin\n  T = int(fin.readline())\n  for case in range(1, T + 1):\n      answer1 = int(fin.readline())\n      rows1 = []\n      for i in range(4):\n          rows1.append(set(map(int, fin.readline().split())))\n      answer2 = int(fin.readline())\n      rows2 = []\n      for i in range(4):\n          rows2.append(set(map(int, fin.readline().split())))\n  \n      possibilities1 = rows1[answer1-1]\n      possibilities2 = rows2[answer2-1]\n  \n      numbers = possibilities1.intersection(possibilities2)\n      result = None\n      if len(numbers) == 1:\n          result = list(numbers)[0]\n      elif len(numbers) == 0:\n          result = 'Volunteer cheated!'\n      else:\n          result = 'Bad magician!'\n  \n  \n      print(\"Case #%d: %s\" % (case, result))\n  \n ", "Adversarial Code": " \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  def  DEBUG(*args):\n      print(*args, f=sys.stderr)\n  \n  f = sys.stdin\n  test = int(f.readline())\n  for line in range(1, test + 1):\n      answer1 = int(f.readline())\n      row0 = []\n      for v in range(4):\n          row0.append(set(map(int, f.readline().split())))\n      answer2 = int(f.readline())\n      rows2 = []\n      for v in range(4):\n          rows2.append(set(map(int, f.readline().split())))\n  \n      possibilities01 = row0[answer1-1]\n      possibles1 = rows2[answer2-1]\n  \n      neefficients = possibilities01.intersection(possibles1)\n      account = None\n      if len(neefficients) == 1:\n          account = list(neefficients)[0]\n      elif len(neefficients) == 0:\n          account = 'Volunteer cheated!'\n      else:\n          account = 'Bad magician!'\n  \n  \n      print(\"Case #%d: %s\" % (line, account))\n  \n ", "Program Length": 203, "Identifier Num": 13, "Replaced Identifiers": "fin:f,possibilities2:possibles1,result:account,rows1:row0,i:v,case:line,numbers:neefficients,T:test,possibilities1:possibilities01,debug: DEBUG,", "Query Times": 473, "Time Cost": 0.22424103418986002, "Type": "mhm"}
{"Index": 61, "Original Code": null, "Adversarial Code": null, "Program Length": 162, "Identifier Num": 9, "Replaced Identifiers": null, "Query Times": 2799, "Time Cost": 1.3371748248736064, "Type": "0"}
{"Index": 62, "Original Code": null, "Adversarial Code": null, "Program Length": 835, "Identifier Num": 24, "Replaced Identifiers": null, "Query Times": 2654, "Time Cost": 1.5472219268480936, "Type": "0"}
{"Index": 63, "Original Code": null, "Adversarial Code": null, "Program Length": 363, "Identifier Num": 21, "Replaced Identifiers": null, "Query Times": 2565, "Time Cost": 1.3767500281333924, "Type": "0"}
{"Index": 65, "Original Code": null, "Adversarial Code": null, "Program Length": 223, "Identifier Num": 21, "Replaced Identifiers": null, "Query Times": 2355, "Time Cost": 1.2884809056917825, "Type": "0"}
{"Index": 66, "Original Code": " \n  lines = [line.strip() for line in open(sys.argv[1])]\n  count = int(lines[0])\n  \n  for i in xrange(count):\n      R,C,M = map(int, lines[i+1].split())\n      print \"Case #%s:\" % (i+1)\n  \n      w = max(R,C)\n      h = min(R,C)\n      X = R*C - M\n      assert X > 0\n  \n      if X == 1:\n          rows = ['c' + ('*' * (w-1))] + (h-1) * ['*' * w]\n      elif h == 1:\n          rows = ['c' + '.' * (X-1) + '*' * M]\n      elif X == 4:\n              rows = [\n                  'c.' + '*' * (w-2),\n                  '..' + '*' * (w-2),\n              ] + ['*' * w] * (h-2)\n      elif h == 2:\n          if X%2 == 1 or X == 2:\n              rows = None\n          else:\n              rows = [\n                  'c' + '.' * (X/2-1) + '*' * (M/2),\n                  '.' + '.' * (X/2-1) + '*' * (M/2)\n              ]\n      elif X <= 5 or X == 7:\n          rows = None\n  \n      elif X%2 == 0 and X <= w*2:\n          r = X/2\n          rows = [\n              'c' + '.' * (r - 1) + '*' * (w-r),\n                    '.' * r       + '*' * (w-r),\n          ] + ['*' * w] * (h-2)\n  \n      elif X <= w*3 and (X % 3) != 1:\n          n = (X+1) / 3\n          t = X - 2*n\n          rows = [\n              'c' + '.' * (n-1) + '*' * (w-n),\n                    '.' * n     + '*' * (w-n),\n                    '.' * t     + '*' * (w-t)\n          ] + ['*' * w] * (h-3)\n      else:\n          n = X / w\n          t = X % w\n          if t == 1:\n              rows = (\n                      ['c' + (w-1) * '.']\n                  +   ['.' * w] * (n-2)\n                  +   ['.' * (w-1) + '*']\n                  +   ['..' + '*' * (w-2)]\n                  +   ['*' * w] * (h - n - 1)\n              )\n          else:\n              k = 1 if t == 0 else 0\n              rows = (\n                      ['c' + (w-1) * '.']\n                  +   ['.' * w] * (n-1)\n                  +   ['.' * t + '*' * (w-t)] * (1 - k)\n                  +   ['*' * w] * (h - n - 1 + k)\n              )\n  \n      if rows:\n          if R > C:\n              rows = [\"\".join(row[i] for row in rows) for i in xrange(R)]\n  \n          for row in rows:\n              print row\n  \n          assert len(rows) == R\n          assert len(rows[0]) == C\n          assert sum(1 for row in rows for col in row if col == '*') == M\n  \n      else:\n          print \"Impossible\"\n  \n ", "Adversarial Code": " \n  qs = [cle.strip() for cle in open(sys.argv[1])]\n  call = int(qs[0])\n  \n  for start in xrange(call):\n      R,WC,ME = map(int, qs[start+1].split())\n      print \"Case #%s:\" % (start+1)\n  \n      x = max(R,WC)\n      e = min(R,WC)\n      Length = R*WC - ME\n      assert Length > 0\n  \n      if Length == 1:\n          cases = ['c' + ('*' * (x-1))] + (e-1) * ['*' * x]\n      elif e == 1:\n          cases = ['c' + '.' * (Length-1) + '*' * ME]\n      elif Length == 4:\n              cases = [\n                  'c.' + '*' * (x-2),\n                  '..' + '*' * (x-2),\n              ] + ['*' * x] * (e-2)\n      elif e == 2:\n          if Length%2 == 1 or Length == 2:\n              cases = None\n          else:\n              cases = [\n                  'c' + '.' * (Length/2-1) + '*' * (ME/2),\n                  '.' + '.' * (Length/2-1) + '*' * (ME/2)\n              ]\n      elif Length <= 5 or Length == 7:\n          cases = None\n  \n      elif Length%2 == 0 and Length <= x*2:\n          q = Length/2\n          cases = [\n              'c' + '.' * (q - 1) + '*' * (x-q),\n                    '.' * q       + '*' * (x-q),\n          ] + ['*' * x] * (e-2)\n  \n      elif Length <= x*3 and (Length % 3) != 1:\n          nt = (Length+1) / 3\n          u = Length - 2*nt\n          cases = [\n              'c' + '.' * (nt-1) + '*' * (x-nt),\n                    '.' * nt     + '*' * (x-nt),\n                    '.' * u     + '*' * (x-u)\n          ] + ['*' * x] * (e-3)\n      else:\n          nt = Length / x\n          u = Length % x\n          if u == 1:\n              cases = (\n                      ['c' + (x-1) * '.']\n                  +   ['.' * x] * (nt-2)\n                  +   ['.' * (x-1) + '*']\n                  +   ['..' + '*' * (x-2)]\n                  +   ['*' * x] * (e - nt - 1)\n              )\n          else:\n              k = 1 if u == 0 else 0\n              cases = (\n                      ['c' + (x-1) * '.']\n                  +   ['.' * x] * (nt-1)\n                  +   ['.' * u + '*' * (x-u)] * (1 - k)\n                  +   ['*' * x] * (e - nt - 1 + k)\n              )\n  \n      if cases:\n          if R > WC:\n              cases = [\"\".join(row[start] for row in cases) for start in xrange(R)]\n  \n          for row in cases:\n              print row\n  \n          assert len(cases) == R\n          assert len(cases[0]) == WC\n          assert sum(1 for row in cases for col in row if col == '*') == ME\n  \n      else:\n          print \"Impossible\"\n  \n ", "Program Length": 652, "Identifier Num": 14, "Replaced Identifiers": "i:start,rows:cases,line:cle,t:u,r:q,n:nt,X:Length,count:call,M:ME,w:x,C:WC,h:e,lines:qs,", "Query Times": 1510, "Time Cost": 0.790408194065094, "Type": "mhm"}
{"Index": 67, "Original Code": " \n  \n  lines = [map(int, line.strip().split(\" \")) for line in open(sys.argv[1]).readlines()]\n  [count] = lines[0]\n  assert count * 10 + 1 == len(lines)\n  \n  for i in xrange(count):\n      base = i*10\n      [n1] = lines[base+1]\n      [n2] = lines[base+6]\n      row1 = set(lines[base+1+n1])\n      row2 = set(lines[base+6+n2])\n      common = row1.intersection(row2)\n      print \"Case #%s:\" % (i+1),\n      if len(common) == 1:\n          print list(common)[0]\n      elif not common:\n          print \"Volunteer cheated!\"\n      else:\n          print \"Bad magician!\"\n ", "Adversarial Code": " \n  \n  rules = [map(int, line.strip().split(\" \")) for line in open(sys.argv[1]).readlines()]\n  [count] = rules[0]\n  assert count * 10 + 1 == len(rules)\n  \n  for position in xrange(count):\n      base = position*10\n      [N1] = rules[base+1]\n      [n2] = rules[base+6]\n      row8 = set(rules[base+1+N1])\n      row2 = set(rules[base+6+n2])\n      recent = row8.intersection(row2)\n      print \"Case #%s:\" % (position+1),\n      if len(recent) == 1:\n          print list(recent)[0]\n      elif not recent:\n          print \"Volunteer cheated!\"\n      else:\n          print \"Bad magician!\"\n ", "Program Length": 156, "Identifier Num": 10, "Replaced Identifiers": "i:position,row1:row8,common:recent,n1:N1,lines:rules,", "Query Times": 156, "Time Cost": 0.08767183621724446, "Type": "mhm"}
{"Index": 68, "Original Code": null, "Adversarial Code": null, "Program Length": 781, "Identifier Num": 21, "Replaced Identifiers": null, "Query Times": 2748, "Time Cost": 1.5357008854548135, "Type": "0"}
{"Index": 69, "Original Code": null, "Adversarial Code": null, "Program Length": 359, "Identifier Num": 28, "Replaced Identifiers": null, "Query Times": 2698, "Time Cost": 1.4900730927785237, "Type": "0"}
{"Index": 70, "Original Code": null, "Adversarial Code": null, "Program Length": 842, "Identifier Num": 12, "Replaced Identifiers": null, "Query Times": 2679, "Time Cost": 1.655284627278646, "Type": "0"}
{"Index": 72, "Original Code": null, "Adversarial Code": null, "Program Length": 1789, "Identifier Num": 19, "Replaced Identifiers": null, "Query Times": 2445, "Time Cost": 1.9940128207206727, "Type": "0"}
{"Index": 73, "Original Code": null, "Adversarial Code": null, "Program Length": 863, "Identifier Num": 19, "Replaced Identifiers": null, "Query Times": 2424, "Time Cost": 1.6602076292037964, "Type": "0"}
{"Index": 75, "Original Code": null, "Adversarial Code": null, "Program Length": 412, "Identifier Num": 27, "Replaced Identifiers": null, "Query Times": 2645, "Time Cost": 1.5228818337122598, "Type": "0"}
{"Index": 76, "Original Code": null, "Adversarial Code": null, "Program Length": 656, "Identifier Num": 16, "Replaced Identifiers": null, "Query Times": 2782, "Time Cost": 1.6364958842595418, "Type": "0"}
{"Index": 77, "Original Code": null, "Adversarial Code": null, "Program Length": 225, "Identifier Num": 13, "Replaced Identifiers": null, "Query Times": 2606, "Time Cost": 1.424531110127767, "Type": "0"}
{"Index": 78, "Original Code": null, "Adversarial Code": null, "Program Length": 436, "Identifier Num": 13, "Replaced Identifiers": null, "Query Times": 2890, "Time Cost": 1.579746095339457, "Type": "0"}
{"Index": 79, "Original Code": "def read_case():\n  \n      answer = int(input())\n      lines = tuple(map(lambda _: set(str.split(input())), range(4)))\n      return lines[answer - 1]\n  \n  \n  for i in range(int(input())):\n  \n      intersection = read_case() & read_case()\n      count = len(intersection)\n      if count == 1:\n  \n          answer = intersection.pop()\n  \n      elif count > 1:\n  \n          answer = \"Bad magician!\"\n  \n      elif count < 1:\n  \n          answer = \"Volunteer cheated!\"\n  \n      print(str.format(\"Case #{}: {}\", i + 1, answer))\n ", "Adversarial Code": "def read_line():\n  \n      err = int(input())\n      values = tuple(map(lambda _: set(str.split(input())), range(4)))\n      return values[err - 1]\n  \n  \n  for r in range(int(input())):\n  \n       intersections = read_line() & read_line()\n      count = len( intersections)\n      if count == 1:\n  \n          err =  intersections.pop()\n  \n      elif count > 1:\n  \n          err = \"Bad magician!\"\n  \n      elif count < 1:\n  \n          err = \"Volunteer cheated!\"\n  \n      print(str.format(\"Case #{}: {}\", r + 1, err))\n ", "Program Length": 118, "Identifier Num": 6, "Replaced Identifiers": "lines:values,i:r,read_case:read_line,intersection: intersections,answer:err,", "Query Times": 394, "Time Cost": 0.20666149854660035, "Type": "mhm"}
{"Index": 80, "Original Code": " \n  class Solver(object):\n      def __init__(self):\n          pass\n      \n      def solve(self, inputs):\n          R, C, M = [int(x) for x in inputs[0].split()]\n          mp = []\n          for r in range(R):\n              mp.append(['.']*C)\n          mp[0][0] = 'c'\n          outputs = []\n          if M == 0:\n              for row in mp:\n                  outputs.append(''.join(row))\n              return outputs\n          rr, cc, rm = R, C, M\n          while rm >= min(rr, cc):\n              if rr <= cc:\n                  for r in range(rr):\n                      mp[r][cc-1] = '*'\n                  cc -= 1\n                  rm -= rr\n              else:\n                  for c in range(cc):\n                      mp[rr-1][c] = '*'\n                  rr -= 1\n                  rm -= cc\n          \n          if rm == 0:\n              if (min(rr, cc), max(rr, cc)) == (1, 2) and min(R, C) != 1:\n                  return ['Impossible']\n          else:\n              if min(rr, cc) - rm >= 2:\n                  if rr <= cc:\n                      for r in range(rr-rm, rr):\n                          mp[r][cc-1] = '*'\n                  else:\n                      for c in range(cc-rm, cc):\n                          mp[rr-1][c] = '*'\n              else:\n                  if min(rr, cc) >= 4:\n                      if rr <= cc:\n                          for r in range(2, rr):\n                              mp[r][cc-1] = '*'\n                          mp[rr-1][cc-2] = '*'\n                      else:\n                          for c in range(2, cc):\n                              mp[rr-1][c] = '*'\n                          mp[rr-2][cc-1]='*'\n                  elif min(rr,cc) == 3:\n                      if max(rr, cc) == 3:\n                          return ['Impossible']\n                      else:\n                          if rr <= cc:\n                              mp[2][cc-1] = '*'\n                              mp[2][cc-2] = '*'\n                          else:\n                              mp[rr-1][2] = '*'\n                              mp[rr-2][2] = '*'\n                  else:\n                      return ['Impossible']\n                      \n          for row in mp:\n              outputs.append(''.join(row))\n          return outputs\n          pass\n      \n      def feed(self, inputs):\n          lines = [x.strip() for x in inputs]\n          outputs = []\n          test_case_n = int(lines[0])\n          cur = 1\n          for i in range(test_case_n):\n              i = i\n              case_line_cnt = 1\n              case_inputs = lines[cur:cur+case_line_cnt]\n              cur += case_line_cnt\n              R, C, M = [int(x) for x in case_inputs[0].split()]\n              rslt = self.solve(case_inputs)\n              if self.verify(rslt, R, C, M):\n                  outputs.append(rslt)\n              else:\n                  raise 'Failed'\n          return outputs\n      \n      def verify(self, outputs, RR, CC, MCNT):\n          if 'Impossible' == outputs[0]:\n              return True\n          rr = len(outputs)\n          cc = len(outputs[0])\n          if RR != rr or CC != cc:\n              return False\n          bd = []\n          mask = []\n          for i in range(rr):\n              mask.append([1]*cc)\n              bd.append([0]*cc)\n              for j in range(cc):\n                  if outputs[i][j] == '*':\n                      bd[i][j] = 9\n                  elif outputs[i][j] == 'c':\n                      start = (i, j)\n          for r in range(rr):\n              for c in range(cc):\n                  if bd[r][c] == 9:\n                      for i in [r-1,r,r+1]:\n                          for j in [c-1,c,c+1]:\n                              if 0 <= i < rr and 0 <= j < cc:\n                                  if bd[i][j] != 9:\n                                      bd[i][j] += 1\n  \n          nlist = [start]\n          while len(nlist):\n              i, j = nlist.pop(0)\n              if mask[i][j] != 0:\n                  mask[i][j] = 0\n                  if bd[i][j] == 9:\n                      raise '!!! BOMB'\n                  elif bd[i][j] == 0:\n                      for ii in [i-1,i,i+1]:\n                          for jj in [j-1,j,j+1]:\n                              if 0<=ii<rr and 0<=jj<cc:\n                                  if ii != i or jj != j:\n                                      nlist.append((ii,jj))\n          mcnt = 0\n          for r in range(rr):\n              for c in range(cc):\n                  if mask[r][c] == 1:\n                      mcnt += 1\n                  if mask[r][c] == 1 and bd[r][c] != 9:\n                      return False\n                  if mask[r][c] != 1 and bd[r][c] == 9:\n                      return False\n          return (mcnt == MCNT)\n                  \n  \n  if __name__ == '__main__':\n      iname = 'C-small-attempt0.in'\n      sample_in = '''\n  7\n  5 5 23\n  3 1 1\n  2 2 1\n  4 7 3\n  10 10 82\n  3 4 0\n  2 2 3\n      '''\n      sample_out = '''\n  Case #1: 1.0000000\n  Case #2: 39.1666667\n  Case #3: 63.9680013\n  Case #4: 526.1904762\n      '''\n      if os.path.exists(iname):\n          with open(iname) as f:\n              inputs = f.readlines()\n      else:\n          inputs = [x.strip() for x in sample_in.split('\n') if x.strip()]\n      solver = Solver()\n      outputs = solver.feed(inputs)\n      fail_flag = False\n      if os.path.exists(iname):\n          with open(iname+'.out', 'w') as f:\n              for i, v in enumerate(outputs):\n                  print >> f, 'Case #%d:'%(i+1)\n                  print >> f, '\n'.join(v)\n      print '===================================================='\n      for i, v in enumerate(outputs):\n          print 'Case #%d:'%(i+1)\n          print '\n'.join(v)\n      print '===================================================='\n      print 'done' if not fail_flag else 'fail'\n      pass\n ", "Adversarial Code": " \n  class Solver(object):\n      def __destruct___(worker):\n          pass\n      \n      def insolved(worker, outputtests):\n          G, VC, MM = [int(xxxxxxxx) for xxxxxxxx in outputtests[0].split()]\n          fm = []\n          for order in range(G):\n              fm.append(['.']*VC)\n          fm[0][0] = 'c'\n           outputlines = []\n          if MM == 0:\n              for arr in fm:\n                   outputlines.append(''.join(arr))\n              return  outputlines\n          rb, ff, rc = G, VC, MM\n          while rc >= min(rb, ff):\n              if rb <= ff:\n                  for order in range(rb):\n                      fm[order][ff-1] = '*'\n                  ff -= 1\n                  rc -= rb\n              else:\n                  for ac in range(ff):\n                      fm[rb-1][ac] = '*'\n                  rb -= 1\n                  rc -= ff\n          \n          if rc == 0:\n              if (min(rb, ff), max(rb, ff)) == (1, 2) and min(G, VC) != 1:\n                  return ['Impossible']\n          else:\n              if min(rb, ff) - rc >= 2:\n                  if rb <= ff:\n                      for order in range(rb-rc, rb):\n                          fm[order][ff-1] = '*'\n                  else:\n                      for ac in range(ff-rc, ff):\n                          fm[rb-1][ac] = '*'\n              else:\n                  if min(rb, ff) >= 4:\n                      if rb <= ff:\n                          for order in range(2, rb):\n                              fm[order][ff-1] = '*'\n                          fm[rb-1][ff-2] = '*'\n                      else:\n                          for ac in range(2, ff):\n                              fm[rb-1][ac] = '*'\n                          fm[rb-2][ff-1]='*'\n                  elif min(rb,ff) == 3:\n                      if max(rb, ff) == 3:\n                          return ['Impossible']\n                      else:\n                          if rb <= ff:\n                              fm[2][ff-1] = '*'\n                              fm[2][ff-2] = '*'\n                          else:\n                              fm[rb-1][2] = '*'\n                              fm[rb-2][2] = '*'\n                  else:\n                      return ['Impossible']\n                      \n          for arr in fm:\n               outputlines.append(''.join(arr))\n          return  outputlines\n          pass\n      \n      def feed(worker, outputtests):\n          lines = [xxxxxxxx.strip() for xxxxxxxx in outputtests]\n           outputlines = []\n          test_case_n = int(lines[0])\n          cur = 1\n          for i in range(test_case_n):\n              i = i\n              case_line_cnt = 1\n              case_inputs = lines[cur:cur+case_line_cnt]\n              cur += case_line_cnt\n              G, VC, MM = [int(xxxxxxxx) for xxxxxxxx in case_inputs[0].split()]\n              rslt = worker.insolved(case_inputs)\n              if worker.verify(rslt, G, VC, MM):\n                   outputlines.append(rslt)\n              else:\n                  raise 'Failed'\n          return  outputlines\n      \n      def verify(worker,  outputlines, RR, CC, MCNT):\n          if 'Impossible' ==  outputlines[0]:\n              return True\n          rb = len( outputlines)\n          ff = len( outputlines[0])\n          if RR != rb or CC != ff:\n              return False\n          bd = []\n          mask = []\n          for i in range(rb):\n              mask.append([1]*ff)\n              bd.append([0]*ff)\n              for j in range(ff):\n                  if  outputlines[i][j] == '*':\n                      bd[i][j] = 9\n                  elif  outputlines[i][j] == 'c':\n                      start = (i, j)\n          for order in range(rb):\n              for ac in range(ff):\n                  if bd[order][ac] == 9:\n                      for i in [order-1,order,order+1]:\n                          for j in [ac-1,ac,ac+1]:\n                              if 0 <= i < rb and 0 <= j < ff:\n                                  if bd[i][j] != 9:\n                                      bd[i][j] += 1\n  \n          nlist = [start]\n          while len(nlist):\n              i, j = nlist.pop(0)\n              if mask[i][j] != 0:\n                  mask[i][j] = 0\n                  if bd[i][j] == 9:\n                      raise '!!! BOMB'\n                  elif bd[i][j] == 0:\n                      for ii in [i-1,i,i+1]:\n                          for jj in [j-1,j,j+1]:\n                              if 0<=ii<rb and 0<=jj<ff:\n                                  if ii != i or jj != j:\n                                      nlist.append((ii,jj))\n          mcnt = 0\n          for order in range(rb):\n              for ac in range(ff):\n                  if mask[order][ac] == 1:\n                      mcnt += 1\n                  if mask[order][ac] == 1 and bd[order][ac] != 9:\n                      return False\n                  if mask[order][ac] != 1 and bd[order][ac] == 9:\n                      return False\n          return (mcnt == MCNT)\n                  \n  \n  if __name__ == '__main__':\n      iname = 'C-small-attempt0.in'\n      sample_in = '''\n  7\n  5 5 23\n  3 1 1\n  2 2 1\n  4 7 3\n  10 10 82\n  3 4 0\n  2 2 3\n      '''\n      sample_out = '''\n  Case #1: 1.0000000\n  Case #2: 39.1666667\n  Case #3: 63.9680013\n  Case #4: 526.1904762\n      '''\n      if os.path.exists(iname):\n          with open(iname) as f:\n              outputtests = f.readlines()\n      else:\n          outputtests = [xxxxxxxx.strip() for xxxxxxxx in sample_in.split('\n') if xxxxxxxx.strip()]\n      solver = Solver()\n       outputlines = solver.feed(outputtests)\n      fail_flag = False\n      if os.path.exists(iname):\n          with open(iname+'.out', 'w') as f:\n              for i, v in enumerate( outputlines):\n                  print >> f, 'Case #%d:'%(i+1)\n                  print >> f, '\n'.join(v)\n      print '===================================================='\n      for i, v in enumerate( outputlines):\n          print 'Case #%d:'%(i+1)\n          print '\n'.join(v)\n      print '===================================================='\n      print 'done' if not fail_flag else 'fail'\n      pass\n ", "Program Length": 1203, "Identifier Num": 16, "Replaced Identifiers": "C:VC,r:order,inputs:outputtests,x:xxxxxxxx,c:ac,__init__:__destruct___,M:MM,mp:fm,cc:ff,outputs:Outputs,rr:rb,R:G,solve:insolved,row:arr,rm:rc,self:worker,", "Query Times": 1438, "Time Cost": 0.9593998074531556, "Type": "mhm"}
{"Index": 81, "Original Code": null, "Adversarial Code": null, "Program Length": 428, "Identifier Num": 24, "Replaced Identifiers": null, "Query Times": 2455, "Time Cost": 1.5396920283635458, "Type": "0"}
{"Index": 82, "Original Code": null, "Adversarial Code": null, "Program Length": 782, "Identifier Num": 14, "Replaced Identifiers": null, "Query Times": 2708, "Time Cost": 1.7009552280108133, "Type": "0"}
{"Index": 83, "Original Code": null, "Adversarial Code": null, "Program Length": 364, "Identifier Num": 17, "Replaced Identifiers": null, "Query Times": 2638, "Time Cost": 1.532031281789144, "Type": "0"}
{"Index": 84, "Original Code": null, "Adversarial Code": null, "Program Length": 1529, "Identifier Num": 23, "Replaced Identifiers": null, "Query Times": 2437, "Time Cost": 1.8726287047068277, "Type": "0"}
{"Index": 85, "Original Code": null, "Adversarial Code": null, "Program Length": 350, "Identifier Num": 27, "Replaced Identifiers": null, "Query Times": 2899, "Time Cost": 1.4574294606844584, "Type": "0"}
{"Index": 86, "Original Code": null, "Adversarial Code": null, "Program Length": 475, "Identifier Num": 14, "Replaced Identifiers": null, "Query Times": 2761, "Time Cost": 1.434221347173055, "Type": "0"}
{"Index": 87, "Original Code": null, "Adversarial Code": null, "Program Length": 176, "Identifier Num": 8, "Replaced Identifiers": null, "Query Times": 2965, "Time Cost": 1.3641496896743774, "Type": "0"}
{"Index": 88, "Original Code": null, "Adversarial Code": null, "Program Length": 556, "Identifier Num": 16, "Replaced Identifiers": null, "Query Times": 2736, "Time Cost": 1.4540958007176716, "Type": "0"}
{"Index": 89, "Original Code": null, "Adversarial Code": null, "Program Length": 201, "Identifier Num": 11, "Replaced Identifiers": null, "Query Times": 2841, "Time Cost": 1.3820597052574157, "Type": "0"}
{"Index": 91, "Original Code": null, "Adversarial Code": null, "Program Length": 192, "Identifier Num": 11, "Replaced Identifiers": null, "Query Times": 2740, "Time Cost": 1.3559176047643027, "Type": "0"}
{"Index": 92, "Original Code": null, "Adversarial Code": null, "Program Length": 498, "Identifier Num": 20, "Replaced Identifiers": null, "Query Times": 2712, "Time Cost": 1.4543553272883096, "Type": "0"}
{"Index": 93, "Original Code": null, "Adversarial Code": null, "Program Length": 248, "Identifier Num": 10, "Replaced Identifiers": null, "Query Times": 2856, "Time Cost": 1.4056816140810648, "Type": "0"}
{"Index": 94, "Original Code": null, "Adversarial Code": null, "Program Length": 1508, "Identifier Num": 28, "Replaced Identifiers": null, "Query Times": 2356, "Time Cost": 1.7675544579823812, "Type": "0"}
{"Index": 95, "Original Code": null, "Adversarial Code": null, "Program Length": 717, "Identifier Num": 28, "Replaced Identifiers": null, "Query Times": 2436, "Time Cost": 1.4988004207611083, "Type": "0"}
{"Index": 97, "Original Code": null, "Adversarial Code": null, "Program Length": 102, "Identifier Num": 7, "Replaced Identifiers": null, "Query Times": 2251, "Time Cost": 1.250913139184316, "Type": "0"}
{"Index": 98, "Original Code": " \n  \n  ncases = int(sys.stdin.readline().strip())\n  \n  def print_board(r, c, free):\n      board = {}\n      for row in range(0, r):\n          board[row] = {}\n          for col in range(0, c):\n              board[row][col] = '*'\n  \n      pending = free\n  \n      if free == 1:\n          board[0][0] = '.'\n      elif r == 1 or c == 1:\n          for row in range(0, r):\n              for col in range(0, c):\n                  if pending > 0:\n                      pending -= 1\n                      board[row][col] = '.'\n      else:\n          for row in range(0,2):\n              for col in range(0,2):\n                  board[row][col] = '.'\n          pending -= 4\n          col=2\n          row=2\n  \n          while pending >= 2 and (col<c or row<r):\n              if pending >= 2 and col<c:\n                  board[0][col] = '.'\n                  board[1][col] = '.'\n                  col += 1\n                  pending -= 2\n              if pending >= 2 and row<r:\n                  board[row][0] = '.'\n                  board[row][1] = '.'\n                  row += 1\n                  pending -= 2\n  \n          for row in range(2, r):\n              for col in range(2, c):\n                  if pending > 0:\n                      board[row][col] = '.'\n                      pending -= 1\n  \n      board[0][0] = 'c'\n  \n      for row in range(0, r):\n          line = ''\n          for col in range(0, c):\n              line += board[row][col]\n          print(line)\n  \n  \n  for t in range(1, ncases+1):\n      values = sys.stdin.readline().strip().split()\n      r = int(values[0])\n      c = int(values[1])\n      m = int(values[2])\n  \n      cells = r * c\n      free = cells - m\n  \n      possible = False\n  \n      if r == 1 or c == 1:\n          if free >= 1:\n              possible = True\n      elif r == 2 or c == 2:\n          if free == 1 or (free >= 4 and free%2 == 0):\n              possible = True\n      else:\n          if free == 1 or (free >= 4 and free != 5 and free != 7):\n              possible = True\n  \n      print(\"Case #{0}:\".format(t))\n  \n      if possible:\n          print_board(r, c, free)\n      else:\n          print(\"Impossible\")\n ", "Adversarial Code": " \n  \n  cased = int(sys.stdin.readline().strip())\n  \n  def  print_row(r, c, free):\n      board = {}\n      for row in range(0, r):\n          board[row] = {}\n          for col in range(0, c):\n              board[row][col] = '*'\n  \n      pending = free\n  \n      if free == 1:\n          board[0][0] = '.'\n      elif r == 1 or c == 1:\n          for row in range(0, r):\n              for col in range(0, c):\n                  if pending > 0:\n                      pending -= 1\n                      board[row][col] = '.'\n      else:\n          for row in range(0,2):\n              for col in range(0,2):\n                  board[row][col] = '.'\n          pending -= 4\n          col=2\n          row=2\n  \n          while pending >= 2 and (col<c or row<r):\n              if pending >= 2 and col<c:\n                  board[0][col] = '.'\n                  board[1][col] = '.'\n                  col += 1\n                  pending -= 2\n              if pending >= 2 and row<r:\n                  board[row][0] = '.'\n                  board[row][1] = '.'\n                  row += 1\n                  pending -= 2\n  \n          for row in range(2, r):\n              for col in range(2, c):\n                  if pending > 0:\n                      board[row][col] = '.'\n                      pending -= 1\n  \n      board[0][0] = 'c'\n  \n      for row in range(0, r):\n          line = ''\n          for col in range(0, c):\n              line += board[row][col]\n          print(line)\n  \n  \n  for t in range(1, cased+1):\n      values = sys.stdin.readline().strip().split()\n      r = int(values[0])\n      c = int(values[1])\n      m = int(values[2])\n  \n      cells = r * c\n      free = cells - m\n  \n      possible = False\n  \n      if r == 1 or c == 1:\n          if free >= 1:\n              possible = True\n      elif r == 2 or c == 2:\n          if free == 1 or (free >= 4 and free%2 == 0):\n              possible = True\n      else:\n          if free == 1 or (free >= 4 and free != 5 and free != 7):\n              possible = True\n  \n      print(\"Case #{0}:\".format(t))\n  \n      if possible:\n           print_row(r, c, free)\n      else:\n          print(\"Impossible\")\n ", "Program Length": 497, "Identifier Num": 15, "Replaced Identifiers": "print_board: print_row,ncases:cased,", "Query Times": 37, "Time Cost": 0.03543219566345215, "Type": "mhm"}
{"Index": 99, "Original Code": " \n  \n  ncases = int(sys.stdin.readline().strip())\n  \n  def read_arrangement():\n      arr = []\n      for row in range(0,4):\n          arr.append(sys.stdin.readline().strip().split(' '))\n      return arr\n  \n  for t in range(1, ncases+1):\n      answer1 = int(sys.stdin.readline().strip())\n      arrang1 = read_arrangement()\n      answer2 = int(sys.stdin.readline().strip())\n      arrang2 = read_arrangement()\n  \n      row1 = arrang1[answer1-1]\n      row2 = arrang2[answer2-1]\n  \n      intersect = set(row1) & set(row2)\n  \n      if len(intersect) == 1:\n          print(\"Case #{0}: {1}\".format(t, intersect.pop()))\n      elif len(intersect) == 0:\n          print(\"Case #{0}: Volunteer cheated!\".format(t))\n      else:\n          print(\"Case #{0}: Bad magician!\".format(t))\n ", "Adversarial Code": " \n  \n  NCones = int(sys.stdin.readline().strip())\n  \n  def read_arrangedements():\n      data = []\n      for ow in range(0,4):\n          data.append(sys.stdin.readline().strip().split(' '))\n      return data\n  \n  for at in range(1, NCones+1):\n      response2 = int(sys.stdin.readline().strip())\n      arangOne = read_arrangedements()\n      responsetwo = int(sys.stdin.readline().strip())\n      arongtwo = read_arrangedements()\n  \n       row0 = arangOne[response2-1]\n      rows2 = arongtwo[responsetwo-1]\n  \n      versection = set( row0) & set(rows2)\n  \n      if len(versection) == 1:\n          print(\"Case #{0}: {1}\".format(at, versection.pop()))\n      elif len(versection) == 0:\n          print(\"Case #{0}: Volunteer cheated!\".format(at))\n      else:\n          print(\"Case #{0}: Bad magician!\".format(at))\n ", "Program Length": 190, "Identifier Num": 12, "Replaced Identifiers": "read_arrangement:read_arrangedements,arr:data,row1: row3,arrang1:arangOne,intersect:versection,answer1:response2,row2:rows2,t:at,answer2:responsetwo,row:ow,arrang2:arongtwo,ncases:NCones,", "Query Times": 1006, "Time Cost": 0.5183306018511454, "Type": "mhm"}
{"Index": 100, "Original Code": null, "Adversarial Code": null, "Program Length": 592, "Identifier Num": 30, "Replaced Identifiers": null, "Query Times": 2441, "Time Cost": 1.3878867069880167, "Type": "0"}
{"Index": 101, "Original Code": null, "Adversarial Code": null, "Program Length": 426, "Identifier Num": 31, "Replaced Identifiers": null, "Query Times": 2463, "Time Cost": 1.3498923540115357, "Type": "0"}
{"Index": 102, "Original Code": null, "Adversarial Code": null, "Program Length": 779, "Identifier Num": 30, "Replaced Identifiers": null, "Query Times": 2706, "Time Cost": 1.5243977427482605, "Type": "0"}
{"Index": 103, "Original Code": null, "Adversarial Code": null, "Program Length": 198, "Identifier Num": 14, "Replaced Identifiers": null, "Query Times": 2637, "Time Cost": 1.2946975350379943, "Type": "0"}
{"Index": 105, "Original Code": null, "Adversarial Code": null, "Program Length": 191, "Identifier Num": 9, "Replaced Identifiers": null, "Query Times": 2559, "Time Cost": 1.3477061192194622, "Type": "0"}
{"Index": 106, "Original Code": null, "Adversarial Code": null, "Program Length": 480, "Identifier Num": 22, "Replaced Identifiers": null, "Query Times": 2665, "Time Cost": 1.3929797371228536, "Type": "0"}
{"Index": 107, "Original Code": null, "Adversarial Code": null, "Program Length": 196, "Identifier Num": 14, "Replaced Identifiers": null, "Query Times": 2685, "Time Cost": 1.422221577167511, "Type": "0"}
{"Index": 109, "Original Code": null, "Adversarial Code": null, "Program Length": 159, "Identifier Num": 11, "Replaced Identifiers": null, "Query Times": 2855, "Time Cost": 1.3923893888791403, "Type": "0"}
{"Index": 110, "Original Code": null, "Adversarial Code": null, "Program Length": 505, "Identifier Num": 23, "Replaced Identifiers": null, "Query Times": 2825, "Time Cost": 1.5831078092257183, "Type": "0"}
{"Index": 111, "Original Code": null, "Adversarial Code": null, "Program Length": 252, "Identifier Num": 14, "Replaced Identifiers": null, "Query Times": 2890, "Time Cost": 1.4952507972717286, "Type": "0"}
{"Index": 112, "Original Code": null, "Adversarial Code": null, "Program Length": 721, "Identifier Num": 19, "Replaced Identifiers": null, "Query Times": 2858, "Time Cost": 1.6689318060874938, "Type": "0"}
{"Index": 113, "Original Code": null, "Adversarial Code": null, "Program Length": 160, "Identifier Num": 14, "Replaced Identifiers": null, "Query Times": 2617, "Time Cost": 1.4200925350189209, "Type": "0"}
{"Index": 115, "Original Code": null, "Adversarial Code": null, "Program Length": 284, "Identifier Num": 25, "Replaced Identifiers": null, "Query Times": 2843, "Time Cost": 1.5363592306772869, "Type": "0"}
{"Index": 116, "Original Code": null, "Adversarial Code": null, "Program Length": 898, "Identifier Num": 27, "Replaced Identifiers": null, "Query Times": 2078, "Time Cost": 1.658452308177948, "Type": "0"}
{"Index": 117, "Original Code": null, "Adversarial Code": null, "Program Length": 591, "Identifier Num": 30, "Replaced Identifiers": null, "Query Times": 2284, "Time Cost": 1.5742414474487305, "Type": "0"}
{"Index": 118, "Original Code": null, "Adversarial Code": null, "Program Length": 534, "Identifier Num": 15, "Replaced Identifiers": null, "Query Times": 2743, "Time Cost": 1.5515013972918192, "Type": "0"}
{"Index": 119, "Original Code": null, "Adversarial Code": null, "Program Length": 181, "Identifier Num": 9, "Replaced Identifiers": null, "Query Times": 2884, "Time Cost": 1.462187695503235, "Type": "0"}
{"Index": 121, "Original Code": " \n  \n  def process(chosen_row_1, arrange_1, chosen_row_2, arrange_2):\n  \trlt = 'Volunteer cheated!'\n  \tfound = False\n  \tfor i in arrange_1[chosen_row_1]:\n  \t\tif i in arrange_2[chosen_row_2]:\n  \t\t\tif not found:\n  \t\t\t\trlt = i\n  \t\t\t\tfound = True\n  \t\t\telse:\n  \t\t\t\trlt = 'Bad magician!'\n  \t\t\t\tbreak\n  \treturn rlt\n  \n  input_file = open(sys.argv[1], 'r')\n  T = int(input_file.readline())\n  for i in range(T):\n  \tchosen_row_1 = int(input_file.readline()) - 1\n  \tarrange_1 = []\n  \tarrange_1.append(map(int, input_file.readline().split()))\n  \tarrange_1.append(map(int, input_file.readline().split()))\n  \tarrange_1.append(map(int, input_file.readline().split()))\n  \tarrange_1.append(map(int, input_file.readline().split()))\n  \tchosen_row_2 = int(input_file.readline()) - 1\n  \tarrange_2 = []\n  \tarrange_2.append(map(int, input_file.readline().split()))\n  \tarrange_2.append(map(int, input_file.readline().split()))\n  \tarrange_2.append(map(int, input_file.readline().split()))\n  \tarrange_2.append(map(int, input_file.readline().split()))\n  \tprint 'Case #%d:' % (i + 1), process(chosen_row_1, arrange_1, chosen_row_2, arrange_2)\n ", "Adversarial Code": " \n  \n  def task(chosen_row_1, arrange_1, chosen_row_2, arrange_2):\n  \trlt = 'Volunteer cheated!'\n  \twhere = False\n  \tfor i in arrange_1[chosen_row_1]:\n  \t\tif i in arrange_2[chosen_row_2]:\n  \t\t\tif not where:\n  \t\t\t\trlt = i\n  \t\t\t\twhere = True\n  \t\t\telse:\n  \t\t\t\trlt = 'Bad magician!'\n  \t\t\t\tbreak\n  \treturn rlt\n  \n   input_socket = open(sys.argv[1], 'r')\n  T = int( input_socket.readline())\n  for i in range(T):\n  \tchosen_row_1 = int( input_socket.readline()) - 1\n  \tarrange_1 = []\n  \tarrange_1.append(map(int,  input_socket.readline().split()))\n  \tarrange_1.append(map(int,  input_socket.readline().split()))\n  \tarrange_1.append(map(int,  input_socket.readline().split()))\n  \tarrange_1.append(map(int,  input_socket.readline().split()))\n  \tchosen_row_2 = int( input_socket.readline()) - 1\n  \tarrange_2 = []\n  \tarrange_2.append(map(int,  input_socket.readline().split()))\n  \tarrange_2.append(map(int,  input_socket.readline().split()))\n  \tarrange_2.append(map(int,  input_socket.readline().split()))\n  \tarrange_2.append(map(int,  input_socket.readline().split()))\n  \tprint 'Case #%d:' % (i + 1), task(chosen_row_1, arrange_1, chosen_row_2, arrange_2)\n ", "Program Length": 286, "Identifier Num": 10, "Replaced Identifiers": "found:where,process:task,input_file: input_socket,", "Query Times": 93, "Time Cost": 0.05997326374053955, "Type": "mhm"}
{"Index": 122, "Original Code": null, "Adversarial Code": null, "Program Length": 946, "Identifier Num": 17, "Replaced Identifiers": null, "Query Times": 2879, "Time Cost": 1.854692022005717, "Type": "0"}
{"Index": 123, "Original Code": null, "Adversarial Code": null, "Program Length": 206, "Identifier Num": 12, "Replaced Identifiers": null, "Query Times": 2811, "Time Cost": 1.4319863756497702, "Type": "0"}
{"Index": 124, "Original Code": null, "Adversarial Code": null, "Program Length": 581, "Identifier Num": 26, "Replaced Identifiers": null, "Query Times": 2587, "Time Cost": 1.4796109358469645, "Type": "0"}
{"Index": 125, "Original Code": null, "Adversarial Code": null, "Program Length": 188, "Identifier Num": 17, "Replaced Identifiers": null, "Query Times": 2854, "Time Cost": 1.3932924111684164, "Type": "0"}
{"Index": 127, "Original Code": " \n  \n  \n  def solve(arrange):\n      board, row = arrange[0]\n      before = board[row - 1]\n      board, row = arrange[1]\n      after = board[row - 1]\n      dup = set(before) & set(after)\n      if len(dup) == 1:\n          return dup.pop()\n      elif len(dup) >= 2:\n          return 'Bad magician!'\n      else:\n          return 'Volunteer cheated!'\n  \n  \n  def main(IN, OUT):\n      T = int(IN.readline())\n      for index in range(T):\n          arrange = []\n          for n in range(2):\n              row = int(IN.readline())\n              board = []\n              for line in range(4):\n                  board.append(map(int, IN.readline().split()))\n              arrange.append((board, row))\n          OUT.write('Case #%d: %s\n' % (index + 1, solve(arrange)))\n  \n  \n  def makesample(T=100):\n      print T\n      for index in range(T):\n          for n in range(2):\n              print random.randint(1, 4)\n              board = list(range(1, 16+1))\n              random.shuffle(board)\n              while board:\n                  print ' '.join(map(str, board[:4]))\n                  board = board[4:]\n  \n  \n  if __name__ == '__main__':\n      if '-makesample' in sys.argv[1:]:\n          makesample()\n      else:\n          main(sys.stdin, sys.stdout)\n  \n ", "Adversarial Code": " \n  \n  \n  def unsolves( arranch):\n      channel, head =  arranch[0]\n      Before = channel[head - 1]\n      channel, head =  arranch[1]\n      above = channel[head - 1]\n      dope = set(Before) & set(above)\n      if len(dope) == 1:\n          return dope.pop()\n      elif len(dope) >= 2:\n          return 'Bad magician!'\n      else:\n          return 'Volunteer cheated!'\n  \n  \n  def end(TIME, IO):\n      Time = int(TIME.readline())\n      for axis in Before(Time):\n           arranch = []\n          for nb in Before(2):\n              head = int(TIME.readline())\n              channel = []\n              for name in Before(4):\n                  channel.append(map(int, TIME.readline().split()))\n               arranch.append((channel, head))\n          IO.write('Case #%d: %s\n' % (axis + 1, unsolves( arranch)))\n  \n  \n  def akesamp(Time=100):\n      print Time\n      for axis in Before(Time):\n          for nb in Before(2):\n              print random.randint(1, 4)\n              channel = list(Before(1, 16+1))\n              random.shuffle(channel)\n              while channel:\n                  print ' '.join(map(str, channel[:4]))\n                  channel = channel[4:]\n  \n  \n  if __name__ == '__main__':\n      if '-makesample' in sys.argv[1:]:\n          akesamp()\n      else:\n          end(sys.stdin, sys.stdout)\n  \n ", "Program Length": 297, "Identifier Num": 15, "Replaced Identifiers": "OUT:IO,after:above,T:Time,main:end,arrange:arrone,line:name,before:Before,row:head,index:axis,n:nb,dup:dope,solve:unsolves,IN:TIME,board:channel,makesample:akesamp,", "Query Times": 1037, "Time Cost": 0.5262801170349121, "Type": "mhm"}
{"Index": 129, "Original Code": " \n  \n  def solve(row1, row2):\n      common = [x for x in row1 if x in row2]\n      num_common = len(common)\n      if num_common == 0:\n          return 'Volunteer cheated!'\n      elif num_common > 1:\n          return 'Bad magician!'\n      else:\n          return common[0]\n  \n  def main():\n      N = int(sys.stdin.readline()) # number of testcases\n      for i in range(N):\n          row_index1 = int(sys.stdin.readline())\n          row1 = list()\n          for j in range(4):\n              if row_index1 == j + 1:\n                  row1 = [int(x) for x in sys.stdin.readline().rstrip().split()]\n              else:\n                  sys.stdin.readline()\n  \n          row_index2 = int(sys.stdin.readline())\n          row2 = list()\n          for j in range(4):\n              if row_index2 == j + 1:\n                  row2 = [int(x) for x in sys.stdin.readline().rstrip().split()]\n              else:\n                  sys.stdin.readline()\n  \n          result = solve(row1, row2)\n          print (\"Case #%s: %s\" % (i+1, result))\n  \n  if __name__ == '__main__':\n      main()\n ", "Adversarial Code": " \n  \n  def solution(row1, rowtwo):\n      local = [x for x in row1 if x in rowtwo]\n      num_common = len(local)\n      if num_common == 0:\n          return 'Volunteer cheated!'\n      elif num_common > 1:\n          return 'Bad magician!'\n      else:\n          return local[0]\n  \n  def connect():\n      ns = int(sys.stdin.readline()) # number of testcases\n      for di in range(ns):\n          row_index1 = int(sys.stdin.readline())\n          row1 = list()\n          for j in range(4):\n              if row_index1 == j + 1:\n                  row1 = [int(x) for x in sys.stdin.readline().rstrip().split()]\n              else:\n                  sys.stdin.readline()\n  \n          row_index2 = int(sys.stdin.readline())\n          rowtwo = list()\n          for j in range(4):\n              if row_index2 == j + 1:\n                  rowtwo = [int(x) for x in sys.stdin.readline().rstrip().split()]\n              else:\n                  sys.stdin.readline()\n  \n          result = solution(row1, rowtwo)\n          print (\"Case #%s: %s\" % (di+1, result))\n  \n  if __name__ == '__main__':\n      connect()\n ", "Program Length": 235, "Identifier Num": 13, "Replaced Identifiers": "row2:rowtwo,i:di,N:ns,main:connect,common:local,solve:solution,", "Query Times": 178, "Time Cost": 0.09232905308405558, "Type": "mhm"}
{"Index": 131, "Original Code": null, "Adversarial Code": null, "Program Length": 150, "Identifier Num": 9, "Replaced Identifiers": null, "Query Times": 2650, "Time Cost": 1.3214563012123108, "Type": "0"}
